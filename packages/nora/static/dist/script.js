!function(t){var n={};function e(i){if(n[i])return n[i].exports;var r=n[i]={i:i,l:!1,exports:{}};return t[i].call(r.exports,r,r.exports,e),r.l=!0,r.exports}e.m=t,e.c=n,e.d=function(t,n,i){e.o(t,n)||Object.defineProperty(t,n,{enumerable:!0,get:i})},e.r=function(t){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(t,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(t,"__esModule",{value:!0})},e.t=function(t,n){if(1&n&&(t=e(t)),8&n)return t;if(4&n&&"object"==typeof t&&t&&t.__esModule)return t;var i=Object.create(null);if(e.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:t}),2&n&&"string"!=typeof t)for(var r in t)e.d(i,r,function(n){return t[n]}.bind(null,r));return i},e.n=function(t){var n=t&&t.__esModule?function(){return t.default}:function(){return t};return e.d(n,"a",n),n},e.o=function(t,n){return Object.prototype.hasOwnProperty.call(t,n)},e.p="",e(e.s=75)}([function(t,n,e){"use strict";(function(t){e.d(n,"e",(function(){return i})),e.d(n,"p",(function(){return r})),e.d(n,"a",(function(){return a})),e.d(n,"c",(function(){return o})),e.d(n,"d",(function(){return s})),e.d(n,"o",(function(){return l})),e.d(n,"q",(function(){return d})),e.d(n,"t",(function(){return c})),e.d(n,"i",(function(){return f})),e.d(n,"r",(function(){return p})),e.d(n,"s",(function(){return u})),e.d(n,"k",(function(){return h})),e.d(n,"m",(function(){return m})),e.d(n,"j",(function(){return v})),e.d(n,"l",(function(){return g})),e.d(n,"g",(function(){return b})),e.d(n,"f",(function(){return w})),e.d(n,"h",(function(){return x})),e.d(n,"n",(function(){return y})),e.d(n,"b",(function(){return _}));var i="1.12.0",r="object"==typeof self&&self.self===self&&self||"object"==typeof t&&t.global===t&&t||Function("return this")()||{},a=Array.prototype,o=Object.prototype,s="undefined"!=typeof Symbol?Symbol.prototype:null,l=a.push,d=a.slice,c=o.toString,f=o.hasOwnProperty,p="undefined"!=typeof ArrayBuffer,u="undefined"!=typeof DataView,h=Array.isArray,m=Object.keys,v=Object.create,g=p&&ArrayBuffer.isView,b=isNaN,w=isFinite,x=!{toString:null}.propertyIsEnumerable("toString"),y=["valueOf","isPrototypeOf","toString","propertyIsEnumerable","hasOwnProperty","toLocaleString"],_=Math.pow(2,53)-1}).call(this,e(39))},function(t,n){t.exports=function(t){function n(t){"undefined"!=typeof console&&(console.error||console.log)("[Script Loader]",t)}try{"undefined"!=typeof execScript&&"undefined"!=typeof attachEvent&&"undefined"==typeof addEventListener?execScript(t):"undefined"!=typeof eval?eval.call(null,t):n("EvalError: No eval function available")}catch(t){n(t)}}},function(t,n,e){"use strict";var i,r=function(){return void 0===i&&(i=Boolean(window&&document&&document.all&&!window.atob)),i},a=function(){var t={};return function(n){if(void 0===t[n]){var e=document.querySelector(n);if(window.HTMLIFrameElement&&e instanceof window.HTMLIFrameElement)try{e=e.contentDocument.head}catch(t){e=null}t[n]=e}return t[n]}}(),o=[];function s(t){for(var n=-1,e=0;e<o.length;e++)if(o[e].identifier===t){n=e;break}return n}function l(t,n){for(var e={},i=[],r=0;r<t.length;r++){var a=t[r],l=n.base?a[0]+n.base:a[0],d=e[l]||0,c="".concat(l," ").concat(d);e[l]=d+1;var f=s(c),p={css:a[1],media:a[2],sourceMap:a[3]};-1!==f?(o[f].references++,o[f].updater(p)):o.push({identifier:c,updater:v(p,n),references:1}),i.push(c)}return i}function d(t){var n=document.createElement("style"),i=t.attributes||{};if(void 0===i.nonce){var r=e.nc;r&&(i.nonce=r)}if(Object.keys(i).forEach((function(t){n.setAttribute(t,i[t])})),"function"==typeof t.insert)t.insert(n);else{var o=a(t.insert||"head");if(!o)throw new Error("Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.");o.appendChild(n)}return n}var c,f=(c=[],function(t,n){return c[t]=n,c.filter(Boolean).join("\n")});function p(t,n,e,i){var r=e?"":i.media?"@media ".concat(i.media," {").concat(i.css,"}"):i.css;if(t.styleSheet)t.styleSheet.cssText=f(n,r);else{var a=document.createTextNode(r),o=t.childNodes;o[n]&&t.removeChild(o[n]),o.length?t.insertBefore(a,o[n]):t.appendChild(a)}}function u(t,n,e){var i=e.css,r=e.media,a=e.sourceMap;if(r?t.setAttribute("media",r):t.removeAttribute("media"),a&&"undefined"!=typeof btoa&&(i+="\n/*# sourceMappingURL=data:application/json;base64,".concat(btoa(unescape(encodeURIComponent(JSON.stringify(a))))," */")),t.styleSheet)t.styleSheet.cssText=i;else{for(;t.firstChild;)t.removeChild(t.firstChild);t.appendChild(document.createTextNode(i))}}var h=null,m=0;function v(t,n){var e,i,r;if(n.singleton){var a=m++;e=h||(h=d(n)),i=p.bind(null,e,a,!1),r=p.bind(null,e,a,!0)}else e=d(n),i=u.bind(null,e,n),r=function(){!function(t){if(null===t.parentNode)return!1;t.parentNode.removeChild(t)}(e)};return i(t),function(n){if(n){if(n.css===t.css&&n.media===t.media&&n.sourceMap===t.sourceMap)return;i(t=n)}else r()}}t.exports=function(t,n){(n=n||{}).singleton||"boolean"==typeof n.singleton||(n.singleton=r());var e=l(t=t||[],n);return function(t){if(t=t||[],"[object Array]"===Object.prototype.toString.call(t)){for(var i=0;i<e.length;i++){var r=s(e[i]);o[r].references--}for(var a=l(t,n),d=0;d<e.length;d++){var c=s(e[d]);0===o[c].references&&(o[c].updater(),o.splice(c,1))}e=a}}}},function(t,n,e){"use strict";t.exports=function(t){var n=[];return n.toString=function(){return this.map((function(n){var e=function(t,n){var e=t[1]||"",i=t[3];if(!i)return e;if(n&&"function"==typeof btoa){var r=(o=i,s=btoa(unescape(encodeURIComponent(JSON.stringify(o)))),l="sourceMappingURL=data:application/json;charset=utf-8;base64,".concat(s),"/*# ".concat(l," */")),a=i.sources.map((function(t){return"/*# sourceURL=".concat(i.sourceRoot||"").concat(t," */")}));return[e].concat(a).concat([r]).join("\n")}var o,s,l;return[e].join("\n")}(n,t);return n[2]?"@media ".concat(n[2]," {").concat(e,"}"):e})).join("")},n.i=function(t,e,i){"string"==typeof t&&(t=[[null,t,""]]);var r={};if(i)for(var a=0;a<this.length;a++){var o=this[a][0];null!=o&&(r[o]=!0)}for(var s=0;s<t.length;s++){var l=[].concat(t[s]);i&&r[l[0]]||(e&&(l[2]?l[2]="".concat(e," and ").concat(l[2]):l[2]=e),n.push(l))}},n}},function(t,n,e){e(1)(e(40))},function(t,n,e){e(1)(e(41))},function(t,n,e){var i=e(2),r=e(42);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[t.i,r,""]]);var a={insert:"head",singleton:!1};i(r,a);t.exports=r.locals||{}},function(t,n,e){var i=e(2),r=e(43);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[t.i,r,""]]);var a={insert:"head",singleton:!1};i(r,a);t.exports=r.locals||{}},function(t,n,e){var i=e(2),r=e(44);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[t.i,r,""]]);var a={insert:"head",singleton:!1};i(r,a);t.exports=r.locals||{}},function(t,n,e){var i=e(2),r=e(45);"string"==typeof(r=r.__esModule?r.default:r)&&(r=[[t.i,r,""]]);var a={insert:"head",singleton:!1};i(r,a);t.exports=r.locals||{}},function(t,n,e){e(1)(e(46))},function(t,n,e){e(1)(e(47))},function(t,n,e){e(1)(e(48))},function(t,n,e){e(1)(e(49))},function(t,n,e){e(1)(e(50))},function(t,n,e){e(1)(e(51))},function(t,n,e){e(1)(e(52))},function(t,n,e){e(1)(e(53))},function(t,n,e){e(1)(e(54))},function(t,n,e){e(1)(e(55))},function(t,n,e){e(1)(e(56))},function(t,n,e){e(1)(e(57))},function(t,n,e){e(1)(e(58))},function(t,n,e){e(1)(e(59))},function(t,n,e){e(1)(e(60))},function(t,n,e){e(1)(e(61))},function(t,n,e){e(1)(e(62))},function(t,n,e){e(1)(e(63))},function(t,n,e){e(1)(e(64))},function(t,n,e){e(1)(e(65))},function(t,n,e){e(1)(e(66))},function(t,n,e){e(1)(e(67))},function(t,n,e){e(1)(e(68))},function(t,n,e){e(1)(e(69))},function(t,n,e){e(1)(e(70))},function(t,n,e){e(1)(e(71))},function(t,n,e){e(1)(e(72))},function(t,n,e){e(1)(e(73))},function(t,n,e){e(1)(e(74))},function(t,n){var e;e=function(){return this}();try{e=e||new Function("return this")()}catch(t){"object"==typeof window&&(e=window)}t.exports=e},function(t,n){t.exports='(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.daikon = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module \'"+o+"\'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n/*\n Copyright 2011 notmasteryet\n\n Licensed under the Apache License, Version 2.0 (the "License");\n you may not use this file except in compliance with the License.\n You may obtain a copy of the License at\n\n http://www.apache.org/licenses/LICENSE-2.0\n\n Unless required by applicable law or agreed to in writing, software\n distributed under the License is distributed on an "AS IS" BASIS,\n WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n See the License for the specific language governing permissions and\n limitations under the License.\n */\n\n// - The JPEG specification can be found in the ITU CCITT Recommendation T.81\n//   (www.w3.org/Graphics/JPEG/itu-t81.pdf)\n// - The JFIF specification can be found in the JPEG File Interchange Format\n//   (www.w3.org/Graphics/JPEG/jfif3.pdf)\n// - The Adobe Application-Specific JPEG markers in the Supporting the DCT Filters\n//   in PostScript Level 2, Technical Note #5116\n//   (partners.adobe.com/public/developer/en/ps/sdk/5116.DCT_Filter.pdf)\n\nvar ColorSpace = {Unkown: 0, Grayscale: 1, AdobeRGB: 2, RGB: 3, CYMK: 4};\nvar JpegImage = (function jpegImage() {\n    "use strict";\n    var dctZigZag = new Int32Array([\n        0,\n        1, 8,\n        16, 9, 2,\n        3, 10, 17, 24,\n        32, 25, 18, 11, 4,\n        5, 12, 19, 26, 33, 40,\n        48, 41, 34, 27, 20, 13, 6,\n        7, 14, 21, 28, 35, 42, 49, 56,\n        57, 50, 43, 36, 29, 22, 15,\n        23, 30, 37, 44, 51, 58,\n        59, 52, 45, 38, 31,\n        39, 46, 53, 60,\n        61, 54, 47,\n        55, 62,\n        63\n    ]);\n\n    var dctCos1 = 4017;   // cos(pi/16)\n    var dctSin1 = 799;   // sin(pi/16)\n    var dctCos3 = 3406;   // cos(3*pi/16)\n    var dctSin3 = 2276;   // sin(3*pi/16)\n    var dctCos6 = 1567;   // cos(6*pi/16)\n    var dctSin6 = 3784;   // sin(6*pi/16)\n    var dctSqrt2 = 5793;   // sqrt(2)\n    var dctSqrt1d2 = 2896;  // sqrt(2) / 2\n\n    function constructor() {\n    }\n\n    function buildHuffmanTable(codeLengths, values) {\n        var k = 0, code = [], i, j, length = 16;\n        while (length > 0 && !codeLengths[length - 1])\n            length--;\n        code.push({children: [], index: 0});\n        var p = code[0], q;\n        for (i = 0; i < length; i++) {\n            for (j = 0; j < codeLengths[i]; j++) {\n                p = code.pop();\n                p.children[p.index] = values[k];\n                while (p.index > 0) {\n                    p = code.pop();\n                }\n                p.index++;\n                code.push(p);\n                while (code.length <= i) {\n                    code.push(q = {children: [], index: 0});\n                    p.children[p.index] = q.children;\n                    p = q;\n                }\n                k++;\n            }\n            if (i + 1 < length) {\n                // p here points to last code\n                code.push(q = {children: [], index: 0});\n                p.children[p.index] = q.children;\n                p = q;\n                \n            }\n        }\n        return code[0].children;\n    }\n\n    function getBlockBufferOffset(component, row, col) {\n        return 64 * ((component.blocksPerLine + 1) * row + col);\n    }\n\n    function decodeScan(data, offset,\n                        frame, components, resetInterval,\n                        spectralStart, spectralEnd,\n                        successivePrev, successive) {\n        var precision = frame.precision;\n        var samplesPerLine = frame.samplesPerLine;\n        var scanLines = frame.scanLines;\n        var mcusPerLine = frame.mcusPerLine;\n        var progressive = frame.progressive;\n        var maxH = frame.maxH, maxV = frame.maxV;\n\n        var startOffset = offset, bitsData = 0, bitsCount = 0;\n\n        function readBit() {\n            if (bitsCount > 0) {\n                bitsCount--;\n                return (bitsData >> bitsCount) & 1;\n            }\n            bitsData = data[offset++];\n            if (bitsData == 0xFF) {\n                var nextByte = data[offset++];\n                if (nextByte) {\n                    throw "unexpected marker: " + ((bitsData << 8) | nextByte).toString(16);\n                }\n                // unstuff 0\n            }\n            bitsCount = 7;\n            return bitsData >>> 7;\n        }\n\n        function decodeHuffman(tree) {\n            var node = tree;\n            var bit;\n            while ((bit = readBit()) !== null) {\n                node = node[bit];\n                if (typeof node === \'number\')\n                    return node;\n                if (typeof node !== \'object\')\n                    throw "invalid huffman sequence";\n            }\n            return null;\n        }\n\n        function receive(length) {\n            var n = 0;\n            while (length > 0) {\n                var bit = readBit();\n                if (bit === null)\n                    return;\n                n = (n << 1) | bit;\n                length--;\n            }\n            return n;\n        }\n\n        function receiveAndExtend(length) {\n            var n = receive(length);\n            if (n >= 1 << (length - 1))\n                return n;\n            return n + (-1 << length) + 1;\n        }\n\n        function decodeBaseline(component, offset) {\n            var t = decodeHuffman(component.huffmanTableDC);\n            var diff = t === 0 ? 0 : receiveAndExtend(t);\n            component.blockData[offset] = (component.pred += diff);\n            var k = 1;\n            while (k < 64) {\n                var rs = decodeHuffman(component.huffmanTableAC);\n                var s = rs & 15, r = rs >> 4;\n                if (s === 0) {\n                    if (r < 15)\n                        break;\n                    k += 16;\n                    continue;\n                }\n                k += r;\n                var z = dctZigZag[k];\n                component.blockData[offset + z] = receiveAndExtend(s);\n                k++;\n            }\n        }\n\n        function decodeDCFirst(component, offset) {\n            var t = decodeHuffman(component.huffmanTableDC);\n            var diff = t === 0 ? 0 : (receiveAndExtend(t) << successive);\n            component.blockData[offset] = (component.pred += diff);\n        }\n\n        function decodeDCSuccessive(component, offset) {\n            component.blockData[offset] |= readBit() << successive;\n        }\n\n        var eobrun = 0;\n        function decodeACFirst(component, offset) {\n            if (eobrun > 0) {\n                eobrun--;\n                return;\n            }\n            var k = spectralStart, e = spectralEnd;\n            while (k <= e) {\n                var rs = decodeHuffman(component.huffmanTableAC);\n                var s = rs & 15, r = rs >> 4;\n                if (s === 0) {\n                    if (r < 15) {\n                        eobrun = receive(r) + (1 << r) - 1;\n                        break;\n                    }\n                    k += 16;\n                    continue;\n                }\n                k += r;\n                var z = dctZigZag[k];\n                component.blockData[offset + z] = receiveAndExtend(s) * (1 << successive);\n                k++;\n            }\n        }\n\n        var successiveACState = 0, successiveACNextValue;\n        function decodeACSuccessive(component, offset) {\n            var k = spectralStart, e = spectralEnd, r = 0;\n            while (k <= e) {\n                var z = dctZigZag[k];\n                switch (successiveACState) {\n                    case 0: // initial state\n                        var rs = decodeHuffman(component.huffmanTableAC);\n                        var s = rs & 15;\n                        r = rs >> 4;\n                        if (s === 0) {\n                            if (r < 15) {\n                                eobrun = receive(r) + (1 << r);\n                                successiveACState = 4;\n                            } else {\n                                r = 16;\n                                successiveACState = 1;\n                            }\n                        } else {\n                            if (s !== 1)\n                                throw "invalid ACn encoding";\n                            successiveACNextValue = receiveAndExtend(s);\n                            successiveACState = r ? 2 : 3;\n                        }\n                        continue;\n                    case 1: // skipping r zero items\n                    case 2:\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += (readBit() << successive);\n                        } else {\n                            r--;\n                            if (r === 0)\n                                successiveACState = successiveACState == 2 ? 3 : 0;\n                        }\n                        break;\n                    case 3: // set value for a zero item\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += (readBit() << successive);\n                        } else {\n                            component.blockData[offset + z] = successiveACNextValue << successive;\n                            successiveACState = 0;\n                        }\n                        break;\n                    case 4: // eob\n                        if (component.blockData[offset + z]) {\n                            component.blockData[offset + z] += (readBit() << successive);\n                        }\n                        break;\n                }\n                k++;\n            }\n            if (successiveACState === 4) {\n                eobrun--;\n                if (eobrun === 0)\n                    successiveACState = 0;\n            }\n        }\n\n        function decodeMcu(component, decode, mcu, row, col) {\n            var mcuRow = (mcu / mcusPerLine) | 0;\n            var mcuCol = mcu % mcusPerLine;\n            var blockRow = mcuRow * component.v + row;\n            var blockCol = mcuCol * component.h + col;\n            var offset = getBlockBufferOffset(component, blockRow, blockCol);\n            decode(component, offset);\n        }\n\n        function decodeBlock(component, decode, mcu) {\n            var blockRow = (mcu / component.blocksPerLine) | 0;\n            var blockCol = mcu % component.blocksPerLine;\n            var offset = getBlockBufferOffset(component, blockRow, blockCol);\n            decode(component, offset);\n        }\n\n        var componentsLength = components.length;\n        var component, i, j, k, n;\n        var decodeFn;\n        if (progressive) {\n            if (spectralStart === 0)\n                decodeFn = successivePrev === 0 ? decodeDCFirst : decodeDCSuccessive;\n            else\n                decodeFn = successivePrev === 0 ? decodeACFirst : decodeACSuccessive;\n        } else {\n            decodeFn = decodeBaseline;\n        }\n\n        var mcu = 0, marker;\n        var mcuExpected;\n        if (componentsLength == 1) {\n            mcuExpected = components[0].blocksPerLine * components[0].blocksPerColumn;\n        } else {\n            mcuExpected = mcusPerLine * frame.mcusPerColumn;\n        }\n        if (!resetInterval) {\n            resetInterval = mcuExpected;\n        }\n\n        var h, v;\n        while (mcu < mcuExpected) {\n            // reset interval stuff\n            for (i = 0; i < componentsLength; i++) {\n                components[i].pred = 0;\n            }\n            eobrun = 0;\n\n            if (componentsLength == 1) {\n                component = components[0];\n                for (n = 0; n < resetInterval; n++) {\n                    decodeBlock(component, decodeFn, mcu);\n                    mcu++;\n                }\n            } else {\n                for (n = 0; n < resetInterval; n++) {\n                    for (i = 0; i < componentsLength; i++) {\n                        component = components[i];\n                        h = component.h;\n                        v = component.v;\n                        for (j = 0; j < v; j++) {\n                            for (k = 0; k < h; k++) {\n                                decodeMcu(component, decodeFn, mcu, j, k);\n                            }\n                        }\n                    }\n                    mcu++;\n                }\n            }\n\n            // find marker\n            bitsCount = 0;\n            marker = (data[offset] << 8) | data[offset + 1];\n            if (marker <= 0xFF00) {\n                throw "marker was not found";\n            }\n\n            if (marker >= 0xFFD0 && marker <= 0xFFD7) { // RSTx\n                offset += 2;\n            } else {\n                break;\n            }\n        }\n\n        return offset - startOffset;\n    }\n\n    // A port of poppler\'s IDCT method which in turn is taken from:\n    //   Christoph Loeffler, Adriaan Ligtenberg, George S. Moschytz,\n    //   "Practical Fast 1-D DCT Algorithms with 11 Multiplications",\n    //   IEEE Intl. Conf. on Acoustics, Speech & Signal Processing, 1989,\n    //   988-991.\n    function quantizeAndInverse(component, blockBufferOffset, p) {\n        var qt = component.quantizationTable;\n        var v0, v1, v2, v3, v4, v5, v6, v7, t;\n        var i;\n\n        // dequant\n        for (i = 0; i < 64; i++) {\n            p[i] = component.blockData[blockBufferOffset + i] * qt[i];\n        }\n\n        // inverse DCT on rows\n        for (i = 0; i < 8; ++i) {\n            var row = 8 * i;\n\n            // check for all-zero AC coefficients\n            if (p[1 + row] === 0 && p[2 + row] === 0 && p[3 + row] === 0 &&\n                p[4 + row] === 0 && p[5 + row] === 0 && p[6 + row] === 0 &&\n                p[7 + row] === 0) {\n                t = (dctSqrt2 * p[0 + row] + 512) >> 10;\n                p[0 + row] = t;\n                p[1 + row] = t;\n                p[2 + row] = t;\n                p[3 + row] = t;\n                p[4 + row] = t;\n                p[5 + row] = t;\n                p[6 + row] = t;\n                p[7 + row] = t;\n                continue;\n            }\n\n            // stage 4\n            v0 = (dctSqrt2 * p[0 + row] + 128) >> 8;\n            v1 = (dctSqrt2 * p[4 + row] + 128) >> 8;\n            v2 = p[2 + row];\n            v3 = p[6 + row];\n            v4 = (dctSqrt1d2 * (p[1 + row] - p[7 + row]) + 128) >> 8;\n            v7 = (dctSqrt1d2 * (p[1 + row] + p[7 + row]) + 128) >> 8;\n            v5 = p[3 + row] << 4;\n            v6 = p[5 + row] << 4;\n\n            // stage 3\n            t = (v0 - v1 + 1) >> 1;\n            v0 = (v0 + v1 + 1) >> 1;\n            v1 = t;\n            t = (v2 * dctSin6 + v3 * dctCos6 + 128) >> 8;\n            v2 = (v2 * dctCos6 - v3 * dctSin6 + 128) >> 8;\n            v3 = t;\n            t = (v4 - v6 + 1) >> 1;\n            v4 = (v4 + v6 + 1) >> 1;\n            v6 = t;\n            t = (v7 + v5 + 1) >> 1;\n            v5 = (v7 - v5 + 1) >> 1;\n            v7 = t;\n\n            // stage 2\n            t = (v0 - v3 + 1) >> 1;\n            v0 = (v0 + v3 + 1) >> 1;\n            v3 = t;\n            t = (v1 - v2 + 1) >> 1;\n            v1 = (v1 + v2 + 1) >> 1;\n            v2 = t;\n            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n            v7 = t;\n            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n            v6 = t;\n\n            // stage 1\n            p[0 + row] = v0 + v7;\n            p[7 + row] = v0 - v7;\n            p[1 + row] = v1 + v6;\n            p[6 + row] = v1 - v6;\n            p[2 + row] = v2 + v5;\n            p[5 + row] = v2 - v5;\n            p[3 + row] = v3 + v4;\n            p[4 + row] = v3 - v4;\n        }\n\n        // inverse DCT on columns\n        for (i = 0; i < 8; ++i) {\n            var col = i;\n\n            // check for all-zero AC coefficients\n            if (p[1 * 8 + col] === 0 && p[2 * 8 + col] === 0 && p[3 * 8 + col] === 0 &&\n                p[4 * 8 + col] === 0 && p[5 * 8 + col] === 0 && p[6 * 8 + col] === 0 &&\n                p[7 * 8 + col] === 0) {\n                t = (dctSqrt2 * p[i + 0] + 8192) >> 14;\n                p[0 * 8 + col] = t;\n                p[1 * 8 + col] = t;\n                p[2 * 8 + col] = t;\n                p[3 * 8 + col] = t;\n                p[4 * 8 + col] = t;\n                p[5 * 8 + col] = t;\n                p[6 * 8 + col] = t;\n                p[7 * 8 + col] = t;\n                continue;\n            }\n\n            // stage 4\n            v0 = (dctSqrt2 * p[0 * 8 + col] + 2048) >> 12;\n            v1 = (dctSqrt2 * p[4 * 8 + col] + 2048) >> 12;\n            v2 = p[2 * 8 + col];\n            v3 = p[6 * 8 + col];\n            v4 = (dctSqrt1d2 * (p[1 * 8 + col] - p[7 * 8 + col]) + 2048) >> 12;\n            v7 = (dctSqrt1d2 * (p[1 * 8 + col] + p[7 * 8 + col]) + 2048) >> 12;\n            v5 = p[3 * 8 + col];\n            v6 = p[5 * 8 + col];\n\n            // stage 3\n            t = (v0 - v1 + 1) >> 1;\n            v0 = (v0 + v1 + 1) >> 1;\n            v1 = t;\n            t = (v2 * dctSin6 + v3 * dctCos6 + 2048) >> 12;\n            v2 = (v2 * dctCos6 - v3 * dctSin6 + 2048) >> 12;\n            v3 = t;\n            t = (v4 - v6 + 1) >> 1;\n            v4 = (v4 + v6 + 1) >> 1;\n            v6 = t;\n            t = (v7 + v5 + 1) >> 1;\n            v5 = (v7 - v5 + 1) >> 1;\n            v7 = t;\n\n            // stage 2\n            t = (v0 - v3 + 1) >> 1;\n            v0 = (v0 + v3 + 1) >> 1;\n            v3 = t;\n            t = (v1 - v2 + 1) >> 1;\n            v1 = (v1 + v2 + 1) >> 1;\n            v2 = t;\n            t = (v4 * dctSin3 + v7 * dctCos3 + 2048) >> 12;\n            v4 = (v4 * dctCos3 - v7 * dctSin3 + 2048) >> 12;\n            v7 = t;\n            t = (v5 * dctSin1 + v6 * dctCos1 + 2048) >> 12;\n            v5 = (v5 * dctCos1 - v6 * dctSin1 + 2048) >> 12;\n            v6 = t;\n\n            // stage 1\n            p[0 * 8 + col] = v0 + v7;\n            p[7 * 8 + col] = v0 - v7;\n            p[1 * 8 + col] = v1 + v6;\n            p[6 * 8 + col] = v1 - v6;\n            p[2 * 8 + col] = v2 + v5;\n            p[5 * 8 + col] = v2 - v5;\n            p[3 * 8 + col] = v3 + v4;\n            p[4 * 8 + col] = v3 - v4;\n        }\n\n        // convert to 8-bit integers\n        for (i = 0; i < 64; ++i) {\n            var index = blockBufferOffset + i;\n            var q = p[i];\n            q = (q <= -2056 / component.bitConversion) ? 0 :\n                (q >= 2024 / component.bitConversion) ? 255 / component.bitConversion :\n                (q + 2056 / component.bitConversion) >> 4;\n            component.blockData[index] = q;\n        }\n    }\n\n    function buildComponentData(frame, component) {\n        var lines = [];\n        var blocksPerLine = component.blocksPerLine;\n        var blocksPerColumn = component.blocksPerColumn;\n        var samplesPerLine = blocksPerLine << 3;\n        var computationBuffer = new Int32Array(64);\n\n        var i, j, ll = 0;\n        for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n            for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                var offset = getBlockBufferOffset(component, blockRow, blockCol);\n                quantizeAndInverse(component, offset, computationBuffer);\n            }\n        }\n        return component.blockData;\n    }\n\n    function clampToUint8(a) {\n        return a <= 0 ? 0 : a >= 255 ? 255 : a | 0;\n    }\n\n    constructor.prototype = {\n        load: function load(path) {\n            var handleData = (function (data) {\n                this.parse(data);\n                if (this.onload)\n                    this.onload();\n            }).bind(this);\n\n            if (path.indexOf("data:") > -1) {\n                var offset = path.indexOf("base64,") + 7;\n                var data = atob(path.substring(offset));\n                var arr = new Uint8Array(data.length);\n                for (var i = data.length - 1; i >= 0; i--) {\n                    arr[i] = data.charCodeAt(i);\n                }\n                handleData(data);\n            } else {\n                var xhr = new XMLHttpRequest();\n                xhr.open("GET", path, true);\n                xhr.responseType = "arraybuffer";\n                xhr.onload = (function () {\n                    // TODO catch parse error\n                    var data = new Uint8Array(xhr.response);\n                    handleData(data);\n                }).bind(this);\n                xhr.send(null);\n            }\n        },\n        parse: function parse(data) {\n\n            function readUint16() {\n                var value = (data[offset] << 8) | data[offset + 1];\n                offset += 2;\n                return value;\n            }\n\n            function readDataBlock() {\n                var length = readUint16();\n                var array = data.subarray(offset, offset + length - 2);\n                offset += array.length;\n                return array;\n            }\n\n            function prepareComponents(frame) {\n                var mcusPerLine = Math.ceil(frame.samplesPerLine / 8 / frame.maxH);\n                var mcusPerColumn = Math.ceil(frame.scanLines / 8 / frame.maxV);\n                for (var i = 0; i < frame.components.length; i++) {\n                    component = frame.components[i];\n                    var blocksPerLine = Math.ceil(Math.ceil(frame.samplesPerLine / 8) * component.h / frame.maxH);\n                    var blocksPerColumn = Math.ceil(Math.ceil(frame.scanLines / 8) * component.v / frame.maxV);\n                    var blocksPerLineForMcu = mcusPerLine * component.h;\n                    var blocksPerColumnForMcu = mcusPerColumn * component.v;\n\n                    var blocksBufferSize = 64 * blocksPerColumnForMcu * (blocksPerLineForMcu + 1);\n                    component.blockData = new Int16Array(blocksBufferSize);\n                    component.blocksPerLine = blocksPerLine;\n                    component.blocksPerColumn = blocksPerColumn;\n                }\n                frame.mcusPerLine = mcusPerLine;\n                frame.mcusPerColumn = mcusPerColumn;\n            }\n\n            var offset = 0, length = data.length;\n            var jfif = null;\n            var adobe = null;\n            var pixels = null;\n            var frame, resetInterval;\n            var quantizationTables = [];\n            var huffmanTablesAC = [], huffmanTablesDC = [];\n            var fileMarker = readUint16();\n            if (fileMarker != 0xFFD8) { // SOI (Start of Image)\n                throw "SOI not found";\n            }\n\n            fileMarker = readUint16();\n            while (fileMarker != 0xFFD9) { // EOI (End of image)\n                var i, j, l;\n                switch (fileMarker) {\n                    case 0xFFE0: // APP0 (Application Specific)\n                    case 0xFFE1: // APP1\n                    case 0xFFE2: // APP2\n                    case 0xFFE3: // APP3\n                    case 0xFFE4: // APP4\n                    case 0xFFE5: // APP5\n                    case 0xFFE6: // APP6\n                    case 0xFFE7: // APP7\n                    case 0xFFE8: // APP8\n                    case 0xFFE9: // APP9\n                    case 0xFFEA: // APP10\n                    case 0xFFEB: // APP11\n                    case 0xFFEC: // APP12\n                    case 0xFFED: // APP13\n                    case 0xFFEE: // APP14\n                    case 0xFFEF: // APP15\n                    case 0xFFFE: // COM (Comment)\n                        var appData = readDataBlock();\n\n                        if (fileMarker === 0xFFE0) {\n                            if (appData[0] === 0x4A && appData[1] === 0x46 && appData[2] === 0x49 &&\n                                appData[3] === 0x46 && appData[4] === 0) { // \'JFIF\\x00\'\n                                jfif = {\n                                    version: {major: appData[5], minor: appData[6]},\n                                    densityUnits: appData[7],\n                                    xDensity: (appData[8] << 8) | appData[9],\n                                    yDensity: (appData[10] << 8) | appData[11],\n                                    thumbWidth: appData[12],\n                                    thumbHeight: appData[13],\n                                    thumbData: appData.subarray(14, 14 + 3 * appData[12] * appData[13])\n                                };\n                            }\n                        }\n                        // TODO APP1 - Exif\n                        if (fileMarker === 0xFFEE) {\n                            if (appData[0] === 0x41 && appData[1] === 0x64 && appData[2] === 0x6F &&\n                                appData[3] === 0x62 && appData[4] === 0x65 && appData[5] === 0) { // \'Adobe\\x00\'\n                                adobe = {\n                                    version: appData[6],\n                                    flags0: (appData[7] << 8) | appData[8],\n                                    flags1: (appData[9] << 8) | appData[10],\n                                    transformCode: appData[11]\n                                };\n                            }\n                        }\n                        break;\n\n                    case 0xFFDB: // DQT (Define Quantization Tables)\n                        var quantizationTablesLength = readUint16();\n                        var quantizationTablesEnd = quantizationTablesLength + offset - 2;\n                        while (offset < quantizationTablesEnd) {\n                            var quantizationTableSpec = data[offset++];\n                            var tableData = new Int32Array(64);\n                            if ((quantizationTableSpec >> 4) === 0) { // 8 bit values\n                                for (j = 0; j < 64; j++) {\n                                    var z = dctZigZag[j];\n                                    tableData[z] = data[offset++];\n                                }\n                            } else if ((quantizationTableSpec >> 4) === 1) { //16 bit\n                                for (j = 0; j < 64; j++) {\n                                    var zz = dctZigZag[j];\n                                    tableData[zz] = readUint16();\n                                }\n                            } else\n                                throw "DQT: invalid table spec";\n                            quantizationTables[quantizationTableSpec & 15] = tableData;\n                        }\n                        break;\n\n                    case 0xFFC0: // SOF0 (Start of Frame, Baseline DCT)\n                    case 0xFFC1: // SOF1 (Start of Frame, Extended DCT)\n                    case 0xFFC2: // SOF2 (Start of Frame, Progressive DCT)\n                        if (frame) {\n                            throw "Only single frame JPEGs supported";\n                        }\n                        readUint16(); // skip data length\n                        frame = {};\n                        frame.extended = (fileMarker === 0xFFC1);\n                        frame.progressive = (fileMarker === 0xFFC2);\n                        frame.precision = data[offset++];\n                        frame.scanLines = readUint16();\n                        frame.samplesPerLine = readUint16();\n                        frame.components = [];\n                        frame.componentIds = {};\n                        var componentsCount = data[offset++], componentId;\n                        var maxH = 0, maxV = 0;\n                        for (i = 0; i < componentsCount; i++) {\n                            componentId = data[offset];\n                            var h = data[offset + 1] >> 4;\n                            var v = data[offset + 1] & 15;\n                            if (maxH < h)\n                                maxH = h;\n                            if (maxV < v)\n                                maxV = v;\n                            var qId = data[offset + 2];\n                            l = frame.components.push({\n                                h: h,\n                                v: v,\n                                quantizationTable: quantizationTables[qId],\n                                quantizationTableId: qId,\n                                bitConversion: 255 / ((1 << frame.precision) - 1)\n                            });\n                            frame.componentIds[componentId] = l - 1;\n                            offset += 3;\n                        }\n                        frame.maxH = maxH;\n                        frame.maxV = maxV;\n                        prepareComponents(frame);\n                        break;\n\n                    case 0xFFC4: // DHT (Define Huffman Tables)\n                        var huffmanLength = readUint16();\n                        for (i = 2; i < huffmanLength; ) {\n                            var huffmanTableSpec = data[offset++];\n                            var codeLengths = new Uint8Array(16);\n                            var codeLengthSum = 0;\n                            for (j = 0; j < 16; j++, offset++)\n                                codeLengthSum += (codeLengths[j] = data[offset]);\n                            var huffmanValues = new Uint8Array(codeLengthSum);\n                            for (j = 0; j < codeLengthSum; j++, offset++)\n                                huffmanValues[j] = data[offset];\n                            i += 17 + codeLengthSum;\n\n                            ((huffmanTableSpec >> 4) === 0 ?\n                                huffmanTablesDC : huffmanTablesAC)[huffmanTableSpec & 15] =\n                                buildHuffmanTable(codeLengths, huffmanValues);\n                        }\n                        break;\n\n                    case 0xFFDD: // DRI (Define Restart Interval)\n                        readUint16(); // skip data length\n                        resetInterval = readUint16();\n                        break;\n\n                    case 0xFFDA: // SOS (Start of Scan)\n                        var scanLength = readUint16();\n                        var selectorsCount = data[offset++];\n                        var components = [], component;\n                        for (i = 0; i < selectorsCount; i++) {\n                            var componentIndex = frame.componentIds[data[offset++]];\n                            component = frame.components[componentIndex];\n                            var tableSpec = data[offset++];\n                            component.huffmanTableDC = huffmanTablesDC[tableSpec >> 4];\n                            component.huffmanTableAC = huffmanTablesAC[tableSpec & 15];\n                            components.push(component);\n                        }\n                        var spectralStart = data[offset++];\n                        var spectralEnd = data[offset++];\n                        var successiveApproximation = data[offset++];\n                        var processed = decodeScan(data, offset,\n                            frame, components, resetInterval,\n                            spectralStart, spectralEnd,\n                            successiveApproximation >> 4, successiveApproximation & 15);\n                        offset += processed;\n                        break;\n                    default:\n                        if (data[offset - 3] == 0xFF &&\n                            data[offset - 2] >= 0xC0 && data[offset - 2] <= 0xFE) {\n                            // could be incorrect encoding -- last 0xFF byte of the previous\n                            // block was eaten by the encoder\n                            offset -= 3;\n                            break;\n                        }\n                        throw "unknown JPEG marker " + fileMarker.toString(16);\n                }\n                fileMarker = readUint16();\n            }\n\n            this.width = frame.samplesPerLine;\n            this.height = frame.scanLines;\n            this.jfif = jfif;\n            this.adobe = adobe;\n            this.components = [];\n            switch (frame.components.length)\n            {\n                case 1:\n                    this.colorspace = ColorSpace.Grayscale;\n                    break;\n                case 3:\n                    if (this.adobe)\n                        this.colorspace = ColorSpace.AdobeRGB;\n                    else\n                        this.colorspace = ColorSpace.RGB;\n                    break;\n                case 4:\n                    this.colorspace = ColorSpace.CYMK;\n                    break;\n                default:\n                    this.colorspace = ColorSpace.Unknown;\n            }\n            for (var i = 0; i < frame.components.length; i++) {\n                var component = frame.components[i];\n                if (!component.quantizationTable && component.quantizationTableId !== null)\n                    component.quantizationTable = quantizationTables[component.quantizationTableId];\n                this.components.push({\n                    output: buildComponentData(frame, component),\n                    scaleX: component.h / frame.maxH,\n                    scaleY: component.v / frame.maxV,\n                    blocksPerLine: component.blocksPerLine,\n                    blocksPerColumn: component.blocksPerColumn,\n                    bitConversion: component.bitConversion\n                });\n            }\n        },\n        getData16: function getData16(width, height) {\n            if (this.components.length !== 1)\n                throw \'Unsupported color mode\';\n            var scaleX = this.width / width, scaleY = this.height / height;\n\n            var component, componentScaleX, componentScaleY;\n            var x, y, i;\n            var offset = 0;\n            var numComponents = this.components.length;\n            var dataLength = width * height * numComponents;\n            var data = new Uint16Array(dataLength);\n            var componentLine;\n\n            // lineData is reused for all components. Assume first component is\n            // the biggest\n            var lineData = new Uint16Array((this.components[0].blocksPerLine << 3) *\n                this.components[0].blocksPerColumn * 8);\n\n            // First construct image data ...\n            for (i = 0; i < numComponents; i++) {\n                component = this.components[i];\n                var blocksPerLine = component.blocksPerLine;\n                var blocksPerColumn = component.blocksPerColumn;\n                var samplesPerLine = blocksPerLine << 3;\n\n                var j, k, ll = 0;\n                var lineOffset = 0;\n                for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                    var scanLine = blockRow << 3;\n                    for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                        var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);\n                        var offset = 0, sample = blockCol << 3;\n                        for (j = 0; j < 8; j++) {\n                            var lineOffset = (scanLine + j) * samplesPerLine;\n                            for (k = 0; k < 8; k++) {\n                                lineData[lineOffset + sample + k] =\n                                    component.output[bufferOffset + offset++];\n                            }\n                        }\n                    }\n                }\n\n                componentScaleX = component.scaleX * scaleX;\n                componentScaleY = component.scaleY * scaleY;\n                offset = i;\n\n                var cx, cy;\n                var index;\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        cy = 0 | (y * componentScaleY);\n                        cx = 0 | (x * componentScaleX);\n                        index = cy * samplesPerLine + cx;\n                        data[offset] = lineData[index];\n                        offset += numComponents;\n                    }\n                }\n            }\n            return data;\n        },\n        getData: function getData(width, height) {\n            var scaleX = this.width / width, scaleY = this.height / height;\n\n            var component, componentScaleX, componentScaleY;\n            var x, y, i;\n            var offset = 0;\n            var Y, Cb, Cr, K, C, M, Ye, R, G, B;\n            var colorTransform;\n            var numComponents = this.components.length;\n            var dataLength = width * height * numComponents;\n            var data = new Uint8Array(dataLength);\n            var componentLine;\n\n            // lineData is reused for all components. Assume first component is\n            // the biggest\n            var lineData = new Uint8Array((this.components[0].blocksPerLine << 3) *\n                this.components[0].blocksPerColumn * 8);\n\n            // First construct image data ...\n            for (i = 0; i < numComponents; i++) {\n                component = this.components[i];\n                var blocksPerLine = component.blocksPerLine;\n                var blocksPerColumn = component.blocksPerColumn;\n                var samplesPerLine = blocksPerLine << 3;\n\n                var j, k, ll = 0;\n                var lineOffset = 0;\n                for (var blockRow = 0; blockRow < blocksPerColumn; blockRow++) {\n                    var scanLine = blockRow << 3;\n                    for (var blockCol = 0; blockCol < blocksPerLine; blockCol++) {\n                        var bufferOffset = getBlockBufferOffset(component, blockRow, blockCol);\n                        var offset = 0, sample = blockCol << 3;\n                        for (j = 0; j < 8; j++) {\n                            var lineOffset = (scanLine + j) * samplesPerLine;\n                            for (k = 0; k < 8; k++) {\n                                lineData[lineOffset + sample + k] =\n                                    component.output[bufferOffset + offset++] * component.bitConversion;\n                            }\n                        }\n                    }\n                }\n\n                componentScaleX = component.scaleX * scaleX;\n                componentScaleY = component.scaleY * scaleY;\n                offset = i;\n\n                var cx, cy;\n                var index;\n                for (y = 0; y < height; y++) {\n                    for (x = 0; x < width; x++) {\n                        cy = 0 | (y * componentScaleY);\n                        cx = 0 | (x * componentScaleX);\n                        index = cy * samplesPerLine + cx;\n                        data[offset] = lineData[index];\n                        offset += numComponents;\n                    }\n                }\n            }\n\n            // ... then transform colors, if necessary\n            switch (numComponents) {\n                case 1:\n                case 2:\n                    break;\n                // no color conversion for one or two compoenents\n\n                case 3:\n                    // The default transform for three components is true\n                    colorTransform = true;\n                    // The adobe transform marker overrides any previous setting\n                    if (this.adobe && this.adobe.transformCode)\n                        colorTransform = true;\n                    else if (typeof this.colorTransform !== \'undefined\')\n                        colorTransform = !!this.colorTransform;\n\n                    if (colorTransform) {\n                        for (i = 0; i < dataLength; i += numComponents) {\n                            Y = data[i    ];\n                            Cb = data[i + 1];\n                            Cr = data[i + 2];\n\n                            R = clampToUint8(Y - 179.456 + 1.402 * Cr);\n                            G = clampToUint8(Y + 135.459 - 0.344 * Cb - 0.714 * Cr);\n                            B = clampToUint8(Y - 226.816 + 1.772 * Cb);\n\n                            data[i    ] = R;\n                            data[i + 1] = G;\n                            data[i + 2] = B;\n                        }\n                    }\n                    break;\n                case 4:\n                    if (!this.adobe)\n                        throw \'Unsupported color mode (4 components)\';\n                    // The default transform for four components is false\n                    colorTransform = false;\n                    // The adobe transform marker overrides any previous setting\n                    if (this.adobe && this.adobe.transformCode)\n                        colorTransform = true;\n                    else if (typeof this.colorTransform !== \'undefined\')\n                        colorTransform = !!this.colorTransform;\n\n                    if (colorTransform) {\n                        for (i = 0; i < dataLength; i += numComponents) {\n                            Y = data[i];\n                            Cb = data[i + 1];\n                            Cr = data[i + 2];\n\n                            C = clampToUint8(434.456 - Y - 1.402 * Cr);\n                            M = clampToUint8(119.541 - Y + 0.344 * Cb + 0.714 * Cr);\n                            Y = clampToUint8(481.816 - Y - 1.772 * Cb);\n\n                            data[i    ] = C;\n                            data[i + 1] = M;\n                            data[i + 2] = Y;\n                            // K is unchanged\n                        }\n                    }\n                    break;\n                default:\n                    throw \'Unsupported color mode\';\n            }\n            return data;\n        },\n        copyToImageData: function copyToImageData(imageData) {\n            var width = imageData.width, height = imageData.height;\n            var imageDataBytes = width * height * 4;\n            var imageDataArray = imageData.data;\n            var data = this.getData16(width, height);\n            var i = 0, j = 0, k0, k1;\n            var Y, K, C, M, R, G, B;\n            switch (this.components.length) {\n                case 1:\n                    while (j < imageDataBytes) {\n                        Y = data[i++];\n\n                        imageDataArray[j++] = Y;\n                        imageDataArray[j++] = Y;\n                        imageDataArray[j++] = Y;\n                        imageDataArray[j++] = 255;\n                    }\n                    break;\n                case 3:\n                    while (j < imageDataBytes) {\n                        R = data[i++];\n                        G = data[i++];\n                        B = data[i++];\n\n                        imageDataArray[j++] = R;\n                        imageDataArray[j++] = G;\n                        imageDataArray[j++] = B;\n                        imageDataArray[j++] = 255;\n                    }\n                    break;\n                case 4:\n                    while (j < imageDataBytes) {\n                        C = data[i++];\n                        M = data[i++];\n                        Y = data[i++];\n                        K = data[i++];\n\n                        k0 = 255 - K;\n                        k1 = k0 / 255;\n\n\n                        R = clampToUint8(k0 - C * k1);\n                        G = clampToUint8(k0 - M * k1);\n                        B = clampToUint8(k0 - Y * k1);\n\n                        imageDataArray[j++] = R;\n                        imageDataArray[j++] = G;\n                        imageDataArray[j++] = B;\n                        imageDataArray[j++] = 255;\n                    }\n                    break;\n                default:\n                    throw \'Unsupported color mode\';\n            }\n        }\n    };\n\n    return constructor;\n})();\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = {\n        JpegImage: JpegImage\n    };\n}\n},{}],2:[function(require,module,exports){\n/*! image-JPEG2000 - v0.3.1 - 2015-08-26 | https://github.com/OHIF/image-JPEG2000 */\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* globals ArithmeticDecoder, globalScope, log2, readUint16, readUint32,\n           info, warn */\n\n\'use strict\';\n\nvar JpxImage = (function JpxImageClosure() {\n  // Table E.1\n  var SubbandsGainLog2 = {\n    \'LL\': 0,\n    \'LH\': 1,\n    \'HL\': 1,\n    \'HH\': 2\n  };\n  function JpxImage() {\n    this.failOnCorruptedImage = false;\n  }\n  JpxImage.prototype = {\n    parse: function JpxImage_parse(data) {\n\n      var head = readUint16(data, 0);\n      // No box header, immediate start of codestream (SOC)\n      if (head === 0xFF4F) {\n        this.parseCodestream(data, 0, data.length);\n        return;\n      }\n\n      var position = 0, length = data.length;\n      while (position < length) {\n        var headerSize = 8;\n        var lbox = readUint32(data, position);\n        var tbox = readUint32(data, position + 4);\n        position += headerSize;\n        if (lbox === 1) {\n          // XLBox: read UInt64 according to spec.\n          // JavaScript\'s int precision of 53 bit should be sufficient here.\n          lbox = readUint32(data, position) * 4294967296 +\n                 readUint32(data, position + 4);\n          position += 8;\n          headerSize += 8;\n        }\n        if (lbox === 0) {\n          lbox = length - position + headerSize;\n        }\n        if (lbox < headerSize) {\n          throw new Error(\'JPX Error: Invalid box field size\');\n        }\n        var dataLength = lbox - headerSize;\n        var jumpDataLength = true;\n        switch (tbox) {\n          case 0x6A703268: // \'jp2h\'\n            jumpDataLength = false; // parsing child boxes\n            break;\n          case 0x636F6C72: // \'colr\'\n            // Colorspaces are not used, the CS from the PDF is used.\n            var method = data[position];\n            var precedence = data[position + 1];\n            var approximation = data[position + 2];\n            if (method === 1) {\n              // enumerated colorspace\n              var colorspace = readUint32(data, position + 3);\n              switch (colorspace) {\n                case 16: // this indicates a sRGB colorspace\n                case 17: // this indicates a grayscale colorspace\n                case 18: // this indicates a YUV colorspace\n                  break;\n                default:\n                  warn(\'Unknown colorspace \' + colorspace);\n                  break;\n              }\n            } else if (method === 2) {\n              info(\'ICC profile not supported\');\n            }\n            break;\n          case 0x6A703263: // \'jp2c\'\n            this.parseCodestream(data, position, position + dataLength);\n            break;\n          case 0x6A502020: // \'jP\\024\\024\'\n            if (0x0d0a870a !== readUint32(data, position)) {\n              warn(\'Invalid JP2 signature\');\n            }\n            break;\n          // The following header types are valid but currently not used:\n          case 0x6A501A1A: // \'jP\\032\\032\'\n          case 0x66747970: // \'ftyp\'\n          case 0x72726571: // \'rreq\'\n          case 0x72657320: // \'res \'\n          case 0x69686472: // \'ihdr\'\n            break;\n          default:\n            var headerType = String.fromCharCode((tbox >> 24) & 0xFF,\n                                                 (tbox >> 16) & 0xFF,\n                                                 (tbox >> 8) & 0xFF,\n                                                 tbox & 0xFF);\n            warn(\'Unsupported header type \' + tbox + \' (\' + headerType + \')\');\n            break;\n        }\n        if (jumpDataLength) {\n          position += dataLength;\n        }\n      }\n    },\n    parseImageProperties: function JpxImage_parseImageProperties(stream) {\n      var newByte = stream.getByte();\n      while (newByte >= 0) {\n        var oldByte = newByte;\n        newByte = stream.getByte();\n        var code = (oldByte << 8) | newByte;\n        // Image and tile size (SIZ)\n        if (code === 0xFF51) {\n          stream.skip(4);\n          var Xsiz = stream.getInt32() >>> 0; // Byte 4\n          var Ysiz = stream.getInt32() >>> 0; // Byte 8\n          var XOsiz = stream.getInt32() >>> 0; // Byte 12\n          var YOsiz = stream.getInt32() >>> 0; // Byte 16\n          stream.skip(16);\n          var Csiz = stream.getUint16(); // Byte 36\n          this.width = Xsiz - XOsiz;\n          this.height = Ysiz - YOsiz;\n          this.componentsCount = Csiz;\n          // Results are always returned as Uint8Arrays\n          this.bitsPerComponent = 8;\n          return;\n        }\n      }\n      throw new Error(\'JPX Error: No size marker found in JPX stream\');\n    },\n    parseCodestream: function JpxImage_parseCodestream(data, start, end) {\n      var context = {};\n      try {\n        var doNotRecover = false;\n        var position = start;\n        while (position + 1 < end) {\n          var code = readUint16(data, position);\n          position += 2;\n\n          var length = 0, j, sqcd, spqcds, spqcdSize, scalarExpounded, tile;\n          switch (code) {\n            case 0xFF4F: // Start of codestream (SOC)\n              context.mainHeader = true;\n              break;\n            case 0xFFD9: // End of codestream (EOC)\n              break;\n            case 0xFF51: // Image and tile size (SIZ)\n              length = readUint16(data, position);\n              var siz = {};\n              siz.Xsiz = readUint32(data, position + 4);\n              siz.Ysiz = readUint32(data, position + 8);\n              siz.XOsiz = readUint32(data, position + 12);\n              siz.YOsiz = readUint32(data, position + 16);\n              siz.XTsiz = readUint32(data, position + 20);\n              siz.YTsiz = readUint32(data, position + 24);\n              siz.XTOsiz = readUint32(data, position + 28);\n              siz.YTOsiz = readUint32(data, position + 32);\n              var componentsCount = readUint16(data, position + 36);\n              siz.Csiz = componentsCount;\n              var components = [];\n              j = position + 38;\n              for (var i = 0; i < componentsCount; i++) {\n                var component = {\n                  precision: (data[j] & 0x7F) + 1,\n                  isSigned: !!(data[j] & 0x80),\n                  XRsiz: data[j + 1],\n                  YRsiz: data[j + 1]\n                };\n                calculateComponentDimensions(component, siz);\n                components.push(component);\n              }\n              context.SIZ = siz;\n              context.components = components;\n              calculateTileGrids(context, components);\n              context.QCC = [];\n              context.COC = [];\n              break;\n            case 0xFF5C: // Quantization default (QCD)\n              length = readUint16(data, position);\n              var qcd = {};\n              j = position + 2;\n              sqcd = data[j++];\n              switch (sqcd & 0x1F) {\n                case 0:\n                  spqcdSize = 8;\n                  scalarExpounded = true;\n                  break;\n                case 1:\n                  spqcdSize = 16;\n                  scalarExpounded = false;\n                  break;\n                case 2:\n                  spqcdSize = 16;\n                  scalarExpounded = true;\n                  break;\n                default:\n                  throw new Error(\'JPX Error: Invalid SQcd value \' + sqcd);\n              }\n              qcd.noQuantization = (spqcdSize === 8);\n              qcd.scalarExpounded = scalarExpounded;\n              qcd.guardBits = sqcd >> 5;\n              spqcds = [];\n              while (j < length + position) {\n                var spqcd = {};\n                if (spqcdSize === 8) {\n                  spqcd.epsilon = data[j++] >> 3;\n                  spqcd.mu = 0;\n                } else {\n                  spqcd.epsilon = data[j] >> 3;\n                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];\n                  j += 2;\n                }\n                spqcds.push(spqcd);\n              }\n              qcd.SPqcds = spqcds;\n              if (context.mainHeader) {\n                context.QCD = qcd;\n              } else {\n                context.currentTile.QCD = qcd;\n                context.currentTile.QCC = [];\n              }\n              break;\n            case 0xFF5D: // Quantization component (QCC)\n              length = readUint16(data, position);\n              var qcc = {};\n              j = position + 2;\n              var cqcc;\n              if (context.SIZ.Csiz < 257) {\n                cqcc = data[j++];\n              } else {\n                cqcc = readUint16(data, j);\n                j += 2;\n              }\n              sqcd = data[j++];\n              switch (sqcd & 0x1F) {\n                case 0:\n                  spqcdSize = 8;\n                  scalarExpounded = true;\n                  break;\n                case 1:\n                  spqcdSize = 16;\n                  scalarExpounded = false;\n                  break;\n                case 2:\n                  spqcdSize = 16;\n                  scalarExpounded = true;\n                  break;\n                default:\n                  throw new Error(\'JPX Error: Invalid SQcd value \' + sqcd);\n              }\n              qcc.noQuantization = (spqcdSize === 8);\n              qcc.scalarExpounded = scalarExpounded;\n              qcc.guardBits = sqcd >> 5;\n              spqcds = [];\n              while (j < (length + position)) {\n                spqcd = {};\n                if (spqcdSize === 8) {\n                  spqcd.epsilon = data[j++] >> 3;\n                  spqcd.mu = 0;\n                } else {\n                  spqcd.epsilon = data[j] >> 3;\n                  spqcd.mu = ((data[j] & 0x7) << 8) | data[j + 1];\n                  j += 2;\n                }\n                spqcds.push(spqcd);\n              }\n              qcc.SPqcds = spqcds;\n              if (context.mainHeader) {\n                context.QCC[cqcc] = qcc;\n              } else {\n                context.currentTile.QCC[cqcc] = qcc;\n              }\n              break;\n            case 0xFF52: // Coding style default (COD)\n              length = readUint16(data, position);\n              var cod = {};\n              j = position + 2;\n              var scod = data[j++];\n              cod.entropyCoderWithCustomPrecincts = !!(scod & 1);\n              cod.sopMarkerUsed = !!(scod & 2);\n              cod.ephMarkerUsed = !!(scod & 4);\n              cod.progressionOrder = data[j++];\n              cod.layersCount = readUint16(data, j);\n              j += 2;\n              cod.multipleComponentTransform = data[j++];\n\n              cod.decompositionLevelsCount = data[j++];\n              cod.xcb = (data[j++] & 0xF) + 2;\n              cod.ycb = (data[j++] & 0xF) + 2;\n              var blockStyle = data[j++];\n              cod.selectiveArithmeticCodingBypass = !!(blockStyle & 1);\n              cod.resetContextProbabilities = !!(blockStyle & 2);\n              cod.terminationOnEachCodingPass = !!(blockStyle & 4);\n              cod.verticalyStripe = !!(blockStyle & 8);\n              cod.predictableTermination = !!(blockStyle & 16);\n              cod.segmentationSymbolUsed = !!(blockStyle & 32);\n              cod.reversibleTransformation = data[j++];\n              if (cod.entropyCoderWithCustomPrecincts) {\n                var precinctsSizes = [];\n                while (j < length + position) {\n                  var precinctsSize = data[j++];\n                  precinctsSizes.push({\n                    PPx: precinctsSize & 0xF,\n                    PPy: precinctsSize >> 4\n                  });\n                }\n                cod.precinctsSizes = precinctsSizes;\n              }\n              var unsupported = [];\n              if (cod.selectiveArithmeticCodingBypass) {\n                unsupported.push(\'selectiveArithmeticCodingBypass\');\n              }\n              if (cod.resetContextProbabilities) {\n                unsupported.push(\'resetContextProbabilities\');\n              }\n              if (cod.terminationOnEachCodingPass) {\n                unsupported.push(\'terminationOnEachCodingPass\');\n              }\n              if (cod.verticalyStripe) {\n                unsupported.push(\'verticalyStripe\');\n              }\n              if (cod.predictableTermination) {\n                unsupported.push(\'predictableTermination\');\n              }\n              if (unsupported.length > 0) {\n                doNotRecover = true;\n                throw new Error(\'JPX Error: Unsupported COD options (\' +\n                                unsupported.join(\', \') + \')\');\n              }\n              if (context.mainHeader) {\n                context.COD = cod;\n              } else {\n                context.currentTile.COD = cod;\n                context.currentTile.COC = [];\n              }\n              break;\n            case 0xFF90: // Start of tile-part (SOT)\n              length = readUint16(data, position);\n              tile = {};\n              tile.index = readUint16(data, position + 2);\n              tile.length = readUint32(data, position + 4);\n              tile.dataEnd = tile.length + position - 2;\n              tile.partIndex = data[position + 8];\n              tile.partsCount = data[position + 9];\n\n              context.mainHeader = false;\n              if (tile.partIndex === 0) {\n                // reset component specific settings\n                tile.COD = context.COD;\n                tile.COC = context.COC.slice(0); // clone of the global COC\n                tile.QCD = context.QCD;\n                tile.QCC = context.QCC.slice(0); // clone of the global COC\n              }\n              context.currentTile = tile;\n              break;\n            case 0xFF93: // Start of data (SOD)\n              tile = context.currentTile;\n              if (tile.partIndex === 0) {\n                initializeTile(context, tile.index);\n                buildPackets(context);\n              }\n\n              // moving to the end of the data\n              length = tile.dataEnd - position;\n              parseTilePackets(context, data, position, length);\n              break;\n            case 0xFF55: // Tile-part lengths, main header (TLM)\n            case 0xFF57: // Packet length, main header (PLM)\n            case 0xFF58: // Packet length, tile-part header (PLT)\n            case 0xFF64: // Comment (COM)\n              length = readUint16(data, position);\n              // skipping content\n              break;\n            case 0xFF53: // Coding style component (COC)\n              throw new Error(\'JPX Error: Codestream code 0xFF53 (COC) is \' +\n                              \'not implemented\');\n            default:\n              throw new Error(\'JPX Error: Unknown codestream code: \' +\n                              code.toString(16));\n          }\n          position += length;\n        }\n      } catch (e) {\n        if (doNotRecover || this.failOnCorruptedImage) {\n          throw e;\n        } else {\n          warn(\'Trying to recover from \' + e.message);\n        }\n      }\n      this.tiles = transformComponents(context);\n      this.width = context.SIZ.Xsiz - context.SIZ.XOsiz;\n      this.height = context.SIZ.Ysiz - context.SIZ.YOsiz;\n      this.componentsCount = context.SIZ.Csiz;\n    }\n  };\n  function calculateComponentDimensions(component, siz) {\n    // Section B.2 Component mapping\n    component.x0 = Math.ceil(siz.XOsiz / component.XRsiz);\n    component.x1 = Math.ceil(siz.Xsiz / component.XRsiz);\n    component.y0 = Math.ceil(siz.YOsiz / component.YRsiz);\n    component.y1 = Math.ceil(siz.Ysiz / component.YRsiz);\n    component.width = component.x1 - component.x0;\n    component.height = component.y1 - component.y0;\n  }\n  function calculateTileGrids(context, components) {\n    var siz = context.SIZ;\n    // Section B.3 Division into tile and tile-components\n    var tile, tiles = [];\n    var numXtiles = Math.ceil((siz.Xsiz - siz.XTOsiz) / siz.XTsiz);\n    var numYtiles = Math.ceil((siz.Ysiz - siz.YTOsiz) / siz.YTsiz);\n    for (var q = 0; q < numYtiles; q++) {\n      for (var p = 0; p < numXtiles; p++) {\n        tile = {};\n        tile.tx0 = Math.max(siz.XTOsiz + p * siz.XTsiz, siz.XOsiz);\n        tile.ty0 = Math.max(siz.YTOsiz + q * siz.YTsiz, siz.YOsiz);\n        tile.tx1 = Math.min(siz.XTOsiz + (p + 1) * siz.XTsiz, siz.Xsiz);\n        tile.ty1 = Math.min(siz.YTOsiz + (q + 1) * siz.YTsiz, siz.Ysiz);\n        tile.width = tile.tx1 - tile.tx0;\n        tile.height = tile.ty1 - tile.ty0;\n        tile.components = [];\n        tiles.push(tile);\n      }\n    }\n    context.tiles = tiles;\n\n    var componentsCount = siz.Csiz;\n    for (var i = 0, ii = componentsCount; i < ii; i++) {\n      var component = components[i];\n      for (var j = 0, jj = tiles.length; j < jj; j++) {\n        var tileComponent = {};\n        tile = tiles[j];\n        tileComponent.tcx0 = Math.ceil(tile.tx0 / component.XRsiz);\n        tileComponent.tcy0 = Math.ceil(tile.ty0 / component.YRsiz);\n        tileComponent.tcx1 = Math.ceil(tile.tx1 / component.XRsiz);\n        tileComponent.tcy1 = Math.ceil(tile.ty1 / component.YRsiz);\n        tileComponent.width = tileComponent.tcx1 - tileComponent.tcx0;\n        tileComponent.height = tileComponent.tcy1 - tileComponent.tcy0;\n        tile.components[i] = tileComponent;\n      }\n    }\n  }\n  function getBlocksDimensions(context, component, r) {\n    var codOrCoc = component.codingStyleParameters;\n    var result = {};\n    if (!codOrCoc.entropyCoderWithCustomPrecincts) {\n      result.PPx = 15;\n      result.PPy = 15;\n    } else {\n      result.PPx = codOrCoc.precinctsSizes[r].PPx;\n      result.PPy = codOrCoc.precinctsSizes[r].PPy;\n    }\n    // calculate codeblock size as described in section B.7\n    result.xcb_ = (r > 0 ? Math.min(codOrCoc.xcb, result.PPx - 1) :\n                   Math.min(codOrCoc.xcb, result.PPx));\n    result.ycb_ = (r > 0 ? Math.min(codOrCoc.ycb, result.PPy - 1) :\n                   Math.min(codOrCoc.ycb, result.PPy));\n    return result;\n  }\n  function buildPrecincts(context, resolution, dimensions) {\n    // Section B.6 Division resolution to precincts\n    var precinctWidth = 1 << dimensions.PPx;\n    var precinctHeight = 1 << dimensions.PPy;\n    // Jasper introduces codeblock groups for mapping each subband codeblocks\n    // to precincts. Precinct partition divides a resolution according to width\n    // and height parameters. The subband that belongs to the resolution level\n    // has a different size than the level, unless it is the zero resolution.\n\n    // From Jasper documentation: jpeg2000.pdf, section K: Tier-2 coding:\n    // The precinct partitioning for a particular subband is derived from a\n    // partitioning of its parent LL band (i.e., the LL band at the next higher\n    // resolution level)... The LL band associated with each resolution level is\n    // divided into precincts... Each of the resulting precinct regions is then\n    // mapped into its child subbands (if any) at the next lower resolution\n    // level. This is accomplished by using the coordinate transformation\n    // (u, v) = (ceil(x/2), ceil(y/2)) where (x, y) and (u, v) are the\n    // coordinates of a point in the LL band and child subband, respectively.\n    var isZeroRes = resolution.resLevel === 0;\n    var precinctWidthInSubband = 1 << (dimensions.PPx + (isZeroRes ? 0 : -1));\n    var precinctHeightInSubband = 1 << (dimensions.PPy + (isZeroRes ? 0 : -1));\n    var numprecinctswide = (resolution.trx1 > resolution.trx0 ?\n      Math.ceil(resolution.trx1 / precinctWidth) -\n      Math.floor(resolution.trx0 / precinctWidth) : 0);\n    var numprecinctshigh = (resolution.try1 > resolution.try0 ?\n      Math.ceil(resolution.try1 / precinctHeight) -\n      Math.floor(resolution.try0 / precinctHeight) : 0);\n    var numprecincts = numprecinctswide * numprecinctshigh;\n\n    resolution.precinctParameters = {\n      precinctWidth: precinctWidth,\n      precinctHeight: precinctHeight,\n      numprecinctswide: numprecinctswide,\n      numprecinctshigh: numprecinctshigh,\n      numprecincts: numprecincts,\n      precinctWidthInSubband: precinctWidthInSubband,\n      precinctHeightInSubband: precinctHeightInSubband\n    };\n  }\n  function buildCodeblocks(context, subband, dimensions) {\n    // Section B.7 Division sub-band into code-blocks\n    var xcb_ = dimensions.xcb_;\n    var ycb_ = dimensions.ycb_;\n    var codeblockWidth = 1 << xcb_;\n    var codeblockHeight = 1 << ycb_;\n    var cbx0 = subband.tbx0 >> xcb_;\n    var cby0 = subband.tby0 >> ycb_;\n    var cbx1 = (subband.tbx1 + codeblockWidth - 1) >> xcb_;\n    var cby1 = (subband.tby1 + codeblockHeight - 1) >> ycb_;\n    var precinctParameters = subband.resolution.precinctParameters;\n    var codeblocks = [];\n    var precincts = [];\n    var i, j, codeblock, precinctNumber;\n    for (j = cby0; j < cby1; j++) {\n      for (i = cbx0; i < cbx1; i++) {\n        codeblock = {\n          cbx: i,\n          cby: j,\n          tbx0: codeblockWidth * i,\n          tby0: codeblockHeight * j,\n          tbx1: codeblockWidth * (i + 1),\n          tby1: codeblockHeight * (j + 1)\n        };\n\n        codeblock.tbx0_ = Math.max(subband.tbx0, codeblock.tbx0);\n        codeblock.tby0_ = Math.max(subband.tby0, codeblock.tby0);\n        codeblock.tbx1_ = Math.min(subband.tbx1, codeblock.tbx1);\n        codeblock.tby1_ = Math.min(subband.tby1, codeblock.tby1);\n\n        // Calculate precinct number for this codeblock, codeblock position\n        // should be relative to its subband, use actual dimension and position\n        // See comment about codeblock group width and height\n        var pi = Math.floor((codeblock.tbx0_ - subband.tbx0) /\n          precinctParameters.precinctWidthInSubband);\n        var pj = Math.floor((codeblock.tby0_ - subband.tby0) /\n          precinctParameters.precinctHeightInSubband);\n        precinctNumber = pi + (pj * precinctParameters.numprecinctswide);\n\n        codeblock.precinctNumber = precinctNumber;\n        codeblock.subbandType = subband.type;\n        codeblock.Lblock = 3;\n\n        if (codeblock.tbx1_ <= codeblock.tbx0_ ||\n            codeblock.tby1_ <= codeblock.tby0_) {\n          continue;\n        }\n        codeblocks.push(codeblock);\n        // building precinct for the sub-band\n        var precinct = precincts[precinctNumber];\n        if (precinct !== undefined) {\n          if (i < precinct.cbxMin) {\n            precinct.cbxMin = i;\n          } else if (i > precinct.cbxMax) {\n            precinct.cbxMax = i;\n          }\n          if (j < precinct.cbyMin) {\n            precinct.cbxMin = j;\n          } else if (j > precinct.cbyMax) {\n            precinct.cbyMax = j;\n          }\n        } else {\n          precincts[precinctNumber] = precinct = {\n            cbxMin: i,\n            cbyMin: j,\n            cbxMax: i,\n            cbyMax: j\n          };\n        }\n        codeblock.precinct = precinct;\n      }\n    }\n    subband.codeblockParameters = {\n      codeblockWidth: xcb_,\n      codeblockHeight: ycb_,\n      numcodeblockwide: cbx1 - cbx0 + 1,\n      numcodeblockhigh: cby1 - cby0 + 1\n    };\n    subband.codeblocks = codeblocks;\n    subband.precincts = precincts;\n  }\n  function createPacket(resolution, precinctNumber, layerNumber) {\n    var precinctCodeblocks = [];\n    // Section B.10.8 Order of info in packet\n    var subbands = resolution.subbands;\n    // sub-bands already ordered in \'LL\', \'HL\', \'LH\', and \'HH\' sequence\n    for (var i = 0, ii = subbands.length; i < ii; i++) {\n      var subband = subbands[i];\n      var codeblocks = subband.codeblocks;\n      for (var j = 0, jj = codeblocks.length; j < jj; j++) {\n        var codeblock = codeblocks[j];\n        if (codeblock.precinctNumber !== precinctNumber) {\n          continue;\n        }\n        precinctCodeblocks.push(codeblock);\n      }\n    }\n    return {\n      layerNumber: layerNumber,\n      codeblocks: precinctCodeblocks\n    };\n  }\n  function LayerResolutionComponentPositionIterator(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\n    var componentsCount = siz.Csiz;\n    var maxDecompositionLevelsCount = 0;\n    for (var q = 0; q < componentsCount; q++) {\n      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,\n        tile.components[q].codingStyleParameters.decompositionLevelsCount);\n    }\n\n    var l = 0, r = 0, i = 0, k = 0;\n\n    this.nextPacket = function JpxImage_nextPacket() {\n      // Section B.12.1.1 Layer-resolution-component-position\n      for (; l < layersCount; l++) {\n        for (; r <= maxDecompositionLevelsCount; r++) {\n          for (; i < componentsCount; i++) {\n            var component = tile.components[i];\n            if (r > component.codingStyleParameters.decompositionLevelsCount) {\n              continue;\n            }\n\n            var resolution = component.resolutions[r];\n            var numprecincts = resolution.precinctParameters.numprecincts;\n            for (; k < numprecincts;) {\n              var packet = createPacket(resolution, k, l);\n              k++;\n              return packet;\n            }\n            k = 0;\n          }\n          i = 0;\n        }\n        r = 0;\n      }\n    };\n  }\n  function ResolutionLayerComponentPositionIterator(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\n    var componentsCount = siz.Csiz;\n    var maxDecompositionLevelsCount = 0;\n    for (var q = 0; q < componentsCount; q++) {\n      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,\n        tile.components[q].codingStyleParameters.decompositionLevelsCount);\n    }\n\n    var r = 0, l = 0, i = 0, k = 0;\n\n    this.nextPacket = function JpxImage_nextPacket() {\n      // Section B.12.1.2 Resolution-layer-component-position\n      for (; r <= maxDecompositionLevelsCount; r++) {\n        for (; l < layersCount; l++) {\n          for (; i < componentsCount; i++) {\n            var component = tile.components[i];\n            if (r > component.codingStyleParameters.decompositionLevelsCount) {\n              continue;\n            }\n\n            var resolution = component.resolutions[r];\n            var numprecincts = resolution.precinctParameters.numprecincts;\n            for (; k < numprecincts;) {\n              var packet = createPacket(resolution, k, l);\n              k++;\n              return packet;\n            }\n            k = 0;\n          }\n          i = 0;\n        }\n        l = 0;\n      }\n    };\n  }\n  function ResolutionPositionComponentLayerIterator(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\n    var componentsCount = siz.Csiz;\n    var l, r, c, p;\n    var maxDecompositionLevelsCount = 0;\n    for (c = 0; c < componentsCount; c++) {\n      var component = tile.components[c];\n      maxDecompositionLevelsCount = Math.max(maxDecompositionLevelsCount,\n        component.codingStyleParameters.decompositionLevelsCount);\n    }\n    var maxNumPrecinctsInLevel = new Int32Array(\n      maxDecompositionLevelsCount + 1);\n    for (r = 0; r <= maxDecompositionLevelsCount; ++r) {\n      var maxNumPrecincts = 0;\n      for (c = 0; c < componentsCount; ++c) {\n        var resolutions = tile.components[c].resolutions;\n        if (r < resolutions.length) {\n          maxNumPrecincts = Math.max(maxNumPrecincts,\n            resolutions[r].precinctParameters.numprecincts);\n        }\n      }\n      maxNumPrecinctsInLevel[r] = maxNumPrecincts;\n    }\n    l = 0;\n    r = 0;\n    c = 0;\n    p = 0;\n\n    this.nextPacket = function JpxImage_nextPacket() {\n      // Section B.12.1.3 Resolution-position-component-layer\n      for (; r <= maxDecompositionLevelsCount; r++) {\n        for (; p < maxNumPrecinctsInLevel[r]; p++) {\n          for (; c < componentsCount; c++) {\n            var component = tile.components[c];\n            if (r > component.codingStyleParameters.decompositionLevelsCount) {\n              continue;\n            }\n            var resolution = component.resolutions[r];\n            var numprecincts = resolution.precinctParameters.numprecincts;\n            if (p >= numprecincts) {\n              continue;\n            }\n            for (; l < layersCount;) {\n              var packet = createPacket(resolution, p, l);\n              l++;\n              return packet;\n            }\n            l = 0;\n          }\n          c = 0;\n        }\n        p = 0;\n      }\n    };\n  }\n  function PositionComponentResolutionLayerIterator(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\n    var componentsCount = siz.Csiz;\n    var precinctsSizes = getPrecinctSizesInImageScale(tile);\n    var precinctsIterationSizes = precinctsSizes;\n    var l = 0, r = 0, c = 0, px = 0, py = 0;\n\n    this.nextPacket = function JpxImage_nextPacket() {\n      // Section B.12.1.4 Position-component-resolution-layer\n      for (; py < precinctsIterationSizes.maxNumHigh; py++) {\n        for (; px < precinctsIterationSizes.maxNumWide; px++) {\n          for (; c < componentsCount; c++) {\n            var component = tile.components[c];\n            var decompositionLevelsCount =\n              component.codingStyleParameters.decompositionLevelsCount;\n            for (; r <= decompositionLevelsCount; r++) {\n              var resolution = component.resolutions[r];\n              var sizeInImageScale =\n                precinctsSizes.components[c].resolutions[r];\n              var k = getPrecinctIndexIfExist(\n                px,\n                py,\n                sizeInImageScale,\n                precinctsIterationSizes,\n                resolution);\n              if (k === null) {\n                continue;\n              }\n              for (; l < layersCount;) {\n                var packet = createPacket(resolution, k, l);\n                l++;\n                return packet;\n              }\n              l = 0;\n            }\n            r = 0;\n          }\n          c = 0;\n        }\n        px = 0;\n      }\n    };\n  }\n  function ComponentPositionResolutionLayerIterator(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var layersCount = tile.codingStyleDefaultParameters.layersCount;\n    var componentsCount = siz.Csiz;\n    var precinctsSizes = getPrecinctSizesInImageScale(tile);\n    var l = 0, r = 0, c = 0, px = 0, py = 0;\n\n    this.nextPacket = function JpxImage_nextPacket() {\n      // Section B.12.1.5 Component-position-resolution-layer\n      for (; c < componentsCount; ++c) {\n        var component = tile.components[c];\n        var precinctsIterationSizes = precinctsSizes.components[c];\n        var decompositionLevelsCount =\n          component.codingStyleParameters.decompositionLevelsCount;\n        for (; py < precinctsIterationSizes.maxNumHigh; py++) {\n          for (; px < precinctsIterationSizes.maxNumWide; px++) {\n            for (; r <= decompositionLevelsCount; r++) {\n              var resolution = component.resolutions[r];\n              var sizeInImageScale = precinctsIterationSizes.resolutions[r];\n              var k = getPrecinctIndexIfExist(\n                px,\n                py,\n                sizeInImageScale,\n                precinctsIterationSizes,\n                resolution);\n              if (k === null) {\n                continue;\n              }\n              for (; l < layersCount;) {\n                var packet = createPacket(resolution, k, l);\n                l++;\n                return packet;\n              }\n              l = 0;\n            }\n            r = 0;\n          }\n          px = 0;\n        }\n        py = 0;\n      }\n    };\n  }\n  function getPrecinctIndexIfExist(\n    pxIndex, pyIndex, sizeInImageScale, precinctIterationSizes, resolution) {\n    var posX = pxIndex * precinctIterationSizes.minWidth;\n    var posY = pyIndex * precinctIterationSizes.minHeight;\n    if (posX % sizeInImageScale.width !== 0 ||\n        posY % sizeInImageScale.height !== 0) {\n      return null;\n    }\n    var startPrecinctRowIndex =\n      (posY / sizeInImageScale.width) *\n      resolution.precinctParameters.numprecinctswide;\n    return (posX / sizeInImageScale.height) + startPrecinctRowIndex;\n  }\n  function getPrecinctSizesInImageScale(tile) {\n    var componentsCount = tile.components.length;\n    var minWidth = Number.MAX_VALUE;\n    var minHeight = Number.MAX_VALUE;\n    var maxNumWide = 0;\n    var maxNumHigh = 0;\n    var sizePerComponent = new Array(componentsCount);\n    for (var c = 0; c < componentsCount; c++) {\n      var component = tile.components[c];\n      var decompositionLevelsCount =\n        component.codingStyleParameters.decompositionLevelsCount;\n      var sizePerResolution = new Array(decompositionLevelsCount + 1);\n      var minWidthCurrentComponent = Number.MAX_VALUE;\n      var minHeightCurrentComponent = Number.MAX_VALUE;\n      var maxNumWideCurrentComponent = 0;\n      var maxNumHighCurrentComponent = 0;\n      var scale = 1;\n      for (var r = decompositionLevelsCount; r >= 0; --r) {\n        var resolution = component.resolutions[r];\n        var widthCurrentResolution =\n          scale * resolution.precinctParameters.precinctWidth;\n        var heightCurrentResolution =\n          scale * resolution.precinctParameters.precinctHeight;\n        minWidthCurrentComponent = Math.min(\n          minWidthCurrentComponent,\n          widthCurrentResolution);\n        minHeightCurrentComponent = Math.min(\n          minHeightCurrentComponent,\n          heightCurrentResolution);\n        maxNumWideCurrentComponent = Math.max(maxNumWideCurrentComponent,\n          resolution.precinctParameters.numprecinctswide);\n        maxNumHighCurrentComponent = Math.max(maxNumHighCurrentComponent,\n          resolution.precinctParameters.numprecinctshigh);\n        sizePerResolution[r] = {\n          width: widthCurrentResolution,\n          height: heightCurrentResolution\n        };\n        scale <<= 1;\n      }\n      minWidth = Math.min(minWidth, minWidthCurrentComponent);\n      minHeight = Math.min(minHeight, minHeightCurrentComponent);\n      maxNumWide = Math.max(maxNumWide, maxNumWideCurrentComponent);\n      maxNumHigh = Math.max(maxNumHigh, maxNumHighCurrentComponent);\n      sizePerComponent[c] = {\n        resolutions: sizePerResolution,\n        minWidth: minWidthCurrentComponent,\n        minHeight: minHeightCurrentComponent,\n        maxNumWide: maxNumWideCurrentComponent,\n        maxNumHigh: maxNumHighCurrentComponent\n      };\n    }\n    return {\n      components: sizePerComponent,\n      minWidth: minWidth,\n      minHeight: minHeight,\n      maxNumWide: maxNumWide,\n      maxNumHigh: maxNumHigh\n    };\n  }\n  function buildPackets(context) {\n    var siz = context.SIZ;\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var componentsCount = siz.Csiz;\n    // Creating resolutions and sub-bands for each component\n    for (var c = 0; c < componentsCount; c++) {\n      var component = tile.components[c];\n      var decompositionLevelsCount =\n        component.codingStyleParameters.decompositionLevelsCount;\n      // Section B.5 Resolution levels and sub-bands\n      var resolutions = [];\n      var subbands = [];\n      for (var r = 0; r <= decompositionLevelsCount; r++) {\n        var blocksDimensions = getBlocksDimensions(context, component, r);\n        var resolution = {};\n        var scale = 1 << (decompositionLevelsCount - r);\n        resolution.trx0 = Math.ceil(component.tcx0 / scale);\n        resolution.try0 = Math.ceil(component.tcy0 / scale);\n        resolution.trx1 = Math.ceil(component.tcx1 / scale);\n        resolution.try1 = Math.ceil(component.tcy1 / scale);\n        resolution.resLevel = r;\n        buildPrecincts(context, resolution, blocksDimensions);\n        resolutions.push(resolution);\n\n        var subband;\n        if (r === 0) {\n          // one sub-band (LL) with last decomposition\n          subband = {};\n          subband.type = \'LL\';\n          subband.tbx0 = Math.ceil(component.tcx0 / scale);\n          subband.tby0 = Math.ceil(component.tcy0 / scale);\n          subband.tbx1 = Math.ceil(component.tcx1 / scale);\n          subband.tby1 = Math.ceil(component.tcy1 / scale);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolution.subbands = [subband];\n        } else {\n          var bscale = 1 << (decompositionLevelsCount - r + 1);\n          var resolutionSubbands = [];\n          // three sub-bands (HL, LH and HH) with rest of decompositions\n          subband = {};\n          subband.type = \'HL\';\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);\n          subband.tby0 = Math.ceil(component.tcy0 / bscale);\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);\n          subband.tby1 = Math.ceil(component.tcy1 / bscale);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolutionSubbands.push(subband);\n\n          subband = {};\n          subband.type = \'LH\';\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale);\n          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale);\n          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolutionSubbands.push(subband);\n\n          subband = {};\n          subband.type = \'HH\';\n          subband.tbx0 = Math.ceil(component.tcx0 / bscale - 0.5);\n          subband.tby0 = Math.ceil(component.tcy0 / bscale - 0.5);\n          subband.tbx1 = Math.ceil(component.tcx1 / bscale - 0.5);\n          subband.tby1 = Math.ceil(component.tcy1 / bscale - 0.5);\n          subband.resolution = resolution;\n          buildCodeblocks(context, subband, blocksDimensions);\n          subbands.push(subband);\n          resolutionSubbands.push(subband);\n\n          resolution.subbands = resolutionSubbands;\n        }\n      }\n      component.resolutions = resolutions;\n      component.subbands = subbands;\n    }\n    // Generate the packets sequence\n    var progressionOrder = tile.codingStyleDefaultParameters.progressionOrder;\n    switch (progressionOrder) {\n      case 0:\n        tile.packetsIterator =\n          new LayerResolutionComponentPositionIterator(context);\n        break;\n      case 1:\n        tile.packetsIterator =\n          new ResolutionLayerComponentPositionIterator(context);\n        break;\n      case 2:\n        tile.packetsIterator =\n          new ResolutionPositionComponentLayerIterator(context);\n        break;\n      case 3:\n        tile.packetsIterator =\n          new PositionComponentResolutionLayerIterator(context);\n        break;\n      case 4:\n        tile.packetsIterator =\n          new ComponentPositionResolutionLayerIterator(context);\n        break;\n      default:\n        throw new Error(\'JPX Error: Unsupported progression order \' +\n                        progressionOrder);\n    }\n  }\n  function parseTilePackets(context, data, offset, dataLength) {\n    var position = 0;\n    var buffer, bufferSize = 0, skipNextBit = false;\n    function readBits(count) {\n      while (bufferSize < count) {\n        if(offset + position  >= data.length){\n          throw new Error("Unexpected EOF");\n        }\n        var b = data[offset + position];\n        position++;\n        if (skipNextBit) {\n          buffer = (buffer << 7) | b;\n          bufferSize += 7;\n          skipNextBit = false;\n        } else {\n          buffer = (buffer << 8) | b;\n          bufferSize += 8;\n        }\n        if (b === 0xFF) {\n          skipNextBit = true;\n        }\n      }\n      bufferSize -= count;\n      return (buffer >>> bufferSize) & ((1 << count) - 1);\n    }\n    function skipMarkerIfEqual(value) {\n      if (data[offset + position - 1] === 0xFF &&\n          data[offset + position] === value) {\n        skipBytes(1);\n        return true;\n      } else if (data[offset + position] === 0xFF &&\n                 data[offset + position + 1] === value) {\n        skipBytes(2);\n        return true;\n      }\n      return false;\n    }\n    function skipBytes(count) {\n      position += count;\n    }\n    function alignToByte() {\n      bufferSize = 0;\n      if (skipNextBit) {\n        position++;\n        skipNextBit = false;\n      }\n    }\n    function readCodingpasses() {\n      if (readBits(1) === 0) {\n        return 1;\n      }\n      if (readBits(1) === 0) {\n        return 2;\n      }\n      var value = readBits(2);\n      if (value < 3) {\n        return value + 3;\n      }\n      value = readBits(5);\n      if (value < 31) {\n        return value + 6;\n      }\n      value = readBits(7);\n      return value + 37;\n    }\n    var tileIndex = context.currentTile.index;\n    var tile = context.tiles[tileIndex];\n    var sopMarkerUsed = context.COD.sopMarkerUsed;\n    var ephMarkerUsed = context.COD.ephMarkerUsed;\n    var packetsIterator = tile.packetsIterator;\n    while (position < dataLength) {\n      try{\n        alignToByte();\n        if (sopMarkerUsed && skipMarkerIfEqual(0x91)) {\n          // Skip also marker segment length and packet sequence ID\n          skipBytes(4);\n        }\n        var packet = packetsIterator.nextPacket();\n        if (packet === undefined) {\n          //No more packets. Stream is probably truncated.\n          return;\n        }\n        if (!readBits(1)) {\n          continue;\n        }\n        var layerNumber = packet.layerNumber;\n        var queue = [], codeblock;\n        for (var i = 0, ii = packet.codeblocks.length; i < ii; i++) {\n          codeblock = packet.codeblocks[i];\n          var precinct = codeblock.precinct;\n          var codeblockColumn = codeblock.cbx - precinct.cbxMin;\n          var codeblockRow = codeblock.cby - precinct.cbyMin;\n          var codeblockIncluded = false;\n          var firstTimeInclusion = false;\n          var valueReady;\n          if (codeblock[\'included\'] !== undefined) {\n            codeblockIncluded = !!readBits(1);\n          } else {\n            // reading inclusion tree\n            precinct = codeblock.precinct;\n            var inclusionTree, zeroBitPlanesTree;\n            if (precinct[\'inclusionTree\'] !== undefined) {\n              inclusionTree = precinct.inclusionTree;\n            } else {\n              // building inclusion and zero bit-planes trees\n              var width = precinct.cbxMax - precinct.cbxMin + 1;\n              var height = precinct.cbyMax - precinct.cbyMin + 1;\n              inclusionTree = new InclusionTree(width, height);\n              zeroBitPlanesTree = new TagTree(width, height);\n              precinct.inclusionTree = inclusionTree;\n              precinct.zeroBitPlanesTree = zeroBitPlanesTree;\n            }\n\n            inclusionTree.reset(codeblockColumn, codeblockRow, layerNumber);\n            while (true) {\n              if (position >= data.length) {\n                return;\n              }\n              if (inclusionTree.isAboveThreshold()){\n                break;\n              }\n              if (inclusionTree.isKnown()) {\n                inclusionTree.nextLevel();\n                continue;\n              }\n              if (readBits(1)) {\n                inclusionTree.setKnown();\n                if (inclusionTree.isLeaf()) {\n                  codeblock.included = true;\n                  codeblockIncluded = firstTimeInclusion = true;\n                  break;\n                } else {\n                  inclusionTree.nextLevel();\n                }\n              } else {\n                inclusionTree.incrementValue();\n              }\n            }\n          }\n          if (!codeblockIncluded) {\n            continue;\n          }\n          if (firstTimeInclusion) {\n            zeroBitPlanesTree = precinct.zeroBitPlanesTree;\n            zeroBitPlanesTree.reset(codeblockColumn, codeblockRow);\n            while (true) {\n              if (position >= data.length) {\n                return;\n              }\n              if (readBits(1)) {\n                valueReady = !zeroBitPlanesTree.nextLevel();\n                if (valueReady) {\n                  break;\n                }\n              } else {\n                zeroBitPlanesTree.incrementValue();\n              }\n            }\n            codeblock.zeroBitPlanes = zeroBitPlanesTree.value;\n          }\n          var codingpasses = readCodingpasses();\n          while (readBits(1)) {\n            codeblock.Lblock++;\n          }\n          var codingpassesLog2 = log2(codingpasses);\n          // rounding down log2\n          var bits = ((codingpasses < (1 << codingpassesLog2)) ?\n                      codingpassesLog2 - 1 : codingpassesLog2) + codeblock.Lblock;\n          var codedDataLength = readBits(bits);\n          queue.push({\n            codeblock: codeblock,\n            codingpasses: codingpasses,\n            dataLength: codedDataLength\n          });\n        }\n        alignToByte();\n        if (ephMarkerUsed) {\n          skipMarkerIfEqual(0x92);\n        }\n        while (queue.length > 0) {\n          var packetItem = queue.shift();\n          codeblock = packetItem.codeblock;\n          if (codeblock[\'data\'] === undefined) {\n            codeblock.data = [];\n          }\n          codeblock.data.push({\n            data: data,\n            start: offset + position,\n            end: offset + position + packetItem.dataLength,\n            codingpasses: packetItem.codingpasses\n          });\n          position += packetItem.dataLength;\n        }\n      } catch (e) {\n        return;\n      }\n    }\n    return position;\n  }\n  function copyCoefficients(coefficients, levelWidth, levelHeight, subband,\n                            delta, mb, reversible, segmentationSymbolUsed) {\n    var x0 = subband.tbx0;\n    var y0 = subband.tby0;\n    var width = subband.tbx1 - subband.tbx0;\n    var codeblocks = subband.codeblocks;\n    var right = subband.type.charAt(0) === \'H\' ? 1 : 0;\n    var bottom = subband.type.charAt(1) === \'H\' ? levelWidth : 0;\n\n    for (var i = 0, ii = codeblocks.length; i < ii; ++i) {\n      var codeblock = codeblocks[i];\n      var blockWidth = codeblock.tbx1_ - codeblock.tbx0_;\n      var blockHeight = codeblock.tby1_ - codeblock.tby0_;\n      if (blockWidth === 0 || blockHeight === 0) {\n        continue;\n      }\n      if (codeblock[\'data\'] === undefined) {\n        continue;\n      }\n\n      var bitModel, currentCodingpassType;\n      bitModel = new BitModel(blockWidth, blockHeight, codeblock.subbandType,\n                              codeblock.zeroBitPlanes, mb);\n      currentCodingpassType = 2; // first bit plane starts from cleanup\n\n      // collect data\n      var data = codeblock.data, totalLength = 0, codingpasses = 0;\n      var j, jj, dataItem;\n      for (j = 0, jj = data.length; j < jj; j++) {\n        dataItem = data[j];\n        totalLength += dataItem.end - dataItem.start;\n        codingpasses += dataItem.codingpasses;\n      }\n      var encodedData = new Int16Array(totalLength);\n      var position = 0;\n      for (j = 0, jj = data.length; j < jj; j++) {\n        dataItem = data[j];\n        var chunk = dataItem.data.subarray(dataItem.start, dataItem.end);\n        encodedData.set(chunk, position);\n        position += chunk.length;\n      }\n      // decoding the item\n      var decoder = new ArithmeticDecoder(encodedData, 0, totalLength);\n      bitModel.setDecoder(decoder);\n\n      for (j = 0; j < codingpasses; j++) {\n        switch (currentCodingpassType) {\n          case 0:\n            bitModel.runSignificancePropogationPass();\n            break;\n          case 1:\n            bitModel.runMagnitudeRefinementPass();\n            break;\n          case 2:\n            bitModel.runCleanupPass();\n            if (segmentationSymbolUsed) {\n              bitModel.checkSegmentationSymbol();\n            }\n            break;\n        }\n        currentCodingpassType = (currentCodingpassType + 1) % 3;\n      }\n\n      var offset = (codeblock.tbx0_ - x0) + (codeblock.tby0_ - y0) * width;\n      var sign = bitModel.coefficentsSign;\n      var magnitude = bitModel.coefficentsMagnitude;\n      var bitsDecoded = bitModel.bitsDecoded;\n      var magnitudeCorrection = reversible ? 0 : 0.5;\n      var k, n, nb;\n      position = 0;\n      // Do the interleaving of Section F.3.3 here, so we do not need\n      // to copy later. LL level is not interleaved, just copied.\n      var interleave = (subband.type !== \'LL\');\n      for (j = 0; j < blockHeight; j++) {\n        var row = (offset / width) | 0; // row in the non-interleaved subband\n        var levelOffset = 2 * row * (levelWidth - width) + right + bottom;\n        for (k = 0; k < blockWidth; k++) {\n          n = magnitude[position];\n          if (n !== 0) {\n            n = (n + magnitudeCorrection) * delta;\n            if (sign[position] !== 0) {\n              n = -n;\n            }\n            nb = bitsDecoded[position];\n            var pos = interleave ? (levelOffset + (offset << 1)) : offset;\n            if (reversible && (nb >= mb)) {\n              coefficients[pos] = n;\n            } else {\n              coefficients[pos] = n * (1 << (mb - nb));\n            }\n          }\n          offset++;\n          position++;\n        }\n        offset += width - blockWidth;\n      }\n    }\n  }\n  function transformTile(context, tile, c) {\n    var component = tile.components[c];\n    var codingStyleParameters = component.codingStyleParameters;\n    var quantizationParameters = component.quantizationParameters;\n    var decompositionLevelsCount =\n      codingStyleParameters.decompositionLevelsCount;\n    var spqcds = quantizationParameters.SPqcds;\n    var scalarExpounded = quantizationParameters.scalarExpounded;\n    var guardBits = quantizationParameters.guardBits;\n    var segmentationSymbolUsed = codingStyleParameters.segmentationSymbolUsed;\n    var precision = context.components[c].precision;\n\n    var reversible = codingStyleParameters.reversibleTransformation;\n    var transform = (reversible ? new ReversibleTransform() :\n                                  new IrreversibleTransform());\n\n    var subbandCoefficients = [];\n    var b = 0;\n    for (var i = 0; i <= decompositionLevelsCount; i++) {\n      var resolution = component.resolutions[i];\n\n      var width = resolution.trx1 - resolution.trx0;\n      var height = resolution.try1 - resolution.try0;\n      // Allocate space for the whole sublevel.\n      var coefficients = new Float32Array(width * height);\n\n      for (var j = 0, jj = resolution.subbands.length; j < jj; j++) {\n        var mu, epsilon;\n        if (!scalarExpounded) {\n          // formula E-5\n          mu = spqcds[0].mu;\n          epsilon = spqcds[0].epsilon + (i > 0 ? 1 - i : 0);\n        } else {\n          mu = spqcds[b].mu;\n          epsilon = spqcds[b].epsilon;\n          b++;\n        }\n\n        var subband = resolution.subbands[j];\n        var gainLog2 = SubbandsGainLog2[subband.type];\n\n        // calulate quantization coefficient (Section E.1.1.1)\n        var delta = (reversible ? 1 :\n          Math.pow(2, precision + gainLog2 - epsilon) * (1 + mu / 2048));\n        var mb = (guardBits + epsilon - 1);\n\n        // In the first resolution level, copyCoefficients will fill the\n        // whole array with coefficients. In the succeding passes,\n        // copyCoefficients will consecutively fill in the values that belong\n        // to the interleaved positions of the HL, LH, and HH coefficients.\n        // The LL coefficients will then be interleaved in Transform.iterate().\n        copyCoefficients(coefficients, width, height, subband, delta, mb,\n                         reversible, segmentationSymbolUsed);\n      }\n      subbandCoefficients.push({\n        width: width,\n        height: height,\n        items: coefficients\n      });\n    }\n\n    var result = transform.calculate(subbandCoefficients,\n                                     component.tcx0, component.tcy0);\n    return {\n      left: component.tcx0,\n      top: component.tcy0,\n      width: result.width,\n      height: result.height,\n      items: result.items\n    };\n  }\n  function transformComponents(context) {\n    var siz = context.SIZ;\n    var components = context.components;\n    var componentsCount = siz.Csiz;\n    var resultImages = [];\n    for (var i = 0, ii = context.tiles.length; i < ii; i++) {\n      var tile = context.tiles[i];\n      var transformedTiles = [];\n      var c;\n      for (c = 0; c < componentsCount; c++) {\n        transformedTiles[c] = transformTile(context, tile, c);\n      }\n      var tile0 = transformedTiles[0];\n      var isSigned = components[0].isSigned;\n      if (isSigned) {\n        var out = new Int16Array(tile0.items.length * componentsCount);\n      } else {\n        var out = new Uint16Array(tile0.items.length * componentsCount);\n      }\n      var result = {\n        left: tile0.left,\n        top: tile0.top,\n        width: tile0.width,\n        height: tile0.height,\n        items: out\n      };\n\n      // Section G.2.2 Inverse multi component transform\n      var shift, offset, max, min, maxK;\n      var pos = 0, j, jj, y0, y1, y2, r, g, b, k, val;\n      if (tile.codingStyleDefaultParameters.multipleComponentTransform) {\n        var fourComponents = componentsCount === 4;\n        var y0items = transformedTiles[0].items;\n        var y1items = transformedTiles[1].items;\n        var y2items = transformedTiles[2].items;\n        var y3items = fourComponents ? transformedTiles[3].items : null;\n\n        // HACK: The multiple component transform formulas below assume that\n        // all components have the same precision. With this in mind, we\n        // compute shift and offset only once.\n        shift = components[0].precision - 8;\n        offset = (128 << shift) + 0.5;\n        max = 255 * (1 << shift);\n        maxK = max * 0.5;\n        min = -maxK;\n\n        var component0 = tile.components[0];\n        var alpha01 = componentsCount - 3;\n        jj = y0items.length;\n        if (!component0.codingStyleParameters.reversibleTransformation) {\n          // inverse irreversible multiple component transform\n          for (j = 0; j < jj; j++, pos += alpha01) {\n            y0 = y0items[j] + offset;\n            y1 = y1items[j];\n            y2 = y2items[j];\n            r = y0 + 1.402 * y2;\n            g = y0 - 0.34413 * y1 - 0.71414 * y2;\n            b = y0 + 1.772 * y1;\n            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;\n            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;\n            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;\n          }\n        } else {\n          // inverse reversible multiple component transform\n          for (j = 0; j < jj; j++, pos += alpha01) {\n            y0 = y0items[j] + offset;\n            y1 = y1items[j];\n            y2 = y2items[j];\n            g = y0 - ((y2 + y1) >> 2);\n            r = g + y2;\n            b = g + y1;\n            out[pos++] = r <= 0 ? 0 : r >= max ? 255 : r >> shift;\n            out[pos++] = g <= 0 ? 0 : g >= max ? 255 : g >> shift;\n            out[pos++] = b <= 0 ? 0 : b >= max ? 255 : b >> shift;\n          }\n        }\n        if (fourComponents) {\n          for (j = 0, pos = 3; j < jj; j++, pos += 4) {\n            k = y3items[j];\n            out[pos] = k <= min ? 0 : k >= maxK ? 255 : (k + offset) >> shift;\n          }\n        }\n      } else { // no multi-component transform\n        for (c = 0; c < componentsCount; c++) {\n          if (components[c].precision === 8){\n            var items = transformedTiles[c].items;\n            shift = components[c].precision - 8;\n            offset = (128 << shift) + 0.5;\n            max = (127.5 * (1 << shift));\n            min = -max;\n            for (pos = c, j = 0, jj = items.length; j < jj; j++) {\n              val = items[j];\n              out[pos] = val <= min ? 0 :\n                         val >= max ? 255 : (val + offset) >> shift;\n              pos += componentsCount;\n            }\n          }else{\n            var isSigned = components[c].isSigned;\n            var items = transformedTiles[c].items;\n\n            if(isSigned){\n              for (pos = c, j = 0, jj = items.length; j < jj; j++) {\n                out[pos] = items[j];\n                pos += componentsCount;\n              }\n            }else{\n              shift = components[c].precision - 8;\n              offset = (128 << shift) + 0.5;\n              var precisionMax = Math.pow(2,components[c].precision)-1;\n              for (pos = c, j = 0, jj = items.length; j < jj; j++) {\n                val = items[j];\n                out[pos] = Math.max(Math.min((val + offset),precisionMax),0);\n                pos += componentsCount;\n              }\n            }\n          }\n        }\n      }\n      resultImages.push(result);\n    }\n    return resultImages;\n  }\n  function initializeTile(context, tileIndex) {\n    var siz = context.SIZ;\n    var componentsCount = siz.Csiz;\n    var tile = context.tiles[tileIndex];\n    for (var c = 0; c < componentsCount; c++) {\n      var component = tile.components[c];\n      var qcdOrQcc = (context.currentTile.QCC[c] !== undefined ?\n        context.currentTile.QCC[c] : context.currentTile.QCD);\n      component.quantizationParameters = qcdOrQcc;\n      var codOrCoc = (context.currentTile.COC[c] !== undefined  ?\n        context.currentTile.COC[c] : context.currentTile.COD);\n      component.codingStyleParameters = codOrCoc;\n    }\n    tile.codingStyleDefaultParameters = context.currentTile.COD;\n  }\n\n  // Section B.10.2 Tag trees\n  var TagTree = (function TagTreeClosure() {\n    function TagTree(width, height) {\n      var levelsLength = log2(Math.max(width, height)) + 1;\n      this.levels = [];\n      for (var i = 0; i < levelsLength; i++) {\n        var level = {\n          width: width,\n          height: height,\n          items: []\n        };\n        this.levels.push(level);\n        width = Math.ceil(width / 2);\n        height = Math.ceil(height / 2);\n      }\n    }\n    TagTree.prototype = {\n      reset: function TagTree_reset(i, j) {\n        var currentLevel = 0, value = 0, level;\n        while (currentLevel < this.levels.length) {\n          level = this.levels[currentLevel];\n          var index = i + j * level.width;\n          if (level.items[index] !== undefined) {\n            value = level.items[index];\n            break;\n          }\n          level.index = index;\n          i >>= 1;\n          j >>= 1;\n          currentLevel++;\n        }\n        currentLevel--;\n        level = this.levels[currentLevel];\n        level.items[level.index] = value;\n        this.currentLevel = currentLevel;\n        delete this.value;\n      },\n      incrementValue: function TagTree_incrementValue() {\n        var level = this.levels[this.currentLevel];\n        level.items[level.index]++;\n      },\n      nextLevel: function TagTree_nextLevel() {\n        var currentLevel = this.currentLevel;\n        var level = this.levels[currentLevel];\n        var value = level.items[level.index];\n        currentLevel--;\n        if (currentLevel < 0) {\n          this.value = value;\n          return false;\n        }\n\n        this.currentLevel = currentLevel;\n        level = this.levels[currentLevel];\n        level.items[level.index] = value;\n        return true;\n      }\n    };\n    return TagTree;\n  })();\n\n  var InclusionTree = (function InclusionTreeClosure() {\n    function InclusionTree(width, height) {\n      var levelsLength = log2(Math.max(width, height)) + 1;\n      this.levels = [];\n      for (var i = 0; i < levelsLength; i++) {\n        var items = new Uint8Array(width * height);\n        var status = new Uint8Array(width * height);\n        for (var j = 0, jj = items.length; j < jj; j++) {\n          items[j] = 0;\n          status[j] = 0;\n        }\n\n        var level = {\n          width: width,\n          height: height,\n          items: items,\n          status: status\n        };\n        this.levels.push(level);\n\n        width = Math.ceil(width / 2);\n        height = Math.ceil(height / 2);\n      }\n    }\n    InclusionTree.prototype = {\n      reset: function InclusionTree_reset(i, j, stopValue) {\n        this.currentStopValue = stopValue;\n        var currentLevel = 0;\n        while (currentLevel < this.levels.length) {\n          var level = this.levels[currentLevel];\n          var index = i + j * level.width;\n          level.index = index;\n\n          i >>= 1;\n          j >>= 1;\n          currentLevel++;\n        }\n\n        this.currentLevel = this.levels.length - 1;\n        this.minValue =this.levels[this.currentLevel].items[0];\n        return;\n      },\n      incrementValue: function InclusionTree_incrementValue() {\n        var level = this.levels[this.currentLevel];\n        level.items[level.index] = level.items[level.index] + 1;\n        if(level.items[level.index] > this.minValue) {\n          this.minValue = level.items[level.index];\n        }\n      },\n      nextLevel: function InclusionTree_nextLevel() {\n        var currentLevel = this.currentLevel;\n        currentLevel--;\n        if (currentLevel < 0) {\n          return false;\n        } else {\n          this.currentLevel = currentLevel;\n          var level = this.levels[currentLevel];\n          if(level.items[level.index] < this.minValue) {\n            level.items[level.index] = this.minValue;\n          }else if (level.items[level.index] > this.minValue) {\n            this.minValue = level.items[level.index];\n          }\n          return true;\n        }\n      },\n    isLeaf: function InclusionTree_isLeaf(){\n      return (this.currentLevel === 0);\n    },\n    isAboveThreshold: function InclusionTree_isAboveThreshold(){\n      var levelindex = this.currentLevel;\n      var level = this.levels[levelindex];\n      return (level.items[level.index] > this.currentStopValue);\n    },\n    isKnown: function InclusionTree_isKnown(){\n      var levelindex = this.currentLevel;\n      var level = this.levels[levelindex];\n      return (level.status[level.index] > 0);\n    },\n    setKnown: function InclusionTree_setKnown(){\n      var levelindex = this.currentLevel;\n      var level = this.levels[levelindex];\n      level.status[level.index] = 1;\n      return;\n    }\n\n    };\n    return InclusionTree;\n  })();\n\n  // Section D. Coefficient bit modeling\n  var BitModel = (function BitModelClosure() {\n    var UNIFORM_CONTEXT = 17;\n    var RUNLENGTH_CONTEXT = 18;\n    // Table D-1\n    // The index is binary presentation: 0dddvvhh, ddd - sum of Di (0..4),\n    // vv - sum of Vi (0..2), and hh - sum of Hi (0..2)\n    var LLAndLHContextsLabel = new Uint8Array([\n      0, 5, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 1, 6, 8, 0, 3, 7, 8, 0, 4,\n      7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6,\n      8, 0, 3, 7, 8, 0, 4, 7, 8, 0, 0, 0, 0, 0, 2, 6, 8, 0, 3, 7, 8, 0, 4, 7, 8\n    ]);\n    var HLContextLabel = new Uint8Array([\n      0, 3, 4, 0, 5, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 1, 3, 4, 0, 6, 7, 7, 0, 8,\n      8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3,\n      4, 0, 6, 7, 7, 0, 8, 8, 8, 0, 0, 0, 0, 0, 2, 3, 4, 0, 6, 7, 7, 0, 8, 8, 8\n    ]);\n    var HHContextLabel = new Uint8Array([\n      0, 1, 2, 0, 1, 2, 2, 0, 2, 2, 2, 0, 0, 0, 0, 0, 3, 4, 5, 0, 4, 5, 5, 0, 5,\n      5, 5, 0, 0, 0, 0, 0, 6, 7, 7, 0, 7, 7, 7, 0, 7, 7, 7, 0, 0, 0, 0, 0, 8, 8,\n      8, 0, 8, 8, 8, 0, 8, 8, 8, 0, 0, 0, 0, 0, 8, 8, 8, 0, 8, 8, 8, 0, 8, 8, 8\n    ]);\n\n    function BitModel(width, height, subband, zeroBitPlanes, mb) {\n      this.width = width;\n      this.height = height;\n\n      this.contextLabelTable = (subband === \'HH\' ? HHContextLabel :\n        (subband === \'HL\' ? HLContextLabel : LLAndLHContextsLabel));\n\n      var coefficientCount = width * height;\n\n      // coefficients outside the encoding region treated as insignificant\n      // add border state cells for significanceState\n      this.neighborsSignificance = new Uint8Array(coefficientCount);\n      this.coefficentsSign = new Uint8Array(coefficientCount);\n      this.coefficentsMagnitude = mb > 14 ? new Uint32Array(coefficientCount) :\n                                  mb > 6 ? new Uint16Array(coefficientCount) :\n                                  new Uint8Array(coefficientCount);\n      this.processingFlags = new Uint8Array(coefficientCount);\n\n      var bitsDecoded = new Uint8Array(coefficientCount);\n      if (zeroBitPlanes !== 0) {\n        for (var i = 0; i < coefficientCount; i++) {\n          bitsDecoded[i] = zeroBitPlanes;\n        }\n      }\n      this.bitsDecoded = bitsDecoded;\n\n      this.reset();\n    }\n\n    BitModel.prototype = {\n      setDecoder: function BitModel_setDecoder(decoder) {\n        this.decoder = decoder;\n      },\n      reset: function BitModel_reset() {\n        // We have 17 contexts that are accessed via context labels,\n        // plus the uniform and runlength context.\n        this.contexts = new Int8Array(19);\n\n        // Contexts are packed into 1 byte:\n        // highest 7 bits carry the index, lowest bit carries mps\n        this.contexts[0] = (4 << 1) | 0;\n        this.contexts[UNIFORM_CONTEXT] = (46 << 1) | 0;\n        this.contexts[RUNLENGTH_CONTEXT] = (3 << 1) | 0;\n      },\n      setNeighborsSignificance:\n        function BitModel_setNeighborsSignificance(row, column, index) {\n        var neighborsSignificance = this.neighborsSignificance;\n        var width = this.width, height = this.height;\n        var left = (column > 0);\n        var right = (column + 1 < width);\n        var i;\n\n        if (row > 0) {\n          i = index - width;\n          if (left) {\n            neighborsSignificance[i - 1] += 0x10;\n          }\n          if (right) {\n            neighborsSignificance[i + 1] += 0x10;\n          }\n          neighborsSignificance[i] += 0x04;\n        }\n\n        if (row + 1 < height) {\n          i = index + width;\n          if (left) {\n            neighborsSignificance[i - 1] += 0x10;\n          }\n          if (right) {\n            neighborsSignificance[i + 1] += 0x10;\n          }\n          neighborsSignificance[i] += 0x04;\n        }\n\n        if (left) {\n          neighborsSignificance[index - 1] += 0x01;\n        }\n        if (right) {\n          neighborsSignificance[index + 1] += 0x01;\n        }\n        neighborsSignificance[index] |= 0x80;\n      },\n      runSignificancePropogationPass:\n        function BitModel_runSignificancePropogationPass() {\n        var decoder = this.decoder;\n        var width = this.width, height = this.height;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var coefficentsSign = this.coefficentsSign;\n        var neighborsSignificance = this.neighborsSignificance;\n        var processingFlags = this.processingFlags;\n        var contexts = this.contexts;\n        var labels = this.contextLabelTable;\n        var bitsDecoded = this.bitsDecoded;\n        var processedInverseMask = ~1;\n        var processedMask = 1;\n        var firstMagnitudeBitMask = 2;\n\n        for (var i0 = 0; i0 < height; i0 += 4) {\n          for (var j = 0; j < width; j++) {\n            var index = i0 * width + j;\n            for (var i1 = 0; i1 < 4; i1++, index += width) {\n              var i = i0 + i1;\n              if (i >= height) {\n                break;\n              }\n              // clear processed flag first\n              processingFlags[index] &= processedInverseMask;\n\n              if (coefficentsMagnitude[index] ||\n                  !neighborsSignificance[index]) {\n                continue;\n              }\n\n              var contextLabel = labels[neighborsSignificance[index]];\n              var decision = decoder.readBit(contexts, contextLabel);\n              if (decision) {\n                var sign = this.decodeSignBit(i, j, index);\n                coefficentsSign[index] = sign;\n                coefficentsMagnitude[index] = 1;\n                this.setNeighborsSignificance(i, j, index);\n                processingFlags[index] |= firstMagnitudeBitMask;\n              }\n              bitsDecoded[index]++;\n              processingFlags[index] |= processedMask;\n            }\n          }\n        }\n      },\n      decodeSignBit: function BitModel_decodeSignBit(row, column, index) {\n        var width = this.width, height = this.height;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var coefficentsSign = this.coefficentsSign;\n        var contribution, sign0, sign1, significance1;\n        var contextLabel, decoded;\n\n        // calculate horizontal contribution\n        significance1 = (column > 0 && coefficentsMagnitude[index - 1] !== 0);\n        if (column + 1 < width && coefficentsMagnitude[index + 1] !== 0) {\n          sign1 = coefficentsSign[index + 1];\n          if (significance1) {\n            sign0 = coefficentsSign[index - 1];\n            contribution = 1 - sign1 - sign0;\n          } else {\n            contribution = 1 - sign1 - sign1;\n          }\n        } else if (significance1) {\n          sign0 = coefficentsSign[index - 1];\n          contribution = 1 - sign0 - sign0;\n        } else {\n          contribution = 0;\n        }\n        var horizontalContribution = 3 * contribution;\n\n        // calculate vertical contribution and combine with the horizontal\n        significance1 = (row > 0 && coefficentsMagnitude[index - width] !== 0);\n        if (row + 1 < height && coefficentsMagnitude[index + width] !== 0) {\n          sign1 = coefficentsSign[index + width];\n          if (significance1) {\n            sign0 = coefficentsSign[index - width];\n            contribution = 1 - sign1 - sign0 + horizontalContribution;\n          } else {\n            contribution = 1 - sign1 - sign1 + horizontalContribution;\n          }\n        } else if (significance1) {\n          sign0 = coefficentsSign[index - width];\n          contribution = 1 - sign0 - sign0 + horizontalContribution;\n        } else {\n          contribution = horizontalContribution;\n        }\n\n        if (contribution >= 0) {\n          contextLabel = 9 + contribution;\n          decoded = this.decoder.readBit(this.contexts, contextLabel);\n        } else {\n          contextLabel = 9 - contribution;\n          decoded = this.decoder.readBit(this.contexts, contextLabel) ^ 1;\n        }\n        return decoded;\n      },\n      runMagnitudeRefinementPass:\n        function BitModel_runMagnitudeRefinementPass() {\n        var decoder = this.decoder;\n        var width = this.width, height = this.height;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var neighborsSignificance = this.neighborsSignificance;\n        var contexts = this.contexts;\n        var bitsDecoded = this.bitsDecoded;\n        var processingFlags = this.processingFlags;\n        var processedMask = 1;\n        var firstMagnitudeBitMask = 2;\n        var length = width * height;\n        var width4 = width * 4;\n\n        for (var index0 = 0, indexNext; index0 < length; index0 = indexNext) {\n          indexNext = Math.min(length, index0 + width4);\n          for (var j = 0; j < width; j++) {\n            for (var index = index0 + j; index < indexNext; index += width) {\n\n              // significant but not those that have just become\n              if (!coefficentsMagnitude[index] ||\n                (processingFlags[index] & processedMask) !== 0) {\n                continue;\n              }\n\n              var contextLabel = 16;\n              if ((processingFlags[index] & firstMagnitudeBitMask) !== 0) {\n                processingFlags[index] ^= firstMagnitudeBitMask;\n                // first refinement\n               var significance = neighborsSignificance[index] & 127;\n               contextLabel = significance === 0 ? 15 : 14;\n              }\n\n              var bit = decoder.readBit(contexts, contextLabel);\n              coefficentsMagnitude[index] =\n                (coefficentsMagnitude[index] << 1) | bit;\n              bitsDecoded[index]++;\n              processingFlags[index] |= processedMask;\n            }\n          }\n        }\n      },\n      runCleanupPass: function BitModel_runCleanupPass() {\n        var decoder = this.decoder;\n        var width = this.width, height = this.height;\n        var neighborsSignificance = this.neighborsSignificance;\n        var coefficentsMagnitude = this.coefficentsMagnitude;\n        var coefficentsSign = this.coefficentsSign;\n        var contexts = this.contexts;\n        var labels = this.contextLabelTable;\n        var bitsDecoded = this.bitsDecoded;\n        var processingFlags = this.processingFlags;\n        var processedMask = 1;\n        var firstMagnitudeBitMask = 2;\n        var oneRowDown = width;\n        var twoRowsDown = width * 2;\n        var threeRowsDown = width * 3;\n        var iNext;\n        for (var i0 = 0; i0 < height; i0 = iNext) {\n          iNext = Math.min(i0 + 4, height);\n          var indexBase = i0 * width;\n          var checkAllEmpty = i0 + 3 < height;\n          for (var j = 0; j < width; j++) {\n            var index0 = indexBase + j;\n            // using the property: labels[neighborsSignificance[index]] === 0\n            // when neighborsSignificance[index] === 0\n            var allEmpty = (checkAllEmpty &&\n              processingFlags[index0] === 0 &&\n              processingFlags[index0 + oneRowDown] === 0 &&\n              processingFlags[index0 + twoRowsDown] === 0 &&\n              processingFlags[index0 + threeRowsDown] === 0 &&\n              neighborsSignificance[index0] === 0 &&\n              neighborsSignificance[index0 + oneRowDown] === 0 &&\n              neighborsSignificance[index0 + twoRowsDown] === 0 &&\n              neighborsSignificance[index0 + threeRowsDown] === 0);\n            var i1 = 0, index = index0;\n            var i = i0, sign;\n            if (allEmpty) {\n              var hasSignificantCoefficent =\n                decoder.readBit(contexts, RUNLENGTH_CONTEXT);\n              if (!hasSignificantCoefficent) {\n                bitsDecoded[index0]++;\n                bitsDecoded[index0 + oneRowDown]++;\n                bitsDecoded[index0 + twoRowsDown]++;\n                bitsDecoded[index0 + threeRowsDown]++;\n                continue; // next column\n              }\n              i1 = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |\n                    decoder.readBit(contexts, UNIFORM_CONTEXT);\n              if (i1 !== 0) {\n                i = i0 + i1;\n                index += i1 * width;\n              }\n\n              sign = this.decodeSignBit(i, j, index);\n              coefficentsSign[index] = sign;\n              coefficentsMagnitude[index] = 1;\n              this.setNeighborsSignificance(i, j, index);\n              processingFlags[index] |= firstMagnitudeBitMask;\n\n              index = index0;\n              for (var i2 = i0; i2 <= i; i2++, index += width) {\n                bitsDecoded[index]++;\n              }\n\n              i1++;\n            }\n            for (i = i0 + i1; i < iNext; i++, index += width) {\n              if (coefficentsMagnitude[index] ||\n                (processingFlags[index] & processedMask) !== 0) {\n                continue;\n              }\n\n              var contextLabel = labels[neighborsSignificance[index]];\n              var decision = decoder.readBit(contexts, contextLabel);\n              if (decision === 1) {\n                sign = this.decodeSignBit(i, j, index);\n                coefficentsSign[index] = sign;\n                coefficentsMagnitude[index] = 1;\n                this.setNeighborsSignificance(i, j, index);\n                processingFlags[index] |= firstMagnitudeBitMask;\n              }\n              bitsDecoded[index]++;\n            }\n          }\n        }\n      },\n      checkSegmentationSymbol: function BitModel_checkSegmentationSymbol() {\n        var decoder = this.decoder;\n        var contexts = this.contexts;\n        var symbol = (decoder.readBit(contexts, UNIFORM_CONTEXT) << 3) |\n                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 2) |\n                     (decoder.readBit(contexts, UNIFORM_CONTEXT) << 1) |\n                      decoder.readBit(contexts, UNIFORM_CONTEXT);\n        if (symbol !== 0xA) {\n          throw new Error(\'JPX Error: Invalid segmentation symbol\');\n        }\n      }\n    };\n\n    return BitModel;\n  })();\n\n  // Section F, Discrete wavelet transformation\n  var Transform = (function TransformClosure() {\n    function Transform() {}\n\n    Transform.prototype.calculate =\n      function transformCalculate(subbands, u0, v0) {\n      var ll = subbands[0];\n      for (var i = 1, ii = subbands.length; i < ii; i++) {\n        ll = this.iterate(ll, subbands[i], u0, v0);\n      }\n      return ll;\n    };\n    Transform.prototype.extend = function extend(buffer, offset, size) {\n      // Section F.3.7 extending... using max extension of 4\n      var i1 = offset - 1, j1 = offset + 1;\n      var i2 = offset + size - 2, j2 = offset + size;\n      buffer[i1--] = buffer[j1++];\n      buffer[j2++] = buffer[i2--];\n      buffer[i1--] = buffer[j1++];\n      buffer[j2++] = buffer[i2--];\n      buffer[i1--] = buffer[j1++];\n      buffer[j2++] = buffer[i2--];\n      buffer[i1] = buffer[j1];\n      buffer[j2] = buffer[i2];\n    };\n    Transform.prototype.iterate = function Transform_iterate(ll, hl_lh_hh,\n                                                             u0, v0) {\n      var llWidth = ll.width, llHeight = ll.height, llItems = ll.items;\n      var width = hl_lh_hh.width;\n      var height = hl_lh_hh.height;\n      var items = hl_lh_hh.items;\n      var i, j, k, l, u, v;\n\n      // Interleave LL according to Section F.3.3\n      for (k = 0, i = 0; i < llHeight; i++) {\n        l = i * 2 * width;\n        for (j = 0; j < llWidth; j++, k++, l += 2) {\n          items[l] = llItems[k];\n        }\n      }\n      // The LL band is not needed anymore.\n      llItems = ll.items = null;\n\n      var bufferPadding = 4;\n      var rowBuffer = new Float32Array(width + 2 * bufferPadding);\n\n      // Section F.3.4 HOR_SR\n      if (width === 1) {\n        // if width = 1, when u0 even keep items as is, when odd divide by 2\n        if ((u0 & 1) !== 0) {\n          for (v = 0, k = 0; v < height; v++, k += width) {\n            items[k] *= 0.5;\n          }\n        }\n      } else {\n        for (v = 0, k = 0; v < height; v++, k += width) {\n          rowBuffer.set(items.subarray(k, k + width), bufferPadding);\n\n          this.extend(rowBuffer, bufferPadding, width);\n          this.filter(rowBuffer, bufferPadding, width);\n\n          items.set(\n            rowBuffer.subarray(bufferPadding, bufferPadding + width),\n            k);\n        }\n      }\n\n      // Accesses to the items array can take long, because it may not fit into\n      // CPU cache and has to be fetched from main memory. Since subsequent\n      // accesses to the items array are not local when reading columns, we\n      // have a cache miss every time. To reduce cache misses, get up to\n      // \'numBuffers\' items at a time and store them into the individual\n      // buffers. The colBuffers should be small enough to fit into CPU cache.\n      var numBuffers = 16;\n      var colBuffers = [];\n      for (i = 0; i < numBuffers; i++) {\n        colBuffers.push(new Float32Array(height + 2 * bufferPadding));\n      }\n      var b, currentBuffer = 0;\n      ll = bufferPadding + height;\n\n      // Section F.3.5 VER_SR\n      if (height === 1) {\n          // if height = 1, when v0 even keep items as is, when odd divide by 2\n        if ((v0 & 1) !== 0) {\n          for (u = 0; u < width; u++) {\n            items[u] *= 0.5;\n          }\n        }\n      } else {\n        for (u = 0; u < width; u++) {\n          // if we ran out of buffers, copy several image columns at once\n          if (currentBuffer === 0) {\n            numBuffers = Math.min(width - u, numBuffers);\n            for (k = u, l = bufferPadding; l < ll; k += width, l++) {\n              for (b = 0; b < numBuffers; b++) {\n                colBuffers[b][l] = items[k + b];\n              }\n            }\n            currentBuffer = numBuffers;\n          }\n\n          currentBuffer--;\n          var buffer = colBuffers[currentBuffer];\n          this.extend(buffer, bufferPadding, height);\n          this.filter(buffer, bufferPadding, height);\n\n          // If this is last buffer in this group of buffers, flush all buffers.\n          if (currentBuffer === 0) {\n            k = u - numBuffers + 1;\n            for (l = bufferPadding; l < ll; k += width, l++) {\n              for (b = 0; b < numBuffers; b++) {\n                items[k + b] = colBuffers[b][l];\n              }\n            }\n          }\n        }\n      }\n\n      return {\n        width: width,\n        height: height,\n        items: items\n      };\n    };\n    return Transform;\n  })();\n\n  // Section 3.8.2 Irreversible 9-7 filter\n  var IrreversibleTransform = (function IrreversibleTransformClosure() {\n    function IrreversibleTransform() {\n      Transform.call(this);\n    }\n\n    IrreversibleTransform.prototype = Object.create(Transform.prototype);\n    IrreversibleTransform.prototype.filter =\n      function irreversibleTransformFilter(x, offset, length) {\n      var len = length >> 1;\n      offset = offset | 0;\n      var j, n, current, next;\n\n      var alpha = -1.586134342059924;\n      var beta = -0.052980118572961;\n      var gamma = 0.882911075530934;\n      var delta = 0.443506852043971;\n      var K = 1.230174104914001;\n      var K_ = 1 / K;\n\n      // step 1 is combined with step 3\n\n      // step 2\n      j = offset - 3;\n      for (n = len + 4; n--; j += 2) {\n        x[j] *= K_;\n      }\n\n      // step 1 & 3\n      j = offset - 2;\n      current = delta * x[j -1];\n      for (n = len + 3; n--; j += 2) {\n        next = delta * x[j + 1];\n        x[j] = K * x[j] - current - next;\n        if (n--) {\n          j += 2;\n          current = delta * x[j + 1];\n          x[j] = K * x[j] - current - next;\n        } else {\n          break;\n        }\n      }\n\n      // step 4\n      j = offset - 1;\n      current = gamma * x[j - 1];\n      for (n = len + 2; n--; j += 2) {\n        next = gamma * x[j + 1];\n        x[j] -= current + next;\n        if (n--) {\n          j += 2;\n          current = gamma * x[j + 1];\n          x[j] -= current + next;\n        } else {\n          break;\n        }\n      }\n\n      // step 5\n      j = offset;\n      current = beta * x[j - 1];\n      for (n = len + 1; n--; j += 2) {\n        next = beta * x[j + 1];\n        x[j] -= current + next;\n        if (n--) {\n          j += 2;\n          current = beta * x[j + 1];\n          x[j] -= current + next;\n        } else {\n          break;\n        }\n      }\n\n      // step 6\n      if (len !== 0) {\n        j = offset + 1;\n        current = alpha * x[j - 1];\n        for (n = len; n--; j += 2) {\n          next = alpha * x[j + 1];\n          x[j] -= current + next;\n          if (n--) {\n            j += 2;\n            current = alpha * x[j + 1];\n            x[j] -= current + next;\n          } else {\n            break;\n          }\n        }\n      }\n    };\n\n    return IrreversibleTransform;\n  })();\n\n  // Section 3.8.1 Reversible 5-3 filter\n  var ReversibleTransform = (function ReversibleTransformClosure() {\n    function ReversibleTransform() {\n      Transform.call(this);\n    }\n\n    ReversibleTransform.prototype = Object.create(Transform.prototype);\n    ReversibleTransform.prototype.filter =\n      function reversibleTransformFilter(x, offset, length) {\n      var len = length >> 1;\n      offset = offset | 0;\n      var j, n;\n\n      for (j = offset, n = len + 1; n--; j += 2) {\n        x[j] -= (x[j - 1] + x[j + 1] + 2) >> 2;\n      }\n\n      for (j = offset + 1, n = len; n--; j += 2) {\n        x[j] += (x[j - 1] + x[j + 1]) >> 1;\n      }\n    };\n\n    return ReversibleTransform;\n  })();\n\n  return JpxImage;\n})();\n\n\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n\'use strict\';\n\n/* This class implements the QM Coder decoding as defined in\n *   JPEG 2000 Part I Final Committee Draft Version 1.0\n *   Annex C.3 Arithmetic decoding procedure \n * available at http://www.jpeg.org/public/fcd15444-1.pdf\n * \n * The arithmetic decoder is used in conjunction with context models to decode\n * JPEG2000 and JBIG2 streams.\n */\nvar ArithmeticDecoder = (function ArithmeticDecoderClosure() {\n  // Table C-2\n  var QeTable = [\n    {qe: 0x5601, nmps: 1, nlps: 1, switchFlag: 1},\n    {qe: 0x3401, nmps: 2, nlps: 6, switchFlag: 0},\n    {qe: 0x1801, nmps: 3, nlps: 9, switchFlag: 0},\n    {qe: 0x0AC1, nmps: 4, nlps: 12, switchFlag: 0},\n    {qe: 0x0521, nmps: 5, nlps: 29, switchFlag: 0},\n    {qe: 0x0221, nmps: 38, nlps: 33, switchFlag: 0},\n    {qe: 0x5601, nmps: 7, nlps: 6, switchFlag: 1},\n    {qe: 0x5401, nmps: 8, nlps: 14, switchFlag: 0},\n    {qe: 0x4801, nmps: 9, nlps: 14, switchFlag: 0},\n    {qe: 0x3801, nmps: 10, nlps: 14, switchFlag: 0},\n    {qe: 0x3001, nmps: 11, nlps: 17, switchFlag: 0},\n    {qe: 0x2401, nmps: 12, nlps: 18, switchFlag: 0},\n    {qe: 0x1C01, nmps: 13, nlps: 20, switchFlag: 0},\n    {qe: 0x1601, nmps: 29, nlps: 21, switchFlag: 0},\n    {qe: 0x5601, nmps: 15, nlps: 14, switchFlag: 1},\n    {qe: 0x5401, nmps: 16, nlps: 14, switchFlag: 0},\n    {qe: 0x5101, nmps: 17, nlps: 15, switchFlag: 0},\n    {qe: 0x4801, nmps: 18, nlps: 16, switchFlag: 0},\n    {qe: 0x3801, nmps: 19, nlps: 17, switchFlag: 0},\n    {qe: 0x3401, nmps: 20, nlps: 18, switchFlag: 0},\n    {qe: 0x3001, nmps: 21, nlps: 19, switchFlag: 0},\n    {qe: 0x2801, nmps: 22, nlps: 19, switchFlag: 0},\n    {qe: 0x2401, nmps: 23, nlps: 20, switchFlag: 0},\n    {qe: 0x2201, nmps: 24, nlps: 21, switchFlag: 0},\n    {qe: 0x1C01, nmps: 25, nlps: 22, switchFlag: 0},\n    {qe: 0x1801, nmps: 26, nlps: 23, switchFlag: 0},\n    {qe: 0x1601, nmps: 27, nlps: 24, switchFlag: 0},\n    {qe: 0x1401, nmps: 28, nlps: 25, switchFlag: 0},\n    {qe: 0x1201, nmps: 29, nlps: 26, switchFlag: 0},\n    {qe: 0x1101, nmps: 30, nlps: 27, switchFlag: 0},\n    {qe: 0x0AC1, nmps: 31, nlps: 28, switchFlag: 0},\n    {qe: 0x09C1, nmps: 32, nlps: 29, switchFlag: 0},\n    {qe: 0x08A1, nmps: 33, nlps: 30, switchFlag: 0},\n    {qe: 0x0521, nmps: 34, nlps: 31, switchFlag: 0},\n    {qe: 0x0441, nmps: 35, nlps: 32, switchFlag: 0},\n    {qe: 0x02A1, nmps: 36, nlps: 33, switchFlag: 0},\n    {qe: 0x0221, nmps: 37, nlps: 34, switchFlag: 0},\n    {qe: 0x0141, nmps: 38, nlps: 35, switchFlag: 0},\n    {qe: 0x0111, nmps: 39, nlps: 36, switchFlag: 0},\n    {qe: 0x0085, nmps: 40, nlps: 37, switchFlag: 0},\n    {qe: 0x0049, nmps: 41, nlps: 38, switchFlag: 0},\n    {qe: 0x0025, nmps: 42, nlps: 39, switchFlag: 0},\n    {qe: 0x0015, nmps: 43, nlps: 40, switchFlag: 0},\n    {qe: 0x0009, nmps: 44, nlps: 41, switchFlag: 0},\n    {qe: 0x0005, nmps: 45, nlps: 42, switchFlag: 0},\n    {qe: 0x0001, nmps: 45, nlps: 43, switchFlag: 0},\n    {qe: 0x5601, nmps: 46, nlps: 46, switchFlag: 0}\n  ];\n\n  // C.3.5 Initialisation of the decoder (INITDEC)\n  function ArithmeticDecoder(data, start, end) {\n    this.data = data;\n    this.bp = start;\n    this.dataEnd = end;\n\n    this.chigh = data[start];\n    this.clow = 0;\n\n    this.byteIn();\n\n    this.chigh = ((this.chigh << 7) & 0xFFFF) | ((this.clow >> 9) & 0x7F);\n    this.clow = (this.clow << 7) & 0xFFFF;\n    this.ct -= 7;\n    this.a = 0x8000;\n  }\n\n  ArithmeticDecoder.prototype = {\n    // C.3.4 Compressed data input (BYTEIN)\n    byteIn: function ArithmeticDecoder_byteIn() {\n      var data = this.data;\n      var bp = this.bp;\n      if (data[bp] === 0xFF) {\n        var b1 = data[bp + 1];\n        if (b1 > 0x8F) {\n          this.clow += 0xFF00;\n          this.ct = 8;\n        } else {\n          bp++;\n          this.clow += (data[bp] << 9);\n          this.ct = 7;\n          this.bp = bp;\n        }\n      } else {\n        bp++;\n        this.clow += bp < this.dataEnd ? (data[bp] << 8) : 0xFF00;\n        this.ct = 8;\n        this.bp = bp;\n      }\n      if (this.clow > 0xFFFF) {\n        this.chigh += (this.clow >> 16);\n        this.clow &= 0xFFFF;\n      }\n    },\n    // C.3.2 Decoding a decision (DECODE)\n    readBit: function ArithmeticDecoder_readBit(contexts, pos) {\n      // contexts are packed into 1 byte:\n      // highest 7 bits carry cx.index, lowest bit carries cx.mps\n      var cx_index = contexts[pos] >> 1, cx_mps = contexts[pos] & 1;\n      var qeTableIcx = QeTable[cx_index];\n      var qeIcx = qeTableIcx.qe;\n      var d;\n      var a = this.a - qeIcx;\n\n      if (this.chigh < qeIcx) {\n        // exchangeLps\n        if (a < qeIcx) {\n          a = qeIcx;\n          d = cx_mps;\n          cx_index = qeTableIcx.nmps;\n        } else {\n          a = qeIcx;\n          d = 1 ^ cx_mps;\n          if (qeTableIcx.switchFlag === 1) {\n            cx_mps = d;\n          }\n          cx_index = qeTableIcx.nlps;\n        }\n      } else {\n        this.chigh -= qeIcx;\n        if ((a & 0x8000) !== 0) {\n          this.a = a;\n          return cx_mps;\n        }\n        // exchangeMps\n        if (a < qeIcx) {\n          d = 1 ^ cx_mps;\n          if (qeTableIcx.switchFlag === 1) {\n            cx_mps = d;\n          }\n          cx_index = qeTableIcx.nlps;\n        } else {\n          d = cx_mps;\n          cx_index = qeTableIcx.nmps;\n        }\n      }\n      // C.3.3 renormD;\n      do {\n        if (this.ct === 0) {\n          this.byteIn();\n        }\n\n        a <<= 1;\n        this.chigh = ((this.chigh << 1) & 0xFFFF) | ((this.clow >> 15) & 1);\n        this.clow = (this.clow << 1) & 0xFFFF;\n        this.ct--;\n      } while ((a & 0x8000) === 0);\n      this.a = a;\n\n      contexts[pos] = cx_index << 1 | cx_mps;\n      return d;\n    }\n  };\n\n  return ArithmeticDecoder;\n})();\n\n/* Copyright 2012 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the "License");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an "AS IS" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n/* globals Cmd, ColorSpace, Dict, MozBlobBuilder, Name, PDFJS, Ref, URL,\n           Promise */\n\n\'use strict\';\n\nvar globalScope = (typeof window === \'undefined\') ? this : window;\n\nvar isWorker = (typeof window === \'undefined\');\n\nvar FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\n\nvar TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\n\nvar ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\n\nvar AnnotationType = {\n  WIDGET: 1,\n  TEXT: 2,\n  LINK: 3\n};\n\nvar StreamType = {\n  UNKNOWN: 0,\n  FLATE: 1,\n  LZW: 2,\n  DCT: 3,\n  JPX: 4,\n  JBIG: 5,\n  A85: 6,\n  AHX: 7,\n  CCF: 8,\n  RL: 9\n};\n\nvar FontType = {\n  UNKNOWN: 0,\n  TYPE1: 1,\n  TYPE1C: 2,\n  CIDFONTTYPE0: 3,\n  CIDFONTTYPE0C: 4,\n  TRUETYPE: 5,\n  CIDFONTTYPE2: 6,\n  TYPE3: 7,\n  OPENTYPE: 8,\n  TYPE0: 9,\n  MMTYPE1: 10\n};\n\n// The global PDFJS object exposes the API\n// In production, it will be declared outside a global wrapper\n// In development, it will be declared here\nif (!globalScope.PDFJS) {\n  globalScope.PDFJS = {};\n}\n\n//globalScope.PDFJS.pdfBug = false;\n\nvar PDFJS = PDFJS || {};\n\nPDFJS.VERBOSITY_LEVELS = {\n  errors: 0,\n  warnings: 1,\n  infos: 5\n};\n\n// All the possible operations for an operator list.\nvar OPS = PDFJS.OPS = {\n  // Intentionally start from 1 so it is easy to spot bad operators that will be\n  // 0\'s.\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotations: 78,\n  endAnnotations: 79,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintJpegXObject: 82,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\n\n// A notice for devs. These are good for things that are helpful to devs, such\n// as warning that Workers were disabled, which is important to devs but not\n// end users.\nfunction info(msg) {\n  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.infos) {\n    console.log(\'Info: \' + msg);\n  }\n}\n\n// Non-fatal warnings.\nfunction warn(msg) {\n  if (PDFJS.verbosity >= PDFJS.VERBOSITY_LEVELS.warnings) {\n    console.log(\'Warning: \' + msg);\n  }\n}\n\n// Fatal errors that should trigger the fallback UI and halt execution by\n// throwing an exception.\nfunction error(msg) {\n  // If multiple arguments were passed, pass them all to the log function.\n  if (arguments.length > 1) {\n    var logArguments = [\'Error:\'];\n    logArguments.push.apply(logArguments, arguments);\n    console.log.apply(console, logArguments);\n    // Join the arguments into a single string for the lines below.\n    msg = [].join.call(arguments, \' \');\n  } else {\n    console.log(\'Error: \' + msg);\n  }\n  console.log(backtrace());\n  UnsupportedManager.notify(UNSUPPORTED_FEATURES.unknown);\n  throw new Error(msg);\n}\n\nfunction backtrace() {\n  try {\n    throw new Error();\n  } catch (e) {\n    return e.stack ? e.stack.split(\'\\n\').slice(2).join(\'\\n\') : \'\';\n  }\n}\n\nfunction assert(cond, msg) {\n  if (!cond) {\n    error(msg);\n  }\n}\n\nvar UNSUPPORTED_FEATURES = PDFJS.UNSUPPORTED_FEATURES = {\n  unknown: \'unknown\',\n  forms: \'forms\',\n  javaScript: \'javaScript\',\n  smask: \'smask\',\n  shadingPattern: \'shadingPattern\',\n  font: \'font\'\n};\n\nvar UnsupportedManager = PDFJS.UnsupportedManager =\n  (function UnsupportedManagerClosure() {\n  var listeners = [];\n  return {\n    listen: function (cb) {\n      listeners.push(cb);\n    },\n    notify: function (featureId) {\n      warn(\'Unsupported feature "\' + featureId + \'"\');\n      for (var i = 0, ii = listeners.length; i < ii; i++) {\n        listeners[i](featureId);\n      }\n    }\n  };\n})();\n\n// Combines two URLs. The baseUrl shall be absolute URL. If the url is an\n// absolute URL, it will be returned as is.\nfunction combineUrl(baseUrl, url) {\n  if (!url) {\n    return baseUrl;\n  }\n  if (/^[a-z][a-z0-9+\\-.]*:/i.test(url)) {\n    return url;\n  }\n  var i;\n  if (url.charAt(0) === \'/\') {\n    // absolute path\n    i = baseUrl.indexOf(\'://\');\n    if (url.charAt(1) === \'/\') {\n      ++i;\n    } else {\n      i = baseUrl.indexOf(\'/\', i + 3);\n    }\n    return baseUrl.substring(0, i) + url;\n  } else {\n    // relative path\n    var pathLength = baseUrl.length;\n    i = baseUrl.lastIndexOf(\'#\');\n    pathLength = i >= 0 ? i : pathLength;\n    i = baseUrl.lastIndexOf(\'?\', pathLength);\n    pathLength = i >= 0 ? i : pathLength;\n    var prefixLength = baseUrl.lastIndexOf(\'/\', pathLength);\n    return baseUrl.substring(0, prefixLength + 1) + url;\n  }\n}\n\n// Validates if URL is safe and allowed, e.g. to avoid XSS.\nfunction isValidUrl(url, allowRelative) {\n  if (!url) {\n    return false;\n  }\n  // RFC 3986 (http://tools.ietf.org/html/rfc3986#section-3.1)\n  // scheme = ALPHA *( ALPHA / DIGIT / "+" / "-" / "." )\n  var protocol = /^[a-z][a-z0-9+\\-.]*(?=:)/i.exec(url);\n  if (!protocol) {\n    return allowRelative;\n  }\n  protocol = protocol[0].toLowerCase();\n  switch (protocol) {\n    case \'http\':\n    case \'https\':\n    case \'ftp\':\n    case \'mailto\':\n    case \'tel\':\n      return true;\n    default:\n      return false;\n  }\n}\nPDFJS.isValidUrl = isValidUrl;\n\nfunction shadow(obj, prop, value) {\n  Object.defineProperty(obj, prop, { value: value,\n                                     enumerable: true,\n                                     configurable: true,\n                                     writable: false });\n  return value;\n}\nPDFJS.shadow = shadow;\n\nvar PasswordResponses = PDFJS.PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\n\nvar PasswordException = (function PasswordExceptionClosure() {\n  function PasswordException(msg, code) {\n    this.name = \'PasswordException\';\n    this.message = msg;\n    this.code = code;\n  }\n\n  PasswordException.prototype = new Error();\n  PasswordException.constructor = PasswordException;\n\n  return PasswordException;\n})();\nPDFJS.PasswordException = PasswordException;\n\nvar UnknownErrorException = (function UnknownErrorExceptionClosure() {\n  function UnknownErrorException(msg, details) {\n    this.name = \'UnknownErrorException\';\n    this.message = msg;\n    this.details = details;\n  }\n\n  UnknownErrorException.prototype = new Error();\n  UnknownErrorException.constructor = UnknownErrorException;\n\n  return UnknownErrorException;\n})();\nPDFJS.UnknownErrorException = UnknownErrorException;\n\nvar InvalidPDFException = (function InvalidPDFExceptionClosure() {\n  function InvalidPDFException(msg) {\n    this.name = \'InvalidPDFException\';\n    this.message = msg;\n  }\n\n  InvalidPDFException.prototype = new Error();\n  InvalidPDFException.constructor = InvalidPDFException;\n\n  return InvalidPDFException;\n})();\nPDFJS.InvalidPDFException = InvalidPDFException;\n\nvar MissingPDFException = (function MissingPDFExceptionClosure() {\n  function MissingPDFException(msg) {\n    this.name = \'MissingPDFException\';\n    this.message = msg;\n  }\n\n  MissingPDFException.prototype = new Error();\n  MissingPDFException.constructor = MissingPDFException;\n\n  return MissingPDFException;\n})();\nPDFJS.MissingPDFException = MissingPDFException;\n\nvar UnexpectedResponseException =\n    (function UnexpectedResponseExceptionClosure() {\n  function UnexpectedResponseException(msg, status) {\n    this.name = \'UnexpectedResponseException\';\n    this.message = msg;\n    this.status = status;\n  }\n\n  UnexpectedResponseException.prototype = new Error();\n  UnexpectedResponseException.constructor = UnexpectedResponseException;\n\n  return UnexpectedResponseException;\n})();\nPDFJS.UnexpectedResponseException = UnexpectedResponseException;\n\nvar NotImplementedException = (function NotImplementedExceptionClosure() {\n  function NotImplementedException(msg) {\n    this.message = msg;\n  }\n\n  NotImplementedException.prototype = new Error();\n  NotImplementedException.prototype.name = \'NotImplementedException\';\n  NotImplementedException.constructor = NotImplementedException;\n\n  return NotImplementedException;\n})();\n\nvar MissingDataException = (function MissingDataExceptionClosure() {\n  function MissingDataException(begin, end) {\n    this.begin = begin;\n    this.end = end;\n    this.message = \'Missing data [\' + begin + \', \' + end + \')\';\n  }\n\n  MissingDataException.prototype = new Error();\n  MissingDataException.prototype.name = \'MissingDataException\';\n  MissingDataException.constructor = MissingDataException;\n\n  return MissingDataException;\n})();\n\nvar XRefParseException = (function XRefParseExceptionClosure() {\n  function XRefParseException(msg) {\n    this.message = msg;\n  }\n\n  XRefParseException.prototype = new Error();\n  XRefParseException.prototype.name = \'XRefParseException\';\n  XRefParseException.constructor = XRefParseException;\n\n  return XRefParseException;\n})();\n\n\nfunction bytesToString(bytes) {\n  assert(bytes !== null && typeof bytes === \'object\' &&\n         bytes.length !== undefined, \'Invalid argument for bytesToString\');\n  var length = bytes.length;\n  var MAX_ARGUMENT_COUNT = 8192;\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  var strBuf = [];\n  for (var i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    var chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    var chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n  return strBuf.join(\'\');\n}\n\nfunction stringToBytes(str) {\n  assert(typeof str === \'string\', \'Invalid argument for stringToBytes\');\n  var length = str.length;\n  var bytes = new Uint8Array(length);\n  for (var i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xFF;\n  }\n  return bytes;\n}\n\nfunction string32(value) {\n  return String.fromCharCode((value >> 24) & 0xff, (value >> 16) & 0xff,\n                             (value >> 8) & 0xff, value & 0xff);\n}\n\nfunction log2(x) {\n  var n = 1, i = 0;\n  while (x > n) {\n    n <<= 1;\n    i++;\n  }\n  return i;\n}\n\nfunction readInt8(data, start) {\n  return (data[start] << 24) >> 24;\n}\n\nfunction readUint16(data, offset) {\n  return (data[offset] << 8) | data[offset + 1];\n}\n\nfunction readUint32(data, offset) {\n  return ((data[offset] << 24) | (data[offset + 1] << 16) |\n         (data[offset + 2] << 8) | data[offset + 3]) >>> 0;\n}\n\n// Lazy test the endianness of the platform\n// NOTE: This will be \'true\' for simulated TypedArrays\nfunction isLittleEndian() {\n  var buffer8 = new Uint8Array(2);\n  buffer8[0] = 1;\n  var buffer16 = new Uint16Array(buffer8.buffer);\n  return (buffer16[0] === 1);\n}\n\nObject.defineProperty(PDFJS, \'isLittleEndian\', {\n  configurable: true,\n  get: function PDFJS_isLittleEndian() {\n    return shadow(PDFJS, \'isLittleEndian\', isLittleEndian());\n  }\n});\n\n//#if !(FIREFOX || MOZCENTRAL || B2G || CHROME)\n//// Lazy test if the userAgant support CanvasTypedArrays\nfunction hasCanvasTypedArrays() {\n  var canvas = document.createElement(\'canvas\');\n  canvas.width = canvas.height = 1;\n  var ctx = canvas.getContext(\'2d\');\n  var imageData = ctx.createImageData(1, 1);\n  return (typeof imageData.data.buffer !== \'undefined\');\n}\n\nObject.defineProperty(PDFJS, \'hasCanvasTypedArrays\', {\n  configurable: true,\n  get: function PDFJS_hasCanvasTypedArrays() {\n    return shadow(PDFJS, \'hasCanvasTypedArrays\', hasCanvasTypedArrays());\n  }\n});\n\nvar Uint32ArrayView = (function Uint32ArrayViewClosure() {\n\n  function Uint32ArrayView(buffer, length) {\n    this.buffer = buffer;\n    this.byteLength = buffer.length;\n    this.length = length === undefined ? (this.byteLength >> 2) : length;\n    ensureUint32ArrayViewProps(this.length);\n  }\n  Uint32ArrayView.prototype = Object.create(null);\n\n  var uint32ArrayViewSetters = 0;\n  function createUint32ArrayProp(index) {\n    return {\n      get: function () {\n        var buffer = this.buffer, offset = index << 2;\n        return (buffer[offset] | (buffer[offset + 1] << 8) |\n          (buffer[offset + 2] << 16) | (buffer[offset + 3] << 24)) >>> 0;\n      },\n      set: function (value) {\n        var buffer = this.buffer, offset = index << 2;\n        buffer[offset] = value & 255;\n        buffer[offset + 1] = (value >> 8) & 255;\n        buffer[offset + 2] = (value >> 16) & 255;\n        buffer[offset + 3] = (value >>> 24) & 255;\n      }\n    };\n  }\n\n  function ensureUint32ArrayViewProps(length) {\n    while (uint32ArrayViewSetters < length) {\n      Object.defineProperty(Uint32ArrayView.prototype,\n        uint32ArrayViewSetters,\n        createUint32ArrayProp(uint32ArrayViewSetters));\n      uint32ArrayViewSetters++;\n    }\n  }\n\n  return Uint32ArrayView;\n})();\n//#else\n//PDFJS.hasCanvasTypedArrays = true;\n//#endif\n\nvar IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\n\nvar Util = PDFJS.Util = (function UtilClosure() {\n  function Util() {}\n\n  var rgbBuf = [\'rgb(\', 0, \',\', 0, \',\', 0, \')\'];\n\n  // makeCssRgb() can be called thousands of times. Using |rgbBuf| avoids\n  // creating many intermediate strings.\n  Util.makeCssRgb = function Util_makeCssRgb(r, g, b) {\n    rgbBuf[1] = r;\n    rgbBuf[3] = g;\n    rgbBuf[5] = b;\n    return rgbBuf.join(\'\');\n  };\n\n  // Concatenates two transformation matrices together and returns the result.\n  Util.transform = function Util_transform(m1, m2) {\n    return [\n      m1[0] * m2[0] + m1[2] * m2[1],\n      m1[1] * m2[0] + m1[3] * m2[1],\n      m1[0] * m2[2] + m1[2] * m2[3],\n      m1[1] * m2[2] + m1[3] * m2[3],\n      m1[0] * m2[4] + m1[2] * m2[5] + m1[4],\n      m1[1] * m2[4] + m1[3] * m2[5] + m1[5]\n    ];\n  };\n\n  // For 2d affine transforms\n  Util.applyTransform = function Util_applyTransform(p, m) {\n    var xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    var yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  };\n\n  Util.applyInverseTransform = function Util_applyInverseTransform(p, m) {\n    var d = m[0] * m[3] - m[1] * m[2];\n    var xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    var yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  };\n\n  // Applies the transform to the rectangle and finds the minimum axially\n  // aligned bounding box.\n  Util.getAxialAlignedBoundingBox =\n    function Util_getAxialAlignedBoundingBox(r, m) {\n\n    var p1 = Util.applyTransform(r, m);\n    var p2 = Util.applyTransform(r.slice(2, 4), m);\n    var p3 = Util.applyTransform([r[0], r[3]], m);\n    var p4 = Util.applyTransform([r[2], r[1]], m);\n    return [\n      Math.min(p1[0], p2[0], p3[0], p4[0]),\n      Math.min(p1[1], p2[1], p3[1], p4[1]),\n      Math.max(p1[0], p2[0], p3[0], p4[0]),\n      Math.max(p1[1], p2[1], p3[1], p4[1])\n    ];\n  };\n\n  Util.inverseTransform = function Util_inverseTransform(m) {\n    var d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d,\n      (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  };\n\n  // Apply a generic 3d matrix M on a 3-vector v:\n  //   | a b c |   | X |\n  //   | d e f | x | Y |\n  //   | g h i |   | Z |\n  // M is assumed to be serialized as [a,b,c,d,e,f,g,h,i],\n  // with v as [X,Y,Z]\n  Util.apply3dTransform = function Util_apply3dTransform(m, v) {\n    return [\n      m[0] * v[0] + m[1] * v[1] + m[2] * v[2],\n      m[3] * v[0] + m[4] * v[1] + m[5] * v[2],\n      m[6] * v[0] + m[7] * v[1] + m[8] * v[2]\n    ];\n  };\n\n  // This calculation uses Singular Value Decomposition.\n  // The SVD can be represented with formula A = USV. We are interested in the\n  // matrix S here because it represents the scale values.\n  Util.singularValueDecompose2dScale =\n    function Util_singularValueDecompose2dScale(m) {\n\n    var transpose = [m[0], m[2], m[1], m[3]];\n\n    // Multiply matrix m with its transpose.\n    var a = m[0] * transpose[0] + m[1] * transpose[2];\n    var b = m[0] * transpose[1] + m[1] * transpose[3];\n    var c = m[2] * transpose[0] + m[3] * transpose[2];\n    var d = m[2] * transpose[1] + m[3] * transpose[3];\n\n    // Solve the second degree polynomial to get roots.\n    var first = (a + d) / 2;\n    var second = Math.sqrt((a + d) * (a + d) - 4 * (a * d - c * b)) / 2;\n    var sx = first + second || 1;\n    var sy = first - second || 1;\n\n    // Scale values are the square roots of the eigenvalues.\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  };\n\n  // Normalize rectangle rect=[x1, y1, x2, y2] so that (x1,y1) < (x2,y2)\n  // For coordinate systems whose origin lies in the bottom-left, this\n  // means normalization to (BL,TR) ordering. For systems with origin in the\n  // top-left, this means (TL,BR) ordering.\n  Util.normalizeRect = function Util_normalizeRect(rect) {\n    var r = rect.slice(0); // clone rect\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n    return r;\n  };\n\n  // Returns a rectangle [x1, y1, x2, y2] corresponding to the\n  // intersection of rect1 and rect2. If no intersection, returns \'false\'\n  // The rectangle coordinates of rect1, rect2 should be [x1, y1, x2, y2]\n  Util.intersect = function Util_intersect(rect1, rect2) {\n    function compare(a, b) {\n      return a - b;\n    }\n\n    // Order points along the axes\n    var orderedX = [rect1[0], rect1[2], rect2[0], rect2[2]].sort(compare),\n        orderedY = [rect1[1], rect1[3], rect2[1], rect2[3]].sort(compare),\n        result = [];\n\n    rect1 = Util.normalizeRect(rect1);\n    rect2 = Util.normalizeRect(rect2);\n\n    // X: first and second points belong to different rectangles?\n    if ((orderedX[0] === rect1[0] && orderedX[1] === rect2[0]) ||\n        (orderedX[0] === rect2[0] && orderedX[1] === rect1[0])) {\n      // Intersection must be between second and third points\n      result[0] = orderedX[1];\n      result[2] = orderedX[2];\n    } else {\n      return false;\n    }\n\n    // Y: first and second points belong to different rectangles?\n    if ((orderedY[0] === rect1[1] && orderedY[1] === rect2[1]) ||\n        (orderedY[0] === rect2[1] && orderedY[1] === rect1[1])) {\n      // Intersection must be between second and third points\n      result[1] = orderedY[1];\n      result[3] = orderedY[2];\n    } else {\n      return false;\n    }\n\n    return result;\n  };\n\n  Util.sign = function Util_sign(num) {\n    return num < 0 ? -1 : 1;\n  };\n\n  Util.appendToArray = function Util_appendToArray(arr1, arr2) {\n    Array.prototype.push.apply(arr1, arr2);\n  };\n\n  Util.prependToArray = function Util_prependToArray(arr1, arr2) {\n    Array.prototype.unshift.apply(arr1, arr2);\n  };\n\n  Util.extendObj = function extendObj(obj1, obj2) {\n    for (var key in obj2) {\n      obj1[key] = obj2[key];\n    }\n  };\n\n  Util.getInheritableProperty = function Util_getInheritableProperty(dict,\n                                                                     name) {\n    while (dict && !dict.has(name)) {\n      dict = dict.get(\'Parent\');\n    }\n    if (!dict) {\n      return null;\n    }\n    return dict.get(name);\n  };\n\n  Util.inherit = function Util_inherit(sub, base, prototype) {\n    sub.prototype = Object.create(base.prototype);\n    sub.prototype.constructor = sub;\n    for (var prop in prototype) {\n      sub.prototype[prop] = prototype[prop];\n    }\n  };\n\n  Util.loadScript = function Util_loadScript(src, callback) {\n    var script = document.createElement(\'script\');\n    var loaded = false;\n    script.setAttribute(\'src\', src);\n    if (callback) {\n      script.onload = function() {\n        if (!loaded) {\n          callback();\n        }\n        loaded = true;\n      };\n    }\n    document.getElementsByTagName(\'head\')[0].appendChild(script);\n  };\n\n  return Util;\n})();\n\n/**\n * PDF page viewport created based on scale, rotation and offset.\n * @class\n * @alias PDFJS.PageViewport\n */\nvar PageViewport = PDFJS.PageViewport = (function PageViewportClosure() {\n  /**\n   * @constructor\n   * @private\n   * @param viewBox {Array} xMin, yMin, xMax and yMax coordinates.\n   * @param scale {number} scale of the viewport.\n   * @param rotation {number} rotations of the viewport in degrees.\n   * @param offsetX {number} offset X\n   * @param offsetY {number} offset Y\n   * @param dontFlip {boolean} if true, axis Y will not be flipped.\n   */\n  function PageViewport(viewBox, scale, rotation, offsetX, offsetY, dontFlip) {\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n\n    // creating transform to convert pdf coordinate system to the normal\n    // canvas like coordinates taking in account scale and rotation\n    var centerX = (viewBox[2] + viewBox[0]) / 2;\n    var centerY = (viewBox[3] + viewBox[1]) / 2;\n    var rotateA, rotateB, rotateC, rotateD;\n    rotation = rotation % 360;\n    rotation = rotation < 0 ? rotation + 360 : rotation;\n    switch (rotation) {\n      case 180:\n        rotateA = -1; rotateB = 0; rotateC = 0; rotateD = 1;\n        break;\n      case 90:\n        rotateA = 0; rotateB = 1; rotateC = 1; rotateD = 0;\n        break;\n      case 270:\n        rotateA = 0; rotateB = -1; rotateC = -1; rotateD = 0;\n        break;\n      //case 0:\n      default:\n        rotateA = 1; rotateB = 0; rotateC = 0; rotateD = -1;\n        break;\n    }\n\n    if (dontFlip) {\n      rotateC = -rotateC; rotateD = -rotateD;\n    }\n\n    var offsetCanvasX, offsetCanvasY;\n    var width, height;\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = Math.abs(viewBox[3] - viewBox[1]) * scale;\n      height = Math.abs(viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = Math.abs(viewBox[2] - viewBox[0]) * scale;\n      height = Math.abs(viewBox[3] - viewBox[1]) * scale;\n    }\n    // creating transform for the following operations:\n    // translate(-centerX, -centerY), rotate and flip vertically,\n    // scale, and translate(offsetCanvasX, offsetCanvasY)\n    this.transform = [\n      rotateA * scale,\n      rotateB * scale,\n      rotateC * scale,\n      rotateD * scale,\n      offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY,\n      offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY\n    ];\n\n    this.width = width;\n    this.height = height;\n    this.fontScale = scale;\n  }\n  PageViewport.prototype = /** @lends PDFJS.PageViewport.prototype */ {\n    /**\n     * Clones viewport with additional properties.\n     * @param args {Object} (optional) If specified, may contain the \'scale\' or\n     * \'rotation\' properties to override the corresponding properties in\n     * the cloned viewport.\n     * @returns {PDFJS.PageViewport} Cloned viewport.\n     */\n    clone: function PageViewPort_clone(args) {\n      args = args || {};\n      var scale = \'scale\' in args ? args.scale : this.scale;\n      var rotation = \'rotation\' in args ? args.rotation : this.rotation;\n      return new PageViewport(this.viewBox.slice(), scale, rotation,\n                              this.offsetX, this.offsetY, args.dontFlip);\n    },\n    /**\n     * Converts PDF point to the viewport coordinates. For examples, useful for\n     * converting PDF location into canvas pixel coordinates.\n     * @param x {number} X coordinate.\n     * @param y {number} Y coordinate.\n     * @returns {Object} Object that contains \'x\' and \'y\' properties of the\n     * point in the viewport coordinate space.\n     * @see {@link convertToPdfPoint}\n     * @see {@link convertToViewportRectangle}\n     */\n    convertToViewportPoint: function PageViewport_convertToViewportPoint(x, y) {\n      return Util.applyTransform([x, y], this.transform);\n    },\n    /**\n     * Converts PDF rectangle to the viewport coordinates.\n     * @param rect {Array} xMin, yMin, xMax and yMax coordinates.\n     * @returns {Array} Contains corresponding coordinates of the rectangle\n     * in the viewport coordinate space.\n     * @see {@link convertToViewportPoint}\n     */\n    convertToViewportRectangle:\n      function PageViewport_convertToViewportRectangle(rect) {\n      var tl = Util.applyTransform([rect[0], rect[1]], this.transform);\n      var br = Util.applyTransform([rect[2], rect[3]], this.transform);\n      return [tl[0], tl[1], br[0], br[1]];\n    },\n    /**\n     * Converts viewport coordinates to the PDF location. For examples, useful\n     * for converting canvas pixel location into PDF one.\n     * @param x {number} X coordinate.\n     * @param y {number} Y coordinate.\n     * @returns {Object} Object that contains \'x\' and \'y\' properties of the\n     * point in the PDF coordinate space.\n     * @see {@link convertToViewportPoint}\n     */\n    convertToPdfPoint: function PageViewport_convertToPdfPoint(x, y) {\n      return Util.applyInverseTransform([x, y], this.transform);\n    }\n  };\n  return PageViewport;\n})();\n\nvar PDFStringTranslateTable = [\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0x2D8, 0x2C7, 0x2C6, 0x2D9, 0x2DD, 0x2DB, 0x2DA, 0x2DC, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014,\n  0x2013, 0x192, 0x2044, 0x2039, 0x203A, 0x2212, 0x2030, 0x201E, 0x201C,\n  0x201D, 0x2018, 0x2019, 0x201A, 0x2122, 0xFB01, 0xFB02, 0x141, 0x152, 0x160,\n  0x178, 0x17D, 0x131, 0x142, 0x153, 0x161, 0x17E, 0, 0x20AC\n];\n\nfunction stringToPDFString(str) {\n  var i, n = str.length, strBuf = [];\n  if (str[0] === \'\\xFE\' && str[1] === \'\\xFF\') {\n    // UTF16BE BOM\n    for (i = 2; i < n; i += 2) {\n      strBuf.push(String.fromCharCode(\n        (str.charCodeAt(i) << 8) | str.charCodeAt(i + 1)));\n    }\n  } else {\n    for (i = 0; i < n; ++i) {\n      var code = PDFStringTranslateTable[str.charCodeAt(i)];\n      strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n    }\n  }\n  return strBuf.join(\'\');\n}\n\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\n\nfunction isEmptyObj(obj) {\n  for (var key in obj) {\n    return false;\n  }\n  return true;\n}\n\nfunction isBool(v) {\n  return typeof v === \'boolean\';\n}\n\nfunction isInt(v) {\n  return typeof v === \'number\' && ((v | 0) === v);\n}\n\nfunction isNum(v) {\n  return typeof v === \'number\';\n}\n\nfunction isString(v) {\n  return typeof v === \'string\';\n}\n\nfunction isNull(v) {\n  return v === null;\n}\n\nfunction isName(v) {\n  return v instanceof Name;\n}\n\nfunction isCmd(v, cmd) {\n  return v instanceof Cmd && (cmd === undefined || v.cmd === cmd);\n}\n\nfunction isDict(v, type) {\n  if (!(v instanceof Dict)) {\n    return false;\n  }\n  if (!type) {\n    return true;\n  }\n  var dictType = v.get(\'Type\');\n  return isName(dictType) && dictType.name === type;\n}\n\nfunction isArray(v) {\n  return v instanceof Array;\n}\n\nfunction isStream(v) {\n  return typeof v === \'object\' && v !== null && v.getBytes !== undefined;\n}\n\nfunction isArrayBuffer(v) {\n  return typeof v === \'object\' && v !== null && v.byteLength !== undefined;\n}\n\nfunction isRef(v) {\n  return v instanceof Ref;\n}\n\n/**\n * Promise Capability object.\n *\n * @typedef {Object} PromiseCapability\n * @property {Promise} promise - A promise object.\n * @property {function} resolve - Fullfills the promise.\n * @property {function} reject - Rejects the promise.\n */\n\n/**\n * Creates a promise capability object.\n * @alias PDFJS.createPromiseCapability\n *\n * @return {PromiseCapability} A capability object contains:\n * - a Promise, resolve and reject methods.\n */\nfunction createPromiseCapability() {\n  var capability = {};\n  capability.promise = new Promise(function (resolve, reject) {\n    capability.resolve = resolve;\n    capability.reject = reject;\n  });\n  return capability;\n}\n\nPDFJS.createPromiseCapability = createPromiseCapability;\n\n/**\n * Polyfill for Promises:\n * The following promise implementation tries to generally implement the\n * Promise/A+ spec. Some notable differences from other promise libaries are:\n * - There currently isn\'t a seperate deferred and promise object.\n * - Unhandled rejections eventually show an error if they aren\'t handled.\n *\n * Based off of the work in:\n * https://bugzilla.mozilla.org/show_bug.cgi?id=810490\n */\n(function PromiseClosure() {\n  if (globalScope.Promise) {\n    // Promises existing in the DOM/Worker, checking presence of all/resolve\n    if (typeof globalScope.Promise.all !== \'function\') {\n      globalScope.Promise.all = function (iterable) {\n        var count = 0, results = [], resolve, reject;\n        var promise = new globalScope.Promise(function (resolve_, reject_) {\n          resolve = resolve_;\n          reject = reject_;\n        });\n        iterable.forEach(function (p, i) {\n          count++;\n          p.then(function (result) {\n            results[i] = result;\n            count--;\n            if (count === 0) {\n              resolve(results);\n            }\n          }, reject);\n        });\n        if (count === 0) {\n          resolve(results);\n        }\n        return promise;\n      };\n    }\n    if (typeof globalScope.Promise.resolve !== \'function\') {\n      globalScope.Promise.resolve = function (value) {\n        return new globalScope.Promise(function (resolve) { resolve(value); });\n      };\n    }\n    if (typeof globalScope.Promise.reject !== \'function\') {\n      globalScope.Promise.reject = function (reason) {\n        return new globalScope.Promise(function (resolve, reject) {\n          reject(reason);\n        });\n      };\n    }\n    if (typeof globalScope.Promise.prototype.catch2 !== \'function\') {\n      globalScope.Promise.prototype.catch2 = function (onReject) {\n        return globalScope.Promise.prototype.then(undefined, onReject);\n      };\n    }\n    return;\n  }\n//#if !MOZCENTRAL\n  var STATUS_PENDING = 0;\n  var STATUS_RESOLVED = 1;\n  var STATUS_REJECTED = 2;\n\n  // In an attempt to avoid silent exceptions, unhandled rejections are\n  // tracked and if they aren\'t handled in a certain amount of time an\n  // error is logged.\n  var REJECTION_TIMEOUT = 500;\n\n  var HandlerManager = {\n    handlers: [],\n    running: false,\n    unhandledRejections: [],\n    pendingRejectionCheck: false,\n\n    scheduleHandlers: function scheduleHandlers(promise) {\n      if (promise._status === STATUS_PENDING) {\n        return;\n      }\n\n      this.handlers = this.handlers.concat(promise._handlers);\n      promise._handlers = [];\n\n      if (this.running) {\n        return;\n      }\n      this.running = true;\n\n      setTimeout(this.runHandlers.bind(this), 0);\n    },\n\n    runHandlers: function runHandlers() {\n      var RUN_TIMEOUT = 1; // ms\n      var timeoutAt = Date.now() + RUN_TIMEOUT;\n      while (this.handlers.length > 0) {\n        var handler = this.handlers.shift();\n\n        var nextStatus = handler.thisPromise._status;\n        var nextValue = handler.thisPromise._value;\n\n        try {\n          if (nextStatus === STATUS_RESOLVED) {\n            if (typeof handler.onResolve === \'function\') {\n              nextValue = handler.onResolve(nextValue);\n            }\n          } else if (typeof handler.onReject === \'function\') {\n              nextValue = handler.onReject(nextValue);\n              nextStatus = STATUS_RESOLVED;\n\n              if (handler.thisPromise._unhandledRejection) {\n                this.removeUnhandeledRejection(handler.thisPromise);\n              }\n          }\n        } catch (ex) {\n          nextStatus = STATUS_REJECTED;\n          nextValue = ex;\n        }\n\n        handler.nextPromise._updateStatus(nextStatus, nextValue);\n        if (Date.now() >= timeoutAt) {\n          break;\n        }\n      }\n\n      if (this.handlers.length > 0) {\n        setTimeout(this.runHandlers.bind(this), 0);\n        return;\n      }\n\n      this.running = false;\n    },\n\n    addUnhandledRejection: function addUnhandledRejection(promise) {\n      this.unhandledRejections.push({\n        promise: promise,\n        time: Date.now()\n      });\n      this.scheduleRejectionCheck();\n    },\n\n    removeUnhandeledRejection: function removeUnhandeledRejection(promise) {\n      promise._unhandledRejection = false;\n      for (var i = 0; i < this.unhandledRejections.length; i++) {\n        if (this.unhandledRejections[i].promise === promise) {\n          this.unhandledRejections.splice(i);\n          i--;\n        }\n      }\n    },\n\n    scheduleRejectionCheck: function scheduleRejectionCheck() {\n      if (this.pendingRejectionCheck) {\n        return;\n      }\n      this.pendingRejectionCheck = true;\n      setTimeout(function rejectionCheck() {\n        this.pendingRejectionCheck = false;\n        var now = Date.now();\n        for (var i = 0; i < this.unhandledRejections.length; i++) {\n          if (now - this.unhandledRejections[i].time > REJECTION_TIMEOUT) {\n            var unhandled = this.unhandledRejections[i].promise._value;\n            var msg = \'Unhandled rejection: \' + unhandled;\n            if (unhandled.stack) {\n              msg += \'\\n\' + unhandled.stack;\n            }\n            warn(msg);\n            this.unhandledRejections.splice(i);\n            i--;\n          }\n        }\n        if (this.unhandledRejections.length) {\n          this.scheduleRejectionCheck();\n        }\n      }.bind(this), REJECTION_TIMEOUT);\n    }\n  };\n\n  function Promise(resolver) {\n    this._status = STATUS_PENDING;\n    this._handlers = [];\n    try {\n      resolver.call(this, this._resolve.bind(this), this._reject.bind(this));\n    } catch (e) {\n      this._reject(e);\n    }\n  }\n  /**\n   * Builds a promise that is resolved when all the passed in promises are\n   * resolved.\n   * @param {array} array of data and/or promises to wait for.\n   * @return {Promise} New dependant promise.\n   */\n  Promise.all = function Promise_all(promises) {\n    var resolveAll, rejectAll;\n    var deferred = new Promise(function (resolve, reject) {\n      resolveAll = resolve;\n      rejectAll = reject;\n    });\n    var unresolved = promises.length;\n    var results = [];\n    if (unresolved === 0) {\n      resolveAll(results);\n      return deferred;\n    }\n    function reject(reason) {\n      if (deferred._status === STATUS_REJECTED) {\n        return;\n      }\n      results = [];\n      rejectAll(reason);\n    }\n    for (var i = 0, ii = promises.length; i < ii; ++i) {\n      var promise = promises[i];\n      var resolve = (function(i) {\n        return function(value) {\n          if (deferred._status === STATUS_REJECTED) {\n            return;\n          }\n          results[i] = value;\n          unresolved--;\n          if (unresolved === 0) {\n            resolveAll(results);\n          }\n        };\n      })(i);\n      if (Promise.isPromise(promise)) {\n        promise.then(resolve, reject);\n      } else {\n        resolve(promise);\n      }\n    }\n    return deferred;\n  };\n\n  /**\n   * Checks if the value is likely a promise (has a \'then\' function).\n   * @return {boolean} true if value is thenable\n   */\n  Promise.isPromise = function Promise_isPromise(value) {\n    return value && typeof value.then === \'function\';\n  };\n\n  /**\n   * Creates resolved promise\n   * @param value resolve value\n   * @returns {Promise}\n   */\n  Promise.resolve = function Promise_resolve(value) {\n    return new Promise(function (resolve) { resolve(value); });\n  };\n\n  /**\n   * Creates rejected promise\n   * @param reason rejection value\n   * @returns {Promise}\n   */\n  Promise.reject = function Promise_reject(reason) {\n    return new Promise(function (resolve, reject) { reject(reason); });\n  };\n\n  Promise.prototype = {\n    _status: null,\n    _value: null,\n    _handlers: null,\n    _unhandledRejection: null,\n\n    _updateStatus: function Promise__updateStatus(status, value) {\n      if (this._status === STATUS_RESOLVED ||\n          this._status === STATUS_REJECTED) {\n        return;\n      }\n\n      if (status === STATUS_RESOLVED &&\n          Promise.isPromise(value)) {\n        value.then(this._updateStatus.bind(this, STATUS_RESOLVED),\n                   this._updateStatus.bind(this, STATUS_REJECTED));\n        return;\n      }\n\n      this._status = status;\n      this._value = value;\n\n      if (status === STATUS_REJECTED && this._handlers.length === 0) {\n        this._unhandledRejection = true;\n        HandlerManager.addUnhandledRejection(this);\n      }\n\n      HandlerManager.scheduleHandlers(this);\n    },\n\n    _resolve: function Promise_resolve(value) {\n      this._updateStatus(STATUS_RESOLVED, value);\n    },\n\n    _reject: function Promise_reject(reason) {\n      this._updateStatus(STATUS_REJECTED, reason);\n    },\n\n    then: function Promise_then(onResolve, onReject) {\n      var nextPromise = new Promise(function (resolve, reject) {\n        this.resolve = resolve;\n        this.reject = reject;\n      });\n      this._handlers.push({\n        thisPromise: this,\n        onResolve: onResolve,\n        onReject: onReject,\n        nextPromise: nextPromise\n      });\n      HandlerManager.scheduleHandlers(this);\n      return nextPromise;\n    },\n\n    catch2: function Promise_catch(onReject) {\n      return this.then(undefined, onReject);\n    }\n  };\n\n  globalScope.Promise = Promise;\n//#else\n//throw new Error(\'DOM Promise is not present\');\n//#endif\n})();\n\nvar StatTimer = (function StatTimerClosure() {\n  function rpad(str, pad, length) {\n    while (str.length < length) {\n      str += pad;\n    }\n    return str;\n  }\n  function StatTimer() {\n    this.started = {};\n    this.times = [];\n    this.enabled = true;\n  }\n  StatTimer.prototype = {\n    time: function StatTimer_time(name) {\n      if (!this.enabled) {\n        return;\n      }\n      if (name in this.started) {\n        warn(\'Timer is already running for \' + name);\n      }\n      this.started[name] = Date.now();\n    },\n    timeEnd: function StatTimer_timeEnd(name) {\n      if (!this.enabled) {\n        return;\n      }\n      if (!(name in this.started)) {\n        warn(\'Timer has not been started for \' + name);\n      }\n      this.times.push({\n        \'name\': name,\n        \'start\': this.started[name],\n        \'end\': Date.now()\n      });\n      // Remove timer from started so it can be called again.\n      delete this.started[name];\n    },\n    toString: function StatTimer_toString() {\n      var i, ii;\n      var times = this.times;\n      var out = \'\';\n      // Find the longest name for padding purposes.\n      var longest = 0;\n      for (i = 0, ii = times.length; i < ii; ++i) {\n        var name = times[i][\'name\'];\n        if (name.length > longest) {\n          longest = name.length;\n        }\n      }\n      for (i = 0, ii = times.length; i < ii; ++i) {\n        var span = times[i];\n        var duration = span.end - span.start;\n        out += rpad(span[\'name\'], \' \', longest) + \' \' + duration + \'ms\\n\';\n      }\n      return out;\n    }\n  };\n  return StatTimer;\n})();\n\nPDFJS.createBlob = function createBlob(data, contentType) {\n  if (typeof Blob !== \'undefined\') {\n    return new Blob([data], { type: contentType });\n  }\n  // Blob builder is deprecated in FF14 and removed in FF18.\n  var bb = new MozBlobBuilder();\n  bb.append(data);\n  return bb.getBlob(contentType);\n};\n\nPDFJS.createObjectURL = (function createObjectURLClosure() {\n  // Blob/createObjectURL is not available, falling back to data schema.\n  var digits =\n    \'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\';\n\n  return function createObjectURL(data, contentType) {\n    if (!PDFJS.disableCreateObjectURL &&\n        typeof URL !== \'undefined\' && URL.createObjectURL) {\n      var blob = PDFJS.createBlob(data, contentType);\n      return URL.createObjectURL(blob);\n    }\n\n    var buffer = \'data:\' + contentType + \';base64,\';\n    for (var i = 0, ii = data.length; i < ii; i += 3) {\n      var b1 = data[i] & 0xFF;\n      var b2 = data[i + 1] & 0xFF;\n      var b3 = data[i + 2] & 0xFF;\n      var d1 = b1 >> 2, d2 = ((b1 & 3) << 4) | (b2 >> 4);\n      var d3 = i + 1 < ii ? ((b2 & 0xF) << 2) | (b3 >> 6) : 64;\n      var d4 = i + 2 < ii ? (b3 & 0x3F) : 64;\n      buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n    }\n    return buffer;\n  };\n})();\n\nfunction MessageHandler(name, comObj) {\n  this.name = name;\n  this.comObj = comObj;\n  this.callbackIndex = 1;\n  this.postMessageTransfers = true;\n  var callbacksCapabilities = this.callbacksCapabilities = {};\n  var ah = this.actionHandler = {};\n\n  ah[\'console_log\'] = [function ahConsoleLog(data) {\n    console.log.apply(console, data);\n  }];\n  ah[\'console_error\'] = [function ahConsoleError(data) {\n    console.error.apply(console, data);\n  }];\n  ah[\'_unsupported_feature\'] = [function ah_unsupportedFeature(data) {\n    UnsupportedManager.notify(data);\n  }];\n\n  comObj.onmessage = function messageHandlerComObjOnMessage(event) {\n    var data = event.data;\n    if (data.isReply) {\n      var callbackId = data.callbackId;\n      if (data.callbackId in callbacksCapabilities) {\n        var callback = callbacksCapabilities[callbackId];\n        delete callbacksCapabilities[callbackId];\n        if (\'error\' in data) {\n          callback.reject(data.error);\n        } else {\n          callback.resolve(data.data);\n        }\n      } else {\n        error(\'Cannot resolve callback \' + callbackId);\n      }\n    } else if (data.action in ah) {\n      var action = ah[data.action];\n      if (data.callbackId) {\n        Promise.resolve().then(function () {\n          return action[0].call(action[1], data.data);\n        }).then(function (result) {\n          comObj.postMessage({\n            isReply: true,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            isReply: true,\n            callbackId: data.callbackId,\n            error: reason\n          });\n        });\n      } else {\n        action[0].call(action[1], data.data);\n      }\n    } else {\n      error(\'Unknown action from worker: \' + data.action);\n    }\n  };\n}\n\nMessageHandler.prototype = {\n  on: function messageHandlerOn(actionName, handler, scope) {\n    var ah = this.actionHandler;\n    if (ah[actionName]) {\n      error(\'There is already an actionName called "\' + actionName + \'"\');\n    }\n    ah[actionName] = [handler, scope];\n  },\n  /**\n   * Sends a message to the comObj to invoke the action with the supplied data.\n   * @param {String} actionName Action to call.\n   * @param {JSON} data JSON data to send.\n   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers\n   */\n  send: function messageHandlerSend(actionName, data, transfers) {\n    var message = {\n      action: actionName,\n      data: data\n    };\n    this.postMessage(message, transfers);\n  },\n  /**\n   * Sends a message to the comObj to invoke the action with the supplied data.\n   * Expects that other side will callback with the response.\n   * @param {String} actionName Action to call.\n   * @param {JSON} data JSON data to send.\n   * @param {Array} [transfers] Optional list of transfers/ArrayBuffers.\n   * @returns {Promise} Promise to be resolved with response data.\n   */\n  sendWithPromise:\n    function messageHandlerSendWithPromise(actionName, data, transfers) {\n    var callbackId = this.callbackIndex++;\n    var message = {\n      action: actionName,\n      data: data,\n      callbackId: callbackId\n    };\n    var capability = createPromiseCapability();\n    this.callbacksCapabilities[callbackId] = capability;\n    try {\n      this.postMessage(message, transfers);\n    } catch (e) {\n      capability.reject(e);\n    }\n    return capability.promise;\n  },\n  /**\n   * Sends raw message to the comObj.\n   * @private\n   * @param message {Object} Raw message.\n   * @param transfers List of transfers/ArrayBuffers, or undefined.\n   */\n  postMessage: function (message, transfers) {\n    if (transfers && this.postMessageTransfers) {\n      this.comObj.postMessage(message, transfers);\n    } else {\n      this.comObj.postMessage(message);\n    }\n  }\n};\n\nfunction loadJpegStream(id, imageUrl, objs) {\n  var img = new Image();\n  img.onload = (function loadJpegStream_onloadClosure() {\n    objs.resolve(id, img);\n  });\n  img.onerror = (function loadJpegStream_onerrorClosure() {\n    objs.resolve(id, null);\n    warn(\'Error during JPEG image loading\');\n  });\n  img.src = imageUrl;\n}\n\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n  module.exports = JpxImage;\n}\n},{}],3:[function(require,module,exports){\n/*\n * Copyright (C) 2015 Michael Martinez\n * Changes: Added support for selection values 2-7, fixed minor bugs &\n * warnings, split into multiple class files, and general clean up.\n *\n * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.\n */\n\n/*\n * Copyright (C) Helmut Dersch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\n\n\n/*** Constructor ***/\njpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || function () {\n    this.hSamp = 0; // Horizontal sampling factor\n    this.quantTableSel = 0; // Quantization table destination selector\n    this.vSamp = 0; // Vertical\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg.lossless.ComponentSpec;\n}\n\n},{}],4:[function(require,module,exports){\n/*\n * Copyright (C) 2015 Michael Martinez\n * Changes: Added support for selection values 2-7, fixed minor bugs &\n * warnings, split into multiple class files, and general clean up.\n *\n * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.\n */\n\n/*\n * Copyright (C) Helmut Dersch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\n\n\n/*** Constructor ***/\njpeg.lossless.DataStream = jpeg.lossless.DataStream || function (data, offset, length) {\n    this.buffer = new DataView(data, offset, length);\n    this.index = 0;\n};\n\n\n\njpeg.lossless.DataStream.prototype.get16 = function () {\n    var value = this.buffer.getUint16(this.index, false);\n    this.index += 2;\n    return value;\n};\n\n\n\njpeg.lossless.DataStream.prototype.get8 = function () {\n    var value = this.buffer.getUint8(this.index);\n    this.index += 1;\n    return value;\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg.lossless.DataStream;\n}\n\n},{}],5:[function(require,module,exports){\n/*\n * Copyright (C) 2015 Michael Martinez\n * Changes: Added support for selection values 2-7, fixed minor bugs &\n * warnings, split into multiple class files, and general clean up.\n *\n * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.\n */\n\n/*\n * Copyright (C) Helmut Dersch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\njpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== \'undefined\') ? require(\'./data-stream.js\') : null);\njpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== \'undefined\') ? require(\'./huffman-table.js\') : null);\njpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== \'undefined\') ? require(\'./quantization-table.js\') : null);\njpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== \'undefined\') ? require(\'./scan-header.js\') : null);\njpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== \'undefined\') ? require(\'./frame-header.js\') : null);\njpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== \'undefined\') ? require(\'./utils.js\') : null);\n\n\n/*** Constructor ***/\njpeg.lossless.Decoder = jpeg.lossless.Decoder || function (buffer, numBytes) {\n    this.buffer = buffer;\n    this.frame = new jpeg.lossless.FrameHeader();\n    this.huffTable = new jpeg.lossless.HuffmanTable();\n    this.quantTable = new jpeg.lossless.QuantizationTable();\n    this.scan = new jpeg.lossless.ScanHeader();\n    this.DU = jpeg.lossless.Utils.createArray(10, 4, 64); // at most 10 data units in a MCU, at most 4 data units in one component\n    this.HuffTab = jpeg.lossless.Utils.createArray(4, 2, 50 * 256);\n    this.IDCT_Source = [];\n    this.nBlock = []; // number of blocks in the i-th Comp in a scan\n    this.acTab = jpeg.lossless.Utils.createArray(10, 1); // ac HuffTab for the i-th Comp in a scan\n    this.dcTab = jpeg.lossless.Utils.createArray(10, 1); // dc HuffTab for the i-th Comp in a scan\n    this.qTab = jpeg.lossless.Utils.createArray(10, 1); // quantization table for the i-th Comp in a scan\n    this.marker = 0;\n    this.markerIndex = 0;\n    this.numComp = 0;\n    this.restartInterval = 0;\n    this.selection = 0;\n    this.xDim = 0;\n    this.yDim = 0;\n    this.xLoc = 0;\n    this.yLoc = 0;\n    this.numBytes = 0;\n    this.outputData = null;\n    this.restarting = false;\n    this.mask = 0;\n\n    if (typeof numBytes !== "undefined") {\n        this.numBytes = numBytes;\n    }\n};\n\n\n/*** Static Pseudo-constants ***/\n\njpeg.lossless.Decoder.IDCT_P = [0, 5, 40, 16, 45, 2, 7, 42, 21, 56, 8, 61, 18, 47, 1, 4, 41, 23, 58, 13, 32, 24, 37, 10, 63, 17, 44, 3, 6, 43, 20,\n    57, 15, 34, 29, 48, 53, 26, 39, 9, 60, 19, 46, 22, 59, 12, 33, 31, 50, 55, 25, 36, 11, 62, 14, 35, 28, 49, 52, 27, 38, 30, 51, 54];\njpeg.lossless.Decoder.TABLE = [0, 1, 5, 6, 14, 15, 27, 28, 2, 4, 7, 13, 16, 26, 29, 42, 3, 8, 12, 17, 25, 30, 41, 43, 9, 11, 18, 24, 31, 40, 44, 53,\n    10, 19, 23, 32, 39, 45, 52, 54, 20, 22, 33, 38, 46, 51, 55, 60, 21, 34, 37, 47, 50, 56, 59, 61, 35, 36, 48, 49, 57, 58, 62, 63];\njpeg.lossless.Decoder.MAX_HUFFMAN_SUBTREE = 50;\njpeg.lossless.Decoder.MSB = 0x80000000;\njpeg.lossless.Decoder.RESTART_MARKER_BEGIN = 0xFFD0;\njpeg.lossless.Decoder.RESTART_MARKER_END = 0xFFD7;\n\n/*** Prototype Methods ***/\n\njpeg.lossless.Decoder.prototype.decompress = function (buffer, offset, length) {\n    return this.decode(buffer, offset, length).buffer;\n};\n\n\n\njpeg.lossless.Decoder.prototype.decode = function (buffer, offset, length, numBytes) {\n    /*jslint bitwise: true */\n\n    var current, scanNum = 0, pred = [], i, compN, temp = [], index = [], mcuNum;\n\n    if (typeof buffer !== "undefined") {\n        this.buffer = buffer;\n    }\n\n    if (typeof numBytes !== "undefined") {\n        this.numBytes = numBytes;\n    }\n\n    this.stream = new jpeg.lossless.DataStream(this.buffer, offset, length);\n    this.buffer = null;\n\n    this.xLoc = 0;\n    this.yLoc = 0;\n    current = this.stream.get16();\n\n    if (current !== 0xFFD8) { // SOI\n        throw new Error("Not a JPEG file");\n    }\n\n    current = this.stream.get16();\n\n    while ((((current >> 4) !== 0x0FFC) || (current === 0xFFC4))) { // SOF 0~15\n        switch (current) {\n            case 0xFFC4: // DHT\n                this.huffTable.read(this.stream, this.HuffTab);\n                break;\n            case 0xFFCC: // DAC\n                throw new Error("Program doesn\'t support arithmetic coding. (format throw new IOException)");\n            case 0xFFDB:\n                this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);\n                break;\n            case 0xFFDD:\n                this.restartInterval = this.readNumber();\n                break;\n            case 0xFFE0:\n            case 0xFFE1:\n            case 0xFFE2:\n            case 0xFFE3:\n            case 0xFFE4:\n            case 0xFFE5:\n            case 0xFFE6:\n            case 0xFFE7:\n            case 0xFFE8:\n            case 0xFFE9:\n            case 0xFFEA:\n            case 0xFFEB:\n            case 0xFFEC:\n            case 0xFFED:\n            case 0xFFEE:\n            case 0xFFEF:\n                this.readApp();\n                break;\n            case 0xFFFE:\n                this.readComment();\n                break;\n            default:\n                if ((current >> 8) !== 0xFF) {\n                    throw new Error("ERROR: format throw new IOException! (decode)");\n                }\n        }\n\n        current = this.stream.get16();\n    }\n\n    if ((current < 0xFFC0) || (current > 0xFFC7)) {\n        throw new Error("ERROR: could not handle arithmetic code!");\n    }\n\n    this.frame.read(this.stream);\n    current = this.stream.get16();\n\n    do {\n        while (current !== 0x0FFDA) { // SOS\n            switch (current) {\n                case 0xFFC4: // DHT\n                    this.huffTable.read(this.stream, this.HuffTab);\n                    break;\n                case 0xFFCC: // DAC\n                    throw new Error("Program doesn\'t support arithmetic coding. (format throw new IOException)");\n                case 0xFFDB:\n                    this.quantTable.read(this.stream, jpeg.lossless.Decoder.TABLE);\n                    break;\n                case 0xFFDD:\n                    this.restartInterval = this.readNumber();\n                    break;\n                case 0xFFE0:\n                case 0xFFE1:\n                case 0xFFE2:\n                case 0xFFE3:\n                case 0xFFE4:\n                case 0xFFE5:\n                case 0xFFE6:\n                case 0xFFE7:\n                case 0xFFE8:\n                case 0xFFE9:\n                case 0xFFEA:\n                case 0xFFEB:\n                case 0xFFEC:\n                case 0xFFED:\n                case 0xFFEE:\n                case 0xFFEF:\n                    this.readApp();\n                    break;\n                case 0xFFFE:\n                    this.readComment();\n                    break;\n                default:\n                    if ((current >> 8) !== 0xFF) {\n                        throw new Error("ERROR: format throw new IOException! (Parser.decode)");\n                    }\n            }\n\n            current = this.stream.get16();\n        }\n\n        this.precision = this.frame.precision;\n        this.components = this.frame.components;\n\n        if (!this.numBytes) {\n            this.numBytes = parseInt(Math.ceil(this.precision / 8));\n        }\n\n        if (this.numBytes == 1) {\n            this.mask = 0xFF;\n        } else {\n            this.mask = 0xFFFF;\n        }\n\n        this.scan.read(this.stream);\n        this.numComp = this.scan.numComp;\n        this.selection = this.scan.selection;\n\n        if (this.numBytes === 1) {\n            if (this.numComp === 3) {\n                this.getter = this.getValueRGB;\n                this.setter = this.setValueRGB;\n                this.output = this.outputRGB;\n            } else {\n                this.getter = this.getValue8;\n                this.setter = this.setValue8;\n                this.output = this.outputSingle;\n            }\n        } else {\n            this.getter = this.getValue16;\n            this.setter = this.setValue16;\n            this.output = this.outputSingle;\n        }\n\n        switch (this.selection) {\n            case 2:\n                this.selector = this.select2;\n                break;\n            case 3:\n                this.selector = this.select3;\n                break;\n            case 4:\n                this.selector = this.select4;\n                break;\n            case 5:\n                this.selector = this.select5;\n                break;\n            case 6:\n                this.selector = this.select6;\n                break;\n            case 7:\n                this.selector = this.select7;\n                break;\n            default:\n                this.selector = this.select1;\n                break;\n        }\n\n        this.scanComps = this.scan.components;\n        this.quantTables = this.quantTable.quantTables;\n\n        for (i = 0; i < this.numComp; i+=1) {\n            compN = this.scanComps[i].scanCompSel;\n            this.qTab[i] = this.quantTables[this.components[compN].quantTableSel];\n            this.nBlock[i] = this.components[compN].vSamp * this.components[compN].hSamp;\n            this.dcTab[i] = this.HuffTab[this.scanComps[i].dcTabSel][0];\n            this.acTab[i] = this.HuffTab[this.scanComps[i].acTabSel][1];\n        }\n\n        this.xDim = this.frame.dimX;\n        this.yDim = this.frame.dimY;\n        this.outputData = new DataView(new ArrayBuffer(this.xDim * this.yDim * this.numBytes * this.numComp));\n\n        scanNum+=1;\n\n        while (true) { // Decode one scan\n            temp[0] = 0;\n            index[0] = 0;\n\n            for (i = 0; i < 10; i+=1) {\n                pred[i] = (1 << (this.precision - 1));\n            }\n\n            if (this.restartInterval === 0) {\n                current = this.decodeUnit(pred, temp, index);\n\n                while ((current === 0) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim))) {\n                    this.output(pred);\n                    current = this.decodeUnit(pred, temp, index);\n                }\n\n                break; //current=MARKER\n            }\n\n            for (mcuNum = 0; mcuNum < this.restartInterval; mcuNum+=1) {\n                this.restarting = (mcuNum == 0);\n                current = this.decodeUnit(pred, temp, index);\n                this.output(pred);\n\n                if (current !== 0) {\n                    break;\n                }\n            }\n\n            if (current === 0) {\n                if (this.markerIndex !== 0) {\n                    current = (0xFF00 | this.marker);\n                    this.markerIndex = 0;\n                } else {\n                    current = this.stream.get16();\n                }\n            }\n\n            if (!((current >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) &&\n                (current <= jpeg.lossless.Decoder.RESTART_MARKER_END))) {\n                break; //current=MARKER\n            }\n        }\n\n        if ((current === 0xFFDC) && (scanNum === 1)) { //DNL\n            this.readNumber();\n            current = this.stream.get16();\n        }\n    } while ((current !== 0xFFD9) && ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) && (scanNum === 0));\n\n    return this.outputData;\n};\n\n\n\njpeg.lossless.Decoder.prototype.decodeUnit = function (prev, temp, index) {\n    if (this.numComp == 1) {\n        return this.decodeSingle(prev, temp, index);\n    } else if (this.numComp == 3) {\n        return this.decodeRGB(prev, temp, index);\n    } else {\n        return -1;\n    }\n};\n\n\n\njpeg.lossless.Decoder.prototype.select1 = function (compOffset) {\n    return this.getPreviousX(compOffset);\n};\n\n\n\njpeg.lossless.Decoder.prototype.select2 = function (compOffset) {\n    return this.getPreviousY(compOffset);\n};\n\n\n\njpeg.lossless.Decoder.prototype.select3 = function (compOffset) {\n    return this.getPreviousXY(compOffset);\n};\n\n\n\njpeg.lossless.Decoder.prototype.select4 = function (compOffset) {\n    return (this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) - this.getPreviousXY(compOffset);\n};\n\n\n\njpeg.lossless.Decoder.prototype.select5 = function (compOffset) {\n    return this.getPreviousX(compOffset) + ((this.getPreviousY(compOffset) - this.getPreviousXY(compOffset)) >> 1);\n};\n\n\n\njpeg.lossless.Decoder.prototype.select6 = function (compOffset) {\n    return this.getPreviousY(compOffset) + ((this.getPreviousX(compOffset) - this.getPreviousXY(compOffset)) >> 1);\n};\n\n\n\njpeg.lossless.Decoder.prototype.select7 = function (compOffset) {\n    return ((this.getPreviousX(compOffset) + this.getPreviousY(compOffset)) / 2);\n};\n\n\n\njpeg.lossless.Decoder.prototype.decodeRGB = function (prev, temp, index) {\n    /*jslint bitwise: true */\n\n    var value, actab, dctab, qtab, ctrC, i, k, j;\n\n    prev[0] = this.selector(0);\n    prev[1] = this.selector(1);\n    prev[2] = this.selector(2);\n\n    for (ctrC = 0; ctrC < this.numComp; ctrC+=1) {\n        qtab = this.qTab[ctrC];\n        actab = this.acTab[ctrC];\n        dctab = this.dcTab[ctrC];\n        for (i = 0; i < this.nBlock[ctrC]; i+=1) {\n            for (k = 0; k < this.IDCT_Source.length; k+=1) {\n                this.IDCT_Source[k] = 0;\n            }\n\n            value = this.getHuffmanValue(dctab, temp, index);\n\n            if (value >= 0xFF00) {\n                return value;\n            }\n\n            prev[ctrC] = this.IDCT_Source[0] = prev[ctrC] + this.getn(index, value, temp, index);\n            this.IDCT_Source[0] *= qtab[0];\n\n            for (j = 1; j < 64; j+=1) {\n                value = this.getHuffmanValue(actab, temp, index);\n\n                if (value >= 0xFF00) {\n                    return value;\n                }\n\n                j += (value >> 4);\n\n                if ((value & 0x0F) === 0) {\n                    if ((value >> 4) === 0) {\n                        break;\n                    }\n                } else {\n                    this.IDCT_Source[jpeg.lossless.Decoder.IDCT_P[j]] = this.getn(index, value & 0x0F, temp, index) * qtab[j];\n                }\n            }\n        }\n    }\n\n    return 0;\n};\n\n\n\njpeg.lossless.Decoder.prototype.decodeSingle = function (prev, temp, index) {\n    /*jslint bitwise: true */\n\n    var value, i, n, nRestart;\n\n    if (this.restarting) {\n        this.restarting = false;\n        prev[0] = (1 << (this.frame.precision - 1));\n    } else {\n        prev[0] = this.selector();\n    }\n\n    for (i = 0; i < this.nBlock[0]; i+=1) {\n        value = this.getHuffmanValue(this.dcTab[0], temp, index);\n        if (value >= 0xFF00) {\n            return value;\n        }\n\n        n = this.getn(prev, value, temp, index);\n        nRestart = (n >> 8);\n\n        if ((nRestart >= jpeg.lossless.Decoder.RESTART_MARKER_BEGIN) && (nRestart <= jpeg.lossless.Decoder.RESTART_MARKER_END)) {\n            return nRestart;\n        }\n\n        prev[0] += n;\n    }\n\n    return 0;\n};\n\n\n\n//\tHuffman table for fast search: (HuffTab) 8-bit Look up table 2-layer search architecture, 1st-layer represent 256 node (8 bits) if codeword-length > 8\n//\tbits, then the entry of 1st-layer = (# of 2nd-layer table) | MSB and it is stored in the 2nd-layer Size of tables in each layer are 256.\n//\tHuffTab[*][*][0-256] is always the only 1st-layer table.\n//\n//\tAn entry can be: (1) (# of 2nd-layer table) | MSB , for code length > 8 in 1st-layer (2) (Code length) << 8 | HuffVal\n//\n//\tHuffmanValue(table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)\n//\t                ):\n//\t    return: Huffman Value of table\n//\t            0xFF?? if it receives a MARKER\n//\t    Parameter:  table   HuffTab[x][y] (ex) HuffmanValue(HuffTab[1][0],...)\n//\t                temp    temp storage for remainded bits\n//\t                index   index to bit of temp\n//\t                in      FILE pointer\n//\t    Effect:\n//\t        temp  store new remainded bits\n//\t        index change to new index\n//\t        in    change to new position\n//\t    NOTE:\n//\t      Initial by   temp=0; index=0;\n//\t    NOTE: (explain temp and index)\n//\t      temp: is always in the form at calling time or returning time\n//\t       |  byte 4  |  byte 3  |  byte 2  |  byte 1  |\n//\t       |     0    |     0    | 00000000 | 00000??? |  if not a MARKER\n//\t                                               ^index=3 (from 0 to 15)\n//\t                                               321\n//\t    NOTE (marker and marker_index):\n//\t      If get a MARKER from \'in\', marker=the low-byte of the MARKER\n//\t        and marker_index=9\n//\t      If marker_index=9 then index is always > 8, or HuffmanValue()\n//\t        will not be called\njpeg.lossless.Decoder.prototype.getHuffmanValue = function (table, temp, index) {\n    /*jslint bitwise: true */\n\n    var code, input, mask;\n    mask = 0xFFFF;\n\n    if (index[0] < 8) {\n        temp[0] <<= 8;\n        input = this.stream.get8();\n        if (input === 0xFF) {\n            this.marker = this.stream.get8();\n            if (this.marker !== 0) {\n                this.markerIndex = 9;\n            }\n        }\n        temp[0] |= input;\n    } else {\n        index[0] -= 8;\n    }\n\n    code = table[temp[0] >> index[0]];\n\n    if ((code & jpeg.lossless.Decoder.MSB) !== 0) {\n        if (this.markerIndex !== 0) {\n            this.markerIndex = 0;\n            return 0xFF00 | this.marker;\n        }\n\n        temp[0] &= (mask >> (16 - index[0]));\n        temp[0] <<= 8;\n        input = this.stream.get8();\n\n        if (input === 0xFF) {\n            this.marker = this.stream.get8();\n            if (this.marker !== 0) {\n                this.markerIndex = 9;\n            }\n        }\n\n        temp[0] |= input;\n        code = table[((code & 0xFF) * 256) + (temp[0] >> index[0])];\n        index[0] += 8;\n    }\n\n    index[0] += 8 - (code >> 8);\n\n    if (index[0] < 0) {\n        throw new Error("index=" + index[0] + " temp=" + temp[0] + " code=" + code + " in HuffmanValue()");\n    }\n\n    if (index[0] < this.markerIndex) {\n        this.markerIndex = 0;\n        return 0xFF00 | this.marker;\n    }\n\n    temp[0] &= (mask >> (16 - index[0]));\n    return code & 0xFF;\n};\n\n\n\njpeg.lossless.Decoder.prototype.getn = function (PRED, n, temp, index) {\n    /*jslint bitwise: true */\n\n    var result, one, n_one, mask, input;\n    one = 1;\n    n_one = -1;\n    mask = 0xFFFF;\n\n    if (n === 0) {\n        return 0;\n    }\n\n    if (n === 16) {\n        if (PRED[0] >= 0) {\n            return -32768;\n        } else {\n            return 32768;\n        }\n    }\n\n    index[0] -= n;\n\n    if (index[0] >= 0) {\n        if ((index[0] < this.markerIndex) && !this.isLastPixel()) { // this was corrupting the last pixel in some cases\n            this.markerIndex = 0;\n            return (0xFF00 | this.marker) << 8;\n        }\n\n        result = temp[0] >> index[0];\n        temp[0] &= (mask >> (16 - index[0]));\n    } else {\n        temp[0] <<= 8;\n        input = this.stream.get8();\n\n        if (input === 0xFF) {\n            this.marker = this.stream.get8();\n            if (this.marker !== 0) {\n                this.markerIndex = 9;\n            }\n        }\n\n        temp[0] |= input;\n        index[0] += 8;\n\n        if (index[0] < 0) {\n            if (this.markerIndex !== 0) {\n                this.markerIndex = 0;\n                return (0xFF00 | this.marker) << 8;\n            }\n\n            temp[0] <<= 8;\n            input = this.stream.get8();\n\n            if (input === 0xFF) {\n                this.marker = this.stream.get8();\n                if (this.marker !== 0) {\n                    this.markerIndex = 9;\n                }\n            }\n\n            temp[0] |= input;\n            index[0] += 8;\n        }\n\n        if (index[0] < 0) {\n            throw new Error("index=" + index[0] + " in getn()");\n        }\n\n        if (index[0] < this.markerIndex) {\n            this.markerIndex = 0;\n            return (0xFF00 | this.marker) << 8;\n        }\n\n        result = temp[0] >> index[0];\n        temp[0] &= (mask >> (16 - index[0]));\n    }\n\n    if (result < (one << (n - 1))) {\n        result += (n_one << n) + 1;\n    }\n\n    return result;\n};\n\n\n\njpeg.lossless.Decoder.prototype.getPreviousX = function (compOffset) {\n    /*jslint bitwise: true */\n\n    if (this.xLoc > 0) {\n        return this.getter((((this.yLoc * this.xDim) + this.xLoc) - 1), compOffset);\n    } else if (this.yLoc > 0) {\n        return this.getPreviousY(compOffset);\n    } else {\n        return (1 << (this.frame.precision - 1));\n    }\n};\n\n\n\njpeg.lossless.Decoder.prototype.getPreviousXY = function (compOffset) {\n    /*jslint bitwise: true */\n\n    if ((this.xLoc > 0) && (this.yLoc > 0)) {\n        return this.getter(((((this.yLoc - 1) * this.xDim) + this.xLoc) - 1), compOffset);\n    } else {\n        return this.getPreviousY(compOffset);\n    }\n};\n\n\n\njpeg.lossless.Decoder.prototype.getPreviousY = function (compOffset) {\n    /*jslint bitwise: true */\n\n    if (this.yLoc > 0) {\n        return this.getter((((this.yLoc - 1) * this.xDim) + this.xLoc), compOffset);\n    } else {\n        return this.getPreviousX(compOffset);\n    }\n};\n\n\n\njpeg.lossless.Decoder.prototype.isLastPixel = function () {\n    return (this.xLoc === (this.xDim - 1)) && (this.yLoc === (this.yDim - 1));\n};\n\n\n\njpeg.lossless.Decoder.prototype.outputSingle = function (PRED) {\n    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {\n        this.setter((((this.yLoc * this.xDim) + this.xLoc)), this.mask & PRED[0]);\n\n        this.xLoc+=1;\n\n        if (this.xLoc >= this.xDim) {\n            this.yLoc+=1;\n            this.xLoc = 0;\n        }\n    }\n};\n\n\n\njpeg.lossless.Decoder.prototype.outputRGB = function (PRED) {\n    var offset = ((this.yLoc * this.xDim) + this.xLoc);\n\n    if ((this.xLoc < this.xDim) && (this.yLoc < this.yDim)) {\n        this.setter(offset, PRED[0], 0);\n        this.setter(offset, PRED[1], 1);\n        this.setter(offset, PRED[2], 2);\n\n        this.xLoc+=1;\n\n        if (this.xLoc >= this.xDim) {\n            this.yLoc+=1;\n            this.xLoc = 0;\n        }\n    }\n};\n\n\n\njpeg.lossless.Decoder.prototype.setValue16 = function (index, val) {\n    this.outputData.setInt16(index * 2, val, true);\n};\n\n\n\njpeg.lossless.Decoder.prototype.getValue16 = function (index) {\n    return this.outputData.getInt16(index * 2, true) & this.mask;\n};\n\n\n\njpeg.lossless.Decoder.prototype.setValue8 = function (index, val) {\n    this.outputData.setInt8(index, val);\n};\n\n\n\njpeg.lossless.Decoder.prototype.getValue8 = function (index) {\n    return this.outputData.getInt8(index) & this.mask;\n};\n\n\n\njpeg.lossless.Decoder.prototype.setValueRGB = function (index, val, compOffset) {\n    this.outputData.setUint8(index * 3 + compOffset, val);\n};\n\n\n\njpeg.lossless.Decoder.prototype.getValueRGB = function (index, compOffset) {\n    return this.outputData.getUint8(index * 3 + compOffset);\n};\n\n\n\njpeg.lossless.Decoder.prototype.readApp = function() {\n    var count = 0, length = this.stream.get16();\n    count += 2;\n\n    while (count < length) {\n        this.stream.get8();\n        count+=1;\n    }\n\n    return length;\n};\n\n\n\njpeg.lossless.Decoder.prototype.readComment = function () {\n    var sb = "", count = 0, length;\n\n    length = this.stream.get16();\n    count += 2;\n\n    while (count < length) {\n        sb += this.stream.get8();\n        count+=1;\n    }\n\n    return sb;\n};\n\n\n\njpeg.lossless.Decoder.prototype.readNumber = function() {\n    var Ld = this.stream.get16();\n\n    if (Ld !== 4) {\n        throw new Error("ERROR: Define number format throw new IOException [Ld!=4]");\n    }\n\n    return this.stream.get16();\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg.lossless.Decoder;\n}\n\n},{"./data-stream.js":4,"./frame-header.js":6,"./huffman-table.js":7,"./quantization-table.js":9,"./scan-header.js":11,"./utils.js":12}],6:[function(require,module,exports){\n/*\n * Copyright (C) 2015 Michael Martinez\n * Changes: Added support for selection values 2-7, fixed minor bugs &\n * warnings, split into multiple class files, and general clean up.\n *\n * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.\n */\n\n/*\n * Copyright (C) Helmut Dersch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\njpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== \'undefined\') ? require(\'./component-spec.js\') : null);\njpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== \'undefined\') ? require(\'./data-stream.js\') : null);\n\n\n/*** Constructor ***/\njpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || function () {\n    this.components = []; // Components\n    this.dimX = 0; // Number of samples per line\n    this.dimY = 0; // Number of lines\n    this.numComp = 0; // Number of component in the frame\n    this.precision = 0; // Sample Precision (from the original image)\n};\n\n\n\n/*** Prototype Methods ***/\n\njpeg.lossless.FrameHeader.prototype.read = function (data) {\n    /*jslint bitwise: true */\n\n    var count = 0, length, i, c, temp;\n\n    length = data.get16();\n    count += 2;\n\n    this.precision = data.get8();\n    count+=1;\n\n    this.dimY = data.get16();\n    count += 2;\n\n    this.dimX = data.get16();\n    count += 2;\n\n    this.numComp = data.get8();\n    count+=1;\n    for (i = 1; i <= this.numComp; i+=1) {\n        if (count > length) {\n            throw new Error("ERROR: frame format error");\n        }\n\n        c = data.get8();\n        count+=1;\n\n        if (count >= length) {\n            throw new Error("ERROR: frame format error [c>=Lf]");\n        }\n\n        temp = data.get8();\n        count+=1;\n\n        if (!this.components[c]) {\n            this.components[c] = new jpeg.lossless.ComponentSpec();\n        }\n\n        this.components[c].hSamp = temp >> 4;\n        this.components[c].vSamp = temp & 0x0F;\n        this.components[c].quantTableSel = data.get8();\n        count+=1;\n    }\n\n    if (count !== length) {\n        throw new Error("ERROR: frame format error [Lf!=count]");\n    }\n\n    return 1;\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg.lossless.FrameHeader;\n}\n\n},{"./component-spec.js":3,"./data-stream.js":4}],7:[function(require,module,exports){\n/*\n * Copyright (C) 2015 Michael Martinez\n * Changes: Added support for selection values 2-7, fixed minor bugs &\n * warnings, split into multiple class files, and general clean up.\n *\n * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.\n */\n\n/*\n * Copyright (C) Helmut Dersch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\njpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== \'undefined\') ? require(\'./data-stream.js\') : null);\njpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== \'undefined\') ? require(\'./utils.js\') : null);\n\n\n/*** Constructor ***/\njpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || function () {\n    this.l = jpeg.lossless.Utils.createArray(4, 2, 16);\n    this.th = [];\n    this.v = jpeg.lossless.Utils.createArray(4, 2, 16, 200);\n    this.tc = jpeg.lossless.Utils.createArray(4, 2);\n\n    this.tc[0][0] = 0;\n    this.tc[1][0] = 0;\n    this.tc[2][0] = 0;\n    this.tc[3][0] = 0;\n    this.tc[0][1] = 0;\n    this.tc[1][1] = 0;\n    this.tc[2][1] = 0;\n    this.tc[3][1] = 0;\n    this.th[0] = 0;\n    this.th[1] = 0;\n    this.th[2] = 0;\n    this.th[3] = 0;\n};\n\n\n\n/*** Static Pseudo-constants ***/\n\njpeg.lossless.HuffmanTable.MSB = 0x80000000;\n\n\n/*** Prototype Methods ***/\n\njpeg.lossless.HuffmanTable.prototype.read = function(data, HuffTab) {\n    /*jslint bitwise: true */\n\n    var count = 0, length, temp, t, c, i, j;\n\n    length = data.get16();\n    count += 2;\n\n    while (count < length) {\n        temp = data.get8();\n        count+=1;\n        t = temp & 0x0F;\n        if (t > 3) {\n            throw new Error("ERROR: Huffman table ID > 3");\n        }\n\n        c = temp >> 4;\n        if (c > 2) {\n            throw new Error("ERROR: Huffman table [Table class > 2 ]");\n        }\n\n        this.th[t] = 1;\n        this.tc[t][c] = 1;\n\n        for (i = 0; i < 16; i+=1) {\n            this.l[t][c][i] = data.get8();\n            count+=1;\n        }\n\n        for (i = 0; i < 16; i+=1) {\n            for (j = 0; j < this.l[t][c][i]; j+=1) {\n                if (count > length) {\n                    throw new Error("ERROR: Huffman table format error [count>Lh]");\n                }\n\n                this.v[t][c][i][j] = data.get8();\n                count+=1;\n            }\n        }\n    }\n\n    if (count !== length) {\n        throw new Error("ERROR: Huffman table format error [count!=Lf]");\n    }\n\n    for (i = 0; i < 4; i+=1) {\n        for (j = 0; j < 2; j+=1) {\n            if (this.tc[i][j] !== 0) {\n                this.buildHuffTable(HuffTab[i][j], this.l[i][j], this.v[i][j]);\n            }\n        }\n    }\n\n    return 1;\n};\n\n\n\n//\tBuild_HuffTab()\n//\tParameter:  t       table ID\n//\t            c       table class ( 0 for DC, 1 for AC )\n//\t            L[i]    # of codewords which length is i\n//\t            V[i][j] Huffman Value (length=i)\n//\tEffect:\n//\t    build up HuffTab[t][c] using L and V.\njpeg.lossless.HuffmanTable.prototype.buildHuffTable = function(tab, L, V) {\n    /*jslint bitwise: true */\n\n    var currentTable, temp, k, i, j, n;\n    temp = 256;\n    k = 0;\n\n    for (i = 0; i < 8; i+=1) { // i+1 is Code length\n        for (j = 0; j < L[i]; j+=1) {\n            for (n = 0; n < (temp >> (i + 1)); n+=1) {\n                tab[k] = V[i][j] | ((i + 1) << 8);\n                k+=1;\n            }\n        }\n    }\n\n    for (i = 1; k < 256; i+=1, k+=1) {\n        tab[k] = i | jpeg.lossless.HuffmanTable.MSB;\n    }\n\n    currentTable = 1;\n    k = 0;\n\n    for (i = 8; i < 16; i+=1) { // i+1 is Code length\n        for (j = 0; j < L[i]; j+=1) {\n            for (n = 0; n < (temp >> (i - 7)); n+=1) {\n                tab[(currentTable * 256) + k] = V[i][j] | ((i + 1) << 8);\n                k+=1;\n            }\n\n            if (k >= 256) {\n                if (k > 256) {\n                    throw new Error("ERROR: Huffman table error(1)!");\n                }\n\n                k = 0;\n                currentTable+=1;\n            }\n        }\n    }\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg.lossless.HuffmanTable;\n}\n\n},{"./data-stream.js":4,"./utils.js":12}],8:[function(require,module,exports){\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ****/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\njpeg.lossless.ComponentSpec = jpeg.lossless.ComponentSpec || ((typeof require !== \'undefined\') ? require(\'./component-spec.js\') : null);\njpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== \'undefined\') ? require(\'./data-stream.js\') : null);\njpeg.lossless.Decoder = jpeg.lossless.Decoder || ((typeof require !== \'undefined\') ? require(\'./decoder.js\') : null);\njpeg.lossless.FrameHeader = jpeg.lossless.FrameHeader || ((typeof require !== \'undefined\') ? require(\'./frame-header.js\') : null);\njpeg.lossless.HuffmanTable = jpeg.lossless.HuffmanTable || ((typeof require !== \'undefined\') ? require(\'./huffman-table.js\') : null);\njpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || ((typeof require !== \'undefined\') ? require(\'./quantization-table.js\') : null);\njpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== \'undefined\') ? require(\'./scan-component.js\') : null);\njpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || ((typeof require !== \'undefined\') ? require(\'./scan-header.js\') : null);\njpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== \'undefined\') ? require(\'./utils.js\') : null);\n\n\n/*** Exports ***/\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg;\n}\n\n},{"./component-spec.js":3,"./data-stream.js":4,"./decoder.js":5,"./frame-header.js":6,"./huffman-table.js":7,"./quantization-table.js":9,"./scan-component.js":10,"./scan-header.js":11,"./utils.js":12}],9:[function(require,module,exports){\n/*\n * Copyright (C) 2015 Michael Martinez\n * Changes: Added support for selection values 2-7, fixed minor bugs &\n * warnings, split into multiple class files, and general clean up.\n *\n * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.\n */\n\n/*\n * Copyright (C) Helmut Dersch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\njpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== \'undefined\') ? require(\'./data-stream.js\') : null);\njpeg.lossless.Utils = jpeg.lossless.Utils || ((typeof require !== \'undefined\') ? require(\'./utils.js\') : null);\n\n\n/*** Constructor ***/\njpeg.lossless.QuantizationTable = jpeg.lossless.QuantizationTable || function () {\n    this.precision = []; // Quantization precision 8 or 16\n    this.tq = []; // 1: this table is presented\n    this.quantTables = jpeg.lossless.Utils.createArray(4, 64); // Tables\n\n    this.tq[0] = 0;\n    this.tq[1] = 0;\n    this.tq[2] = 0;\n    this.tq[3] = 0;\n};\n\n\n\n/*** Static Methods ***/\n\njpeg.lossless.QuantizationTable.enhanceQuantizationTable = function(qtab, table) {\n    /*jslint bitwise: true */\n\n    var i;\n\n    for (i = 0; i < 8; i+=1) {\n        qtab[table[(0 * 8) + i]] *= 90;\n        qtab[table[(4 * 8) + i]] *= 90;\n        qtab[table[(2 * 8) + i]] *= 118;\n        qtab[table[(6 * 8) + i]] *= 49;\n        qtab[table[(5 * 8) + i]] *= 71;\n        qtab[table[(1 * 8) + i]] *= 126;\n        qtab[table[(7 * 8) + i]] *= 25;\n        qtab[table[(3 * 8) + i]] *= 106;\n    }\n\n    for (i = 0; i < 8; i+=1) {\n        qtab[table[0 + (8 * i)]] *= 90;\n        qtab[table[4 + (8 * i)]] *= 90;\n        qtab[table[2 + (8 * i)]] *= 118;\n        qtab[table[6 + (8 * i)]] *= 49;\n        qtab[table[5 + (8 * i)]] *= 71;\n        qtab[table[1 + (8 * i)]] *= 126;\n        qtab[table[7 + (8 * i)]] *= 25;\n        qtab[table[3 + (8 * i)]] *= 106;\n    }\n\n    for (i = 0; i < 64; i+=1) {\n        qtab[i] >>= 6;\n    }\n};\n\n\n/*** Prototype Methods ***/\n\njpeg.lossless.QuantizationTable.prototype.read = function (data, table) {\n    /*jslint bitwise: true */\n\n    var count = 0, length, temp, t, i;\n\n    length = data.get16();\n    count += 2;\n\n    while (count < length) {\n        temp = data.get8();\n        count+=1;\n        t = temp & 0x0F;\n\n        if (t > 3) {\n            throw new Error("ERROR: Quantization table ID > 3");\n        }\n\n        this.precision[t] = temp >> 4;\n\n        if (this.precision[t] === 0) {\n            this.precision[t] = 8;\n        } else if (this.precision[t] === 1) {\n            this.precision[t] = 16;\n        } else {\n            throw new Error("ERROR: Quantization table precision error");\n        }\n\n        this.tq[t] = 1;\n\n        if (this.precision[t] === 8) {\n            for (i = 0; i < 64; i+=1) {\n                if (count > length) {\n                    throw new Error("ERROR: Quantization table format error");\n                }\n\n                this.quantTables[t][i] = data.get8();\n                count+=1;\n            }\n\n            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);\n        } else {\n            for (i = 0; i < 64; i+=1) {\n                if (count > length) {\n                    throw new Error("ERROR: Quantization table format error");\n                }\n\n                this.quantTables[t][i] = data.get16();\n                count += 2;\n            }\n\n            jpeg.lossless.QuantizationTable.enhanceQuantizationTable(this.quantTables[t], table);\n        }\n    }\n\n    if (count !== length) {\n        throw new Error("ERROR: Quantization table error [count!=Lq]");\n    }\n\n    return 1;\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg.lossless.QuantizationTable;\n}\n\n},{"./data-stream.js":4,"./utils.js":12}],10:[function(require,module,exports){\n/*\n * Copyright (C) 2015 Michael Martinez\n * Changes: Added support for selection values 2-7, fixed minor bugs &\n * warnings, split into multiple class files, and general clean up.\n *\n * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.\n */\n\n/*\n * Copyright (C) Helmut Dersch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\n\n\n/*** Constructor ***/\njpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || function () {\n    this.acTabSel = 0; // AC table selector\n    this.dcTabSel = 0; // DC table selector\n    this.scanCompSel = 0; // Scan component selector\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg.lossless.ScanComponent;\n}\n\n},{}],11:[function(require,module,exports){\n/*\n * Copyright (C) 2015 Michael Martinez\n * Changes: Added support for selection values 2-7, fixed minor bugs &\n * warnings, split into multiple class files, and general clean up.\n *\n * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.\n */\n\n/*\n * Copyright (C) Helmut Dersch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\njpeg.lossless.DataStream = jpeg.lossless.DataStream || ((typeof require !== \'undefined\') ? require(\'./data-stream.js\') : null);\njpeg.lossless.ScanComponent = jpeg.lossless.ScanComponent || ((typeof require !== \'undefined\') ? require(\'./scan-component.js\') : null);\n\n\n/*** Constructor ***/\njpeg.lossless.ScanHeader = jpeg.lossless.ScanHeader || function () {\n    this.ah = 0;\n    this.al = 0;\n    this.numComp = 0; // Number of components in the scan\n    this.selection = 0; // Start of spectral or predictor selection\n    this.spectralEnd = 0; // End of spectral selection\n    this.components = [];\n};\n\n\n/*** Prototype Methods ***/\n\njpeg.lossless.ScanHeader.prototype.read = function(data) {\n    /*jslint bitwise: true */\n\n    var count = 0, length, i, temp;\n\n    length = data.get16();\n    count += 2;\n\n    this.numComp = data.get8();\n    count+=1;\n\n    for (i = 0; i < this.numComp; i+=1) {\n        this.components[i] = new jpeg.lossless.ScanComponent();\n\n        if (count > length) {\n            throw new Error("ERROR: scan header format error");\n        }\n\n        this.components[i].scanCompSel = data.get8();\n        count+=1;\n\n        temp = data.get8();\n        count+=1;\n\n        this.components[i].dcTabSel = (temp >> 4);\n        this.components[i].acTabSel = (temp & 0x0F);\n    }\n\n    this.selection = data.get8();\n    count+=1;\n\n    this.spectralEnd = data.get8();\n    count+=1;\n\n    temp = data.get8();\n    this.ah = (temp >> 4);\n    this.al = (temp & 0x0F);\n    count+=1;\n\n    if (count !== length) {\n        throw new Error("ERROR: scan header format error [count!=Ns]");\n    }\n\n    return 1;\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg.lossless.ScanHeader;\n}\n\n},{"./data-stream.js":4,"./scan-component.js":10}],12:[function(require,module,exports){\n/*\n * Copyright (C) 2015 Michael Martinez\n * Changes: Added support for selection values 2-7, fixed minor bugs &\n * warnings, split into multiple class files, and general clean up.\n *\n * 08-25-2015: Helmut Dersch agreed to a license change from LGPL to MIT.\n */\n\n/*\n * Copyright (C) Helmut Dersch\n *\n * Permission is hereby granted, free of charge, to any person obtaining a copy\n * of this software and associated documentation files (the "Software"), to deal\n * in the Software without restriction, including without limitation the rights\n * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n * copies of the Software, and to permit persons to whom the Software is\n * furnished to do so, subject to the following conditions:\n\n * The above copyright notice and this permission notice shall be included in\n * all copies or substantial portions of the Software.\n\n * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n * THE SOFTWARE.\n */\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\n\n\n/*** Constructor ***/\njpeg.lossless.Utils = jpeg.lossless.Utils || {};\n\n\n/*** Static methods ***/\n\n// http://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript\njpeg.lossless.Utils.createArray = function (length) {\n    var arr = new Array(length || 0),\n        i = length;\n\n    if (arguments.length > 1) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        while(i--) arr[length-1 - i] = jpeg.lossless.Utils.createArray.apply(this, args);\n    }\n\n    return arr;\n};\n\n\n// http://stackoverflow.com/questions/18638900/javascript-crc32\njpeg.lossless.Utils.makeCRCTable = function(){\n    var c;\n    var crcTable = [];\n    for(var n =0; n < 256; n++){\n        c = n;\n        for(var k =0; k < 8; k++){\n            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n        }\n        crcTable[n] = c;\n    }\n    return crcTable;\n};\n\njpeg.lossless.Utils.crc32 = function(dataView) {\n    var crcTable = jpeg.lossless.Utils.crcTable || (jpeg.lossless.Utils.crcTable = jpeg.lossless.Utils.makeCRCTable());\n    var crc = 0 ^ (-1);\n\n    for (var i = 0; i < dataView.byteLength; i++ ) {\n        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];\n    }\n\n    return (crc ^ (-1)) >>> 0;\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = jpeg.lossless.Utils;\n}\n\n},{}],13:[function(require,module,exports){\n// Top level file is just a mixin of submodules & constants\n\'use strict\';\n\nvar assign    = require(\'./lib/utils/common\').assign;\n\nvar deflate   = require(\'./lib/deflate\');\nvar inflate   = require(\'./lib/inflate\');\nvar constants = require(\'./lib/zlib/constants\');\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n},{"./lib/deflate":14,"./lib/inflate":15,"./lib/utils/common":16,"./lib/zlib/constants":19}],14:[function(require,module,exports){\n\'use strict\';\n\n\nvar zlib_deflate = require(\'./zlib/deflate.js\');\nvar utils = require(\'./utils/common\');\nvar strings = require(\'./utils/strings\');\nvar msg = require(\'./zlib/messages\');\nvar zstream = require(\'./zlib/zstream\');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don\'t need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overriden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to \'string\', then result will be "binary string"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require(\'pako\')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nvar Deflate = function(options) {\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: \'\'\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = \'\';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new zstream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n};\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don\'t skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function(data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === \'string\') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === \'[object ArrayBuffer]\') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === \'string\') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function(chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function(status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === \'string\') {\n      this.result = this.chunks.join(\'\');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate alrorythm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don\'t wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to \'string\', then result will be "binary string"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require(\'pako\')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don\'t cheat with options :)\n  if (deflator.err) { throw deflator.msg; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n},{"./utils/common":16,"./utils/strings":17,"./zlib/deflate.js":21,"./zlib/messages":26,"./zlib/zstream":28}],15:[function(require,module,exports){\n\'use strict\';\n\n\nvar zlib_inflate = require(\'./zlib/inflate.js\');\nvar utils = require(\'./utils/common\');\nvar strings = require(\'./utils/strings\');\nvar c = require(\'./zlib/constants\');\nvar msg = require(\'./zlib/messages\');\nvar zstream = require(\'./zlib/zstream\');\nvar gzheader = require(\'./zlib/gzheader\');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don\'t need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overriden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to \'string\', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require(\'pako\')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nvar Inflate = function(options) {\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: \'\'\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = \'\';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new zstream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new gzheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n};\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don\'t skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function(data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === \'string\') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === \'[object ArrayBuffer]\') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === \'string\') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function(chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function(status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === \'string\') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 alligned strings to onData\n      this.result = this.chunks.join(\'\');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That\'s why we don\'t provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don\'t wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to \'string\', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require(\'pako\')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don\'t cheat with options :)\n  if (inflator.err) { throw inflator.msg; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n},{"./utils/common":16,"./utils/strings":17,"./zlib/constants":19,"./zlib/gzheader":22,"./zlib/inflate.js":24,"./zlib/messages":26,"./zlib/zstream":28}],16:[function(require,module,exports){\n\'use strict\';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== \'undefined\') &&\n                (typeof Uint16Array !== \'undefined\') &&\n                (typeof Int32Array !== \'undefined\');\n\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== \'object\') {\n      throw new TypeError(source + \'must be non-object\');\n    }\n\n    for (var p in source) {\n      if (source.hasOwnProperty(p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs+len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i=0; i<len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function(chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i=0, l=chunks.length; i<l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i=0, l=chunks.length; i<l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i=0; i<len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function(chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n},{}],17:[function(require,module,exports){\n// String encode/decode helpers\n\'use strict\';\n\n\nvar utils = require(\'./common\');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safary\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [0]); } catch(__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch(__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q=0; q<256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254]=_utf8len[254]=1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n      c2 = str.charCodeAt(m_pos+1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i=0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos+1 < str_len)) {\n      c2 = str.charCodeAt(m_pos+1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = \'\';\n  for (var i=0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function(buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function(str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i=0, len=buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len*2);\n\n  for (out=0, i=0; i<len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len-1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that\'s not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function(buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max-1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n},{"./common":16}],18:[function(require,module,exports){\n\'use strict\';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It doesn\'t worth to make additional optimizationa as in original.\n// Small size is preferable.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n},{}],19:[function(require,module,exports){\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n},{}],20:[function(require,module,exports){\n\'use strict\';\n\n// Note: we can\'t get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n =0; n < 256; n++) {\n    c = n;\n    for (var k =0; k < 8; k++) {\n      c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc = crc ^ (-1);\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n},{}],21:[function(require,module,exports){\n\'use strict\';\n\nvar utils   = require(\'../utils/common\');\nvar trees   = require(\'./trees\');\nvar adler32 = require(\'./adler32\');\nvar crc32   = require(\'./crc32\');\nvar msg   = require(\'./messages\');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2*L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don\'t detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only (s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, "Code too clever");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, "need lookahead");\n\n  do {\n    // Assert(cur_match < s->strstart, "no future");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, "match[2]?");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), "wild scan");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, "already enough lookahead");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don\'t care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, "more < 2");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH-1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    "not enough room for search");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, "slide too late");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error("slide too late");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, "block gone");\n//    if (s.block_start < 0) throw new Error("block gone");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,"%c", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH-1)) ? s.strstart : MIN_MATCH-1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH-1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size-MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH-1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1- s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length-1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH-1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,"%c", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, "no flush?");\n  if (s.match_available) {\n    //Tracevv((stderr,"%c", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart-1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH-1 ? s.strstart : MIN_MATCH-1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), "wild scan");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,"%c", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,"%c", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nvar Config = function (good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n};\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the "longest match" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That\'s alias to max_lazy_match, don\'t use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn\'t use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2*D_CODES+1) * 2);\n  this.bl_tree    = new utils.Buf16((2*BL_CODES+1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS+1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2*L_CODES+1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2*L_CODES+1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can\'t count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don\'t need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  s.d_buf = s.lit_bufsize >> 1;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won\'t be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don\'t have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, "bug2");\n  //if (strm.avail_out <= 0) { throw new Error("bug2");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n/* =========================================================================\n * Copy the source state to the destination state\n */\n//function deflateCopy(dest, source) {\n//\n//}\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateInfo = \'pako deflate (from Nodeca project)\';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n},{"../utils/common":16,"./adler32":18,"./crc32":20,"./messages":26,"./trees":27}],22:[function(require,module,exports){\n\'use strict\';\n\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don\'t need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = \'\';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = \'\';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n},{}],23:[function(require,module,exports){\n\'use strict\';\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()\'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        "inflate:         literal \'%c\'\\n" :\n        //        "inflate:         literal 0x%02x\\n", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, "inflate:         length %u\\n", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = \'invalid distance too far back\';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, "inflate:         distance %u\\n", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = \'invalid distance too far back\';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don\'t enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n              from = _out - dist;          /* copy direct from output */\n              do {                        /* minimum length is three */\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                output[_out++] = output[from++];\n                len -= 3;\n              } while (len > 2);\n              if (len) {\n                output[_out++] = output[from++];\n                if (len > 1) {\n                  output[_out++] = output[from++];\n                }\n              }\n            }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = \'invalid distance code\';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via "continue"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, "inflate:         end of block\\n"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = \'invalid literal/length code\';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via "continue"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won\'t go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n},{}],24:[function(require,module,exports){\n\'use strict\';\n\n\nvar utils = require(\'../utils/common\');\nvar adler32 = require(\'./adler32\');\nvar crc32   = require(\'./crc32\');\nvar inflate_fast = require(\'./inffast\');\nvar inflate_table = require(\'./inftrees\');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction ZSWAP32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in "in" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don\'t have pointers in js, we use lencode and distcode directly\n   as buffers so we don\'t need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = \'\'; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, "inflate: reset\\n"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, "inflate: allocated\\n"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it\'s called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, {bits: 9});\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, {bits: 5});\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor\'s data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn\'t been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window,src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window,src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window,src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked "here" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked "last" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n    case HEAD:\n      if (state.wrap === 0) {\n        state.mode = TYPEDO;\n        break;\n      }\n      //=== NEEDBITS(16);\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n        state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = FLAGS;\n        break;\n      }\n      state.flags = 0;           /* expect zlib header */\n      if (state.head) {\n        state.head.done = false;\n      }\n      if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n        strm.msg = \'incorrect header check\';\n        state.mode = BAD;\n        break;\n      }\n      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n        strm.msg = \'unknown compression method\';\n        state.mode = BAD;\n        break;\n      }\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n      len = (hold & 0x0f)/*BITS(4)*/ + 8;\n      if (state.wbits === 0) {\n        state.wbits = len;\n      }\n      else if (len > state.wbits) {\n        strm.msg = \'invalid window size\';\n        state.mode = BAD;\n        break;\n      }\n      state.dmax = 1 << len;\n      //Tracev((stderr, "inflate:   zlib header ok\\n"));\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = hold & 0x200 ? DICTID : TYPE;\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      break;\n    case FLAGS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.flags = hold;\n      if ((state.flags & 0xff) !== Z_DEFLATED) {\n        strm.msg = \'unknown compression method\';\n        state.mode = BAD;\n        break;\n      }\n      if (state.flags & 0xe000) {\n        strm.msg = \'unknown header flags set\';\n        state.mode = BAD;\n        break;\n      }\n      if (state.head) {\n        state.head.text = ((hold >> 8) & 1);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = TIME;\n      /* falls through */\n    case TIME:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.time = hold;\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC4(state.check, hold)\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        hbuf[2] = (hold >>> 16) & 0xff;\n        hbuf[3] = (hold >>> 24) & 0xff;\n        state.check = crc32(state.check, hbuf, 4, 0);\n        //===\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = OS;\n      /* falls through */\n    case OS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.xflags = (hold & 0xff);\n        state.head.os = (hold >> 8);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = EXLEN;\n      /* falls through */\n    case EXLEN:\n      if (state.flags & 0x0400) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length = hold;\n        if (state.head) {\n          state.head.extra_len = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      else if (state.head) {\n        state.head.extra = null/*Z_NULL*/;\n      }\n      state.mode = EXTRA;\n      /* falls through */\n    case EXTRA:\n      if (state.flags & 0x0400) {\n        copy = state.length;\n        if (copy > have) { copy = have; }\n        if (copy) {\n          if (state.head) {\n            len = state.head.extra_len - state.length;\n            if (!state.head.extra) {\n              // Use untyped array for more conveniend processing later\n              state.head.extra = new Array(state.head.extra_len);\n            }\n            utils.arraySet(\n              state.head.extra,\n              input,\n              next,\n              // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              copy,\n              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n              len\n            );\n            //zmemcpy(state.head.extra + len, next,\n            //        len + copy > state.head.extra_max ?\n            //        state.head.extra_max - len : copy);\n          }\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          state.length -= copy;\n        }\n        if (state.length) { break inf_leave; }\n      }\n      state.length = 0;\n      state.mode = NAME;\n      /* falls through */\n    case NAME:\n      if (state.flags & 0x0800) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          // TODO: 2 or 1 bytes?\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.name_max*/)) {\n            state.head.name += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.name = null;\n      }\n      state.length = 0;\n      state.mode = COMMENT;\n      /* falls through */\n    case COMMENT:\n      if (state.flags & 0x1000) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.comm_max*/)) {\n            state.head.comment += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.comment = null;\n      }\n      state.mode = HCRC;\n      /* falls through */\n    case HCRC:\n      if (state.flags & 0x0200) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.check & 0xffff)) {\n          strm.msg = \'header crc mismatch\';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      if (state.head) {\n        state.head.hcrc = ((state.flags >> 9) & 1);\n        state.head.done = true;\n      }\n      strm.adler = state.check = 0 /*crc32(0L, Z_NULL, 0)*/;\n      state.mode = TYPE;\n      break;\n    case DICTID:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      strm.adler = state.check = ZSWAP32(hold);\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = DICT;\n      /* falls through */\n    case DICT:\n      if (state.havedict === 0) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        return Z_NEED_DICT;\n      }\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = TYPE;\n      /* falls through */\n    case TYPE:\n      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case TYPEDO:\n      if (state.last) {\n        //--- BYTEBITS() ---//\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        state.mode = CHECK;\n        break;\n      }\n      //=== NEEDBITS(3); */\n      while (bits < 3) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.last = (hold & 0x01)/*BITS(1)*/;\n      //--- DROPBITS(1) ---//\n      hold >>>= 1;\n      bits -= 1;\n      //---//\n\n      switch ((hold & 0x03)/*BITS(2)*/) {\n      case 0:                             /* stored block */\n        //Tracev((stderr, "inflate:     stored block%s\\n",\n        //        state.last ? " (last)" : ""));\n        state.mode = STORED;\n        break;\n      case 1:                             /* fixed block */\n        fixedtables(state);\n        //Tracev((stderr, "inflate:     fixed codes block%s\\n",\n        //        state.last ? " (last)" : ""));\n        state.mode = LEN_;             /* decode codes */\n        if (flush === Z_TREES) {\n          //--- DROPBITS(2) ---//\n          hold >>>= 2;\n          bits -= 2;\n          //---//\n          break inf_leave;\n        }\n        break;\n      case 2:                             /* dynamic block */\n        //Tracev((stderr, "inflate:     dynamic codes block%s\\n",\n        //        state.last ? " (last)" : ""));\n        state.mode = TABLE;\n        break;\n      case 3:\n        strm.msg = \'invalid block type\';\n        state.mode = BAD;\n      }\n      //--- DROPBITS(2) ---//\n      hold >>>= 2;\n      bits -= 2;\n      //---//\n      break;\n    case STORED:\n      //--- BYTEBITS() ---// /* go to byte boundary */\n      hold >>>= bits & 7;\n      bits -= bits & 7;\n      //---//\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n        strm.msg = \'invalid stored block lengths\';\n        state.mode = BAD;\n        break;\n      }\n      state.length = hold & 0xffff;\n      //Tracev((stderr, "inflate:       stored length %u\\n",\n      //        state.length));\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = COPY_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case COPY_:\n      state.mode = COPY;\n      /* falls through */\n    case COPY:\n      copy = state.length;\n      if (copy) {\n        if (copy > have) { copy = have; }\n        if (copy > left) { copy = left; }\n        if (copy === 0) { break inf_leave; }\n        //--- zmemcpy(put, next, copy); ---\n        utils.arraySet(output, input, next, copy, put);\n        //---//\n        have -= copy;\n        next += copy;\n        left -= copy;\n        put += copy;\n        state.length -= copy;\n        break;\n      }\n      //Tracev((stderr, "inflate:       stored end\\n"));\n      state.mode = TYPE;\n      break;\n    case TABLE:\n      //=== NEEDBITS(14); */\n      while (bits < 14) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n      if (state.nlen > 286 || state.ndist > 30) {\n        strm.msg = \'too many length or distance symbols\';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracev((stderr, "inflate:       table sizes ok\\n"));\n      state.have = 0;\n      state.mode = LENLENS;\n      /* falls through */\n    case LENLENS:\n      while (state.have < state.ncode) {\n        //=== NEEDBITS(3);\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n        //--- DROPBITS(3) ---//\n        hold >>>= 3;\n        bits -= 3;\n        //---//\n      }\n      while (state.have < 19) {\n        state.lens[order[state.have++]] = 0;\n      }\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      //state.next = state.codes;\n      //state.lencode = state.next;\n      // Switch to use dynamic table\n      state.lencode = state.lendyn;\n      state.lenbits = 7;\n\n      opts = {bits: state.lenbits};\n      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n      state.lenbits = opts.bits;\n\n      if (ret) {\n        strm.msg = \'invalid code lengths set\';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, "inflate:       code lengths ok\\n"));\n      state.have = 0;\n      state.mode = CODELENS;\n      /* falls through */\n    case CODELENS:\n      while (state.have < state.nlen + state.ndist) {\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_val < 16) {\n          //--- DROPBITS(here.bits) ---//\n          hold >>>= here_bits;\n          bits -= here_bits;\n          //---//\n          state.lens[state.have++] = here_val;\n        }\n        else {\n          if (here_val === 16) {\n            //=== NEEDBITS(here.bits + 2);\n            n = here_bits + 2;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            if (state.have === 0) {\n              strm.msg = \'invalid bit length repeat\';\n              state.mode = BAD;\n              break;\n            }\n            len = state.lens[state.have - 1];\n            copy = 3 + (hold & 0x03);//BITS(2);\n            //--- DROPBITS(2) ---//\n            hold >>>= 2;\n            bits -= 2;\n            //---//\n          }\n          else if (here_val === 17) {\n            //=== NEEDBITS(here.bits + 3);\n            n = here_bits + 3;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 3 + (hold & 0x07);//BITS(3);\n            //--- DROPBITS(3) ---//\n            hold >>>= 3;\n            bits -= 3;\n            //---//\n          }\n          else {\n            //=== NEEDBITS(here.bits + 7);\n            n = here_bits + 7;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 11 + (hold & 0x7f);//BITS(7);\n            //--- DROPBITS(7) ---//\n            hold >>>= 7;\n            bits -= 7;\n            //---//\n          }\n          if (state.have + copy > state.nlen + state.ndist) {\n            strm.msg = \'invalid bit length repeat\';\n            state.mode = BAD;\n            break;\n          }\n          while (copy--) {\n            state.lens[state.have++] = len;\n          }\n        }\n      }\n\n      /* handle error breaks in while */\n      if (state.mode === BAD) { break; }\n\n      /* check for end-of-block code (better have one) */\n      if (state.lens[256] === 0) {\n        strm.msg = \'invalid code -- missing end-of-block\';\n        state.mode = BAD;\n        break;\n      }\n\n      /* build code tables -- note: do not change the lenbits or distbits\n         values here (9 and 6) without reading the comments in inftrees.h\n         concerning the ENOUGH constants, which depend on those values */\n      state.lenbits = 9;\n\n      opts = {bits: state.lenbits};\n      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.lenbits = opts.bits;\n      // state.lencode = state.next;\n\n      if (ret) {\n        strm.msg = \'invalid literal/lengths set\';\n        state.mode = BAD;\n        break;\n      }\n\n      state.distbits = 6;\n      //state.distcode.copy(state.codes);\n      // Switch to use dynamic table\n      state.distcode = state.distdyn;\n      opts = {bits: state.distbits};\n      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.distbits = opts.bits;\n      // state.distcode = state.next;\n\n      if (ret) {\n        strm.msg = \'invalid distances set\';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, \'inflate:       codes ok\\n\'));\n      state.mode = LEN_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case LEN_:\n      state.mode = LEN;\n      /* falls through */\n    case LEN:\n      if (have >= 6 && left >= 258) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        inflate_fast(strm, _out);\n        //--- LOAD() ---\n        put = strm.next_out;\n        output = strm.output;\n        left = strm.avail_out;\n        next = strm.next_in;\n        input = strm.input;\n        have = strm.avail_in;\n        hold = state.hold;\n        bits = state.bits;\n        //---\n\n        if (state.mode === TYPE) {\n          state.back = -1;\n        }\n        break;\n      }\n      state.back = 0;\n      for (;;) {\n        here = state.lencode[hold & ((1 << state.lenbits) -1)];  /*BITS(state.lenbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if (here_bits <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if (here_op && (here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.lencode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      state.length = here_val;\n      if (here_op === 0) {\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        "inflate:         literal \'%c\'\\n" :\n        //        "inflate:         literal 0x%02x\\n", here.val));\n        state.mode = LIT;\n        break;\n      }\n      if (here_op & 32) {\n        //Tracevv((stderr, "inflate:         end of block\\n"));\n        state.back = -1;\n        state.mode = TYPE;\n        break;\n      }\n      if (here_op & 64) {\n        strm.msg = \'invalid literal/length code\';\n        state.mode = BAD;\n        break;\n      }\n      state.extra = here_op & 15;\n      state.mode = LENEXT;\n      /* falls through */\n    case LENEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n      //Tracevv((stderr, "inflate:         length %u\\n", state.length));\n      state.was = state.length;\n      state.mode = DIST;\n      /* falls through */\n    case DIST:\n      for (;;) {\n        here = state.distcode[hold & ((1 << state.distbits) -1)];/*BITS(state.distbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if ((here_bits) <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if ((here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.distcode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) -1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      if (here_op & 64) {\n        strm.msg = \'invalid distance code\';\n        state.mode = BAD;\n        break;\n      }\n      state.offset = here_val;\n      state.extra = (here_op) & 15;\n      state.mode = DISTEXT;\n      /* falls through */\n    case DISTEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.offset += hold & ((1 << state.extra) -1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n//#ifdef INFLATE_STRICT\n      if (state.offset > state.dmax) {\n        strm.msg = \'invalid distance too far back\';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracevv((stderr, "inflate:         distance %u\\n", state.offset));\n      state.mode = MATCH;\n      /* falls through */\n    case MATCH:\n      if (left === 0) { break inf_leave; }\n      copy = _out - left;\n      if (state.offset > copy) {         /* copy from window */\n        copy = state.offset - copy;\n        if (copy > state.whave) {\n          if (state.sane) {\n            strm.msg = \'invalid distance too far back\';\n            state.mode = BAD;\n            break;\n          }\n// (!) This block is disabled in zlib defailts,\n// don\'t enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, "inflate.c too far\\n"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n        }\n        if (copy > state.wnext) {\n          copy -= state.wnext;\n          from = state.wsize - copy;\n        }\n        else {\n          from = state.wnext - copy;\n        }\n        if (copy > state.length) { copy = state.length; }\n        from_source = state.window;\n      }\n      else {                              /* copy from output */\n        from_source = output;\n        from = put - state.offset;\n        copy = state.length;\n      }\n      if (copy > left) { copy = left; }\n      left -= copy;\n      state.length -= copy;\n      do {\n        output[put++] = from_source[from++];\n      } while (--copy);\n      if (state.length === 0) { state.mode = LEN; }\n      break;\n    case LIT:\n      if (left === 0) { break inf_leave; }\n      output[put++] = state.length;\n      left--;\n      state.mode = LEN;\n      break;\n    case CHECK:\n      if (state.wrap) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          // Use \'|\' insdead of \'+\' to make sure that result is signed\n          hold |= input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        _out -= left;\n        strm.total_out += _out;\n        state.total += _out;\n        if (_out) {\n          strm.adler = state.check =\n              /*UPDATE(state.check, put - _out, _out);*/\n              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n        }\n        _out = left;\n        // NB: crc32 stored as signed 32-bit int, ZSWAP32 returns signed too\n        if ((state.flags ? hold : ZSWAP32(hold)) !== state.check) {\n          strm.msg = \'incorrect data check\';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, "inflate:   check matches trailer\\n"));\n      }\n      state.mode = LENGTH;\n      /* falls through */\n    case LENGTH:\n      if (state.wrap && state.flags) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.total & 0xffffffff)) {\n          strm.msg = \'incorrect length check\';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, "inflate:   length matches trailer\\n"));\n      }\n      state.mode = DONE;\n      /* falls through */\n    case DONE:\n      ret = Z_STREAM_END;\n      break inf_leave;\n    case BAD:\n      ret = Z_DATA_ERROR;\n      break inf_leave;\n    case MEM:\n      return Z_MEM_ERROR;\n    case SYNC:\n      /* falls through */\n    default:\n      return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for "goto inf_leave", emulated via "break inf_leave"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateInfo = \'pako inflate (from Nodeca project)\';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n},{"../utils/common":16,"./adler32":18,"./crc32":20,"./inffast":23,"./inftrees":25}],25:[function(require,module,exports){\n\'use strict\';\n\n\nvar utils = require(\'../utils/common\');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code\'s length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS+1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  var i=0;\n  /* process all codes and make table entries */\n  for (;;) {\n    i++;\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n},{"../utils/common":16}],26:[function(require,module,exports){\n\'use strict\';\n\nmodule.exports = {\n  \'2\':    \'need dictionary\',     /* Z_NEED_DICT       2  */\n  \'1\':    \'stream end\',          /* Z_STREAM_END      1  */\n  \'0\':    \'\',                    /* Z_OK              0  */\n  \'-1\':   \'file error\',          /* Z_ERRNO         (-1) */\n  \'-2\':   \'stream error\',        /* Z_STREAM_ERROR  (-2) */\n  \'-3\':   \'data error\',          /* Z_DATA_ERROR    (-3) */\n  \'-4\':   \'insufficient memory\', /* Z_MEM_ERROR     (-4) */\n  \'-5\':   \'buffer error\',        /* Z_BUF_ERROR     (-5) */\n  \'-6\':   \'incompatible version\' /* Z_VERSION_ERROR (-6) */\n};\n\n},{}],27:[function(require,module,exports){\n\'use strict\';\n\n\nvar utils = require(\'../utils/common\');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2*L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES+2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH-MIN_MATCH+1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nvar StaticTreeDesc = function (static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n};\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nvar TreeDesc = function(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n};\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short (s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c*2]/*.Code*/, tree[c*2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max]*2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max+1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n*2 +1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n*2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n-base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n*2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,"\\nbit length overflow\\n"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length-1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits+1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from \'ar\' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m*2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,"code %d bits %d->%d\\n", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m*2 + 1]/*.Len*/)*tree[m*2]/*.Freq*/;\n        tree[m*2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS+1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits-1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        "inconsistent bit counts");\n  //Tracev((stderr,"\\ngen_codes: max_code %d ", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n*2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n*2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,"\\nn %3d %c l %2d c %4x (%x) ",\n    //     n, (isgraph(n) ? n : \' \'), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various \'constant\' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS+1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES-1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1<<extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, "tr_static_init: length != 256");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length-1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0 ; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1<<extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, "tr_static_init: dist != 256");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1<<(extra_dbits[code]-7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, "tr_static_init: 256+dist != 512");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n*2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n*2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n*2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n*2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES+1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n*2 + 1]/*.Len*/ = 5;\n    static_dtree[n*2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS+1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc =new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n*2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n*2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n*2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK*2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one\'s complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n*2;\n  var _m2 = m*2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j+1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx*2] << 8) | (s.pending_buf[s.d_buf + lx*2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr," \'%c\' ", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code+LITERALS+1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, "bad d_code");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       "pendingBuf overflow");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n*2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node*2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n*2 + 1]/*.Dad*/ = tree[m*2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code+1)*2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n+1)*2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6*2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10*2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138*2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0*2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n+1)*2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, " 3_6?");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count-3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count-3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count-11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES-1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex]*2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3*(max_blindex+1) + 5+5+4;\n  //Tracev((stderr, "\\ndyn trees: dyn %ld, stat %ld",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, "not enough codes");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        "too many codes");\n  //Tracev((stderr, "\\nbl counts: "));\n  send_bits(s, lcodes-257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes-1,   5);\n  send_bits(s, blcodes-4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, "\\nbl code %2d ", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank]*2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, "\\nbl tree: sent %ld", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes-1); /* literal tree */\n  //Tracev((stderr, "\\nlit tree: sent %ld", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes-1); /* distance tree */\n  //Tracev((stderr, "\\ndist tree: sent %ld", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       "black list" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       "white list" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   "gray list" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual ("black-listed") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n*2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual ("white-listed") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no "black-listed" or "white-listed" bytes:\n   * this stream either is empty or has tolerated ("gray-listed") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK<<1)+(last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES<<1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, "\\nlit data: dyn %ld, stat %ld", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, "\\ndist data: dyn %ld, stat %ld", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len+3+7) >>> 3;\n    static_lenb = (s.static_len+3+7) >>> 3;\n\n    // Tracev((stderr, "\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u ",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, "lost buf");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len+4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can\'t have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES<<1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES<<1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code+1, s.d_desc.max_code+1, max_blindex+1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, "bad compressed size");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,"\\ncomprlen %lu(%lu) ", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc*2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  "_tr_tally: bad match");\n\n    s.dyn_ltree[(_length_code[lc]+LITERALS+1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defailts,\n// don\'t enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) ",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize-1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n},{"../utils/common":16}],28:[function(require,module,exports){\n\'use strict\';\n\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = \'\'/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n},{}],29:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\ndaikon.CompressionUtils = daikon.CompressionUtils || {};\n\n\n/*** Static Pseudo-constants ***/\n\ndaikon.CompressionUtils.JPEG_MAGIC_NUMBER = [0xFF, 0xD8];\ndaikon.CompressionUtils.JPEG2000_MAGIC_NUMBER = [0xFF, 0x4F, 0xFF, 0x51];\n\n\n/*** Static methods ***/\n\ndaikon.CompressionUtils.isHeaderJPEG = function (data) \n{\n    if (data && data.getUint8) \n    {\n        if (data.getUint8(0) !== daikon.CompressionUtils.JPEG_MAGIC_NUMBER[0]) {\n            return false;\n        }\n\n        if (data.getUint8(1) !== daikon.CompressionUtils.JPEG_MAGIC_NUMBER[1]) {\n            return false;\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\n\ndaikon.CompressionUtils.isHeaderJPEG2000 = function (data) {\n    var ctr;\n\n    if (data && data.getUint8) {\n        for (ctr = 0; ctr < daikon.CompressionUtils.JPEG2000_MAGIC_NUMBER.length; ctr+=1) {\n            if (data.getUint8(ctr) !== daikon.CompressionUtils.JPEG2000_MAGIC_NUMBER[ctr]) {\n                return false;\n            }\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.CompressionUtils;\n}\n},{}],30:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\n\n/**\n * daikon.Dictionary\n * @type {{}|*}\n */\ndaikon.Dictionary = daikon.Dictionary || {};\ndaikon.Utils = daikon.Utils || ((typeof require !== \'undefined\') ? require(\'./utilities.js\') : null);\n\n\n/*** Static Pseudo-constants ***/\n\ndaikon.Dictionary.dictPrivate = {\n    "0207" : {\n        "101F" : ["FE", "ElscintDataScale"] // uses special Elscint double type (see Tag class)\n    }\n};\n\n\n\n///Elias Kellner this is the modified dict with only necessary tags ... to save heap\n\n\ndaikon.Dictionary.dict = {\n    "FFFE" : { "E000" : ["SQ", "node"] \n    },\n    "0062" : {\n        "0002" : ["OT", "brainlab"],\n    },\n    "0002" : {\n        "0001" : ["OB", "FileMetaInformationVersion"],\n        "0002" : ["UI", "MediaStoredSOPClassUID"],\n        "0003" : ["UI", "MediaStoredSOPInstanceUID"],\n        "0010" : ["UI", "TransferSyntaxUID"],\n        "0012" : ["UI", "ImplementationClassUID"],\n        "0013" : ["SH", "ImplementationVersionName"],\n        "0016" : ["AE", "SourceApplicationEntityTitle"],\n        "0100" : ["UI", "PrivateInformationCreatorUID"],\n        "0102" : ["OB", "PrivateInformation"]\n    },\n    "0008" : {\n        "0001" : ["UL", "LengthToEnd"],\n        "0005" : ["CS", "SpecificCharacterSet"],\n        "0006" : ["SQ", "LanguageCodeSequence"],\n        "0008" : ["CS", "ImageType"],\n        "0010" : ["SH", "RecognitionCode"],\n        "0012" : ["DA", "InstanceCreationDate"],\n        "0013" : ["TM", "InstanceCreationTime"],\n        "0014" : ["UI", "InstanceCreatorUID"],\n        "0016" : ["UI", "SOPClassUID"],\n        "0018" : ["UI", "SOPInstanceUID"],\n        "001A" : ["UI", "RelatedGeneralSOPClassUID"],\n        "001B" : ["UI", "OriginalSpecializedSOPClassUID"],\n        "0020" : ["DA", "StudyDate"],\n        "0021" : ["DA", "SeriesDate"],\n        "0022" : ["DA", "AcquisitionDate"],\n        "0023" : ["DA", "ContentDate"],\n        "0024" : ["DA", "OverlayDate"],\n        "0025" : ["DA", "CurveDate"],\n        "002A" : ["DT", "AcquisitionDateTime"],\n        "0030" : ["TM", "StudyTime"],\n        "0031" : ["TM", "SeriesTime"],\n        "0032" : ["TM", "AcquisitionTime"],\n        "0033" : ["TM", "ContentTime"],\n        "0034" : ["TM", "OverlayTime"],\n        "0035" : ["TM", "CurveTime"],\n        "0040" : ["US", "DataSetType"],\n        "0041" : ["LO", "DataSetSubtype"],\n        "0042" : ["CS", "NuclearMedicineSeriesType"],\n        "0050" : ["SH", "AccessionNumber"],\n        "0051" : ["SQ", "IssuerOfAccessionNumberSequence"],\n        "0052" : ["CS", "QueryRetrieveLevel"],\n        "0054" : ["AE", "RetrieveAETitle"],\n        "0056" : ["CS", "InstanceAvailability"],\n        "0058" : ["UI", "FailedSOPInstanceUIDList"],\n        "0060" : ["CS", "Modality"],\n        "0061" : ["CS", "ModalitiesInStudy"],\n        "0062" : ["UI", "SOPClassesInStudy"],\n        "0064" : ["CS", "ConversionType"],\n        "0068" : ["CS", "PresentationIntentType"],\n        "0070" : ["LO", "Manufacturer"],\n        "0080" : ["LO", "InstitutionName"],\n        "0081" : ["ST", "InstitutionAddress"],\n        "0082" : ["SQ", "InstitutionCodeSequence"],\n        "0090" : ["PN", "ReferringPhysicianName"],\n        "0092" : ["ST", "ReferringPhysicianAddress"],\n        "0094" : ["SH", "ReferringPhysicianTelephoneNumbers"],\n        "0096" : ["SQ", "ReferringPhysicianIdentificationSequence"],\n        "0100" : ["SH", "CodeValue"],\n        "0102" : ["SH", "CodingSchemeDesignator"],\n        "0103" : ["SH", "CodingSchemeVersion"],\n        "0104" : ["LO", "CodeMeaning"],\n        "0105" : ["CS", "MappingResource"],\n        "0106" : ["DT", "ContextGroupVersion"],\n        "0107" : ["DT", "ContextGroupLocalVersion"],\n        "010B" : ["CS", "ContextGroupExtensionFlag"],\n        "010C" : ["UI", "CodingSchemeUID"],\n        "010D" : ["UI", "ContextGroupExtensionCreatorUID"],\n        "010F" : ["CS", "ContextIdentifier"],\n        "0110" : ["SQ", "CodingSchemeIdentificationSequence"],\n        "0112" : ["LO", "CodingSchemeRegistry"],\n        "0114" : ["ST", "CodingSchemeExternalID"],\n        "0115" : ["ST", "CodingSchemeName"],\n        "0116" : ["ST", "CodingSchemeResponsibleOrganization"],\n        "0117" : ["UI", "ContextUID"],\n        "0201" : ["SH", "TimezoneOffsetFromUTC"],\n        "1000" : ["AE", "NetworkID"],\n        "1010" : ["SH", "StationName"],\n        "1030" : ["LO", "StudyDescription"],\n        "1032" : ["SQ", "ProcedureCodeSequence"],\n        "103E" : ["LO", "SeriesDescription"],\n        "103F" : ["SQ", "SeriesDescriptionCodeSequence"],\n        "1140" : ["SQ", "ReferencedImageSequence"],\n        "1150" : ["SQ", "ReferencedSOPClassUID"],\n        "1155" : ["SQ", "ReferencedSOPInstanceUID"],\n        "1160" : ["SQ", "ReferencedFrameNumber"],\n\n    },\n    "0010" : {\n        "0010" : ["PN", "PatientName"],\n        "0020" : ["LO", "PatientID"],\n        "0030" : ["DA", "PatientBirthDate"],\n        "0040" : ["CS", "PatientSex"],\n        "1005" : ["PN", "PatientBirthName"],\n        "1010" : ["AS", "PatientAge"],\n        "1020" : ["DS", "PatientSize"],\n        "1030" : ["DS", "PatientWeight"],\n    },\n    "0018" : {\n        "0010" : ["LO", "ContrastBolusAgent"],\n        "0012" : ["SQ", "ContrastBolusAgentSequence"],\n        "0014" : ["SQ", "ContrastBolusAdministrationRouteSequence"],\n        "0015" : ["CS", "BodyPartExamined"],\n        "0020" : ["CS", "ScanningSequence"],\n        "0021" : ["CS", "SequenceVariant"],\n        "0022" : ["CS", "ScanOptions"],\n        "0023" : ["CS", "MRAcquisitionType"],\n        "0024" : ["SH", "SequenceName"],\n        "0025" : ["CS", "AngioFlag"],\n        "0042" : ["CS", "InitialCineRunState"],\n        "0050" : ["DS", "SliceThickness"],\n        "0060" : ["DS", "KVP"],\n        "0070" : ["IS", "CountsAccumulated"],\n        "0071" : ["CS", "AcquisitionTerminationCondition"],\n        "0072" : ["DS", "EffectiveDuration"],\n        "0073" : ["CS", "AcquisitionStartCondition"],\n        "0074" : ["IS", "AcquisitionStartConditionData"],\n        "0075" : ["IS", "AcquisitionTerminationConditionData"],\n        "0080" : ["DS", "RepetitionTime"],\n        "0081" : ["DS", "EchoTime"],\n        "0082" : ["DS", "InversionTime"],\n        "0083" : ["DS", "NumberOfAverages"],\n        "0084" : ["DS", "ImagingFrequency"],\n        "0085" : ["SH", "ImagedNucleus"],\n        "0086" : ["IS", "EchoNumbers"],\n        "0087" : ["DS", "MagneticFieldStrength"],\n        "0088" : ["DS", "SpacingBetweenSlices"],\n        "0089" : ["IS", "NumberOfPhaseEncodingSteps"],\n        "0090" : ["DS", "DataCollectionDiameter"],\n        "0091" : ["IS", "EchoTrainLength"],\n        "0093" : ["DS", "PercentSampling"],\n        "0094" : ["DS", "PercentPhaseFieldOfView"],\n        "0095" : ["DS", "PixelBandwidth"],\n        "1000" : ["LO", "DeviceSerialNumber"],\n        "1002" : ["UI", "DeviceUID"],\n        "1003" : ["LO", "DeviceID"],\n        "1004" : ["LO", "PlateID"],\n        "1005" : ["LO", "GeneratorID"],\n        "1006" : ["LO", "GridID"],\n        "1007" : ["LO", "CassetteID"],\n        "1008" : ["LO", "GantryID"],\n        "1030" : ["LO", "ProtocolName"],\n        "1040" : ["LO", "ContrastBolusRoute"],\n        "1041" : ["DS", "ContrastBolusVolume"],\n        "1042" : ["TM", "ContrastBolusStartTime"],\n        "1043" : ["TM", "ContrastBolusStopTime"],\n        "1044" : ["DS", "ContrastBolusTotalDose"],\n        "1046" : ["DS", "ContrastFlowRate"],\n        "1047" : ["DS", "ContrastFlowDuration"],\n        "1048" : ["CS", "ContrastBolusIngredient"],\n        "1049" : ["DS", "ContrastBolusIngredientConcentration"],\n        "1050" : ["DS", "SpatialResolution"],\n        "1060" : ["DS", "TriggerTime"],\n        "1061" : ["LO", "TriggerSourceOrType"],\n        "1062" : ["IS", "NominalInterval"],\n        "1063" : ["DS", "FrameTime"],\n        "1064" : ["LO", "CardiacFramingType"],\n        "1065" : ["DS", "FrameTimeVector"],\n        "1066" : ["DS", "FrameDelay"],\n        "1067" : ["DS", "ImageTriggerDelay"],\n        "1068" : ["DS", "MultiplexGroupTimeOffset"],\n        "1069" : ["DS", "TriggerTimeOffset"],\n        "106A" : ["CS", "SynchronizationTrigger"],\n        "1074" : ["DS", "RadionuclideTotalDose"],\n        "1153" : ["IS", "ExposureInuAs"],\n        "1154" : ["DS", "AveragePulseWidth"],\n        "1155" : ["CS", "RadiationSetting"],\n        "1156" : ["CS", "RectificationType"],\n        "115A" : ["CS", "RadiationMode"],\n        "115E" : ["DS", "ImageAndFluoroscopyAreaDoseProduct"],\n        "1160" : ["SH", "FilterType"],\n        "1161" : ["LO", "TypeOfFilters"],\n        "1162" : ["DS", "IntensifierSize"],\n        "1164" : ["DS", "ImagerPixelSpacing"],\n        "1166" : ["CS", "Grid"],\n        "1170" : ["IS", "GeneratorPower"],\n        "1180" : ["SH", "CollimatorGridName"],\n        "1181" : ["CS", "CollimatorType"],\n        "1182" : ["IS", "FocalDistance"],\n        "1183" : ["DS", "XFocusCenter"],\n        "1184" : ["DS", "YFocusCenter"],\n        "1190" : ["DS", "FocalSpots"],\n        "1191" : ["CS", "AnodeTargetMaterial"],\n        "11A0" : ["DS", "BodyPartThickness"],\n        "11A2" : ["DS", "CompressionForce"],\n        "1200" : ["DA", "DateOfLastCalibration"],\n        "1201" : ["TM", "TimeOfLastCalibration"],\n        "1210" : ["SH", "ConvolutionKernel"],\n        "1240" : ["IS", "UpperLowerPixelValues"],\n        "1242" : ["IS", "ActualFrameDuration"],\n        "1243" : ["IS", "CountRate"],\n        "1244" : ["US", "PreferredPlaybackSequencing"],\n        "1250" : ["SH", "ReceiveCoilName"],\n        "1251" : ["SH", "TransmitCoilName"],\n        "1260" : ["SH", "PlateType"],\n        "1261" : ["LO", "PhosphorType"],\n        "1300" : ["DS", "ScanVelocity"],\n        "1301" : ["CS", "WholeBodyTechnique"],\n        "1302" : ["IS", "ScanLength"],\n        "1310" : ["US", "AcquisitionMatrix"],\n        "1312" : ["CS", "InPlanePhaseEncodingDirection"],\n        "1314" : ["DS", "FlipAngle"],\n        "1315" : ["CS", "VariableFlipAngleFlag"],\n        "1316" : ["DS", "SAR"],\n        "1318" : ["DS", "dBdt"],\n        "1400" : ["LO", "AcquisitionDeviceProcessingDescription"],\n        "1401" : ["LO", "AcquisitionDeviceProcessingCode"],\n        "1402" : ["CS", "CassetteOrientation"],\n        "1403" : ["CS", "CassetteSize"],\n        "1404" : ["US", "ExposuresOnPlate"],\n        "1405" : ["IS", "RelativeXRayExposure"],\n        "1411" : ["DS", "ExposureIndex"],\n        "1412" : ["DS", "TargetExposureIndex"],\n        "1413" : ["DS", "DeviationIndex"],\n        "1450" : ["DS", "ColumnAngulation"],\n        "1460" : ["DS", "TomoLayerHeight"],\n        "1470" : ["DS", "TomoAngle"],\n        "1480" : ["DS", "TomoTime"],\n        "1490" : ["CS", "TomoType"],\n        "1491" : ["CS", "TomoClass"],\n        "1495" : ["IS", "NumberOfTomosynthesisSourceImages"],\n        "1500" : ["CS", "PositionerMotion"],\n        "1508" : ["CS", "PositionerType"],\n        "1510" : ["DS", "PositionerPrimaryAngle"],\n        "1511" : ["DS", "PositionerSecondaryAngle"],\n        "1520" : ["DS", "PositionerPrimaryAngleIncrement"],\n        "1521" : ["DS", "PositionerSecondaryAngleIncrement"],\n        "1530" : ["DS", "DetectorPrimaryAngle"],\n        "1531" : ["DS", "DetectorSecondaryAngle"],\n        "1712" : ["IS", "RadiusOfCircularCollimator"],\n        "1720" : ["IS", "VerticesOfThePolygonalCollimator"],\n        "1800" : ["CS", "AcquisitionTimeSynchronized"],\n        "1801" : ["SH", "TimeSource"],\n        "1802" : ["CS", "TimeDistributionProtocol"],\n        "1803" : ["LO", "NTPSourceAddress"],\n        "2001" : ["IS", "PageNumberVector"],\n        "2002" : ["SH", "FrameLabelVector"],\n        "2003" : ["DS", "FramePrimaryAngleVector"],\n        "2004" : ["DS", "FrameSecondaryAngleVector"],\n        "2005" : ["DS", "SliceLocationVector"],\n        "2006" : ["SH", "DisplayWindowLabelVector"],\n        "2010" : ["DS", "NominalScannedPixelSpacing"],\n        "2020" : ["CS", "DigitizingDeviceTransportDirection"],\n        "2030" : ["DS", "RotationOfScannedFilm"],\n        "3100" : ["CS", "IVUSAcquisition"],\n        "3101" : ["DS", "IVUSPullbackRate"],\n        "3102" : ["DS", "IVUSGatedRate"],\n        "3103" : ["IS", "IVUSPullbackStartFrameNumber"],\n        "3104" : ["IS", "IVUSPullbackStopFrameNumber"],\n        "3105" : ["IS", "LesionNumber"],\n        "4000" : ["LT", "AcquisitionComments"],\n        "5000" : ["SH", "OutputPower"],\n        "5010" : ["LO", "TransducerData"],\n        "5012" : ["DS", "FocusDepth"],\n        "5020" : ["LO", "ProcessingFunction"],\n        "5021" : ["LO", "PostprocessingFunction"],\n        "5022" : ["DS", "MechanicalIndex"],\n        "5024" : ["DS", "BoneThermalIndex"],\n        "5026" : ["DS", "CranialThermalIndex"],\n        "5027" : ["DS", "SoftTissueThermalIndex"],\n        "5028" : ["DS", "SoftTissueFocusThermalIndex"],\n        "5029" : ["DS", "SoftTissueSurfaceThermalIndex"],\n        "5030" : ["DS", "DynamicRange"],\n        "5040" : ["DS", "TotalGain"],\n        "5050" : ["IS", "DepthOfScanField"],\n        "5100" : ["CS", "PatientPosition"],\n        "5101" : ["CS", "ViewPosition"],\n        "5104" : ["SQ", "ProjectionEponymousNameCodeSequence"],\n        "5210" : ["DS", "ImageTransformationMatrix"],\n        "5212" : ["DS", "ImageTranslationVector"],\n        "6000" : ["DS", "Sensitivity"],\n        "6011" : ["SQ", "SequenceOfUltrasoundRegions"],\n        "6012" : ["US", "RegionSpatialFormat"],\n        "6014" : ["US", "RegionDataType"],\n        "6016" : ["UL", "RegionFlags"],\n        "6020" : ["SL", "ReferencePixelX0"],\n        "6022" : ["SL", "ReferencePixelY0"],\n        "6024" : ["US", "PhysicalUnitsXDirection"],\n        "6026" : ["US", "PhysicalUnitsYDirection"],\n        "6028" : ["FD", "ReferencePixelPhysicalValueX"],\n        "602A" : ["FD", "ReferencePixelPhysicalValueY"],\n        "602C" : ["FD", "PhysicalDeltaX"],\n        "602E" : ["FD", "PhysicalDeltaY"],\n        "6030" : ["UL", "TransducerFrequency"],\n        "6031" : ["CS", "TransducerType"],\n        "6032" : ["UL", "PulseRepetitionFrequency"],\n        "6034" : ["FD", "DopplerCorrectionAngle"],\n        "6036" : ["FD", "SteeringAngle"],\n        "6038" : ["UL", "DopplerSampleVolumeXPositionRetired"],\n        "6039" : ["SL", "DopplerSampleVolumeXPosition"],\n        "603A" : ["UL", "DopplerSampleVolumeYPositionRetired"],\n        "603B" : ["SL", "DopplerSampleVolumeYPosition"],\n        "7030" : ["DS", "FieldOfViewOrigin"],\n        "7032" : ["DS", "FieldOfViewRotation"],\n        "7034" : ["CS", "FieldOfViewHorizontalFlip"],\n        "7036" : ["FL", "PixelDataAreaOriginRelativeToFOV"],\n        "7038" : ["FL", "PixelDataAreaRotationAngleRelativeToFOV"],\n        "7040" : ["LT", "GridAbsorbingMaterial"],\n        "7041" : ["LT", "GridSpacingMaterial"],\n        "7042" : ["DS", "GridThickness"],\n        "7044" : ["DS", "GridPitch"],\n        "7046" : ["IS", "GridAspectRatio"],\n        "7048" : ["DS", "GridPeriod"],\n        "704C" : ["DS", "GridFocalDistance"],\n        "9004" : ["CS", "ContentQualification"],\n        "9005" : ["SH", "PulseSequenceName"],\n        "9006" : ["SQ", "MRImagingModifierSequence"],\n        "9008" : ["CS", "EchoPulseSequence"],\n        "9009" : ["CS", "InversionRecovery"],\n        "9010" : ["CS", "FlowCompensation"],\n        "9011" : ["CS", "MultipleSpinEcho"],\n        "9012" : ["CS", "MultiPlanarExcitation"],\n        "9014" : ["CS", "PhaseContrast"],\n        "9015" : ["CS", "TimeOfFlightContrast"],\n        "9016" : ["CS", "Spoiling"],\n        "9017" : ["CS", "SteadyStatePulseSequence"],\n        "9018" : ["CS", "EchoPlanarPulseSequence"],\n        "9019" : ["FD", "TagAngleFirstAxis"],\n        "9020" : ["CS", "MagnetizationTransfer"],\n        "9021" : ["CS", "T2Preparation"],\n        "9022" : ["CS", "BloodSignalNulling"],\n        "9024" : ["CS", "SaturationRecovery"],\n        "9025" : ["CS", "SpectrallySelectedSuppression"],\n        "9026" : ["CS", "SpectrallySelectedExcitation"],\n        "9027" : ["CS", "SpatialPresaturation"],\n        "9028" : ["CS", "Tagging"],\n        "9029" : ["CS", "OversamplingPhase"],\n        "9030" : ["FD", "TagSpacingFirstDimension"],\n        "9032" : ["CS", "GeometryOfKSpaceTraversal"],\n        "9033" : ["CS", "SegmentedKSpaceTraversal"],\n        "9034" : ["CS", "RectilinearPhaseEncodeReordering"],\n        "9035" : ["FD", "TagThickness"],\n        "9036" : ["CS", "PartialFourierDirection"],\n        "9037" : ["CS", "CardiacSynchronizationTechnique"],\n        "9041" : ["LO", "ReceiveCoilManufacturerName"],\n        "9042" : ["SQ", "MRReceiveCoilSequence"],\n        "9043" : ["CS", "ReceiveCoilType"],\n        "9044" : ["CS", "QuadratureReceiveCoil"],\n        "9045" : ["SQ", "MultiCoilDefinitionSequence"],\n        "9046" : ["LO", "MultiCoilConfiguration"],\n        "9047" : ["SH", "MultiCoilElementName"],\n        "9048" : ["CS", "MultiCoilElementUsed"],\n        "9049" : ["SQ", "MRTransmitCoilSequence"],\n        "9050" : ["LO", "TransmitCoilManufacturerName"],\n        "9051" : ["CS", "TransmitCoilType"],\n        "9052" : ["FD", "SpectralWidth"],\n        "9053" : ["FD", "ChemicalShiftReference"],\n        "9054" : ["CS", "VolumeLocalizationTechnique"],\n        "9058" : ["US", "MRAcquisitionFrequencyEncodingSteps"],\n        "9059" : ["CS", "Decoupling"],\n        "9060" : ["CS", "DecoupledNucleus"],\n        "9061" : ["FD", "DecouplingFrequency"],\n        "9062" : ["CS", "DecouplingMethod"],\n        "9063" : ["FD", "DecouplingChemicalShiftReference"],\n        "9064" : ["CS", "KSpaceFiltering"],\n        "9065" : ["CS", "TimeDomainFiltering"],\n        "9066" : ["US", "NumberOfZeroFills"],\n        "9067" : ["CS", "BaselineCorrection"],\n        "9069" : ["FD", "ParallelReductionFactorInPlane"],\n        "9070" : ["FD", "CardiacRRIntervalSpecified"],\n        "9073" : ["FD", "AcquisitionDuration"],\n        "9074" : ["DT", "FrameAcquisitionDateTime"],\n        "9075" : ["CS", "DiffusionDirectionality"],\n        "9076" : ["SQ", "DiffusionGradientDirectionSequence"],\n        "9077" : ["CS", "ParallelAcquisition"],\n        "9078" : ["CS", "ParallelAcquisitionTechnique"],\n        "9079" : ["FD", "InversionTimes"],\n        "9080" : ["ST", "MetaboliteMapDescription"],\n        "9081" : ["CS", "PartialFourier"],\n        "9082" : ["FD", "EffectiveEchoTime"],\n        "9083" : ["SQ", "MetaboliteMapCodeSequence"],\n        "9084" : ["SQ", "ChemicalShiftSequence"],\n        "9085" : ["CS", "CardiacSignalSource"],\n        "9087" : ["FD", "DiffusionBValue"],\n        "9089" : ["FD", "DiffusionGradientOrientation"],\n        "9090" : ["FD", "VelocityEncodingDirection"],\n        "9091" : ["FD", "VelocityEncodingMinimumValue"],\n        "9092" : ["SQ", "VelocityEncodingAcquisitionSequence"],\n        "9093" : ["US", "NumberOfKSpaceTrajectories"],\n        "9094" : ["CS", "CoverageOfKSpace"],\n        "9095" : ["UL", "SpectroscopyAcquisitionPhaseRows"],\n        "9096" : ["FD", "ParallelReductionFactorInPlaneRetired"],\n        "9098" : ["FD", "TransmitterFrequency"],\n        "9100" : ["CS", "ResonantNucleus"],\n        "9101" : ["CS", "FrequencyCorrection"],\n        "9103" : ["SQ", "MRSpectroscopyFOVGeometrySequence"],\n        "9104" : ["FD", "SlabThickness"],\n        "9105" : ["FD", "SlabOrientation"],\n        "9106" : ["FD", "MidSlabPosition"],\n        "9107" : ["SQ", "MRSpatialSaturationSequence"],\n        "9112" : ["SQ", "MRTimingAndRelatedParametersSequence"],\n        "9114" : ["SQ", "MREchoSequence"],\n        "9115" : ["SQ", "MRModifierSequence"],\n        "9117" : ["SQ", "MRDiffusionSequence"],\n        "9118" : ["SQ", "CardiacSynchronizationSequence"],\n        "9119" : ["SQ", "MRAveragesSequence"],\n        "9125" : ["SQ", "MRFOVGeometrySequence"],\n        "9126" : ["SQ", "VolumeLocalizationSequence"],\n        "9127" : ["UL", "SpectroscopyAcquisitionDataColumns"],\n        "9147" : ["CS", "DiffusionAnisotropyType"],\n        "9151" : ["DT", "FrameReferenceDateTime"],\n        "9152" : ["SQ", "MRMetaboliteMapSequence"],\n        "9155" : ["FD", "ParallelReductionFactorOutOfPlane"],\n        "9159" : ["UL", "SpectroscopyAcquisitionOutOfPlanePhaseSteps"],\n        "9166" : ["CS", "BulkMotionStatus"],\n        "9168" : ["FD", "ParallelReductionFactorSecondInPlane"],\n        "9169" : ["CS", "CardiacBeatRejectionTechnique"],\n        "9170" : ["CS", "RespiratoryMotionCompensationTechnique"],\n        "9171" : ["CS", "RespiratorySignalSource"],\n        "9172" : ["CS", "BulkMotionCompensationTechnique"],\n        "9173" : ["CS", "BulkMotionSignalSource"],\n  "A003" : ["ST", "ContributionDescription"]\n    },\n    "0020" : {\n        "000D" : ["UI", "StudyInstanceUID"],\n        "000E" : ["UI", "SeriesInstanceUID"],\n        "0010" : ["SH", "StudyID"],\n        "0011" : ["IS", "SeriesNumber"],\n        "0012" : ["IS", "AcquisitionNumber"],\n        "0013" : ["IS", "InstanceNumber"],\n        "0014" : ["IS", "IsotopeNumber"],\n        "0015" : ["IS", "PhaseNumber"],\n        "0016" : ["IS", "IntervalNumber"],\n        "0017" : ["IS", "TimeSlotNumber"],\n        "0018" : ["IS", "AngleNumber"],\n        "0019" : ["IS", "ItemNumber"],\n        "0020" : ["CS", "PatientOrientation"],\n        "0022" : ["IS", "OverlayNumber"],\n        "0024" : ["IS", "CurveNumber"],\n        "0026" : ["IS", "LUTNumber"],\n        "0030" : ["DS", "ImagePosition"],\n        "0032" : ["DS", "ImagePositionPatient"],\n        "0035" : ["DS", "ImageOrientation"],\n        "0037" : ["DS", "ImageOrientationPatient"],\n        "0050" : ["DS", "Location"],\n        "0052" : ["UI", "FrameOfReferenceUID"],\n        "0060" : ["CS", "Laterality"],\n        "0062" : ["CS", "ImageLaterality"],\n        "0070" : ["LO", "ImageGeometryType"],\n        "0080" : ["CS", "MaskingImage"],\n        "00AA" : ["IS", "ReportNumber"],\n        "0100" : ["IS", "TemporalPositionIdentifier"],\n        "0105" : ["IS", "NumberOfTemporalPositions"],\n        "0110" : ["DS", "TemporalResolution"],\n        "0200" : ["UI", "SynchronizationFrameOfReferenceUID"],\n        "0242" : ["UI", "SOPInstanceUIDOfConcatenationSource"],\n        "1000" : ["IS", "SeriesInStudy"],\n        "1001" : ["IS", "AcquisitionsInSeries"],\n        "1002" : ["IS", "ImagesInAcquisition"],\n        "1003" : ["IS", "ImagesInSeries"],\n        "1004" : ["IS", "AcquisitionsInStudy"],\n        "1005" : ["IS", "ImagesInStudy"],\n        "1020" : ["LO", "Reference"],\n        "1040" : ["LO", "PositionReferenceIndicator"],\n        "1041" : ["DS", "SliceLocation"],\n        "1070" : ["IS", "OtherStudyNumbers"],\n        "1200" : ["IS", "NumberOfPatientRelatedStudies"],\n        "1202" : ["IS", "NumberOfPatientRelatedSeries"],\n        "1204" : ["IS", "NumberOfPatientRelatedInstances"],\n        "1206" : ["IS", "NumberOfStudyRelatedSeries"],\n        "1208" : ["IS", "NumberOfStudyRelatedInstances"],\n        "1209" : ["IS", "NumberOfSeriesRelatedInstances"],\n        "3401" : ["CS", "ModifyingDeviceID"],\n        "3402" : ["CS", "ModifiedImageID"],\n        "3403" : ["DA", "ModifiedImageDate"],\n        "3404" : ["LO", "ModifyingDeviceManufacturer"],\n        "3405" : ["TM", "ModifiedImageTime"],\n        "3406" : ["LO", "ModifiedImageDescription"],\n        "4000" : ["LT", "ImageComments"],\n        "5000" : ["AT", "OriginalImageIdentification"],\n        "5002" : ["LO", "OriginalImageIdentificationNomenclature"],\n        "9056" : ["SH", "StackID"],\n        "9057" : ["UL", "InStackPositionNumber"],\n        "9071" : ["SQ", "FrameAnatomySequence"],\n        "9072" : ["CS", "FrameLaterality"],\n        "9111" : ["SQ", "FrameContentSequence"],\n        "9113" : ["SQ", "PlanePositionSequence"],\n        "9116" : ["SQ", "PlaneOrientationSequence"],\n        "9128" : ["UL", "TemporalPositionIndex"],\n        "9153" : ["FD", "NominalCardiacTriggerDelayTime"],\n        "9154" : ["FL", "NominalCardiacTriggerTimePriorToRPeak"],\n        "9155" : ["FL", "ActualCardiacTriggerTimePriorToRPeak"],\n        "9156" : ["US", "FrameAcquisitionNumber"],\n        "9157" : ["UL", "DimensionIndexValues"],\n        "9158" : ["LT", "FrameComments"],\n        "9161" : ["UI", "ConcatenationUID"],\n        "9162" : ["US", "InConcatenationNumber"],\n        "9163" : ["US", "InConcatenationTotalNumber"],\n        "9164" : ["UI", "DimensionOrganizationUID"],\n        "9165" : ["AT", "DimensionIndexPointer"],\n        "9167" : ["AT", "FunctionalGroupPointer"],\n        "9213" : ["LO", "DimensionIndexPrivateCreator"],\n        "9221" : ["SQ", "DimensionOrganizationSequence"],\n        "9222" : ["SQ", "DimensionIndexSequence"],\n        "9228" : ["UL", "ConcatenationFrameOffsetNumber"],\n        "9238" : ["LO", "FunctionalGroupPrivateCreator"],\n        "9241" : ["FL", "NominalPercentageOfCardiacPhase"],\n        "9245" : ["FL", "NominalPercentageOfRespiratoryPhase"],\n        "9246" : ["FL", "StartingRespiratoryAmplitude"],\n        "9247" : ["CS", "StartingRespiratoryPhase"],\n        "9248" : ["FL", "EndingRespiratoryAmplitude"],\n        "9249" : ["CS", "EndingRespiratoryPhase"],\n        "9250" : ["CS", "RespiratoryTriggerType"],\n        "9251" : ["FD", "RRIntervalTimeNominal"],\n        "9252" : ["FD", "ActualCardiacTriggerDelayTime"],\n        "9253" : ["SQ", "RespiratorySynchronizationSequence"],\n        "9254" : ["FD", "RespiratoryIntervalTime"],\n        "9255" : ["FD", "NominalRespiratoryTriggerDelayTime"],\n        "9256" : ["FD", "RespiratoryTriggerDelayThreshold"],\n        "9257" : ["FD", "ActualRespiratoryTriggerDelayTime"],\n        "9301" : ["FD", "ImagePositionVolume"],\n        "9302" : ["FD", "ImageOrientationVolume"],\n        "9307" : ["CS", "UltrasoundAcquisitionGeometry"],\n        "9308" : ["FD", "ApexPosition"],\n        "9309" : ["FD", "VolumeToTransducerMappingMatrix"],\n        "930A" : ["FD", "VolumeToTableMappingMatrix"],\n        "930C" : ["CS", "PatientFrameOfReferenceSource"],\n        "930D" : ["FD", "TemporalPositionTimeOffset"],\n        "930E" : ["SQ", "PlanePositionVolumeSequence"],\n        "930F" : ["SQ", "PlaneOrientationVolumeSequence"],\n        "9310" : ["SQ", "TemporalPositionSequence"],\n        "9311" : ["CS", "DimensionOrganizationType"],\n        "9312" : ["UI", "VolumeFrameOfReferenceUID"],\n        "9313" : ["UI", "TableFrameOfReferenceUID"],\n        "9421" : ["LO", "DimensionDescriptionLabel"],\n        "9450" : ["SQ", "PatientOrientationInFrameSequence"],\n        "9453" : ["LO", "FrameLabel"],\n        "9518" : ["US", "AcquisitionIndex"],\n        "9529" : ["SQ", "ContributingSOPInstancesReferenceSequence"],\n        "9536" : ["US", "ReconstructionIndex"]\n    },\n    "0028" : {\n        "0002" : ["US", "SamplesPerPixel"],\n        "0003" : ["US", "SamplesPerPixelUsed"],\n        "0004" : ["CS", "PhotometricInterpretation"],\n        "0005" : ["US", "ImageDimensions"],\n        "0006" : ["US", "PlanarConfiguration"],\n        "0008" : ["IS", "NumberOfFrames"],\n        "0009" : ["AT", "FrameIncrementPointer"],\n        "000A" : ["AT", "FrameDimensionPointer"],\n        "0010" : ["US", "Rows"],\n        "0011" : ["US", "Columns"],\n        "0012" : ["US", "Planes"],\n        "0014" : ["US", "UltrasoundColorDataPresent"],\n        "0030" : ["DS", "PixelSpacing"],\n        "0031" : ["DS", "ZoomFactor"],\n        "0032" : ["DS", "ZoomCenter"],\n        "0034" : ["IS", "PixelAspectRatio"],\n        "0040" : ["CS", "ImageFormat"],\n        "0050" : ["LO", "ManipulatedImage"],\n        "0051" : ["CS", "CorrectedImage"],\n        "005F" : ["LO", "CompressionRecognitionCode"],\n        "0060" : ["CS", "CompressionCode"],\n        "0061" : ["SH", "CompressionOriginator"],\n        "0062" : ["LO", "CompressionLabel"],\n        "0063" : ["SH", "CompressionDescription"],\n        "0065" : ["CS", "CompressionSequence"],\n        "0066" : ["AT", "CompressionStepPointers"],\n        "0068" : ["US", "RepeatInterval"],\n        "0069" : ["US", "BitsGrouped"],\n        "0070" : ["US", "PerimeterTable"],\n        "0071" : ["SS", "PerimeterValue"],\n        "0080" : ["US", "PredictorRows"],\n        "0081" : ["US", "PredictorColumns"],\n        "0082" : ["US", "PredictorConstants"],\n        "0090" : ["CS", "BlockedPixels"],\n        "0091" : ["US", "BlockRows"],\n        "0092" : ["US", "BlockColumns"],\n        "0093" : ["US", "RowOverlap"],\n        "0094" : ["US", "ColumnOverlap"],\n        "0100" : ["US", "BitsAllocated"],\n        "0101" : ["US", "BitsStored"],\n        "0102" : ["US", "HighBit"],\n        "0103" : ["US", "PixelRepresentation"],\n        "0104" : ["SS", "SmallestValidPixelValue"],\n        "0105" : ["SS", "LargestValidPixelValue"],\n        "0106" : ["SS", "SmallestImagePixelValue"],\n        "0107" : ["SS", "LargestImagePixelValue"],\n        "0108" : ["SS", "SmallestPixelValueInSeries"],\n        "0109" : ["SS", "LargestPixelValueInSeries"],\n        "0110" : ["SS", "SmallestImagePixelValueInPlane"],\n        "0111" : ["SS", "LargestImagePixelValueInPlane"],\n        "0120" : ["SS", "PixelPaddingValue"],\n        "0121" : ["SS", "PixelPaddingRangeLimit"],\n        "0200" : ["US", "ImageLocation"],\n        "0300" : ["CS", "QualityControlImage"],\n        "0301" : ["CS", "BurnedInAnnotation"],\n        "0302" : ["CS", "RecognizableVisualFeatures"],\n        "0303" : ["CS", "LongitudinalTemporalInformationModified"],\n        "0400" : ["LO", "TransformLabel"],\n        "0401" : ["LO", "TransformVersionNumber"],\n        "0402" : ["US", "NumberOfTransformSteps"],\n        "0403" : ["LO", "SequenceOfCompressedData"],\n        "0404" : ["AT", "DetailsOfCoefficients"],\n        "0700" : ["LO", "DCTLabel"],\n        "0701" : ["CS", "DataBlockDescription"],\n        "0702" : ["AT", "DataBlock"],\n        "0710" : ["US", "NormalizationFactorFormat"],\n        "0720" : ["US", "ZonalMapNumberFormat"],\n        "0721" : ["AT", "ZonalMapLocation"],\n        "0722" : ["US", "ZonalMapFormat"],\n        "0730" : ["US", "AdaptiveMapFormat"],\n        "0740" : ["US", "CodeNumberFormat"],\n        "0A02" : ["CS", "PixelSpacingCalibrationType"],\n        "0A04" : ["LO", "PixelSpacingCalibrationDescription"],\n        "1040" : ["CS", "PixelIntensityRelationship"],\n        "1041" : ["SS", "PixelIntensityRelationshipSign"],\n        "1050" : ["DS", "WindowCenter"],\n        "1051" : ["DS", "WindowWidth"],\n        "1052" : ["DS", "RescaleIntercept"],\n        "1053" : ["DS", "RescaleSlope"],\n        "1054" : ["LO", "RescaleType"],\n        "1055" : ["LO", "WindowCenterWidthExplanation"],\n        "1056" : ["CS", "VOILUTFunction"],\n        "1080" : ["CS", "GrayScale"],\n        "1090" : ["CS", "RecommendedViewingMode"],\n        "1100" : ["SS", "GrayLookupTableDescriptor"],\n        "1101" : ["SS", "RedPaletteColorLookupTableDescriptor"],\n        "1102" : ["SS", "GreenPaletteColorLookupTableDescriptor"],\n        "1103" : ["SS", "BluePaletteColorLookupTableDescriptor"],\n        "1104" : ["US", "AlphaPaletteColorLookupTableDescriptor"],\n        "1111" : ["SS", "LargeRedPaletteColorLookupTableDescriptor"],\n        "1112" : ["SS", "LargeGreenPaletteColorLookupTableDescriptor"],\n        "1113" : ["SS", "LargeBluePaletteColorLookupTableDescriptor"],\n        "1199" : ["UI", "PaletteColorLookupTableUID"],\n        "1200" : ["OW", "GrayLookupTableData"],\n        "1201" : ["OW", "RedPaletteColorLookupTableData"],\n        "1202" : ["OW", "GreenPaletteColorLookupTableData"],\n        "1203" : ["OW", "BluePaletteColorLookupTableData"],\n        "1204" : ["OW", "AlphaPaletteColorLookupTableData"],\n        "1211" : ["OW", "LargeRedPaletteColorLookupTableData"],\n        "1212" : ["OW", "LargeGreenPaletteColorLookupTableData"],\n        "1213" : ["OW", "LargeBluePaletteColorLookupTableData"],\n        "1214" : ["UI", "LargePaletteColorLookupTableUID"],\n        "1221" : ["OW", "SegmentedRedPaletteColorLookupTableData"],\n        "1222" : ["OW", "SegmentedGreenPaletteColorLookupTableData"],\n        "1223" : ["OW", "SegmentedBluePaletteColorLookupTableData"],\n        "1300" : ["CS", "BreastImplantPresent"],\n        "1350" : ["CS", "PartialView"],\n        "1351" : ["ST", "PartialViewDescription"],\n        "1352" : ["SQ", "PartialViewCodeSequence"],\n        "135A" : ["CS", "SpatialLocationsPreserved"],\n        "1401" : ["SQ", "DataFrameAssignmentSequence"],\n        "1402" : ["CS", "DataPathAssignment"],\n        "1403" : ["US", "BitsMappedToColorLookupTable"],\n        "1404" : ["SQ", "BlendingLUT1Sequence"],\n        "1405" : ["CS", "BlendingLUT1TransferFunction"],\n        "1406" : ["FD", "BlendingWeightConstant"],\n        "1407" : ["US", "BlendingLookupTableDescriptor"],\n        "1408" : ["OW", "BlendingLookupTableData"],\n        "140B" : ["SQ", "EnhancedPaletteColorLookupTableSequence"],\n        "140C" : ["SQ", "BlendingLUT2Sequence"],\n        "140D" : ["CS", "BlendingLUT2TransferFunction"],\n        "140E" : ["CS", "DataPathID"],\n        "140F" : ["CS", "RGBLUTTransferFunction"],\n        "1410" : ["CS", "AlphaLUTTransferFunction"],\n        "2000" : ["OB", "ICCProfile"],\n        "2110" : ["CS", "LossyImageCompression"],\n        "2112" : ["DS", "LossyImageCompressionRatio"],\n        "2114" : ["CS", "LossyImageCompressionMethod"],\n        "3000" : ["SQ", "ModalityLUTSequence"],\n        "3002" : ["SS", "LUTDescriptor"],\n        "3003" : ["LO", "LUTExplanation"],\n        "3004" : ["LO", "ModalityLUTType"],\n        "3006" : ["OW", "LUTData"],\n        "3010" : ["SQ", "VOILUTSequence"],\n        "3110" : ["SQ", "SoftcopyVOILUTSequence"],\n        "4000" : ["LT", "ImagePresentationComments"],\n        "5000" : ["SQ", "BiPlaneAcquisitionSequence"],\n        "6010" : ["US", "RepresentativeFrameNumber"],\n        "6020" : ["US", "FrameNumbersOfInterest"],\n        "6022" : ["LO", "FrameOfInterestDescription"],\n        "6023" : ["CS", "FrameOfInterestType"],\n        "6030" : ["US", "MaskPointers"],\n        "6040" : ["US", "RWavePointer"],\n        "6100" : ["SQ", "MaskSubtractionSequence"],\n        "6101" : ["CS", "MaskOperation"],\n        "6102" : ["US", "ApplicableFrameRange"],\n        "6110" : ["US", "MaskFrameNumbers"],\n        "6112" : ["US", "ContrastFrameAveraging"],\n        "6114" : ["FL", "MaskSubPixelShift"],\n        "6120" : ["SS", "TIDOffset"],\n        "6190" : ["ST", "MaskOperationExplanation"],\n        "7FE0" : ["UT", "PixelDataProviderURL"],\n        "9001" : ["UL", "DataPointRows"],\n        "9002" : ["UL", "DataPointColumns"],\n        "9003" : ["CS", "SignalDomainColumns"],\n        "9099" : ["US", "LargestMonochromePixelValue"],\n        "9108" : ["CS", "DataRepresentation"],\n        "9110" : ["SQ", "PixelMeasuresSequence"],\n        "9132" : ["SQ", "FrameVOILUTSequence"],\n        "9145" : ["SQ", "PixelValueTransformationSequence"],\n        "9235" : ["CS", "SignalDomainRows"],\n        "9411" : ["FL", "DisplayFilterPercentage"],\n        "9415" : ["SQ", "FramePixelShiftSequence"],\n        "9416" : ["US", "SubtractionItemID"],\n        "9422" : ["SQ", "PixelIntensityRelationshipLUTSequence"],\n        "9443" : ["SQ", "FramePixelDataPropertiesSequence"],\n        "9444" : ["CS", "GeometricalProperties"],\n        "9445" : ["FL", "GeometricMaximumDistortion"],\n        "9446" : ["CS", "ImageProcessingApplied"],\n        "9454" : ["CS", "MaskSelectionMode"],\n        "9474" : ["CS", "LUTFunction"],\n        "9478" : ["FL", "MaskVisibilityPercentage"],\n        "9501" : ["SQ", "PixelShiftSequence"],\n        "9502" : ["SQ", "RegionPixelShiftSequence"],\n        "9503" : ["SS", "VerticesOfTheRegion"],\n        "9505" : ["SQ", "MultiFramePresentationSequence"],\n        "9506" : ["US", "PixelShiftFrameRange"],\n        "9507" : ["US", "LUTFrameRange"],\n        "9520" : ["DS", "ImageToEquipmentMappingMatrix"],\n        "9537" : ["CS", "EquipmentCoordinateSystemIdentification"]\n    },\n    \n    "0029" : // SIEMENS private headers. See spm_dicom_headers for more info. Can be of different types\n    {                  \n        "1010" : ["UN", "CSAImageHeaderInfo"], // Mosaic info is here. Type UN is unknown.\n//        "1020" : ["UN", "CSASeriesHeaderInfo"] // Mosaic info is here. Type UN is unknown.\n    },\n\n    "0040" : // structured report SR stuff\n    {                  \n        "A730" : ["SQ", "ContentSequence"],\n        "A010" : ["CS", "RelationshipType"],\n        "A040" : ["CS", "ValueType"],\n        "A043" : ["SQ", "ConceptNameCodeSequence"],\n        "A050" : ["CS", "SRContinuityOfContent"],  \n        "A160" : ["CS", "SRTextValue"], // "own" definition\n        "A121" : ["CS", "SRDate"],  \n        "A122" : ["CS", "SRTime"],  \n        "A123" : ["CS", "SRPersonName"],  \n        "A168" : ["SQ", "SRConceptCodeSequence"],  \n        \n        "A491" : ["CS", "CompletionFlag"],  \n        "A493" : ["CS", "VerificationFlag"],  \n    },\n\n\n    \n    "0048" : {\n        "0001" : ["FL", "ImagedVolumeWidth"],\n        "0002" : ["FL", "ImagedVolumeHeight"],\n        "0003" : ["FL", "ImagedVolumeDepth"],\n        "0006" : ["UL", "TotalPixelMatrixColumns"],\n        "0007" : ["UL", "TotalPixelMatrixRows"],\n        "0008" : ["SQ", "TotalPixelMatrixOriginSequence"],\n        "0010" : ["CS", "SpecimenLabelInImage"],\n        "0011" : ["CS", "FocusMethod"],\n        "0012" : ["CS", "ExtendedDepthOfField"],\n        "0013" : ["US", "NumberOfFocalPlanes"],\n        "0014" : ["FL", "DistanceBetweenFocalPlanes"],\n        "0015" : ["US", "RecommendedAbsentPixelCIELabValue"],\n        "0100" : ["SQ", "IlluminatorTypeCodeSequence"],\n        "0102" : ["DS", "ImageOrientationSlide"],\n        "0105" : ["SQ", "OpticalPathSequence"],\n        "0106" : ["SH", "OpticalPathIdentifier"],\n        "0107" : ["ST", "OpticalPathDescription"],\n        "0108" : ["SQ", "IlluminationColorCodeSequence"],\n        "0110" : ["SQ", "SpecimenReferenceSequence"],\n        "0111" : ["DS", "CondenserLensPower"],\n        "0112" : ["DS", "ObjectiveLensPower"],\n        "0113" : ["DS", "ObjectiveLensNumericalAperture"],\n        "0120" : ["SQ", "PaletteColorLookupTableSequence"],\n        "0200" : ["SQ", "ReferencedImageNavigationSequence"],\n        "0201" : ["US", "TopLeftHandCornerOfLocalizerArea"],\n        "0202" : ["US", "BottomRightHandCornerOfLocalizerArea"],\n        "0207" : ["SQ", "OpticalPathIdentificationSequence"],\n        "021A" : ["SQ", "PlanePositionSlideSequence"],\n        "021E" : ["SL", "RowPositionInTotalImagePixelMatrix"],\n        "021F" : ["SL", "ColumnPositionInTotalImagePixelMatrix"],\n        "0301" : ["CS", "PixelOriginInterpretation"]\n    },\n    "0054" : {\n        "0016" : ["SQ", "RadiopharmaceuticalInformationSequence"],\n        "1001" : ["CS", "Units"]\n    },\n    \n    "0062" : {\n        "0001" : ["CS", "SegmentationType"],\n        "0002" : ["SQ", "SegmentSequence"],\n        "0003" : ["SQ", "SegmentedPropertyCategoryCodeSequence"],\n        "0004" : ["US", "SegmentNumber"],\n        "0005" : ["LO", "SegmentLabel"],\n        "0006" : ["ST", "SegmentDescription"],\n        "0008" : ["CS", "SegmentAlgorithmType"],\n        "0009" : ["LO", "SegmentAlgorithmName"],\n        "000A" : ["SQ", "SegmentIdentificationSequence"],\n        "000B" : ["US", "ReferencedSegmentNumber"],\n        "000C" : ["US", "RecommendedDisplayGrayscaleValue"],\n        "000D" : ["US", "RecommendedDisplayCIELabValue"],\n        "000E" : ["US", "MaximumFractionalValue"],\n        "000F" : ["SQ", "SegmentedPropertyTypeCodeSequence"],\n        "0010" : ["CS", "SegmentationFractionalType"],\n    },\n\n    "0066" : {\n        "0001" : ["UL", "NumberOfSurfaces"],\n        "0002" : ["SQ", "SurfaceSequence"],\n        "0003" : ["UL", "SurfaceNumber"],\n        "0004" : ["LT", "SurfaceComments"],\n        "0009" : ["CS", "SurfaceProcessing"],\n        "000A" : ["FL", "SurfaceProcessingRatio"],\n        "000B" : ["LO", "SurfaceProcessingDescription"],\n        "000C" : ["FL", "RecommendedPresentationOpacity"],\n        "000D" : ["CS", "RecommendedPresentationType"],\n        "000E" : ["CS", "FiniteVolume"],\n        "0010" : ["CS", "Manifold"],\n        "0011" : ["SQ", "SurfacePointsSequence"],\n        "0012" : ["SQ", "SurfacePointsNormalsSequence"],\n        "0013" : ["SQ", "SurfaceMeshPrimitivesSequence"],\n        "0015" : ["UL", "NumberOfSurfacePoints"],\n        "0016" : ["OF", "PointCoordinatesData"],\n        "0017" : ["FL", "PointPositionAccuracy"],\n        "0018" : ["FL", "MeanPointDistance"],\n        "0019" : ["FL", "MaximumPointDistance"],\n        "001A" : ["FL", "PointsBoundingBoxCoordinates"],\n        "001B" : ["FL", "AxisOfRotation"],\n        "001C" : ["FL", "CenterOfRotation"],\n        "001E" : ["UL", "NumberOfVectors"],\n        "001F" : ["US", "VectorDimensionality"],\n        "0020" : ["FL", "VectorAccuracy"],\n        "0021" : ["OF", "VectorCoordinateData"],\n        "0023" : ["OW", "TrianglePointIndexList"],\n        "0024" : ["OW", "EdgePointIndexList"],\n        "0025" : ["OW", "VertexPointIndexList"],\n        "0026" : ["SQ", "TriangleStripSequence"],\n        "0027" : ["SQ", "TriangleFanSequence"],\n        "0028" : ["SQ", "LineSequence"],\n        "0029" : ["OW", "PrimitivePointIndexList"],\n        "002A" : ["UL", "SurfaceCount"],\n        "002B" : ["SQ", "ReferencedSurfaceSequence"],\n        "002C" : ["UL", "ReferencedSurfaceNumber"],\n        "002D" : ["SQ", "SegmentSurfaceGenerationAlgorithmIdentificationSequence"],\n        "002E" : ["SQ", "SegmentSurfaceSourceInstanceSequence"],\n        "002F" : ["SQ", "AlgorithmFamilyCodeSequence"],\n        "0030" : ["SQ", "AlgorithmNameCodeSequence"],\n        "0031" : ["LO", "AlgorithmVersion"],\n        "0032" : ["LT", "AlgorithmParameters"],\n        "0034" : ["SQ", "FacetSequence"],\n        "0035" : ["SQ", "SurfaceProcessingAlgorithmIdentificationSequence"],\n        "0036" : ["LO", "AlgorithmName"],\n    },\n       \n\n\t"0070": {\n        "0001" : ["SQ", "GraphicAnnotationSequence"],\n        "0002" : ["CS", "GraphicLayer"],\n        "0003" : ["CS", "BoundingBoxAnnotationUnits"],\n        "0004" : ["CS", "AnchorPointAnnotationUnits"],\n        "0005" : ["CS", "GraphicAnnotationUnits"],\n        "0006" : ["ST", "UnformattedTextValue"],\n        "0008" : ["SQ", "TextObjectSequence"],\n        "0009" : ["SQ", "GraphicObjectSequence"],\n        "0010" : ["FL", "BoundingBoxTopLeftHandCorner"],\n        "0011" : ["FL", "BoundingBoxBottomRightHandCorner"],\n        "0012" : ["CS", "BoundingBoxTextHorizontalJustification"],\n        "0014" : ["FL", "AnchorPoint"],\n        "0015" : ["CS", "AnchorPointVisibility"],\n        "0020" : ["US", "GraphicDimensions"],\n        "0021" : ["US", "NumberOfGraphicPoints"],\n        "0022" : ["FL", "GraphicData"],\n        "0023" : ["CS", "GraphicType"],\n        "0024" : ["CS", "GraphicFilled"],\n        "0041" : ["CS", "ImageHorizontalFlip"],\n        "0042" : ["US", "ImageRotation"],\n        "0052" : ["SL", "DisplayedAreaTopLeftHandCorner"],\n        "0053" : ["SL", "DisplayedAreaBottomRightHandCorner"],\n        "005A" : ["SQ", "DisplayedAreaSelectionSequence"],\n        "0060" : ["SQ", "GraphicLayerSequence"],\n        "0062" : ["IS", "GraphicLayerOrder"],\n        "0066" : ["US", "GraphicLayerRecommendedDisplayGrayscaleValue"],\n        "0068" : ["LO", "GraphicLayerDescription"],\n        "0080" : ["CS", "ContentLabel"],\n        "0081" : ["LO", "ContentDescription"],\n        "0082" : ["DA", "PresentationCreationDate"],\n        "0083" : ["TM", "PresentationCreationTime"],\n        "0084" : ["PN", "ContentCreatorName"],\n        "0086" : ["SQ", "ContentCreatorIdentificationCodeSequence"],\n        "0087" : ["SQ", "AlternateContentDescriptionSequence"],\n        "0100" : ["CS", "PresentationSizeMode"],\n        "0101" : ["DS", "PresentationPixelSpacing"],\n        "0102" : ["IS", "PresentationPixelAspectRatio"],\n        "0103" : ["FL", "PresentationPixelMagnificationRatio"],\n        "0306" : ["CS", "ShapeType"],\n        "0308" : ["SQ", "RegistrationSequence"],\n        "0309" : ["SQ", "MatrixRegistrationSequence"],\n        "030A" : ["SQ", "MatrixSequence"],\n        "030C" : ["CS", "FrameOfReferenceTransformationMatrixType"],\n        "030D" : ["SQ", "RegistrationTypeCodeSequence"],\n        "030F" : ["ST", "FiducialDescription"],\n        "0310" : ["SH", "FiducialIdentifier"],\n        "0311" : ["SQ", "FiducialIdentifierCodeSequence"],\n        "0312" : ["FD", "ContourUncertaintyRadius"],\n        "0314" : ["SQ", "UsedFiducialsSequence"],\n        "0318" : ["SQ", "GraphicCoordinatesDataSequence"],\n        "031A" : ["UI", "FiducialUID"],\n        "031C" : ["SQ", "FiducialSetSequence"],\n        "031E" : ["SQ", "FiducialSequence"],\n        "0401" : ["US", "GraphicLayerRecommendedDisplayCIELabValue"],\n        "0402" : ["SQ", "BlendingSequence"],\n        "0403" : ["FL", "RelativeOpacity"],\n        "0404" : ["SQ", "ReferencedSpatialRegistrationSequence"],\n        "0405" : ["CS", "BlendingPosition"]\n    \t\n\t},\n\n    "5200" : {\n        "9229" : ["SQ", "SharedFunctionalGroupsSequence"],\n        "9230" : ["SQ", "PerFrameFunctionalGroupsSequence"]\n    },\n    "3006" : {\n        "0002":     ["SH", "StructureSetLabel"],\n        "0004" :\t["LO", "StructureSetName"],\n        "0006" :\t["ST", "StructureSetDescription"],\n        "0008" :\t["DA", "StructureSetDate"], \n        "0009" :\t["TM", "StructureSetTime"],\n        "0010" :\t["SQ", "ReferencedFrameOfReferenceSequence"],\n        "0012" :\t["SQ", "RTReferencedStudySequence"],\n        "0014" :\t["SQ", "RTReferencedSeriesSequence"],\t \n        "0016" :\t["SQ", "ContourImageSequence"],\n        "0020" :\t["SQ", "StructureSetROISequence"],\t \n        "0022" :\t["IS", "ROINumber"],\n        "0024" :\t["UI", "ReferencedFrameOfReferenceUID"],\n        "0026" :\t["LO", "ROIName"],\n        "0028" :\t["ST", "ROIDescription"],\n        "002A" :\t["IS", "ROIDisplayColor"],\t \n        "002C" :\t["DS", "ROIVolume"],\n        "0030" :\t["SQ", "RTRelatedROISequence"],\n        "0033" :\t["CS", "RTROIRelationship"],\t \n        "0036" :\t["CS", "ROIGenerationAlgorithm"],\n        "0038" :\t["LO", "ROIGenerationDescription"],\n        \n        "0039" :\t["SQ", "ROIContourSequence"],\n        "0040" :\t["SQ", "ContourSequence"],\n        "0042" :\t["CS", "ContourGeometricType"],\n        "0044" :\t["DS", "ContourSlabThickness"],\t \n        "0045" :\t["DS", "ContourOffsetVector"],\t \n        "0046" :\t["IS", "NumberOfContourPoints"],\t \n        "0048" :\t["IS", "ContourNumber"],\n        "0049" :\t["IS", "AttachedContours"],\t \n        "0050" :\t["DS", "ContourData"],\n        "0080" :\t["SQ", "RTROIObservationsSequence"],\n        "0082" :\t["IS", "ObservationNumber"],\n        "0084" :\t["IS", "ReferencedROINumber"],\t \n        "0085" :\t["SH", "ROIObservationLabel"],\t \n        "0086" :\t["SQ", "RTROIIdentificationCodeSequence"],\n        "0088" :\t["ST", "ROIObservationDescription"],\n        "00A0" :\t["SQ", "RelatedRTROIObservationsSequence"], \n        "00A4" :\t["CS", "RTROIInterpretedType"], \n        "00A6" :\t["PN", "ROIInterpreter"], \n        "00B0" :\t["SQ", "ROIPhysicalPropertiesSequence"], \n        "00B2" :\t["CS", "ROIPhysicalProperty"], \n        "00B4" :\t["DS", "ROIPhysicalPropertyValue"],\n        "00B6" :\t["OB", "ROIElementalCompositionSequence"],\t \n        "00B7" :\t["OB", "ROIElementalCompAtomicNumber"], \n        "00B8" :\t["OB", "ROIElementalCompAtomicMassFraction"], \n        "00C0" :\t["SQ", "FrameOfReferenceRelationshipSeq"], \n        "00C2" :\t["UI", "RelatedFrameOfReferenceUID"],\t \n        "00C4" :\t["CS", "FrameOfReferenceTransformType"],\t \n        "00C6" :\t["DS", "FrameOfReferenceTransformMatrix"],\t \n        "00C8" :\t["LO", "FrameOfReferenceTransformComment"]\t \n        }\n    };\n\n\n\n\n\n/*** Static Methods ***/\n\n/**\n * Returns the VR for the specified group and element.\n * @param {number} group\n * @param {number} element\n * @returns {string}\n */\ndaikon.Dictionary.getVR = function (group, element) {\n    var vr, elementData, groupData;\n\n    groupData = daikon.Dictionary.dict[daikon.Utils.dec2hex(group)];\n    if (groupData) {\n        elementData = groupData[daikon.Utils.dec2hex(element)];\n        if (elementData) {\n            vr = elementData[0];\n        } else if (element === 0) {\n            vr = \'UL\';\n        }\n    }\n\n    if (!vr) {\n        groupData = daikon.Dictionary.dictPrivate[daikon.Utils.dec2hex(group)];\n        if (groupData) {\n            elementData = groupData[daikon.Utils.dec2hex(element)];\n            if (elementData) {\n                vr = elementData[0];\n            }\n        }\n    }\n\n    if (!vr) {\n        vr = \'OB\';\n    }\n\n    return vr;\n};\n\n\n\n/**\n * Returns the description for the specified group and element.\n * @param {number} group\n * @param {number} element\n * @returns {string}\n */\ndaikon.Dictionary.getDescription = function (grouphex, elementhex) {\n    var des, elementData, groupData;\n\n    //var grouphex = daikon.Utils.dec2hex(group);\n\n    groupData = daikon.Dictionary.dict[grouphex];\n    if (groupData) {\n        elementData = groupData[elementhex];\n        if (elementData) {\n            des = elementData[1];\n        } else if (elementhex === "0000") {\n            des = ("Group " + grouphex + " Length");\n        }\n    }\n\n    if (!des) {\n        groupData = daikon.Dictionary.dictPrivate[grouphex];\n        if (groupData) {\n            if (elementData == undefined)\n                elementData = groupData[elementhex];\n            if (elementData) {\n                des = elementData[1];\n            }\n        }\n    }\n\n    if (!des) {\n        des = \'PrivateData\';\n    }\n\n    return des;\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.Dictionary;\n}\n\n},{"./utilities.js":40}],31:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\ndaikon.Tag = daikon.Tag || ((typeof require !== \'undefined\') ? require(\'./tag.js\') : null);\ndaikon.CompressionUtils = daikon.CompressionUtils || ((typeof require !== \'undefined\') ? require(\'./compression-utils.js\') : null);\ndaikon.Utils = daikon.Utils || ((typeof require !== \'undefined\') ? require(\'./utilities.js\') : null);\ndaikon.RLE = daikon.RLE || ((typeof require !== \'undefined\') ? require(\'./rle.js\') : null);\n\nvar jpeg = ((typeof require !== \'undefined\') ? require(\'jpeg-lossless-decoder-js\') : null);\nvar JpegDecoder = JpegDecoder || ((typeof require !== \'undefined\') ? require(\'../lib/jpeg-baseline.js\').JpegImage : null);\nvar JpxImage = JpxImage || ((typeof require !== \'undefined\') ? require(\'../lib/jpx.js\') : null);\n\n\n/*** Constructor ***/\n\n/**\n * The Image constructor.\n * @property {object} tags - a map of tag id to tag (see daikon.Tag.createId)\n * @property {object} tagsFlat - a flattened map of tags\n * @type {Function}\n */\ndaikon.Image = daikon.Image || function () {\n    this.tags = {};\n    this.ktags = {};\n    this.tagsFlat = {};\n    this.littleEndian = false;\n    this.index = -1;\n    this.decompressed = false;\n    this.privateDataAll = null;\n    this.convertedPalette = false;\n};\n\n\n// Kellner\nvar DICOMDICT_defaultTags = \n{\n    // could define standard values\n    \n    "PatientID":           "no_patient_id",\n    "ProtocolName":        "no_protocol_name",\n    "SeriesDescription":   "no_protocol_name",\n    \n}\n\n\ndaikon.Image.prototype.gettag = function(tag)\n{\n    var ret = undefined;\n\n    if( this.ktags[tag] !== undefined )\n    {\n        var val = this.ktags[tag].value;\n        if( val !== undefined && val !== null)\n        {\n            if(val.length == 1) // for single array elements, \n                val = val[0];\n            ret = val;\n            \n        }\n    }\n    \n    if(ret === undefined)\n    {\n        ret = DICOMDICT_defaultTags[tag] || undefined;\n    }\n    \n    return ret;\n}\n\n\n\n\n/*** Static Pseudo-constants ***/\n\ndaikon.Image.SLICE_DIRECTION_UNKNOWN = -1;\ndaikon.Image.SLICE_DIRECTION_AXIAL = 2;\ndaikon.Image.SLICE_DIRECTION_CORONAL = 1;\ndaikon.Image.SLICE_DIRECTION_SAGITTAL = 0;\ndaikon.Image.SLICE_DIRECTION_OBLIQUE = 3;\ndaikon.Image.OBLIQUITY_THRESHOLD_COSINE_VALUE = 0.8;\n\ndaikon.Image.BYTE_TYPE_UNKNOWN = 0;\ndaikon.Image.BYTE_TYPE_BINARY = 1;\ndaikon.Image.BYTE_TYPE_INTEGER = 2;\ndaikon.Image.BYTE_TYPE_INTEGER_UNSIGNED = 3;\ndaikon.Image.BYTE_TYPE_FLOAT = 4;\ndaikon.Image.BYTE_TYPE_COMPLEX = 5;\ndaikon.Image.BYTE_TYPE_RGB = 6;\n\n\n/*** Static Methods ***/\n\ndaikon.Image.getSingleValueSafely = function (tag, index) {\n    if (tag && tag.value) {\n        return tag.value[index];\n    }\n\n    return null;\n};\n\n\n\ndaikon.Image.getValueSafely = function (tag) {\n    if (tag) {\n        return tag.value;\n    }\n\n    return null;\n};\n\n\n\n// originally from: http://public.kitware.com/pipermail/insight-users/2005-March/012246.html\ndaikon.Image.getMajorAxisFromPatientRelativeDirectionCosine = function(x, y, z) {\n    var axis, orientationX, orientationY, orientationZ, absX, absY, absZ;\n\n    orientationX = (x < 0) ? "R" : "L";\n    orientationY = (y < 0) ? "A" : "P";\n    orientationZ = (z < 0) ? "F" : "H";\n\n    absX = Math.abs(x);\n    absY = Math.abs(y);\n    absZ = Math.abs(z);\n\n    // The tests here really don\'t need to check the other dimensions,\n    // just the threshold, since the sum of the squares should be == 1.0\n    // but just in case ...\n\n    if ((absX > daikon.Image.OBLIQUITY_THRESHOLD_COSINE_VALUE) && (absX > absY) && (absX > absZ)) {\n        axis = orientationX;\n    } else if ((absY > daikon.Image.OBLIQUITY_THRESHOLD_COSINE_VALUE) && (absY > absX) && (absY > absZ)) {\n        axis = orientationY;\n    } else if ((absZ > daikon.Image.OBLIQUITY_THRESHOLD_COSINE_VALUE) && (absZ > absX) && (absZ > absY)) {\n        axis = orientationZ;\n    } else {\n        axis = null;\n    }\n\n    return axis;\n};\n\n\n/*** Prototype Methods ***/\n\n/**\n * Returns the number of columns.\n * @returns {number}\n */\ndaikon.Image.prototype.getCols = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_COLS[0], daikon.Tag.TAG_COLS[1]), 0);\n};\n\n\n\n/**\n * Returns the number of rows.\n * @returns {number}\n */\ndaikon.Image.prototype.getRows = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_ROWS[0], daikon.Tag.TAG_ROWS[1]), 0);\n};\n\n\n\n/**\n * Returns the series description.\n * @returns {string}\n */\ndaikon.Image.prototype.getSeriesDescription = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_SERIES_DESCRIPTION[0], daikon.Tag.TAG_SERIES_DESCRIPTION[1]), 0);\n};\n\n\n\n/**\n * Returns the series instance UID.\n * @returns {string}\n */\ndaikon.Image.prototype.getSeriesInstanceUID = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_SERIES_INSTANCE_UID[0], daikon.Tag.TAG_SERIES_INSTANCE_UID[1]), 0);\n};\n\n\n\n/**\n * Returns the series number.\n * @returns {number}\n */\ndaikon.Image.prototype.getSeriesNumber = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_SERIES_NUMBER[0], daikon.Tag.TAG_SERIES_NUMBER[1]), 0);\n};\n\n\n\n/**\n * Returns the echo number.\n * @returns {number}\n */\ndaikon.Image.prototype.getEchoNumber = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_ECHO_NUMBER[0], daikon.Tag.TAG_ECHO_NUMBER[1]), 0);\n};\n\n\n\n/**\n * Returns the image position.\n * @return {number[]}\n */\ndaikon.Image.prototype.getImagePosition = function () {\n    return daikon.Image.getValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_POSITION[0], daikon.Tag.TAG_IMAGE_POSITION[1]));\n};\n\n/**\n * Returns the image axis directions\n * @return {number[]}\n */\ndaikon.Image.prototype.getImageDirections = function () {\n    return daikon.Image.getValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_ORIENTATION[0], daikon.Tag.TAG_IMAGE_ORIENTATION[1]))\n}\n\n\n/**\n * Returns the image position value by index.\n * @param {number} sliceDir - the index\n * @returns {number}\n */\ndaikon.Image.prototype.getImagePositionSliceDir = function (sliceDir) {\n    var imagePos = daikon.Image.getValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_POSITION[0], daikon.Tag.TAG_IMAGE_POSITION[1]));\n    if (imagePos) {\n        if (sliceDir >= 0) {\n            return imagePos[sliceDir];\n        }\n    }\n\n    return 0;\n};\n\n\n\n/**\n * Returns the slice location.\n * @returns {number}\n */\ndaikon.Image.prototype.getSliceLocation = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_SLICE_LOCATION[0], daikon.Tag.TAG_SLICE_LOCATION[1]), 0);\n};\n\n\n\n/**\n * Returns the slice location vector.\n * @returns {number[]}\n */\ndaikon.Image.prototype.getSliceLocationVector = function () {\n    return daikon.Image.getValueSafely(this.getTag(daikon.Tag.TAG_SLICE_LOCATION_VECTOR[0], daikon.Tag.TAG_SLICE_LOCATION_VECTOR[1]));\n};\n\n\n\n/**\n * Returns the image number.\n * @returns {number}\n */\ndaikon.Image.prototype.getImageNumber = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_NUM[0], daikon.Tag.TAG_IMAGE_NUM[1]), 0);\n};\n\n\n/**\n * Returns the temporal position.\n * @returns {number}\n */\ndaikon.Image.prototype.getTemporalPosition = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_TEMPORAL_POSITION[0], daikon.Tag.TAG_TEMPORAL_POSITION[1]), 0);\n};\n\n\n/**\n * Returns the temporal number.\n * @returns {number}\n */\ndaikon.Image.prototype.getTemporalNumber = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_NUMBER_TEMPORAL_POSITIONS[0], daikon.Tag.TAG_NUMBER_TEMPORAL_POSITIONS[1]), 0);\n};\n\n\n/**\n * Returns the slice gap.\n * @returns {number}\n */\ndaikon.Image.prototype.getSliceGap = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_SLICE_GAP[0], daikon.Tag.TAG_SLICE_GAP[1]), 0);\n};\n\n\n/**\n * Returns the slice thickness.\n * @returns {number}\n */\ndaikon.Image.prototype.getSliceThickness = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_SLICE_THICKNESS[0], daikon.Tag.TAG_SLICE_THICKNESS[1]), 0);\n};\n\n\n/**\n * Returns the image maximum.\n * @returns {number}\n */\ndaikon.Image.prototype.getImageMax = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_MAX[0], daikon.Tag.TAG_IMAGE_MAX[1]), 0);\n};\n\n\n/**\n * Returns the image minimum.\n * @returns {number}\n */\ndaikon.Image.prototype.getImageMin = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_MIN[0], daikon.Tag.TAG_IMAGE_MIN[1]), 0);\n};\n\n\n/**\n * Returns the rescale slope.\n * @returns {number}\n */\ndaikon.Image.prototype.getDataScaleSlope = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_DATA_SCALE_SLOPE[0], daikon.Tag.TAG_DATA_SCALE_SLOPE[1]), 0);\n};\n\n\n/**\n * Returns the rescale intercept.\n * @returns {number}\n */\ndaikon.Image.prototype.getDataScaleIntercept = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_DATA_SCALE_INTERCEPT[0], daikon.Tag.TAG_DATA_SCALE_INTERCEPT[1]), 0);\n};\n\n\n\ndaikon.Image.prototype.getDataScaleElscint = function () {\n    var scale = daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_DATA_SCALE_ELSCINT[0], daikon.Tag.TAG_DATA_SCALE_ELSCINT[1]), 0);\n\n    if (!scale) {\n        scale = 1;\n    }\n\n    var bandwidth = this.getPixelBandwidth();\n    scale = Math.sqrt(bandwidth) / (10 * scale);\n\n    if (scale <= 0) {\n        scale = 1;\n    }\n\n    return scale;\n};\n\n\n/**\n * Returns the window width.\n * @returns {number}\n */\ndaikon.Image.prototype.getWindowWidth = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_WINDOW_WIDTH[0], daikon.Tag.TAG_WINDOW_WIDTH[1]), 0);\n};\n\n\n/**\n * Returns the window center.\n * @returns {number}\n */\ndaikon.Image.prototype.getWindowCenter = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_WINDOW_CENTER[0], daikon.Tag.TAG_WINDOW_CENTER[1]), 0);\n};\n\n\n\ndaikon.Image.prototype.getPixelBandwidth = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_PIXEL_BANDWIDTH[0], daikon.Tag.TAG_PIXEL_BANDWIDTH[1]), 0);\n};\n\n\n\ndaikon.Image.prototype.getSeriesId = function () {\n    var des = this.getSeriesDescription();\n    var uid = this.getSeriesInstanceUID();\n    var num = this.getSeriesNumber();\n    var echo = this.getEchoNumber();\n    var orientation = this.getOrientation();\n    var cols = this.getCols();\n    var rows = this.getRows();\n\n    var id = "";\n\n    if (des !== null) {\n        id += (" " + des);\n    }\n\n    if (uid !== null) {\n        id += (" " + uid);\n    }\n\n    if (num !== null) {\n        id += (" " + num);\n    }\n\n    if (echo !== null) {\n        id += (" " + echo);\n    }\n\n    if (orientation !== null) {\n        id += (" " + orientation);\n    }\n\n    id += (" (" + cols + " x " + rows + ")");\n\n    return id;\n};\n\n\n/**\n * Returns the pixel spacing.\n * @returns {number[]}\n */\ndaikon.Image.prototype.getPixelSpacing = function () {\n    return daikon.Image.getValueSafely(this.getTag(daikon.Tag.TAG_PIXEL_SPACING[0], daikon.Tag.TAG_PIXEL_SPACING[1]));\n};\n\n\n/**\n * Returns the image type.\n * @returns {string[]}\n */\ndaikon.Image.prototype.getImageType = function () {\n    return daikon.Image.getValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_TYPE[0], daikon.Tag.TAG_IMAGE_TYPE[1]));\n};\n\n\n/**\n * Returns the number of bits stored.\n * @returns {number}\n */\ndaikon.Image.prototype.getBitsStored = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_BITS_STORED[0], daikon.Tag.TAG_BITS_STORED[1]), 0);\n};\n\n\n/**\n * Returns the number of bits allocated.\n * @returns {number}\n */\ndaikon.Image.prototype.getBitsAllocated = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_BITS_ALLOCATED[0], daikon.Tag.TAG_BITS_ALLOCATED[1]), 0);\n};\n\n\n/**\n * Returns the frame time.\n * @returns {number}\n */\ndaikon.Image.prototype.getFrameTime = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_FRAME_TIME[0], daikon.Tag.TAG_FRAME_TIME[1]), 0);\n};\n\n\n/**\n * Returns the acquisition matrix (e.g., "mosaic" data).\n * @returns {number[]}\n */\ndaikon.Image.prototype.getAcquisitionMatrix = function () {\n    var mat, matPrivate, start, end, str;\n\n    mat = [0, 0];\n\n    var acqmat = this.getTag(daikon.Tag.TAG_ACQUISITION_MATRIX[0], daikon.Tag.TAG_ACQUISITION_MATRIX[1]);\n    if (acqmat != undefined && acqmat.value != undefined)\n    {\n\n        acqmat = acqmat.value;\n\n        if (acqmat[0] == 0)\n            acqmat[0] = acqmat[2];\n        if (acqmat[1] == 0)\n            acqmat[1] = acqmat[3];\n\n        mat[0] = acqmat[0];\n        mat[1] = acqmat[1];\n    }\n\n    \n    if (this.privateDataAll === null) \n    {\n        this.privateDataAll = this.getAllInterpretedPrivateData();\n    }\n\n    if (mat[0] == 0 || mat[1] == 0)\n    {\n        if ((this.privateDataAll !== null) && (this.privateDataAll.length > 0)) {\n            start = this.privateDataAll.indexOf("AcquisitionMatrixText");\n            if (start !== -1) {\n\n                end = this.privateDataAll.indexOf(\'\\n\', start);\n\n                if (end !== -1) {\n                    str = this.privateDataAll.substring(start, end);\n                    matPrivate = str.match(/\\d+/g);\n\n                    if ((matPrivate !== null) && (matPrivate.length === 2)) {\n                        mat[0] = matPrivate[1];\n                        mat[1] = matPrivate[0];\n                    } else if ((matPrivate !== null) && (matPrivate.length === 1)) {\n                        mat[0] = matPrivate[0];\n                    }\n                }\n            }\n        }\n        else\n            console.log("No Acqmat info for Mosaic, reading completely failed :((");\n    }\n\n\n    if (mat[1] === 0) {\n        mat[1] = mat[0];\n    }\n\n\n   //var shdr =this.images[0].gettag(\'CSAImageHeaderInfo\');\n   var shdr = this.privateDataAll;\n   if( this.NumberOfImagesInMosaic == undefined)\n   {\n        var sn = shdr.match(/NumberOfImagesInMosaic=([-\\d.\\s]+)\\n/);\n        if(sn != null && sn.length > 1)\n        {\n            this.NumberOfImagesInMosaic = parseInt(sn[1]);\n        }\n    }\n\n    // still no NumberOfImagesInMosaic found? (=> old vsi sequence) => try to guess by division\n   if( this.NumberOfImagesInMosaic == undefined)\n   {\n        this.NumberOfImagesInMosaic = (this.getRows() / mat[1])* (this.getCols() / mat[0]); \n   }\n\n\n    // quadratic mosaic => can apply workaround for wrong AcquisitionMatrixText\n    if(this.getRows() % mat[1] != 0 | this.getCols() % mat[0] != 0 )\n    {\n        // something went wrong (siemens ASL mosaics can have wrong AcquisitionMatrixText, 62*64 ) ??\n        console.log("something with the mosaic dimensions wrong, assuming quadratic array");\n        console.log("acqmat found in header:" + mat[0] + "," + mat[1]);\n        var ss = math.ceil(math.sqrt(this.NumberOfImagesInMosaic));\n        mat[0] = this.getRows()/ss;\n        mat[1] = this.getRows()/ss;\n        console.log("acqmat assumed:" + mat[0] + "," + mat[1]);\n    }\n\n\n    return mat;\n};\n\n\n/**\n * Returns the TR.\n * @returns {number}\n */\ndaikon.Image.prototype.getTR = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_TR, daikon.Tag.TAG_TR[1]), 0);\n};\n\n\n\ndaikon.Image.prototype.putTag = function (tag) {\n    this.tags[tag.id] = tag;\n    this.putFlattenedTag(this.tagsFlat, tag);\n    this.ktags[tag.key] = tag;\n};\n\n\n\ndaikon.Image.prototype.putFlattenedTag = function (tags, tag) {\n    var ctr;\n\n    if (tag.sublist) \n    {\n        for (ctr = 0; ctr < tag.value.length; ctr += 1) \n        {\n            this.putFlattenedTag(tags, tag.value[ctr]);\n        }\n    } \n    else \n    {\n        if (!tags[tag.id]) \n        {\n            tags[tag.id] = tag;\n        }\n\n        if(this.ktags[tag.key] == undefined)\n        {\n            this.ktags[tag.key] = tag;\n        }\n        else // multiple values, eg in multiframe images. --\x3e put as array\n        {\n            if(this.ktags[tag.key].multival == undefined)\n                this.ktags[tag.key].multival = [ this.ktags[tag.key].value ];\n            // add current\n            this.ktags[tag.key].multival.push( tag.value );\n        }\n\n    }\n};\n\n\n/**\n * Returns a tag matching the specified group and element.\n * @param {number} group\n * @param {number} element\n * @returns {daikon.Tag}\n */\ndaikon.Image.prototype.getTag = function (group, element) {\n    return this.tagsFlat[daikon.Tag.createId(group, element)];\n};\n\n\n/**\n * Returns the pixel data tag.\n * @returns {daikon.Tag}\n */\ndaikon.Image.prototype.getPixelData = function () {\n    return this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])];\n};\n\n\n\ndaikon.Image.prototype.getPixelDataBytes = function () \n{\n    if (this.isCompressed()) \n    {\n        this.decompress();\n    }\n\n    if (this.isPalette()) \n    {\n        this.convertPalette();\n    }\n    var v = this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])];\n    \n    if (v && v.value)\n        return v.value.buffer;\n};\n\n\n/**\n * Returns the raw pixel data.\n * @returns {ArrayBuffer}\n */\ndaikon.Image.prototype.getRawData = function () {\n    return this.getPixelDataBytes();\n};\n\n\n/**\n * Returns interpreted pixel data (considers datatype, byte order, data scales).\n * @param {boolean} asArray - if true, the returned data is a JavaScript Array\n * @param {boolean} asObject - if true, an object is returned with properties: data, min, max, minIndex, maxIndex, numCols, numRows\n * @returns {Float32Array|Array|object}\n */\ndaikon.Image.prototype.getInterpretedData = function (asArray, asObject) \n{\n    var datatype, numBytes, numElements, dataView, data, ctr, mask, slope, intercept, min, max, value, minIndex,\n        maxIndex, littleEndian, rawValue, rawData;\n    mask = daikon.Utils.createBitMask(this.getBitsAllocated() / 8, this.getBitsStored(),\n        this.getDataType() === daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED);\n    datatype = this.getDataType();\n    numBytes = this.getBitsAllocated() / 8;\n    rawData = this.getRawData();\n    dataView = new DataView(rawData);\n    numElements = rawData.byteLength / numBytes;\n    slope = this.getDataScaleSlope() || 1;\n    intercept = this.getDataScaleIntercept() || 0;\n    min = daikon.Utils.MAX_VALUE;\n    max = daikon.Utils.MIN_VALUE;\n    minIndex = -1;\n    maxIndex = -1;\n    littleEndian = this.littleEndian;\n\n//     if (asArray) \n//     {\n//         data = [];\n//         data = new Uint16Array(numElements);\n//     } \n//     else \n//     {\n//         data = new Float32Array(numElements);\n//     }\n    \n    // always use uint16 for now!\n    data = new Uint16Array(numElements);\n\n    for (ctr = 0; ctr < numElements; ctr += 1) \n    {\n        if (datatype === daikon.Image.BYTE_TYPE_INTEGER) \n        {\n            if (numBytes === 1) \n                rawValue = dataView.getInt8(ctr * numBytes);\n            else if (numBytes === 2) \n                rawValue = dataView.getInt16(ctr * numBytes, littleEndian);\n        } \n        else if (datatype === daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED) \n        {\n            if (numBytes === 1) \n                rawValue = dataView.getUint8(ctr * numBytes);\n            else if (numBytes === 2) \n                rawValue = dataView.getUint16(ctr * numBytes, littleEndian);\n        }\n        else if (datatype === daikon.Image.BYTE_TYPE_RGB) \n        {\n                // Kellner: RGB has to be properly implemented.\n                rawValue = dataView.getUint8(ctr * numBytes);\n        }\n\n        value = (rawValue & mask);\n        // NO! do not multiply with slope! write this into the nifti !\n        //value = value * slope) + intercept;\n        value = Math.round(value);\n        data[ctr] = value;\n\n        if (value < min) { min = value; minIndex = ctr; }\n        if (value > max) { max = value; maxIndex = ctr; }\n    }\n\n    if (asObject) {\n        return {data: data, min: min, minIndex: minIndex, max: max, maxIndex: maxIndex, numCols: this.getCols(),\n            numRows: this.getRows()};\n    }\n\n    return data;\n};\n\n\n\ndaikon.Image.prototype.convertPalette = function () {\n    var data, reds, greens, blues, rgb, numBytes, numElements, ctr, index, rVal, gVal, bVal;\n\n    data = this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])].value;\n\n    reds = this.getPalleteValues(daikon.Tag.TAG_PALETTE_RED);\n    greens = this.getPalleteValues(daikon.Tag.TAG_PALETTE_GREEN);\n    blues = this.getPalleteValues(daikon.Tag.TAG_PALETTE_BLUE);\n\n    if ((reds !== null) && (reds.length > 0) && (greens !== null) && (greens.length > 0) && (blues !== null) &&\n            (blues.length > 0) && !this.convertedPalette) {\n        rgb = new DataView(new ArrayBuffer(this.getRows() * this.getCols() * this.getNumberOfFrames() * 3));\n        numBytes = parseInt(Math.ceil(this.getBitsAllocated() / 8));\n        numElements = data.byteLength / numBytes;\n\n        if (numBytes === 1) {\n            for (ctr = 0; ctr < numElements; ctr += 1) {\n                index = data.getUint8(ctr);\n                rVal = reds[index];\n                gVal = greens[index];\n                bVal = blues[index];\n                rgb.setUint8((ctr * 3), rVal);\n                rgb.setUint8((ctr * 3) + 1, gVal);\n                rgb.setUint8((ctr * 3) + 2, bVal);\n            }\n        } else if (numBytes === 2) {\n            for (ctr = 0; ctr < numElements; ctr += 1) {\n                index = data.getUint16(ctr * 2);\n                rVal = reds[index];\n                gVal = greens[index];\n                bVal = blues[index];\n                rgb.setUint8((ctr * 3), rVal);\n                rgb.setUint8((ctr * 3) + 1, gVal);\n                rgb.setUint8((ctr * 3) + 2, bVal);\n            }\n        }\n\n        data = rgb;\n        this.convertedPalette = true;\n    }\n\n    this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])].value = data;\n};\n\n\n\n\ndaikon.Image.prototype.decompress = function () {\n    var jpegs, rle, decoder, decompressed, numFrames, frameSize, temp, ctr, width, height, numComponents, decoded;\n\n    decompressed = null;\n\n    if (!this.decompressed) {\n        this.decompressed = true;\n\n        frameSize = this.getRows() * this.getCols() * parseInt(Math.ceil(this.getBitsAllocated() / 8));\n        numFrames = this.getNumberOfFrames();\n\n        if (this.isCompressedJPEGLossless()) {\n            jpegs = this.getJpegs();\n\n            for (ctr = 0; ctr < jpegs.length; ctr+=1) {\n                decoder = new jpeg.lossless.Decoder();\n                temp = decoder.decode(jpegs[ctr]);\n                numComponents = decoder.numComp;\n\n                if (decompressed === null) {\n                    decompressed = new DataView(new ArrayBuffer(frameSize * numFrames * numComponents));\n                }\n\n                (new Uint8Array(decompressed.buffer)).set(new Uint8Array(temp.buffer), (ctr * frameSize * numComponents));\n                temp = null;\n            }\n\n            this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])].value = decompressed;\n        } else if (this.isCompressedJPEGBaseline()) {\n            jpegs = this.getJpegs();\n\n            for (ctr = 0; ctr < jpegs.length; ctr+=1) {\n                decoder = new JpegDecoder();\n                decoder.parse(new Uint8Array(jpegs[ctr]));\n                width = decoder.width;\n                height = decoder.height;\n                numComponents = decoder.components.length;\n\n                if (decompressed === null) {\n                    decompressed = new DataView(new ArrayBuffer(frameSize * numFrames * numComponents));\n                }\n\n                if (this.getBitsAllocated() === 8) {\n                    decoded = decoder.getData(width, height);\n                } else if (this.getBitsAllocated() === 16) {\n                    decoded = decoder.getData16(width, height);\n                }\n\n                daikon.Utils.fillBuffer(decoded, decompressed, (ctr * frameSize * numComponents),\n                    parseInt(Math.ceil(this.getBitsAllocated() / 8)));\n\n                decoded = null;\n            }\n\n            this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])].value = decompressed;\n        } else if (this.isCompressedJPEG2000()) {\n            jpegs = this.getJpegs();\n\n            for (ctr = 0; ctr < jpegs.length; ctr+=1) {\n                decoder = new JpxImage();\n                decoder.parse(new Uint8Array(jpegs[ctr]));\n                width = decoder.width;\n                height = decoder.height;\n                decoded = decoder.tiles[0].items;\n                numComponents = decoder.componentsCount;\n\n                if (decompressed === null) {\n                    decompressed = new DataView(new ArrayBuffer(frameSize * numFrames * numComponents));\n                }\n\n                daikon.Utils.fillBuffer(decoded, decompressed, (ctr * frameSize * numComponents),\n                    parseInt(Math.ceil(this.getBitsAllocated() / 8)));\n\n                decoded = null;\n            }\n\n            this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])].value = decompressed;\n        } else if (this.isCompressedRLE()) {\n            rle = this.getRLE();\n\n            for (ctr = 0; ctr < rle.length; ctr+=1) {\n                decoder = new daikon.RLE();\n                temp = decoder.decode(rle[ctr], this.littleEndian, this.getRows() * this.getCols());\n                numComponents = (decoder.numSegments === 3 ? 3 : 1);\n\n                if (decompressed === null) {\n                    decompressed = new DataView(new ArrayBuffer(frameSize * numFrames * numComponents));\n                }\n\n                (new Uint8Array(decompressed.buffer)).set(new Uint8Array(temp.buffer), (ctr * frameSize * numComponents));\n                temp = null;\n            }\n\n            this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])].value = decompressed;\n        }\n    }\n};\n\n\n/**\n * Returns true if pixel data is found.\n * @returns {boolean}\n */\ndaikon.Image.prototype.hasPixelData = function () {\n    return (this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])] !== undefined);\n};\n\n\n\ndaikon.Image.prototype.clearPixelData = function () {\n    this.tags[daikon.Tag.createId(daikon.Tag.TAG_PIXEL_DATA[0], daikon.Tag.TAG_PIXEL_DATA[1])].value = null;\n};\n\n\n/**\n * Returns an orientation string (e.g., XYZ+--).\n * @returns {string}\n */\ndaikon.Image.prototype.getOrientation = function () {\n    var orientation = null,\n        dirCos = daikon.Image.getValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_ORIENTATION[0], daikon.Tag.TAG_IMAGE_ORIENTATION[1])),\n        ctr,\n        spacing,\n        rowSpacing,\n        swapZ,\n        bigRow = 0, bigCol = 0,\n        biggest = 0, orient = \'\';\n\n    if (!dirCos || (dirCos.length !== 6)) {\n        return null;\n    }\n\n    spacing = this.getPixelSpacing();\n\n    if (!spacing) {\n        return null;\n    }\n\n    rowSpacing = spacing[0];\n    swapZ = true;\n\n    for (ctr = 0; ctr < 3; ctr += 1) {\n        if (Math.abs(dirCos[ctr]) > biggest) {\n            biggest = Math.abs(dirCos[ctr]);\n            bigRow = ctr;\n        }\n    }\n\n    biggest = 0;\n    for (; ctr < 6; ctr += 1) {\n        if (Math.abs(dirCos[ctr]) > biggest) {\n            biggest = Math.abs(dirCos[ctr]);\n            bigCol = ctr;\n        }\n    }\n\n    switch (bigRow) {\n        case 0:\n            orient += (\'X\');\n            if (bigCol === 4) {\n                orient += ("YZ");\n            } else {\n                orient += ("ZY");\n            }\n            break;\n        case 1:\n            orient += (\'Y\');\n            if (bigCol === 3) {\n                orient += ("XZ");\n            } else {\n                orient += ("ZX");\n            }\n            break;\n        case 2:\n            orient += (\'Z\');\n            if (bigCol === 3) {\n                orient += ("XY");\n            } else {\n                orient += ("YX");\n            }\n            break;\n        default:\n            break;\n    }\n\n    switch (bigRow) {\n        case 0:\n            if (dirCos[bigRow] > 0.0) {\n                orient += (\'-\');\n            } else {\n                orient += (\'+\');\n            }\n            if (bigCol === 4) {\n                if (dirCos[bigCol] > 0.0) {\n                    orient += (\'-\');\n                } else {\n                    orient += (\'+\');\n                }\n            } else {\n                if (dirCos[bigCol] > 0.0) {\n                    orient += (\'+\');\n                } else {\n                    orient += (\'-\');\n                }\n            }\n            break;\n        case 1:\n            if (dirCos[bigRow] > 0.0) {\n                orient += (\'-\');\n            } else {\n                orient += (\'+\');\n            }\n            if (bigCol === 3) {\n                if (dirCos[bigCol] > 0.0) {\n                    orient += (\'-\');\n                } else {\n                    orient += (\'+\');\n                }\n            } else {\n                if (dirCos[bigCol] > 0.0) {\n                    orient += (\'+\');\n                } else {\n                    orient += (\'-\');\n                }\n            }\n            break;\n        case 2:\n            if (dirCos[bigRow] > 0.0) {\n                orient += (\'+\');\n            } else {\n                orient += (\'-\');\n            }\n            //Has to be X or Y so opposite senses\n            if (dirCos[bigCol] > 0.0) {\n                orient += (\'-\');\n            } else {\n                orient += (\'+\');\n            }\n            break;\n        default:\n            break;\n    }\n\n    if (rowSpacing === 0.0) {\n        orient += (\'+\');\n        orientation = orient;\n    } else {\n        if (swapZ) {\n            switch (orient.charAt(2)) {\n                case \'X\':\n                    if (rowSpacing > 0.0) {\n                        orient += (\'-\');\n                    } else {\n                        orient += (\'+\');\n                    }\n                    break;\n                case \'Y\':\n                case \'Z\':\n                    if (rowSpacing > 0.0) {\n                        orient += (\'+\');\n                    } else {\n                        orient += (\'-\');\n                    }\n                    break;\n                default:\n                    break;\n            }\n        } else {\n            switch (orient.charAt(2)) {\n                case \'X\':\n                    if (rowSpacing > 0.0) {\n                        orient += (\'+\');\n                    } else {\n                        orient += (\'-\');\n                    }\n                    break;\n                case \'Y\':\n                case \'Z\':\n                    if (rowSpacing > 0.0) {\n                        orient += (\'-\');\n                    } else {\n                        orient += (\'+\');\n                    }\n                    break;\n                default:\n                    break;\n            }\n        }\n\n        orientation = orient;\n    }\n\n    return orientation;\n};\n\n\n/**\n * Returns true if this image is "mosaic".\n * @returns {boolean}\n */\ndaikon.Image.prototype.isMosaic = function () {\n    var imageType, labeledAsMosaic = false, canReadAsMosaic, ctr, matSize;\n\n    imageType = this.getImageType();\n\n    if (imageType !== null) {\n        for (ctr = 0; ctr < imageType.length; ctr += 1) {\n            if (imageType[ctr].toUpperCase().indexOf("MOSAIC") !== -1) {\n                labeledAsMosaic = true;\n                break;\n            }\n        }\n    }\n\n    if(labeledAsMosaic)\n    {\n        matSize = this.getAcquisitionMatrix();\n        canReadAsMosaic = (matSize[0] > 0) && ((matSize[0] < this.getRows()) || (matSize[1] < this.getCols()));\n    }\n    return labeledAsMosaic && canReadAsMosaic;\n};\n\n\n/**\n * Returns true if this image uses palette colors.\n * @returns {boolean}\n */\ndaikon.Image.prototype.isPalette = function () {\n    var value = daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_PHOTOMETRIC_INTERPRETATION[0], daikon.Tag.TAG_PHOTOMETRIC_INTERPRETATION[1]), 0);\n\n    if (value !== null) {\n        if (value.toLowerCase().indexOf("palette") !== -1) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n\ndaikon.Image.prototype.getMosaicCols = function() {\n    return this.getCols() / this.getAcquisitionMatrix()[0];\n};\n\n\n\ndaikon.Image.prototype.getMosaicRows = function() {\n    return this.getRows() / this.getAcquisitionMatrix()[1];\n};\n\n\n\ndaikon.Image.prototype.isElscint = function() {\n    var tag = this.getTag(daikon.Tag.TAG_DATA_SCALE_ELSCINT[0], daikon.Tag.TAG_DATA_SCALE_ELSCINT[1]);\n    return (tag !== undefined);\n};\n\n\n/**\n * Returns true if this image stores compressed data.\n * @returns {boolean}\n */\ndaikon.Image.prototype.isCompressed = function() {\n    daikon.Parser = daikon.Parser || ((typeof require !== \'undefined\') ? require(\'./parser.js\') : null);\n\n    var transferSyntax = this.getTransferSyntax();\n    if (transferSyntax) {\n        if (transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG) !== -1) {\n            return true;\n        } else if (transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_RLE) !== -1) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Returns true if this image stores JPEG data.\n * @returns {boolean}\n */\ndaikon.Image.prototype.isCompressedJPEG = function() {\n    daikon.Parser = daikon.Parser || ((typeof require !== \'undefined\') ? require(\'./parser.js\') : null);\n\n    var transferSyntax = this.getTransferSyntax();\n    if (transferSyntax) {\n        if (transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG) !== -1) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Returns true of this image stores lossless JPEG data.\n * @returns {boolean}\n */\ndaikon.Image.prototype.isCompressedJPEGLossless = function() {\n    daikon.Parser = daikon.Parser || ((typeof require !== \'undefined\') ? require(\'./parser.js\') : null);\n\n    var transferSyntax = this.getTransferSyntax();\n    if (transferSyntax) {\n        if ((transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_LOSSLESS) !== -1) ||\n            (transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_LOSSLESS_SEL1) !== -1)) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Returns true if this image stores baseline JPEG data.\n * @returns {boolean}\n */\ndaikon.Image.prototype.isCompressedJPEGBaseline = function() {\n    daikon.Parser = daikon.Parser || ((typeof require !== \'undefined\') ? require(\'./parser.js\') : null);\n\n    var transferSyntax = this.getTransferSyntax();\n    if (transferSyntax) {\n        if ((transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_BASELINE_8BIT) !== -1) ||\n            (transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_BASELINE_12BIT) !== -1)) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Returns true if this image stores JPEG2000 data.\n * @returns {boolean}\n */\ndaikon.Image.prototype.isCompressedJPEG2000 = function() {\n    daikon.Parser = daikon.Parser || ((typeof require !== \'undefined\') ? require(\'./parser.js\') : null);\n\n    var transferSyntax = this.getTransferSyntax();\n    if (transferSyntax) {\n        if ((transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_2000) !== -1) ||\n            (transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_2000_LOSSLESS) !== -1)) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Returns true if this image stores RLE data.\n * @returns {boolean}\n */\ndaikon.Image.prototype.isCompressedRLE = function() {\n    daikon.Parser = daikon.Parser || ((typeof require !== \'undefined\') ? require(\'./parser.js\') : null);\n\n    var transferSyntax = this.getTransferSyntax();\n    if (transferSyntax) {\n        if (transferSyntax.indexOf(daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_RLE) !== -1) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n/**\n * Returns the number of frames.\n * @returns {number}\n */\ndaikon.Image.prototype.getNumberOfFrames = function () {\n    var value = daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_NUMBER_OF_FRAMES[0], daikon.Tag.TAG_NUMBER_OF_FRAMES[1]), 0);\n\n    if (value !== null) {\n        return value;\n    }\n\n    return 1;\n};\n\n\n/**\n * Returns the number of samples per pixel.\n * @returns {number}\n */\ndaikon.Image.prototype.getNumberOfSamplesPerPixel = function () {\n    var value = daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_SAMPLES_PER_PIXEL[0], daikon.Tag.TAG_SAMPLES_PER_PIXEL[1]), 0);\n\n    if (value !== null) {\n        return value;\n    }\n\n    return 1;\n};\n\n\n\ndaikon.Image.prototype.getNumberOfImplicitFrames = function () {\n    var pixelData, length, size;\n\n    if (this.isCompressed()) {\n        return 1;\n    }\n\n    pixelData = this.getPixelData();\n    length = pixelData.offsetEnd - pixelData.offsetValue;\n    size = this.getCols() * this.getRows() * (parseInt(this.getBitsAllocated() / 8));\n\n    var r = parseInt(length / size);\n    if (!isNaN(r) )\n        return r;\n    else\n        return 1;\n\n};\n\n\n/**\n * Returns the pixel representation.\n * @returns {number}\n */\ndaikon.Image.prototype.getPixelRepresentation = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_PIXEL_REPRESENTATION[0], daikon.Tag.TAG_PIXEL_REPRESENTATION[1]), 0);\n};\n\n\n/**\n * Returns the photometric interpretation.\n * @returns {string}\n */\ndaikon.Image.prototype.getPhotometricInterpretation = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_PHOTOMETRIC_INTERPRETATION[0], daikon.Tag.TAG_PHOTOMETRIC_INTERPRETATION[1]), 0);\n};\n\n\n/**\n * Returns the patient name.\n * @returns {string}\n */\ndaikon.Image.prototype.getPatientName = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_PATIENT_NAME[0], daikon.Tag.TAG_PATIENT_NAME[1]), 0);\n};\n\n\n/**\n * Returns the patient ID.\n * @returns {string}\n */\ndaikon.Image.prototype.getPatientID = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_PATIENT_ID[0], daikon.Tag.TAG_PATIENT_ID[1]), 0);\n};\n\n\n/**\n * Returns the study time.\n * @returns {string}\n */\ndaikon.Image.prototype.getStudyTime = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_STUDY_TIME[0], daikon.Tag.TAG_STUDY_TIME[1]), 0);\n};\n\n\n/**\n * Returns the transfer syntax.\n * @returns {string}\n */\ndaikon.Image.prototype.getTransferSyntax = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_TRANSFER_SYNTAX[0], daikon.Tag.TAG_TRANSFER_SYNTAX[1]), 0);\n};\n\n\n/**\n * Returns the study date.\n * @returns {string}\n */\ndaikon.Image.prototype.getStudyDate = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_STUDY_DATE[0], daikon.Tag.TAG_STUDY_DATE[1]), 0);\n};\n\n\n/**\n * Returns the planar configuration.\n * @returns {number}\n */\ndaikon.Image.prototype.getPlanarConfig = function () {\n    return daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_PLANAR_CONFIG[0], daikon.Tag.TAG_PLANAR_CONFIG[1]), 0);\n};\n\n\n/**\n * Returns all descriptive info for this image.\n * @returns {string}\n */\ndaikon.Image.prototype.getImageDescription = function () {\n    var value, string = "";\n\n    value = daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_STUDY_DES[0], daikon.Tag.TAG_STUDY_DES[1]), 0);\n    if (value !== null) {\n        string += (" " + value);\n    }\n\n    value = daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_SERIES_DESCRIPTION[0], daikon.Tag.TAG_SERIES_DESCRIPTION[1]), 0);\n    if (value !== null) {\n        string += (" " + value);\n    }\n\n    value = daikon.Image.getSingleValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_COMMENTS[0], daikon.Tag.TAG_IMAGE_COMMENTS[1]), 0);\n    if (value !== null) {\n        string += (" " + value);\n    }\n\n    return string.trim();\n};\n\n\n/**\n * Returns the datatype (e.g., daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED).\n * @returns {number}\n */\ndaikon.Image.prototype.getDataType = function () {\n    var interp, dataType;\n\n    dataType = this.getPixelRepresentation();\n\n    if (dataType === null) {\n        return daikon.Image.BYTE_TYPE_UNKNOWN;\n    }\n\n    interp = this.getPhotometricInterpretation();\n    if (interp !== null) {\n        if ((interp.trim().indexOf(\'RGB\') !== -1) || (interp.trim().indexOf(\'YBR\') !== -1) ||\n                (interp.trim().toLowerCase().indexOf(\'palette\') !== -1)) {\n            return daikon.Image.BYTE_TYPE_RGB;\n        }\n    }\n\n    if (dataType === 0) {\n        return daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED;\n    } else if (dataType === 1) {\n        return daikon.Image.BYTE_TYPE_INTEGER;\n    } else {\n        return daikon.Image.BYTE_TYPE_UNKNOWN;\n    }\n};\n\n\n// Kellner: find slice dir based on all slice vectors\n/*\ndaikon.Series.prototype.getAcquiredSliceDirection = function () \n{   \n    var img = this.images;\n    var pmin = img[k].getImagePosition();\n    var pmax = img[k].getImagePosition();\n\n    for(var k=0; k< img.length; k++)\n    {\n        var p = img[k].getImagePosition();\n        for(var j=0; j<3; j++)\n        {\n            if(p[j] < pmin[j] ) \n                pmin[j] = p[j];\n            if(p[j] < pmax[j] ) \n                pmax[j] = p[j];\n        }\n    }\n    var idx = findIndexOfGreatest([pmax[0] - pmin[0], pmax[1] - pmin[1],pmax[2] - pmin[2] ]);\n    \n    return idx;\n}\n*/\n\n\n// originally from: http://public.kitware.com/pipermail/insight-users/2005-March/012246.html\ndaikon.Image.prototype.getAcquiredSliceDirection = function () {\n    var dirCos, rowAxis, colAxis, label;\n\n    dirCos = daikon.Image.getValueSafely(this.getTag(daikon.Tag.TAG_IMAGE_ORIENTATION[0], daikon.Tag.TAG_IMAGE_ORIENTATION[1]));\n\n    if (!dirCos || (dirCos.length !== 6)) {\n        return daikon.Image.SLICE_DIRECTION_UNKNOWN;\n    }\n\n    rowAxis = daikon.Image.getMajorAxisFromPatientRelativeDirectionCosine(dirCos[0], dirCos[1], dirCos[2]);\n    colAxis = daikon.Image.getMajorAxisFromPatientRelativeDirectionCosine(dirCos[3], dirCos[4], dirCos[5]);\n\n    if ((rowAxis !== null) && (colAxis !== null)) {\n        if (((rowAxis === "R") || (rowAxis === "L")) && ((colAxis === "A") || (colAxis === "P"))) {\n            label = daikon.Image.SLICE_DIRECTION_AXIAL;\n        } else if (((colAxis === "R") || (colAxis === "L")) && ((rowAxis === "A") || (rowAxis === "P"))) {\n            label = daikon.Image.SLICE_DIRECTION_AXIAL;\n        } else if (((rowAxis === "R") || (rowAxis === "L")) && ((colAxis === "H") || (colAxis === "F"))) {\n            label = daikon.Image.SLICE_DIRECTION_CORONAL;\n        } else if (((colAxis === "R") || (colAxis === "L")) && ((rowAxis === "H") || (rowAxis === "F"))) {\n            label = daikon.Image.SLICE_DIRECTION_CORONAL;\n        } else if (((rowAxis === "A") || (rowAxis === "P")) && ((colAxis === "H") || (colAxis === "F"))) {\n            label = daikon.Image.SLICE_DIRECTION_SAGITTAL;\n        } else if (((colAxis === "A") || (colAxis === "P")) && ((rowAxis === "H") || (rowAxis === "F"))) {\n            label = daikon.Image.SLICE_DIRECTION_SAGITTAL;\n        }\n    } else {\n        label = daikon.Image.SLICE_DIRECTION_OBLIQUE;\n    }\n\n    return label;\n};\n\n\n\n// returns an array of tags\n/**\n * Returns encapsulated data tags.\n * @returns {daikon.Tag[]}\n */\ndaikon.Image.prototype.getEncapsulatedData = function () {\n    var buffer, parser;\n\n    daikon.Parser = daikon.Parser || ((typeof require !== \'undefined\') ? require(\'./parser.js\') : null);\n\n    buffer = this.getPixelData().value.buffer;\n    parser = new daikon.Parser();\n    return parser.parseEncapsulated(new DataView(buffer));\n};\n\n\n\ndaikon.Image.prototype.getJpegs = function () {\n    var encapTags, numTags, ctr, currentJpeg, data = [], dataConcat = [];\n\n    encapTags = this.getEncapsulatedData();\n\n    // organize data as an array of an array of JPEG parts\n    if (encapTags) {\n        numTags = encapTags.length;\n\n        for (ctr = 0; ctr < numTags; ctr += 1) {\n            if (daikon.CompressionUtils.isHeaderJPEG(encapTags[ctr].value) ||\n                daikon.CompressionUtils.isHeaderJPEG2000(encapTags[ctr].value)) {\n                currentJpeg = [];\n                currentJpeg.push(encapTags[ctr].value.buffer);\n                data.push(currentJpeg);\n            } else if (currentJpeg && encapTags[ctr].value) {\n                currentJpeg.push(encapTags[ctr].value.buffer);\n            }\n        }\n    }\n\n    // concat into an array of full JPEGs\n    for (ctr = 0; ctr < data.length; ctr += 1) {\n        if (data[ctr].length > 1) {\n            dataConcat[ctr] = daikon.Utils.concatArrayBuffers2(data[ctr]);\n        } else {\n            dataConcat[ctr] = data[ctr][0];\n        }\n\n        data[ctr] = null;\n    }\n\n    return dataConcat;\n};\n\n\n\ndaikon.Image.prototype.getRLE = function () {\n    var encapTags, numTags, ctr, data = [];\n\n    encapTags = this.getEncapsulatedData();\n\n    // organize data as an array of an array of JPEG parts\n    if (encapTags) {\n        numTags = encapTags.length;\n\n        // the first sublist item contains offsets, need offsets?\n        for (ctr = 1; ctr < numTags; ctr += 1) {\n            if (encapTags[ctr].value) {\n                data.push(encapTags[ctr].value.buffer);\n            }\n        }\n    }\n\n    return data;\n};\n\n\n/**\n * Returns a string of interpreted private data.\n * @returns {string}\n */\ndaikon.Image.prototype.getAllInterpretedPrivateData = function() {\n    var ctr, key, tag, str = "";\n\n    var sorted_keys = Object.keys(this.tags).sort();\n\n    for (ctr = 0; ctr < sorted_keys.length; ctr+=1) {\n        key = sorted_keys[ctr];\n        if (this.tags.hasOwnProperty(key)) {\n            tag = this.tags[key];\n            if (tag.hasInterpretedPrivateData()) {\n                str += tag.value;\n            }\n        }\n    }\n\n    return str;\n};\n\n\n\n\n\n/**\n * Returns a string representation of this image.\n * @returns {string}\n */\ndaikon.Image.prototype.toString = function () {\n    var ctr, tag, key, str = "";\n\n    var sorted_keys = Object.keys(this.tags).sort();\n\n    for (ctr = 0; ctr < sorted_keys.length; ctr+=1) {\n        key = sorted_keys[ctr];\n        if (this.tags.hasOwnProperty(key)) {\n            tag = this.tags[key];\n            str += (tag.toHTMLString() + "<br />");\n        }\n    }\n\n    str = str.replace(/\\n\\s*\\n/g, \'\\n\');  // replace mutli-newlines with single newline\n    str = str.replace(/(?:\\r\\n|\\r|\\n)/g, \'<br />\');  // replace newlines with <br>\n\n    return str;\n};\n\n\n\ndaikon.Image.prototype.getPalleteValues = function (tagID) {\n    /*jslint bitwise: true */\n\n    var valsBig, valsLittle, value, numVals, ctr, valsBigMax, valsBigMin, valsLittleMax, valsLittleMin, valsBigDiff,\n        valsLittleDiff;\n\n    valsBig = null;\n    valsLittle = null;\n\n    value = daikon.Image.getValueSafely(this.getTag(tagID[0], tagID[1]));\n\n    if (value !== null) {\n        numVals = value.buffer.byteLength / 2;\n        valsBig = [];\n        valsLittle = [];\n\n        for (ctr = 0; ctr < numVals; ctr += 1) {\n            valsBig[ctr] = (value.getUint16(ctr * 2, false) & 0xFFFF);\n            valsLittle[ctr] = (value.getUint16(ctr * 2, true) & 0xFFFF);\n        }\n\n        valsBigMax = Math.max.apply(Math, valsBig);\n        valsBigMin = Math.min.apply(Math, valsBig);\n        valsLittleMax = Math.max.apply(Math, valsLittle);\n        valsLittleMin = Math.min.apply(Math, valsLittle);\n        valsBigDiff = Math.abs(valsBigMax - valsBigMin);\n        valsLittleDiff = Math.abs(valsLittleMax - valsLittleMin);\n\n        if (valsBigDiff < valsLittleDiff) {\n            return this.scalePalette(valsBig);\n        } else {\n            return this.scalePalette(valsLittle);\n        }\n    }\n\n    return null;\n};\n\n\n\ndaikon.Image.prototype.scalePalette = function (pal) {\n    var min, max, ctr, slope, intercept;\n\n    max = Math.max.apply(Math, pal);\n    min = Math.min.apply(Math, pal);\n\n    if ((max > 255) || (min < 0)) {\n        slope = 255.0 / (max - min);\n        intercept = min;\n\n        for (ctr = 0; ctr < pal.length; ctr += 1) {\n            pal[ctr] = parseInt(Math.round((pal[ctr] - intercept) * slope));\n        }\n    }\n\n    return pal;\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.Image;\n}\n\n},{"../lib/jpeg-baseline.js":1,"../lib/jpx.js":2,"./compression-utils.js":29,"./parser.js":35,"./rle.js":36,"./tag.js":39,"./utilities.js":40,"jpeg-lossless-decoder-js":8}],32:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\n\n\n/*** Constructor ***/\ndaikon.OrderedMapIterator = daikon.OrderedMapIterator || function (orderedMap) {\n    this.orderedMap = orderedMap;\n    this.index = 0;\n};\n\n\n/*** Prototype Methods ***/\n\ndaikon.OrderedMapIterator.prototype.hasNext = function() {\n    return (this.index < this.orderedMap.orderedKeys.length);\n};\n\n\n\ndaikon.OrderedMapIterator.prototype.next = function() {\n    var item = this.orderedMap.get(this.orderedMap.orderedKeys[this.index]);\n    this.index += 1;\n    return item;\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.OrderedMapIterator;\n}\n\n},{}],33:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ****/\n\n/**\n * daikon\n * @type {*|{}}\n */\nvar daikon = daikon || {};\n\ndaikon.CompressionUtils = daikon.CompressionUtils || ((typeof require !== \'undefined\') ? require(\'./compression-utils.js\') : null);\ndaikon.Dictionary = daikon.Dictionary || ((typeof require !== \'undefined\') ? require(\'./dictionary.js\') : null);\ndaikon.Image = daikon.Image || ((typeof require !== \'undefined\') ? require(\'./image.js\') : null);\ndaikon.OrderedMapIterator = daikon.OrderedMapIterator || ((typeof require !== \'undefined\') ? require(\'./iterator.js\') : null);\ndaikon.OrderedMap = daikon.OrderedMap || ((typeof require !== \'undefined\') ? require(\'./orderedmap.js\') : null);\ndaikon.Parser = daikon.Parser || ((typeof require !== \'undefined\') ? require(\'./parser.js\') : null);\ndaikon.RLE = daikon.RLE || ((typeof require !== \'undefined\') ? require(\'./rle.js\') : null);\ndaikon.Series = daikon.Series || ((typeof require !== \'undefined\') ? require(\'./series.js\') : null);\ndaikon.Tag = daikon.Tag || ((typeof require !== \'undefined\') ? require(\'./tag.js\') : null);\ndaikon.Utils = daikon.Utils || ((typeof require !== \'undefined\') ? require(\'./utilities.js\') : null);\ndaikon.Siemens = daikon.Siemens || ((typeof require !== \'undefined\') ? require(\'./siemens.js\') : null);\n\nvar jpeg = jpeg || {};\njpeg.lossless = jpeg.lossless || {};\njpeg.lossless.Decoder = ((typeof require !== \'undefined\') ? require(\'jpeg-lossless-decoder-js\') : null);\n\nvar JpegDecoder = JpegDecoder || ((typeof require !== \'undefined\') ? require(\'../lib/jpeg-baseline.js\').JpegImage : null);\n\nvar JpxImage = JpxImage || ((typeof require !== \'undefined\') ? require(\'../lib/jpx.js\') : null);\n\nvar pako = pako || ((typeof require !== \'undefined\') ? require(\'pako\') : null);\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon;\n}\n\n},{"../lib/jpeg-baseline.js":1,"../lib/jpx.js":2,"./compression-utils.js":29,"./dictionary.js":30,"./image.js":31,"./iterator.js":32,"./orderedmap.js":34,"./parser.js":35,"./rle.js":36,"./series.js":37,"./siemens.js":38,"./tag.js":39,"./utilities.js":40,"jpeg-lossless-decoder-js":8,"pako":13}],34:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require */\n\n"use strict";\n\n// Based on: http://stackoverflow.com/questions/3549894/javascript-data-structure-for-fast-lookup-and-ordered-looping\n\n/*** Imports ***/\nvar daikon = daikon || {};\ndaikon.OrderedMapIterator = daikon.OrderedMapIterator || ((typeof require !== \'undefined\') ? require(\'./iterator.js\') : null);\n\n\n/*** Constructor ***/\ndaikon.OrderedMap = daikon.OrderedMap || function () {\n    this.map = {};\n    this.orderedKeys = [];\n};\n\n\n\ndaikon.OrderedMap.prototype.put = function(key, value) {\n  \n\n\n\n\n    function insertSorted(arr, item, comparator) {\n        if (comparator == null) {\n            // emulate the default Array.sort() comparator\n            comparator = function(a, b) {\n                if (typeof a !== \'string\') a = String(a);\n                if (typeof b !== \'string\') b = String(b);\n                return (a > b ? 1 : (a < b ? -1 : 0));\n            };\n        }\n\n        // get the index we need to insert the item at\n        var min = 0;\n        var max = arr.length;\n        var index = Math.floor((min + max) / 2);\n        while (max > min) {\n            if (comparator(item, arr[index]) < 0) {\n                max = index;\n            } else {\n                min = index + 1;\n            }\n            index = Math.floor((min + max) / 2);\n        }\n\n        // insert the item\n        arr.splice(index, 0, item);\n    };\n\n\n    if (key in this.map) { // key already exists, replace value\n        this.map[key] = value;\n    } else { // insert new key and value\n\n        insertSorted(this.orderedKeys,key,function(a, b) { return parseFloat(a) - parseFloat(b); });\n    \n        //this.orderedKeys.push(key);\n        //this.orderedKeys.sort(function(a, b) { return parseFloat(a) - parseFloat(b); });\n        this.map[key] = value;\n    }\n};\n\n\n\ndaikon.OrderedMap.prototype.remove = function(key) {\n    var index = this.orderedKeys.indexOf(key);\n    if(index === -1) {\n        throw new Error(\'key does not exist\');\n    }\n\n    this.orderedKeys.splice(index, 1);\n    delete this.map[key];\n};\n\n\n\ndaikon.OrderedMap.prototype.get = function(key) {\n    if (key in this.map) {\n        return this.map[key];\n    }\n\n    return null;\n};\n\n\n\ndaikon.OrderedMap.prototype.iterator = function() {\n    return new daikon.OrderedMapIterator(this);\n};\n\n\n\ndaikon.OrderedMap.prototype.getOrderedValues = function() {\n    var orderedValues = [], it = this.iterator();\n\n    while (it.hasNext()) {\n        orderedValues.push(it.next());\n    }\n\n    return orderedValues;\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.OrderedMap;\n}\n\n},{"./iterator.js":32}],35:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\ndaikon.Tag = daikon.Tag || ((typeof require !== \'undefined\') ? require(\'./tag.js\') : null);\ndaikon.Utils = daikon.Utils || ((typeof require !== \'undefined\') ? require(\'./utilities.js\') : null);\ndaikon.Dictionary = daikon.Dictionary || ((typeof require !== \'undefined\') ? require(\'./dictionary.js\') : null);\ndaikon.Image = daikon.Image || ((typeof require !== \'undefined\') ? require(\'./image.js\') : null);\n\nvar pako = pako || ((typeof require !== \'undefined\') ? require(\'pako\') : null);\n\n\n/*** Constructor ***/\n\n/**\n * The Parser constructor.\n * @property {boolean} explicit\n * @property {boolean} littleEndian\n * @type {Function}\n */\ndaikon.Parser = daikon.Parser || function () {\n    this.littleEndian = true;\n    this.explicit = true;\n    this.metaFound = false;\n    this.metaFinished = false;\n    this.metaFinishedOffset = -1;\n    this.needsDeflate = false;\n    this.error = null;\n};\n\n\n/*** Static Fields ***/\n\n/**\n * Global property to output string representation of tags as they are parsed.\n * @type {boolean}\n */\ndaikon.Parser.verbose = false;\n\n\n/*** Static Pseudo-constants ***/\n\ndaikon.Parser.MAGIC_COOKIE_OFFSET = 128;\ndaikon.Parser.MAGIC_COOKIE = [68, 73, 67, 77];\ndaikon.Parser.VRS = ["AE", "AS", "AT", "CS", "DA", "DS", "DT", "FL", "FD", "IS", "LO", "LT", "OB", "OD", "OF", "OW", "PN", "SH", "SL", "SS", "ST", "TM", "UI", "UL", "UN", "US", "UT"];\ndaikon.Parser.DATA_VRS = ["OB", "OW", "OF", "SQ", "UT", "UN"];\ndaikon.Parser.RAW_DATA_VRS = ["OB", "OD", "OF", "OW", "UN"];\ndaikon.Parser.TRANSFER_SYNTAX_IMPLICIT_LITTLE = "1.2.840.10008.1.2";\ndaikon.Parser.TRANSFER_SYNTAX_EXPLICIT_LITTLE = "1.2.840.10008.1.2.1";\ndaikon.Parser.TRANSFER_SYNTAX_EXPLICIT_BIG = "1.2.840.10008.1.2.2";\ndaikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG = "1.2.840.10008.1.2.4";\ndaikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_LOSSLESS = "1.2.840.10008.1.2.4.57";\ndaikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_LOSSLESS_SEL1 = "1.2.840.10008.1.2.4.70";\ndaikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_BASELINE_8BIT = "1.2.840.10008.1.2.4.50";\ndaikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_BASELINE_12BIT = "1.2.840.10008.1.2.4.51";\ndaikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_2000_LOSSLESS = "1.2.840.10008.1.2.4.90";\ndaikon.Parser.TRANSFER_SYNTAX_COMPRESSION_JPEG_2000 = "1.2.840.10008.1.2.4.91";\ndaikon.Parser.TRANSFER_SYNTAX_COMPRESSION_RLE = "1.2.840.10008.1.2.5";\ndaikon.Parser.TRANSFER_SYNTAX_COMPRESSION_DEFLATE = "1.2.840.10008.1.2.1.99";\ndaikon.Parser.UNDEFINED_LENGTH = 0xFFFFFFFF;\n\n\n/*** Static Methods ***/\n\n/**\n * Returns true if the DICOM magic cookie is found.\n * @param {DataView} data\n * @returns {boolean}\n */\ndaikon.Parser.isMagicCookieFound = function (data) {\n    var offset = daikon.Parser.MAGIC_COOKIE_OFFSET, magicCookieLength = daikon.Parser.MAGIC_COOKIE.length, ctr;\n\n    for (ctr = 0; ctr < magicCookieLength; ctr += 1) {\n        if (data.getUint8(offset + ctr) !== daikon.Parser.MAGIC_COOKIE[ctr]) {\n            return false;\n        }\n    }\n\n    return true;\n};\n\n\ndaikon.Parser.prototype.parseRDA = function (data) {\n\n    var image = new daikon.Image();\n    image.fromRDA = true;\n\n\n    // parse Header\n    var view = new DataView(data.buffer)\n    var length = 4096;\n    var utf16 = new ArrayBuffer(length * 2);\n    var utf16View = new Uint16Array(utf16);\n    var i = 0;\n    var li=0;\n    var tags = {}\n    for (;;) {\n        utf16View[i] = view.getUint8(i);\n        if (utf16View[i] == 13 | utf16View[i] == 0 )\n        {\n            if (utf16View[i] == 0 )\n                break;\n            utf16View[i] = 0;\n            var line = String.fromCharCode.apply(null , new Uint16Array(utf16View.buffer.slice(li*2+4,2*i)));\n            li = i;\n            var s = line.split(":")\n            if (s.length>1)\n            {\n                tags[s[0]] = s[1].trim().replace(/\\,/,".");\n            }\n        }\n        i++;\n    }\n\n    // compute FFT\n    var n = parseInt(tags[\'VectorSize\'])\n    var fftimgdata = new Float64Array(data.buffer.slice(i));\n    var imgdata = new Float64Array(fftimgdata.length)\n    var m = fftimgdata.length/(2*n);\n    var fft = new KissFFT.FFT(n);\n    for (var k = 0; k < m; k++)\n    {\n        var r = fft.forward(fftimgdata.slice(k*n*2,(k+1)*n*2))\n        for (var j=0;j<n;j++)\n        {\n            var js = (j+n/2)%n;\n            imgdata[k+m*js] = Math.log(Math.sqrt(r[2*j]*r[2*j] + r[2*j+1]*r[2*j+1]));\n            imgdata[k+m*js+m*n] = Math.atan2(r[2*j],r[2*j+1]);\n            \n        }\n    }\n\n     \n    // set DICOM tags\n    tags[\'PatientName\'] = tags[\'PatientName\'].replace(/\\^/," ");\n    function addTag(id,key,val)\n    {\n        image.putTag({key:key,id:id,value:[tags[key]]})\n    }\n    addTag("00100020","PatientID");\n    addTag("00100010","PatientName");\n    addTag("00100040","PatientSex");\n    addTag("00101010","PatientAge");\n    \n    addTag("00181030","ProtocolName");\n    tags["StudyID"] = "shitty"\n    addTag("00200010","StudyID");\n\n    tags[\'StudyDescription\'] = tags[\'StudyDescription\'] + " " + tags[\'SoftwareVersion[0]\'];\n\n    addTag("00080020","StudyDate");\n    addTag("00080030","StudyTime");\n    addTag("00081030","StudyDescription");\n    addTag("00080021","SeriesDate");\n    addTag("00080031","SeriesTime");\n\n    addTag("00200011","SeriesNumber");\n    addTag("0008103E","SeriesDescription");\n    addTag("00280010","CSIMatrixSize[0]");\n    addTag("00280011","CSIMatrixSize[1]");\n\n    tags.SliceThickness = parseFloat(tags.SliceThickness);\n    addTag("00180050","SliceThickness")\n\n    tags[\'SpacingBetweenSlices\'] = 0\n    addTag("00180088","SpacingBetweenSlices")\n\n    tags[\'NumberOfFrames\'] = parseInt(tags[\'VectorSize\'])*2\n    addTag("00280008","NumberOfFrames")\n\n\n    image.putTag({id:"00280030",key:"pixelspacing",value:[tags.PixelSpacingRow,tags.PixelSpacingCol]});\n    image.putTag({id:"00200032",key:"ImagePosition",value:[tags[\'PositionVector[0]\'],\n                                                           tags[\'PositionVector[1]\'],\n                                                           tags[\'PositionVector[2]\'] ].map(parseFloat)});\n    image.putTag({id:"00200037",key:"ImageOrientation",value:[tags[\'RowVector[0]\'],\n                                                           tags[\'RowVector[1]\'],\n                                                           tags[\'RowVector[2]\'],\n                                                           tags[\'ColumnVector[0]\'],\n                                                           tags[\'ColumnVector[1]\'],\n                                                           tags[\'ColumnVector[2]\'] ].map(parseFloat)});\n\n    image.putTag({id:"00181063",key:"FrameTime",value:[1]});\n    image.putTag({id:"0020000E",key:"SerieInstanceUID",value:[(tags.SeriesTime + tags[\'SoftwareVersion[0]\']+tags[\'SeriesNumber\']+tags[\'InstanceCreationDate\']+tags[\'InstanceCreationTime\']).replace(/\\ /g,"")]});\n    image.putTag({id:"7FE00010",key:"PixelData",value:imgdata})\n\n    return image;\n\n}\n\n\n/*** Prototype Methods ***/\n\n/**\n * Parses this data and returns an image object.\n * @param {DataView} data\n * @returns {daikon.Image|null}\n */\ndaikon.Parser.prototype.parse = function (data) {\n    var image = null, offset, tag, copyMeta, copyDeflated;\n\n\n    //try   // try/catch deep down slow down the code\n    {\n        image = new daikon.Image();\n        offset = this.findFirstTagOffset(data);\n        tag = this.getNextTag(data, offset);\n\n        while (tag !== null) {\n            if (daikon.Parser.verbose) {\n                console.log(tag.toString());\n            }\n    \n            // Elias Kellner: only remeber tags in the modified dictionary, otherwise heap will explode\n            // NB: Tag will be of type other binary "OB" if not in the dictionary\n            if( tag.isPixelData() || daikon.Dictionary.getVR(tag.group, tag.element) !== \'OB\'   )\n                image.putTag(tag);\n           // else\n            //    delete tag.value;\n\n            if (tag.isPixelData()) {\n                break;\n            }\n\n            if (this.needsDeflate && (tag.offsetEnd >= this.metaFinishedOffset)) {\n                this.needsDeflate = false;\n                copyMeta = data.buffer.slice(0, tag.offsetEnd);\n                copyDeflated = data.buffer.slice(tag.offsetEnd);\n                data = new DataView(daikon.Utils.concatArrayBuffers(copyMeta, pako.inflateRaw(copyDeflated)));\n            }\n\n            tag = this.getNextTag(data, tag.offsetEnd);\n        }\n    } \n    //catch (err) {\n    //    this.error = err;\n   // }\n\n    if (image !== null) {\n        image.littleEndian = this.littleEndian;\n    }\n\n    return image;\n};\n\n\n\ndaikon.Parser.prototype.parseEncapsulated = function (data) \n{\n    var offset = 0, tag, tags = [];\n\n/* Kellner\nJPEG compressed data is saved as series of SQ items\nhowever, encountered problems here, with anonymized data:\nstructure might be special: \n\tcontent of SQ elements inside PixelData shall NOT be subnestet\n\tPixelDate itself serves as a SQ tag, and there seems to be a corresponding closing tag at the end ...?\n\n(7fe0,0010) OB (PixelSequence #=2)                      # u/l, 1 PixelData\n  (fffe,e000) pi (no value available)                     #   0, 1 Item\n  (fffe,e000) pi ff\\d8\\ff\\e0\\00\\0f\\4c\\4a\\49\\46\\00\\01\\00\\00\\00\\00\\00\\00\\00\\ff\\fe\\00... # 193892, 1 Item\n(fffe,e0dd) na (SequenceDelimitationItem)               #   0, 0 SequenceDelimitationItem\n\n=> Assume content is list of SQ items with content NOT to be sub-parsed!!\n*/\t\n    try \n    {\n//        tag = this.getNextTag(data, offset);\n\n        while (tag !== null) \n        {\n        \ttag = this.getNextTag(data, offset, 0, 1);\n\n            if(tag!==null)//tag.isSublistItem()) \n            {\n                tags.push(tag);\n            }\n\n            if (daikon.Parser.verbose) {\n                console.log(tag.toString());\n            }\n\t\t\toffset = tag.offsetEnd\n        }\n    } \n    catch (err) \n    {\n        this.error = err;\n    }\n\n    return tags;\n};\n\n\n/* Old versions, did not work\n\n\ndaikon.Parser.prototype.parseEncapsulated___old = function (data) \n{\n    var offset = 0, tag, tags = [];\n    try \n    {\n        tag = this.getNextTag(data, offset);\n\n        while (tag !== null) \n        {\n            if (tag.isSublistItem()) {\n                tags.push(tag);\n            }\n\n            if (daikon.Parser.verbose) {\n                console.log(tag.toString());\n            }\n\n            tag = this.getNextTag(data, tag.offsetEnd);\n        }\n    } \n    catch (err) \n    {\n        this.error = err;\n    }\n\n    return tags;\n};\n*/\n\n\ndaikon.Parser.prototype.testForValidTag = function (data) {\n    var offset, tag = null;\n\n    try {\n        offset = this.findFirstTagOffset(data);\n        tag = this.getNextTag(data, offset, true);\n    } catch (err) {\n        this.error = err;\n    }\n\n    return tag;\n};\n\n\n\ndaikon.Parser.prototype.getNextTag = function (data, offset, testForTag, preventSublistParsing) {\n    var group = 0, element, value = null, offsetStart = offset, offsetValue, length = 0, little = true, vr = null, tag;\n\n    if (offset >= data.byteLength) {\n        return null;\n    }\n\n    if (this.metaFinished) {\n        little = this.littleEndian;\n        group = data.getUint16(offset, little);\n    } else {\n        group = data.getUint16(offset, true);\n\n        if (((this.metaFinishedOffset !== -1) && (offset >= this.metaFinishedOffset)) || (group !== 0x0002)) {\n            this.metaFinished = true;\n            little = this.littleEndian;\n            group = data.getUint16(offset, little);\n        } else {\n            little = true;\n        }\n    }\n\n    if (!this.metaFound && (group === 0x0002)) {\n        this.metaFound = true;\n    }\n\n    offset += 2;\n\n    if (offset > data.byteLength-2)\n        return null;\n    element = data.getUint16(offset, little);\n\n    offset += 2;\n\n    if (this.explicit || !this.metaFinished) {\n        vr = daikon.Utils.getStringAt(data, offset, 2);\n\n        if (!this.metaFound && this.metaFinished && (daikon.Parser.VRS.indexOf(vr) === -1)) {\n            vr = daikon.Dictionary.getVR(group, element);\n            length = data.getUint32(offset, little);\n            offset += 4;\n            this.explicit = false;\n        } else {\n            offset += 2;\n\n            if (daikon.Parser.DATA_VRS.indexOf(vr) !== -1) {\n                offset += 2;  // skip two empty bytes\n\n                length = data.getUint32(offset, little);\n                offset += 4;\n            } else {\n                length = data.getUint16(offset, little);\n                offset += 2;\n            }\n        }\n    } else {\n        vr = daikon.Dictionary.getVR(group, element);\n        if (offset < data.byteLength-4)\n        {\n            length = data.getUint32(offset, little);\n        }\n        else \n            return null;\n\n        if (length === daikon.Parser.UNDEFINED_LENGTH) {\n            vr = \'SQ\';\n        }\n\n        offset += 4;\n    }\n\n    offsetValue = offset;\n\n    if (vr === \'SQ\' && !preventSublistParsing) \n    {\n        value = this.parseSublist(data, offset, length);\n\n        if (length === daikon.Parser.UNDEFINED_LENGTH) \n            length = value[value.length - 1].offsetEnd - offset;\n    } \n    else if ((length > 0) && !testForTag) \n    {\n        if (length === daikon.Parser.UNDEFINED_LENGTH) \n        {\n            if ((group === daikon.Tag.TAG_PIXEL_DATA[0]) && (element === daikon.Tag.TAG_PIXEL_DATA[1])) \n                length = (data.byteLength - offset);\n        }\n\n        value = data.buffer.slice(offset, offset + length);\n        //value = data.buffer\n        //value.koff = offset;\n        //value.klen = length;\n    }\n\n    offset += length;\n    tag = new daikon.Tag(group, element, vr, value, offsetStart, offsetValue, offset, this.littleEndian);\n\n    if(0 && vr === \'SQ\')\n    {\n        console.log("reading tag: " + daikon.Utils.dec2hex(group) + "," + daikon.Utils.dec2hex(element) + " " + daikon.Dictionary.getDescription(daikon.Utils.dec2hex(group),daikon.Utils.dec2hex(element)) + " " + Math.round(offset/1024/1024) + " "  + length)  \n    }\n\n    if (tag.isTransformSyntax()) {\n        if (tag.value[0] === daikon.Parser.TRANSFER_SYNTAX_IMPLICIT_LITTLE) {\n            this.explicit = false;\n            this.littleEndian = true;\n        } else if (tag.value[0] === daikon.Parser.TRANSFER_SYNTAX_EXPLICIT_BIG) {\n            this.explicit = true;\n            this.littleEndian = false;\n        } else if (tag.value[0] === daikon.Parser.TRANSFER_SYNTAX_COMPRESSION_DEFLATE) {\n            this.needsDeflate = true;\n            this.explicit = true;\n            this.littleEndian = true;\n        } else {\n            this.explicit = true;\n            this.littleEndian = true;\n        }\n    } else if (tag.isMetaLength()) {\n        if (tag.value != undefined)\n            this.metaFinishedOffset = tag.value[0] + offset;\n            else\n            this.metaFinishedOffset =  offset;\n    }\n\n    return tag;\n};\n\n\n\ndaikon.Parser.prototype.parseSublist = function (data, offset, length) {\n    var sublistItem,\n        offsetEnd = offset + length,\n        tags = [];\n\n    if (length === daikon.Parser.UNDEFINED_LENGTH) {\n        sublistItem = this.parseSublistItem(data, offset);\n\n        while (!sublistItem.isSequenceDelim()) {\n            tags.push(sublistItem);\n            offset = sublistItem.offsetEnd;\n            sublistItem = this.parseSublistItem(data, offset);\n        }\n\n        tags.push(sublistItem);\n    } else {\n        while (offset < offsetEnd) {\n            sublistItem = this.parseSublistItem(data, offset);\n            tags.push(sublistItem);\n            offset = sublistItem.offsetEnd;\n        }\n    }\n\n    return tags;\n};\n\n\n\ndaikon.Parser.prototype.parseSublistItem = function (data, offset) {\n    var group, element, length, offsetEnd, tag, offsetStart = offset, offsetValue, sublistItemTag, tags = [];\n\n    group = data.getUint16(offset, this.littleEndian);\n    offset += 2;\n\n    element = data.getUint16(offset, this.littleEndian);\n    offset += 2;\n\n    length = data.getUint32(offset, this.littleEndian);\n    offset += 4;\n\n    offsetValue = offset;\n\n    if (length === daikon.Parser.UNDEFINED_LENGTH) {\n        tag = this.getNextTag(data, offset);\n\n        while (!tag.isSublistItemDelim()) {\n            tags.push(tag);\n            offset = tag.offsetEnd;\n            tag = this.getNextTag(data, offset);\n        }\n\n        tags.push(tag);\n        offset = tag.offsetEnd;\n    } else {\n        offsetEnd = offset + length;\n\n        while (offset < offsetEnd) {\n            tag = this.getNextTag(data, offset);\n            if (tag == undefined)\n                break;\n            tags.push(tag);\n            offset = tag.offsetEnd;\n        }\n    }\n\n    sublistItemTag = new daikon.Tag(group, element, null, tags, offsetStart, offsetValue, offset, this.littleEndian);\n\n    return sublistItemTag;\n};\n\n\n\ndaikon.Parser.prototype.findFirstTagOffset = function (data) {\n    var offset = 0,\n        magicCookieLength = daikon.Parser.MAGIC_COOKIE.length,\n        searchOffsetMax = daikon.Parser.MAGIC_COOKIE_OFFSET * 2,\n        found = false,\n        ctr = 0,\n        ctrIn = 0,\n        ch = 0;\n\n    if (daikon.Parser.isMagicCookieFound(data)) {\n        offset = daikon.Parser.MAGIC_COOKIE_OFFSET + magicCookieLength;\n    } else {\n        for (ctr = 0; ctr < searchOffsetMax; ctr += 1) {\n            ch = data.getUint8(offset);\n            if (ch === daikon.Parser.MAGIC_COOKIE[0]) {\n                found = true;\n                for (ctrIn = 1; ctrIn < magicCookieLength; ctrIn += 1) {\n                    if (data.getUint8(ctr + ctrIn) !== daikon.Parser.MAGIC_COOKIE[ctrIn]) {\n                        found = false;\n                    }\n                }\n\n                if (found) {\n                    offset = ctr;\n                    break;\n                }\n            }\n        }\n    }\n\n    return offset;\n};\n\n\n\ndaikon.Parser.prototype.hasError = function () {\n    return (this.error !== null);\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.Parser;\n}\n\n},{"./dictionary.js":30,"./image.js":31,"./tag.js":39,"./utilities.js":40,"pako":13}],36:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\n\n\n/*** Constructor ***/\n\n/**\n * The RLE constructor.\n * @type {Function}\n */\ndaikon.RLE = daikon.RLE || function () {\n    this.rawData = null;\n    this.bytesRead = 0;\n    this.bytesPut = 0;\n    this.segElemPut = 0;\n    this.numSegments = 0;\n    this.segmentOffsets = [];\n    this.littleEndian = true;\n    this.segmentIndex = 0;\n    this.numElements = 0;\n    this.size = 0;\n    this.output = null;\n};\n\n\n/*** Static Pseudo-constants ***/\n\ndaikon.RLE.HEADER_SIZE = 64;\n\n\n/*** Prototype Methods ***/\n\n/**\n * Decodes the RLE data.\n * @param {ArrayBuffer} data\n * @param {boolean} littleEndian\n * @param {number} numElements\n * @returns {DataView}\n */\ndaikon.RLE.prototype.decode = function (data, littleEndian, numElements) {\n    var ctr;\n\n    this.rawData = new DataView(data);\n    this.littleEndian = littleEndian;\n    this.numElements = numElements;\n\n    this.readHeader();\n    this.output = new DataView(new ArrayBuffer(this.size));\n\n    for (ctr = 0; ctr < this.numSegments; ctr+=1) {\n        this.readNextSegment();\n    }\n\n    return this.processData();\n};\n\n\ndaikon.RLE.prototype.processData = function () {\n    /*jslint bitwise: true */\n\n    var ctr, temp1, temp2, temp3, value, outputProcessed, offset;\n\n    if (this.numSegments === 1) {\n        return this.output;\n    } else if (this.numSegments === 2) {\n        outputProcessed = new DataView(new ArrayBuffer(this.size));\n\n        for (ctr = 0; ctr < this.numElements; ctr+=1) {\n            temp1 = (this.output.getInt8(ctr));\n            temp2 = (this.output.getInt8(ctr + this.numElements));\n            value = (((temp1 & 0xFF) << 8) | (temp2 & 0xFF));\n            outputProcessed.setInt16(ctr * 2, value, this.littleEndian);\n        }\n\n        return outputProcessed;\n    } else if (this.numSegments === 3) {  // rgb\n        outputProcessed = new DataView(new ArrayBuffer(this.size));\n        offset = (2 * this.numElements);\n\n        for (ctr = 0; ctr < this.numElements; ctr+=1) {\n            outputProcessed.setInt8(ctr * 3, this.output.getInt8(ctr));\n            outputProcessed.setInt8(ctr * 3 + 1, this.output.getInt8(ctr + this.numElements));\n            outputProcessed.setInt8(ctr * 3 + 2, this.output.getInt8(ctr + offset));\n        }\n\n        return outputProcessed;\n    } else {\n        throw new Error("RLE data with " + this.numSegments + " segments is not supported!");\n    }\n};\n\n\n\ndaikon.RLE.prototype.readHeader = function () {\n    var ctr;\n\n    this.numSegments = this.getInt32();\n    this.size = this.numElements * this.numSegments;\n\n    for (ctr = 0; ctr < this.numSegments; ctr+=1) {\n        this.segmentOffsets[ctr] = this.getInt32();\n    }\n\n    this.bytesRead = daikon.RLE.HEADER_SIZE;\n};\n\n\n\ndaikon.RLE.prototype.hasValidInput = function () {\n    return ((this.bytesRead < this.rawData.buffer.byteLength) &&\n        (this.bytesPut < this.size) && (this.segElemPut < this.numElements));\n};\n\n\n\ndaikon.RLE.prototype.readNextSegment = function () {\n    var code;\n\n    this.bytesRead = this.segmentOffsets[this.segmentIndex];\n    this.segElemPut = 0;\n\n    while (this.hasValidInput()) {\n        code = this.get();\n\n        if ((code >= 0) && (code < 128)) {\n            this.readLiteral(code);\n        } else if ((code <= -1) && (code > -128)) {\n            this.readEncoded(code);\n        } else if (code === -128) {\n            console.warn("RLE: unsupported code!");\n        }\n    }\n\n    this.segmentIndex+=1;\n};\n\n\n\ndaikon.RLE.prototype.readLiteral = function (code) {\n    var ctr, length = (code + 1);\n\n    if (this.hasValidInput()) {\n        for (ctr = 0; ctr < length; ctr+=1) {\n            this.put(this.get());\n        }\n    } else {\n        console.warn("RLE: insufficient data!");\n    }\n};\n\n\n\ndaikon.RLE.prototype.readEncoded = function (code) {\n    var ctr,\n        runLength = (1 - code),\n        encoded = this.get();\n\n    for (ctr = 0; ctr < runLength; ctr+=1) {\n        this.put(encoded);\n    }\n};\n\n\n\ndaikon.RLE.prototype.getInt32 = function () {\n    var value = this.rawData.getInt32(this.bytesRead, this.littleEndian);\n    this.bytesRead += 4;\n    return value;\n};\n\n\n\ndaikon.RLE.prototype.getInt16 = function () {\n    var value = this.rawData.getInt16(this.bytesRead, this.littleEndian);\n    this.bytesRead += 2;\n    return value;\n};\n\n\n\ndaikon.RLE.prototype.get = function () {\n    var value = this.rawData.getInt8(this.bytesRead);\n    this.bytesRead += 1;\n    return value;\n};\n\n\n\ndaikon.RLE.prototype.put = function (val) {\n    this.output.setInt8(this.bytesPut, val);\n    this.bytesPut += 1;\n    this.segElemPut += 1;\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.RLE;\n}\n\n},{}],37:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\ndaikon.Parser = daikon.Parser || ((typeof require !== \'undefined\') ? require(\'./parser.js\') : null);\ndaikon.Image = daikon.Image || ((typeof require !== \'undefined\') ? require(\'./image.js\') : null);\ndaikon.OrderedMap = daikon.OrderedMap || ((typeof require !== \'undefined\') ? require(\'./orderedmap.js\') : null);\ndaikon.OrderedMapIterator = daikon.OrderedMapIterator || ((typeof require !== \'undefined\') ? require(\'./iterator.js\') : null);\ndaikon.Utils = daikon.Utils || ((typeof require !== \'undefined\') ? require(\'./utilities.js\') : null);\n\n\n/*** Constructor ***/\n\n/**\n * The Series constructor.\n * @property {daikon.Image[]} images\n * @type {Function}\n */\ndaikon.Series = daikon.Series || function () {\n    this.images = [];\n    this.imagesOriginalOrder = null;\n    this.isMosaic = false;\n    this.isElscint = false;\n    this.isCompressed = false;\n    this.numberOfFrames = 0;\n    this.numberOfFramesInFile = 0;\n    this.isMultiFrame = false;\n    this.isMultiFrameVolume = false;\n    this.isMultiFrameTimeseries = false;\n    this.isImplicitTimeseries = false;\n    this.sliceSense = false;\n    this.sliceDir = daikon.Image.SLICE_DIRECTION_UNKNOWN;\n    this.error = null;\n};\n\n\n/*** Static fields ***/\ndaikon.Series.parserError = null;\n\n\nDataView.prototype.getUTF8String = function(offset, length) {\n    var utf16 = new ArrayBuffer(length * 2);\n    var utf16View = new Uint16Array(utf16);\n    for (var i = 0; i < length; ++i) {\n        utf16View[i] = this.getUint8(offset + i);\n    }\n    return String.fromCharCode.apply(null , utf16View);\n}\n\n\n\n/*** Static Methods ***/\n\n/**\n * Parses the DICOM header and return an image object.\n * @param {DataView} data\n * @returns {daikon.Image|null}\n */\ndaikon.Series.parseImage = function (data) {\n    var parser, image;\n\n    parser = new daikon.Parser();\n    image = parser.parse(data);\n\n    var view = new DataView(data.buffer);\n    if (view.getUTF8String(0,23) == ">>> Begin of header <<<")\n        image = parser.parseRDA(data);\n\n\n    if (parser.hasError()) {\n        daikon.Series.parserError = parser.error;\n        return null;\n    }\n\n    return image;\n};\n\n\n\ndaikon.Series.getMosaicOffset = function (mosaicCols, mosaicColWidth, mosaicRowHeight, mosaicWidth, xLocVal,\n                                          yLocVal, zLocVal) {\n    var xLoc, yLoc, zLoc;\n\n    xLoc = xLocVal;\n    yLoc = yLocVal;\n    zLoc = zLocVal;\n\n    xLoc = ((zLoc % mosaicCols) * mosaicColWidth) + xLoc;\n    yLoc = (((parseInt(zLoc / mosaicCols)) * mosaicRowHeight) + yLoc) * mosaicWidth;\n\n    return (xLoc + yLoc);\n};\n\n\n\ndaikon.Series.orderDicoms = function (images, numFrames, sliceDir) {\n    var hasImagePosition, hasSliceLocation, hasImageNumber, timeMap, timeIt, ctr, ctrIn, dg, ordered,\n        imagesOrderedByTimeAndSpace;\n\n    hasImagePosition = (images[0].getImagePosition() !== null);\n    hasSliceLocation = (images[0].getSliceLocation() !== null);\n    hasImageNumber = (images[0].getImageNumber() !== null);\n\n    timeMap = daikon.Series.orderByTime(images, numFrames, sliceDir, hasImagePosition, hasSliceLocation);\n    timeIt = timeMap.orderedKeys;\n\n    imagesOrderedByTimeAndSpace = [];\n\n    for (ctr = 0; ctr < timeIt.length; ctr += 1) \n    {\n        dg = timeMap.get(timeIt[ctr]);\n\n        if (hasSliceLocation) \n        {\n            ordered = daikon.Series.orderBySliceLocation(dg);\n        } \n        else if (hasImagePosition) \n        {\n            ordered = daikon.Series.orderByImagePosition(dg, sliceDir);\n        } \n        else if (hasImageNumber) \n        {\n            ordered = daikon.Series.orderByImageNumber(dg);\n        } \n        else \n        {\n            ordered = dg;\n        }\n\n        for (ctrIn = 0; ctrIn < ordered.length; ctrIn += 1) {\n            imagesOrderedByTimeAndSpace.push(ordered[ctrIn]);\n        }\n    }\n\n    for (ctrIn = 0; ctrIn < imagesOrderedByTimeAndSpace.length; ctrIn += 1) {\n        imagesOrderedByTimeAndSpace[ctrIn].index = ctrIn;\n    }\n\n    return imagesOrderedByTimeAndSpace;\n};\n\n\n\ndaikon.Series.orderByImagePosition = function (images, sliceDir) {\n    var dicomMap, ctr;\n    dicomMap = new daikon.OrderedMap();\n\n    for (ctr = 0; ctr < images.length; ctr += 1) {\n        dicomMap.put(images[ctr].getImagePositionSliceDir(sliceDir), images[ctr]);\n    }\n\n    return dicomMap.getOrderedValues();\n};\n\n\n\ndaikon.Series.orderBySliceLocation = function (images) {\n    var dicomMap, ctr;\n    dicomMap = new daikon.OrderedMap();\n\n    for (ctr = 0; ctr < images.length; ctr += 1) {\n        dicomMap.put(images[ctr].getSliceLocation(), images[ctr]);\n    }\n\n    return dicomMap.getOrderedValues();\n};\n\n\n\ndaikon.Series.orderByImageNumber = function (images) {\n    var dicomMap, ctr;\n    dicomMap = new daikon.OrderedMap();\n\n    for (ctr = 0; ctr < images.length; ctr += 1) {\n        dicomMap.put(images[ctr].getImageNumber(), images[ctr]);\n    }\n\n    return dicomMap.getOrderedValues();\n};\n\n\n\ndaikon.Series.hasMatchingSlice = function (dg, image, sliceDir, doImagePos, doSliceLoc) {\n    var matchingNum = 0, ctr, current, imagePos, sliceLoc, imageNum;\n\n    if (doImagePos) {\n        matchingNum = image.getImagePositionSliceDir(sliceDir);\n    } else if (doSliceLoc) {\n        matchingNum = image.getSliceLocation();\n    } else {\n        matchingNum = image.getImageNumber();\n    }\n\n    for (ctr = 0; ctr < dg.length; ctr += 1) {\n        current = dg[ctr];\n\n        if (doImagePos) {\n            imagePos = current.getImagePositionSliceDir(sliceDir);\n            if (imagePos === matchingNum) {\n                return true;\n            }\n        } else if (doSliceLoc) {\n            sliceLoc = current.getSliceLocation();\n            if (sliceLoc === matchingNum) {\n                return true;\n            }\n        } else {\n            imageNum = current.getImageNumber();\n            if (imageNum === matchingNum) {\n                return true;\n            }\n        }\n    }\n\n    return false;\n};\n\n\n\ndaikon.Series.orderByTime = function (images, numFrames, sliceDir, hasImagePosition, hasSliceLocation) {\n    var dicomMap, hasTemporalPosition, hasTemporalNumber, ctr, image, tempPos, dg, timeBySliceMap, imageNum,\n        sliceMarker, slice, dicomsCopy, dicomsCopyIndex, sliceIt, timeIt, dgFound, it;\n\n    dicomMap = new daikon.OrderedMap();\n    hasTemporalPosition = (numFrames > 1) && (images[0].getTemporalPosition() !== null);\n    hasTemporalNumber = (numFrames > 1) && (images[0].getTemporalNumber() !== null) && (images[0].getTemporalNumber() === numFrames);\n\n    if (hasTemporalPosition && hasTemporalNumber) \n    { // explicit series\n        for (ctr = 0; ctr < images.length; ctr += 1) \n        {\n            image = images[ctr];\n\n            tempPos = image.getTemporalPosition();\n            dg = dicomMap.get(tempPos);\n            if (!dg) {\n                dg = [];\n                dicomMap.put(tempPos, dg);\n            }\n\n            dg.push(image);\n        }\n    } \n    else \n    { // implicit series\n        // order data by slice then time\n        timeBySliceMap = new daikon.OrderedMap();\n        for (ctr = 0; ctr < images.length; ctr += 1) \n        {\n            if (images[ctr] !== null) \n            {\n                // image number is instance number\n                imageNum = images[ctr].getImageNumber();\n                sliceMarker = ctr;\n                if (hasSliceLocation) \n                {\n                    sliceMarker = images[ctr].getSliceLocation();\n                }\n                else if (hasImagePosition) \n                {\n                    sliceMarker = images[ctr].getImagePositionSliceDir(sliceDir);\n                } \n\n                slice = timeBySliceMap.get(sliceMarker);\n                if (slice === null) \n                {\n                    slice = new daikon.OrderedMap();\n                    timeBySliceMap.put(sliceMarker, slice);\n                }\n\n                slice.put(ctr, images[ctr]);\n            }\n        }\n\n        // copy into DICOM array (ordered by slice by time)\n        dicomsCopy = [];\n        dicomsCopyIndex = 0;\n        sliceIt = timeBySliceMap.iterator();\n        while (sliceIt.hasNext()) \n        {\n            slice = sliceIt.next();\n            timeIt = slice.iterator();\n            while (timeIt.hasNext()) {\n                dicomsCopy[dicomsCopyIndex] = timeIt.next();\n                dicomsCopyIndex += 1;\n            }\n        }\n\n        // groups dicoms by timepoint\n        for (ctr = 0; ctr < dicomsCopy.length; ctr += 1) \n        {\n            if (dicomsCopy[ctr] !== null) \n            {\n                dgFound = null;\n                it = dicomMap.iterator();\n                while (it.hasNext()) {\n                    dg = it.next();\n                    if (!daikon.Series.hasMatchingSlice(dg, dicomsCopy[ctr], sliceDir, hasImagePosition, hasSliceLocation)) {\n                        dgFound = dg;\n                        break;\n                    }\n                }\n\n                if (dgFound === null) {\n                    dgFound = [];\n                    dicomMap.put(dicomMap.orderedKeys.length, dgFound);\n                }\n\n                dgFound.push(dicomsCopy[ctr]);\n            }\n        }\n    }\n\n    return dicomMap;\n};\n\n\n/*** Prototype Methods ***/\n\ndaikon.Series.prototype.getOrder = function () {\n    var ctr, order = [];\n\n    for (ctr = 0; ctr < this.imagesOriginalOrder.length; ctr += 1) {\n        order[ctr] = this.imagesOriginalOrder[ctr].index;\n    }\n\n    return order;\n};\n\n\n/**\n * Returns the series ID.\n * @returns {string}\n */\ndaikon.Series.prototype.toString = function () {\n    return this.images[0].getSeriesId();\n};\n\n\n/**\n * Returns a nice name for the series.\n * @returns {string|null}\n */\ndaikon.Series.prototype.getName = function () {\n    var des = this.images[0].getSeriesDescription();\n    var uid = this.images[0].getSeriesInstanceUID();\n\n    if (des !== null) {\n        return des;\n    }\n\n    if (uid !== null) {\n        return uid;\n    }\n\n    return null;\n};\n\n\n/**\n * Adds an image to the series.\n * @param {daikon.Image} image\n */\ndaikon.Series.prototype.addImage = function (image) {\n    this.images.push(image);\n};\n\n\n/**\n * Returns true if the specified image is part of the series (or if no images are yet part of the series).\n * @param {daikon.Image} image\n * @returns {boolean}\n */\ndaikon.Series.prototype.matchesSeries = function (image) {\n    if (this.images.length === 0) {\n        return true;\n    }\n\n    return (this.images[0].getSeriesId() === image.getSeriesId());\n};\n\n\n/**\n * Orders and organizes the images in this series.\n */\ndaikon.Series.prototype.buildSeries = function () \n{\n  return this.buildSeries2();    \n\n};\n\n\n\n\n/**\n * Orders and organizes the images in this series.\n */\ndaikon.Series.prototype.buildSeries2 = function () \n{\n\n    if (this.images[0].getPixelData() == undefined) \n        return "noimage";\n    this.isMosaic = this.images[0].isMosaic();\n    \n    if (this.isMosaic)\n    {\n        \n\n\n        //this went to getAcquisitionMatrix(), since we need it already there\n        /*\n            var shdr = this.images[0].gettag(\'CSAImageHeaderInfo\');\n            if(typeof shdr == "string" )\n            {\n                var sn = shdr.match(/NumberOfImagesInMosaic=([-\\d.\\s]+)\\n/);\n                if(sn != null && sn.length > 1)\n                {\n                    this.NumberOfImagesInMosaic = parseInt(sn[1]);\n                    //this.images[0].NumberOfImagesInMosaic = this.NumberOfImagesInMosaic;\n                }\n            }\n        */\n        this.NumberOfImagesInMosaic = this.images[0].NumberOfImagesInMosaic;\n    }\n\n\n\n\n/*    \n    if(this.series.images[0].getImageDirections() != undefined)\n    {\n        var cosines = this.series.images[0].getImageDirections().slice(0);\n        var cx = cosines.splice(0,3);\n        var cy = cosines.splice(0,3);\n        var cz;\n\n    }\n*/\n\n\n    this.isElscint = this.images[0].isElscint();\n    this.isCompressed = this.images[0].isCompressed();\n\n    // check for multi-frame\n    this.numberOfFrames = this.images[0].getNumberOfFrames();\n    this.numberOfFramesInFile = this.images[0].getNumberOfImplicitFrames();\n    this.isMultiFrame = (this.numberOfFrames > 1) || (this.isMosaic && (this.images[0].length > 1));\n    this.isMultiFrameVolume = false;\n    this.isMultiFrameTimeseries = false; \n    \n\n    // =========== true multiframe file ==> all images stored in one dicom\n    if (this.isMultiFrame) \n    {\n        var hasFrameTime = (this.images[0].getFrameTime() > 0);\n        if (this.isMosaic) \n        {\n            this.isMultiFrameTimeseries = true;\n        } \n        else \n        {\n            if (hasFrameTime) \n            {\n                this.isMultiFrameTimeseries = true;\n            } \n            else if (this.numberOfFramesInFile > 1) \n            {\n                this.isMultiFrameTimeseries = true;\n                this.numberOfFrames = this.images.length; //???\n            } \n            else \n            {\n                this.isMultiFrameVolume = true;\n            }\n        }\n    }\n\n\n\n    // =========== normal case: Multiple DICOM Files. can be single volume, time series, multiple acquisitions\n\n    // diffusion or multicoil is also handled as timeseries\n    this.isImplicitTimeseries = false;\n\n    var list = [];   // array with sortable meta information\n    var slices = {}; // struct with information about slices found\n    //  gather info about all images\n    for(var k=0; k< this.images.length; k++)\n    {\n        var img = this.images[k];        \n\n        // create a struct with sort-relevant information\n        var imgstruct = \n        {\n            image: img,\n            initialindex: k,\n            InstanceCreationTime:   img.gettag(\'InstanceCreationTime\'),\n            AcquisitionTime:        img.gettag(\'AcquisitionTime\'),\n            AcquisitionNumber:      img.gettag(\'AcquisitionNumber\'),\n            InstanceNumber:         img.gettag(\'InstanceNumber\'),\n            EchoNumber:             img.gettag(\'EchoNumber\'),\n            SliceLocation:          img.gettag(\'SliceLocation\'),\n            ImagePosition:          img.getImagePosition() || 0\n        }\n        \n        // organise images according to their slice pos\n        var imagePos = img.getImagePosition() || 0;\n        if( slices[imagePos] == undefined)\n            slices[imagePos] = {index:k, pos: imagePos, imgs: [imgstruct] };\n        else\n            slices[imagePos].imgs.push( imgstruct );\n\n    }\n\n    // add vecors, one scaled by s\n    function vsum(a,b,s)\n    {\n        if(a == null || b == null)\n            return [0, 0, 0];\n        else\n            return [a[0] + s*b[0], a[1] + s*b[1], a[2] + s*b[2]];\n    }\n\n    var posvec = Object.keys(slices);\n    var pa = [];\n    \n    \n    if(posvec.length > 1 && slices[posvec[1]].pos !== null) // won\'t be the case for mosaic or 2D images like xray\n        var mutlislice = true;\n    else\n        var mutlislice = false\n    \n    var firstSlice = slices[posvec[0]];\n    var nextSlice  = mutlislice?slices[posvec[1]]:slices[posvec[0]];\n    var d = vsum(nextSlice.pos, firstSlice.pos, -1);\n    d[0] = Math.abs(d[0]); d[1] = Math.abs(d[1]); d[2] = Math.abs(d[2]);\n    var h = vsum(firstSlice.pos, d, 10000); // auxilary reference point for distances\n        \n    // first slice run: calc slice positions \n    var x,y,dist = 0;\n    for(var k=0; k< posvec.length; k++)\n    {\n            //dist =  math.norm( vsum(slices[posvec[k]].pos, h, -1) );\n            // simple by inner product\n            x = slices[posvec[k]].pos;\n            dist = x[0]*d[0] + x[1]*d[1] +x [2]*d[2];\n\n            slices[posvec[k]].dist = dist;\n            pa.push([dist, k, posvec[k]]);\n    }\n        \n    // sort slices by their location\n    pa.sort(function(a,b) { return b[0]>a[0]?1:-1 });\n\n    //second run over slices: \n    //create a sortable array and check integrity  \n    //      1. equidistand slices ??\n    //      2. same number of (timeseries) images per slice?\n    var firstSlice = slices[pa[0][2]];\n    var nextSlice  = mutlislice?slices[pa[1][2]] : slices[pa[0][2]];\n\n    var nimgs1 = slices[pa[0][2]].imgs.length;\n    \n    if(nimgs1 > 1)\n    {\n        this.isImplicitTimeseries = true;\n        this.numberOfFrames = nimgs1;\n    }\n\n    var d1 =math.norm( vsum(nextSlice.pos, firstSlice.pos, -1) );\n    var distances = [d1];\n\n    var timeerr = [];\n    var disterr =  [];\n    for(var k=0; k< posvec.length; k++)\n    {\n            // create a time index for each slice position\n            var tslice = slices[pa[k][2]];\n            var imgs = tslice.imgs;\n            // InstanceCreationTime is important for example for SWI, where all images of same coils have same InstanceNumber\n            // However, note InstanceCreationTime not always present (--\x3e MR yes, CT no)\n            imgs.sort( firstBy("InstanceNumber").thenBy("InstanceCreationTime") );\n            \n            for(var j=0; j < imgs.length; j++)\n            {\n                var img = imgs[j];\n                img.TimeIndex  = j;\n                img.SliceLocation_calculated = -math.norm( vsum(slices[pa[k][2]].pos, firstSlice.pos, -1) ); \n                list.push(img);\n            }\n\n            if(k==0)\n                continue\n            \n            var d2 =  math.norm( vsum(slices[pa[k][2]].pos, slices[pa[k-1][2]].pos, -1) ) ;\n            distances.push(d2);\n            \n            // check for slice distance tolerance (1% )\n            if( (d1-d2) / d1 > 0.01)\n            {\n                disterr.push(k);\n            }\n            d1 = d2;    \n            \n            var nimgs2 = slices[pa[k][2]].imgs.length;\n            if(nimgs2 != nimgs1 )\n            {\n                timeerr.push(k+1);\n            }\n            nimgs2 = nimgs1;\n    }\n\n    // === report inconsistencies\n    if( timeerr.length > 0)\n    {\n            timeerr = \'DICOM read WARNING: Not same number of time points per slice ...missing files? \\n\'\n                       + timeerr.toString() + "\\n"\n            //console.log( timeerr );\n    }\n\n\n    this.hasBadSlicing = false;\n    if( disterr.length > 0)\n    {\n            var errormsg = \'DICOM read WARNING: Not same slice distances. Maybe there are some DICOM files missing...?\\n\'\n                       + "at slice indices: " + disterr.toString() + "\\n";\n\t\t       //+ "slice distances: " + print_matrix(distances);\n            console.log( errormsg );\n            this.hasBadSlicing = true;\n\n            // split this series into multiple series separated by their slice indices.\n            this.subseries = [];\n            for(var u=0; u<disterr.length; u++)\n            {\n                this.subseries.push(new daikon.Series());\n                var newimages = this.images.slice(0, disterr[u])\n                this.subseries[u].images = newimages;\n\n            }\n    }\n\n    // Now, do the major sorting: \n    // We have a major problem here: Whole body PET images might be blockwise messed up. (Kellner 08/2019)\n    // This should be thoroughly investigated. For now, sepeare PET and others\n    if(this.images[0].gettag(\'Modality\') != "PT")\n    {\n        // this is the way we did it so far. leads to problems with PET\n        var s = firstBy("AcquisitionNumber").thenBy("TimeIndex").thenBy("SliceLocation_calculated");\n    }\n    else\n    {\n        var s = firstBy("TimeIndex").thenBy("SliceLocation_calculated").thenBy("AcquisitionNumber");\n    }\n    \n    //var s = firstBy("AcquisitionNumber").thenBy("SliceLocation")\n    list.sort(s);\n    \n    /*********************************************\n    finally, order the images\n    *********************************************/\n    // further, calculate the relative timing (needed for timeseries (Perfusion CT/MR, fMRI))\n    if( this.images[0].gettag(\'Manufacturer\') && \n\t(this.images[0].gettag(\'Manufacturer\').toLowerCase() == \'philips\' || this.images[ 0 ].gettag(\'Manufacturer\').toLowerCase() == \'toshiba\' )   \n\t)\n    {\n        var timetag = \'ContentTime\';\n        console.log(\'This is a \' + this.images[0].gettag(\'Manufacturer\') + \'  scanner,  use DICOM tag "ContentTime" ...\')\n    }\n    else\n    {\n        var timetag = \'AcquisitionTime\';\n    }\n    \n    function calcTime(y)\n    {\n         if(y==undefined)\n             return 0;\n            \n        var hmsf = y.split(\'.\');\n        var hsm = hmsf[0];\n        var ff = hmsf[1];\n        var sec = parseFloat(hsm.substr(0,2))*3600 + parseFloat(hsm.substr(2,2))*60 + parseFloat(hsm.substr(4,2));\n        sec =  sec + parseFloat("0."+ ff);\n        return sec;\n\n    }\n\n    var orderedImages = [];\n    var ttime_firstimage = calcTime(this.images[ list[0].initialindex ].gettag(timetag));\n    this.sliceTimes = [];\n\n    this.imageInfo = { bMatrix:[], bDirections:[],    bValue:[]     };\n\n    for(var k=0; k< this.images.length; k++)\n    {\n        orderedImages.push(this.images[ list[k].initialindex ] );\n        \n        var relativetime = calcTime(this.images[ list[k].initialindex ].gettag(timetag));\n        \n        // correct for measurement time around midnight: diff smaller than 4 hours?\n         if (relativetime - ttime_firstimage < 4*3600)\n             relativetime = relativetime - ttime_firstimage;\n         else \n             relativetime = relativetime + 24*3600 - ttime_firstimage;\n        \n        relativetime = math.round(relativetime*1000);\n        \n//         if(k%4==0)\n//             console.log(this.images[ list[k].initialindex ].gettag(timetag));\n\n        var siemens = orderedImages[k].gettag(\'CSAImageHeaderInfo\');\n\n        this.images[ list[k].initialindex ].ktags.RelativeAcquisitionTime = relativetime; \n        \n        if(!this.isMosaic)\n        {\n            this.sliceTimes.push( relativetime );\n        }\n        else // for mosaic perfusion, must re-establish a .time file\n        {\n            if(   (this.images[0].getSeriesDescription() && (this.images[0].getSeriesDescription().search(\'perf\') > -1 || this.images[0].getSeriesDescription().search(\'cmrr\') > -1) )\n                ||(this.images[0].gettag(\'SequenceName\') && this.images[0].gettag(\'SequenceName\').search(\'B.Poser\') > -1) // SMS VSI sequence\n                )\n            {\n                if(typeof siemens == "string"  && siemens.match(/MosaicRefAcqTimes=([-\\d.\\s]+)\\n/) )\n                {\n                    var sn = siemens.match(/MosaicRefAcqTimes=([-\\d.\\s]+)\\n/);\n                    if (sn && sn.length > 1)\n                    {\n                        var tr = this.images[0].gettag(\'RepetitionTime\');\n                        var dummy = sn[1].split(" ").slice(0,this.NumberOfImagesInMosaic).map(function(x){return (k*tr + parseInt(x))});\n                        this.sliceTimes = this.sliceTimes.concat(dummy);\n                    }                \n                }\n                else // Hack: for mosaics, guess the slice times from the total TR. Assume first slice is second top slice ...\n                {\n                    var tr = this.images[0].gettag(\'RepetitionTime\');\n                    let n = this.NumberOfImagesInMosaic;\n                    var dt = tr/(n-0);\n                    if(tr)\n                    {\n                        \n                        for(var u=0; u<n; u++)\n                        //for(var u=n-1; u>=0; u--)\n                        {\n                           if(u%2 == 1)\n                            this.sliceTimes.push(tr*k + math.round(u/2*dt )); \n                           else\n                            this.sliceTimes.push(tr*k + math.round( (u-1)/2*dt + n/2*dt ) ); \n                        }\n                    }\n                }\n            }\n        }\n\n        \n        if(typeof siemens == "string" )\n        {\n            var sn = siemens.match(/DiffusionGradientDirection=([-\\d.\\s]+)\\n/);\n            var bdir;\n            var bmat;\n            var bv = 0;\n            if (sn && sn.length > 1)\n            {\n                bdir = sn[1].split(" ");\n                this.imageInfo.diffusion = true;\n                var bval = siemens.match(/B_value=([-\\d.\\s]+)\\n/);\n                if (bval && bval.length > 1)\n                     bv = parseFloat(bval[1].trim());\n                var bmat_ = siemens.match(/B_matrix=([-\\d.\\s]+)\\n/);\n                if (bmat_ != null)\n                {\n                  bmat_ = bmat_[1].split(" ");\n                  bmat = [[parseFloat(bmat_[0].trim()),parseFloat(bmat_[1].trim()),parseFloat(bmat_[2].trim())],\n                      [parseFloat(bmat_[1].trim()),parseFloat(bmat_[3].trim()),parseFloat(bmat_[4].trim())],\n                      [parseFloat(bmat_[2].trim()),parseFloat(bmat_[4].trim()),parseFloat(bmat_[5].trim())]];\n                }\n                else\n                  bmat = [];\n\n\n\n            }\n            else\n            {\n                bdir = ["0","0","0"];\n            }\n\n          \n\n\n            // for mosaic, store every bval/vec, for non-mosaic, only take bval/vec of one slice per volume (first slice)\n            if(this.isMosaic\n            ||  ( k==0 || list[k].SliceLocation_calculated == list[0].SliceLocation_calculated)   )\n            {\n                    \n                this.imageInfo.bMatrix.push(bmat);                \n                this.imageInfo.bDirections.push(bdir);                \n                this.imageInfo.bValue.push(bv);\n            }\n\n            //var sn = siemens.match(/FlowVenc=([-\\d.\\s]+)\\n/);\n            //console.log(sn);\n\n        }\n\n\n\n\n\n    }\n    \n    // calculate the average time per slice (in ms)\n    this.sliceDuration = ( math.max( this.sliceTimes ) - math.min( this.sliceTimes) ) / this.images.length;\n    this.sliceDuration = math.round(this.sliceDuration*100)/100;\n    this.volumeDuration = this.sliceDuration * posvec.length;\n    this.volumeDuration = math.round(this.volumeDuration*100)/100 ;\n\n\n\n    // calculate the slice normal vector from the positions. Necessary for correct calculation of getbestTransform (edges)\n    if(mutlislice)\n    {\n        var sliceVec;\n        for (var k = 0;k < list.length;k++)\n        {\n           sliceVec = vsum(list[0].ImagePosition, list[k].ImagePosition,-1);\n           if (math.norm(sliceVec) < 0.0000001)\n                continue;\n           break;\n        }\n        sliceVec = math.multiply( sliceVec, -1/math.norm(sliceVec) )._data;\n        this.sliceVec = sliceVec;\n    }\n    if(this.isMultiFrame)\n    {\n        if(this.images[0].ktags.ImagePositionPatient != undefined && this.images[0].ktags.ImagePositionPatient.multival)\n        {\n            var v = this.images[0].ktags.ImagePositionPatient.multival;\n            var sliceVec = vsum(v[0], v[v.length-1],-1);\n            sliceVec = math.multiply( sliceVec, -1/math.norm(sliceVec) )._data;\n            this.sliceVec = sliceVec;\n            this.MultiFrameSliceThickness = math.norm(vsum(v[0], v[1],-1) ) ;\n        }\n              \n    }\n\n    // could also implement here: make edges roation by checking detsign and flipping image order and slice vector\n\n\n    this.imagesOriginalOrder = this.images;\n    this.images = orderedImages;\n}\n\n\n\n\n/**\n * Concatenates image data (asynchronously).\n * @param {object} progressMeter -- the object must have a drawProgress(percent, label) function [e.g., drawProgress(.5, "Loading...")]\n * @param {Function} onFinishedImageRead -- callback\n */\ndaikon.Series.prototype.concatenateImageData = function (progressMeter, onFinishedImageRead) {\n    var buffer, data, length;\n\n    var index = 0;\n\n    while (index < this.images.length)\n    {\n        if (this.isMosaic) \n        {\n            data = this.getMosaicData(this.images[index], this.images[index].getPixelDataBytes());\n        } \n        else \n        {\n            data = this.images[index].getPixelDataBytes();\n        }\n\n\n        if (data != undefined)\n            break;\n        \n        index++;\n\n    }\n\n\n    //this.images[index].clearPixelData();\n    //length = this.validatePixelDataLength(this.images[0]);\n    length = data.byteLength;\n    if(length==undefined)\n    {\n        console.log("error in concatenateImageData, byte length not defined.");\n        return;\n    }\n    buffer = new Uint8Array(new ArrayBuffer(length * this.images.length));\n    buffer.set(new Uint8Array(data, 0, length), 0);\n    this.concatenateNextImageData(buffer, length, progressMeter, index+1, onFinishedImageRead);\n    \n};\n\n\n\ndaikon.Series.prototype.concatenateNextImageData = function (buffer, frameSize, progressMeter, index,\n                                                             onFinishedImageRead) {\n    var data, length;\n\n    if (index >= this.images.length) \n    {\n        if (progressMeter) {\n            progressMeter.drawProgress(1, "Reading DICOM Images");\n        }\n\n        onFinishedImageRead(buffer.buffer);\n    } else {\n        if (progressMeter) {\n            progressMeter.drawProgress(index / this.images.length, "Reading DICOM Images");\n        }\n\n        if (this.isMosaic) \n        {\n            data = this.getMosaicData(this.images[index], this.images[index].getPixelDataBytes());\n        } \n        else \n        {\n            data = this.images[index].getPixelDataBytes();\n        }\n\n        //length = this.validatePixelDataLength(this.images[index]);\n        if (data)\n        {\n            length = data.byteLength;\n\n            this.images[index].clearPixelData();\n            try {\n                buffer.set(new Uint8Array(data, 0, length), (frameSize * index));\n            }\n            catch(err) {\n                console.log("image sizes inconsistent")\n            }\n        }\n        \n        setTimeout(daikon.Utils.bind(this, function() {this.concatenateNextImageData(buffer, frameSize, progressMeter,\n            index + 1, onFinishedImageRead);}), 0);\n    }\n};\n\n\n\ndaikon.Series.prototype.validatePixelDataLength = function (image) {\n    var length = image.getPixelDataBytes().byteLength,\n        sliceLength = image.getCols() * image.getRows();\n\n    // pixel data length should be divisible by slice size, if not, try to figure out correct pixel data length\n    if ((length % sliceLength) === 0) {\n        return length;\n    }\n\n    return sliceLength * image.getNumberOfFrames() * image.getNumberOfSamplesPerPixel() * (image.getBitsAllocated() / 8);\n};\n\n\n\ndaikon.Series.prototype.getMosaicData = function (image, data) {\n    var mosaicWidth, mosaicHeight, mosaicRows, mosaicCols, mosaicRowHeight, mosaicColWidth,\n        numBytes, ctrS, ctrR, ctrC, numSlices, numRows, numCols, buffer, dataTyped, offset, ctr, index = 0;\n\n    numBytes = parseInt(this.images[0].getBitsAllocated() / 8);\n    numSlices = this.NumberOfImagesInMosaic; //this.images[0].getMosaicCols() * this.images[0].getMosaicRows();\n    numRows = parseInt(this.images[0].getRows() / this.images[0].getMosaicRows());\n    numCols = parseInt(this.images[0].getCols() / this.images[0].getMosaicCols());\n\n    mosaicWidth = this.images[0].getCols();\n    mosaicHeight = this.images[0].getRows();\n    mosaicRows =  this.images[0].getMosaicRows();\n    mosaicCols = this.images[0].getMosaicCols();\n    mosaicRowHeight = parseInt(mosaicHeight / mosaicRows);\n    mosaicColWidth = parseInt(mosaicWidth / mosaicCols);\n\n    buffer = new Uint8Array(new ArrayBuffer(numSlices * numRows * numCols * numBytes));\n    dataTyped = new Uint8Array(data);\n    var offset_tmp;\n\n    for (ctrS = 0; ctrS < numSlices; ctrS += 1) {\n        offset_tmp =  ((ctrS % mosaicCols) * mosaicColWidth) + ((parseInt(ctrS / mosaicCols)) * mosaicRowHeight) * mosaicWidth;\n        for (ctrR = 0; ctrR < numRows; ctrR += 1) {\n            for (ctrC = 0; ctrC < numCols; ctrC += 1) {\n                //offset = numBytes*daikon.Series.getMosaicOffset(mosaicCols, mosaicColWidth, mosaicRowHeight, mosaicWidth, ctrC,  ctrR, ctrS);\n                offset = (offset_tmp  + ctrR * mosaicWidth  + ctrC) * numBytes;                    \n                for (ctr = 0; ctr < numBytes; ctr += 1) {\n                    buffer[index] = dataTyped[offset + ctr];\n                    index += 1;\n                }\n            }\n        }\n    }\n\n    return buffer.buffer;\n};\n\n\n/*\n\ndaikon.Series.getMosaicOffset = function (mosaicCols, mosaicColWidth, mosaicRowHeight, mosaicWidth, xLocVal,\n                                          yLocVal, zLocVal) {\n    var xLoc, yLoc, zLoc;\n\n    xLoc = xLocVal;\n    yLoc = yLocVal;\n    zLoc = zLocVal;\n\n    xLoc = ((zLoc % mosaicCols) * mosaicColWidth) + xLoc;\n    yLoc = (((parseInt(zLoc / mosaicCols)) * mosaicRowHeight) + yLoc) * mosaicWidth;\n((ctrS % mosaicCols) * mosaicColWidth) + ctrC + (((parseInt(zLoc / mosaicCols)) * mosaicRowHeight) + ctrR) * mosaicWidth;\n    return (xLoc + yLoc);\n};\n*/\n\n\n\n\n\n\n\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.Series;\n}\n\n},{"./image.js":31,"./iterator.js":32,"./orderedmap.js":34,"./parser.js":35,"./utilities.js":40}],38:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\ndaikon.Utils = daikon.Utils || ((typeof require !== \'undefined\') ? require(\'./utilities.js\') : null);\n\n\n/*** Constructor ***/\n\n/**\n * The Siemens constructor.\n * @params {ArrayBuffer} buffer\n * @type {Function}\n */\ndaikon.Siemens = daikon.Siemens || function (buffer) {\n    this.output = "";\n    this.data = new DataView(buffer, 0);\n    this.datauint8 = new Uint8Array(buffer);\n   // this.datauint32 = new Uint32Array(buffer);\n};\n\n\n/*** Static Pseudo-constants ***/\n\ndaikon.Siemens.CSA2_MAGIC_NUMBER = [83, 86, 49, 48];\ndaikon.Siemens.NAME_LENGTH = 64;\ndaikon.Siemens.ELEMENT_CSA1 = 0x1010;\ndaikon.Siemens.ELEMENT_CSA2 = 0x1020;\ndaikon.Siemens.GROUP_CSA = 0x029;\n\n\n/*** Prototype Methods ***/\n\n/**\n * Reads the Siemens header.  (See http://nipy.org/nibabel/dicom/siemens_csa.html)\n * @returns {string}\n */\ndaikon.Siemens.prototype.readHeader = function () {\n    /*jslint bitwise: true */\n\n    var returnVal, ctr, match;\n\n    this.output += "<pre>";\n\n    try \n    {\n        match = true;\n        for (ctr = 0; ctr < daikon.Siemens.CSA2_MAGIC_NUMBER.length; ctr += 1) {\n            match &= (this.data.getUint8(ctr) === daikon.Siemens.CSA2_MAGIC_NUMBER[ctr]);\n        }\n\n        if (match) {\n            returnVal = this.readHeaderAtOffset(daikon.Siemens.CSA2_MAGIC_NUMBER.length + 4);\n        } else {\n            returnVal = this.readHeaderAtOffset(0);\n        }\n    } \n    catch (error) {\n        console.log(error);\n    }\n\n    this.output += "</pre>";\n\n    return returnVal;\n};\n\n\n\ndaikon.Siemens.prototype.readHeaderAtOffset = function (offset) {\n    var numTags, ctr;\n\n    this.output += \'\\n\';\n\n    numTags = daikon.Utils.swap32(this.data.getUint32(offset));\n//    numTags = this.datauint32[offset];\n\n    if ((numTags < 1) || (numTags > 128)) {\n        return this.output;\n    }\n\n    offset += 4;\n\n    offset += 4; // unused\n    \n    \n\n    for (ctr = 0; ctr < numTags; ctr += 1) {\n        offset = this.readTag(offset);\n\n        if (offset === -1) {\n            break;\n        }\n    }\n\n    return this.output;\n};\n\n\n\n\ndaikon.Siemens.prototype.readString = function (offset, length) {\n    var char2, ctr, str = "";\n\n    for (ctr = 0; ctr < length; ctr += 1) {\n//        char2 = this.data.getUint8(offset + ctr);\n        char2 = this.datauint8[offset + ctr];\n\n        if (char2 === 0) {\n            break;\n        }\n\n        str += String.fromCharCode(char2);\n    }\n\n    return str;\n};\n\n\ndaikon.Siemens.prototype.readTag = function (offset) {\n    var name, ctr, numItems;\n    name = this.readString(offset, daikon.Siemens.NAME_LENGTH);\n\n    offset += daikon.Siemens.NAME_LENGTH;\n\n    offset += 4; // vm\n\n    offset += 4;\n\n    offset += 4; // syngodt\n\n    numItems = daikon.Utils.swap32(this.data.getUint32(offset));\n//    numItems = datauint32[offset];\n    offset += 4;\n\n    offset += 4; // unused\n\n    this.output += ("    " + name + "=");\n\n    this.databufferlength = this.data.buffer.length;\n\n    for (ctr = 0; ctr < numItems; ctr += 1) {\n        offset = this.readItem(offset);\n\n        if (offset === -1) {\n            break;\n        } else if ((offset % 4) !== 0) {\n            offset += (4 - (offset % 4));\n        }\n    }\n\n    this.output += (\'\\n\');\n\n    return offset;\n};\n\n\n\ndaikon.Siemens.prototype.readItem = function (offset) {\n    var itemLength;\n\n    itemLength = daikon.Utils.swap32(this.data.getUint32(offset));\n\n\n    if ((offset + itemLength) > this.databufferlength) {\n        return -1;\n    }\n\n    offset += 16;\n\n    if (itemLength > 0) {\n        this.output += (this.readString(offset, itemLength) + " ");\n    }\n\n    return offset + itemLength;\n};\n\n\n/**\n * Returns true if the specified group and element indicate this tag can be read.\n * @param {number} group\n * @param {number} element\n * @returns {boolean}\n */\ndaikon.Siemens.prototype.canRead = function (group, element) {\n    return (group === daikon.Siemens.GROUP_CSA) && ((element === daikon.Siemens.ELEMENT_CSA1) || (element === daikon.Siemens.ELEMENT_CSA2));\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.Siemens;\n}\n\n},{"./utilities.js":40}],39:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\ndaikon.Utils = daikon.Utils || ((typeof require !== \'undefined\') ? require(\'./utilities.js\') : null);\ndaikon.Dictionary = daikon.Dictionary || ((typeof require !== \'undefined\') ? require(\'./dictionary.js\') : null);\ndaikon.Siemens = daikon.Siemens || ((typeof require !== \'undefined\') ? require(\'./siemens.js\') : null);\n\n\n/*** Constructor ***/\n\n/**\n * The Tag constuctor.\n * @property {number} group\n * @property {number} element\n * @property {string} vr\n * @property {number} offsetStart\n * @property {number} offsetValue\n * @property {number} offsetEnd\n * @property {boolean} sublist - true if this tag is a sublist\n * @property {number|number[]|string|string[]|object} value\n * @type {Function}\n */\ndaikon.Tag = daikon.Tag || function (group, element, vr, value, offsetStart, offsetValue, offsetEnd, littleEndian) {\n    this.group = group;\n    this.element = element;\n    this.group_hex = daikon.Utils.dec2hex(group);\n    this.element_hex = daikon.Utils.dec2hex(element);\n    this.vr = vr;\n    this.offsetStart = offsetStart;\n    this.offsetValue = offsetValue;\n    this.offsetEnd = offsetEnd;\n    this.sublist = false;\n    this.id = daikon.Tag.createId(group, element);\n\n    // Kellner: save also the string key for this tag\n    this.key = daikon.Dictionary.getDescription(this.group_hex, this.element_hex);\n\n\n    if (value instanceof Array) {\n        this.value = value;\n        this.sublist = true;\n    } else if (value !== null) {\n        var dv = new DataView(value);\n//        var dv = new DataView(value,value.koff,value.klen);\n        this.value = daikon.Tag.convertValue(vr, dv, littleEndian);\n\n        if ((this.value === dv) && this.isPrivateData()) {\n            this.value = daikon.Tag.convertPrivateValue(group, element, dv);\n        }\n    } else {\n        this.value = null;\n    }\n};\n\n\n/*** Static Pseudo-constants ***/\n\ndaikon.Tag.PRIVATE_DATA_READERS = [daikon.Siemens];\n\ndaikon.Tag.VR_AE_MAX_LENGTH = 16;\ndaikon.Tag.VR_AS_MAX_LENGTH = 4;\ndaikon.Tag.VR_AT_MAX_LENGTH = 4;\ndaikon.Tag.VR_CS_MAX_LENGTH = 16;\ndaikon.Tag.VR_DA_MAX_LENGTH = 8;\ndaikon.Tag.VR_DS_MAX_LENGTH = 16;\ndaikon.Tag.VR_DT_MAX_LENGTH = 26;\ndaikon.Tag.VR_FL_MAX_LENGTH = 4;\ndaikon.Tag.VR_FD_MAX_LENGTH = 8;\ndaikon.Tag.VR_IS_MAX_LENGTH = 12;\ndaikon.Tag.VR_LO_MAX_LENGTH = 64;\ndaikon.Tag.VR_LT_MAX_LENGTH = 10240;\ndaikon.Tag.VR_OB_MAX_LENGTH = -1;\ndaikon.Tag.VR_OD_MAX_LENGTH = -1;\ndaikon.Tag.VR_OF_MAX_LENGTH = -1;\ndaikon.Tag.VR_OW_MAX_LENGTH = -1;\ndaikon.Tag.VR_PN_MAX_LENGTH = 64 * 5;\ndaikon.Tag.VR_SH_MAX_LENGTH = 16;\ndaikon.Tag.VR_SL_MAX_LENGTH = 4;\ndaikon.Tag.VR_SS_MAX_LENGTH = 2;\ndaikon.Tag.VR_ST_MAX_LENGTH = 1024;\ndaikon.Tag.VR_TM_MAX_LENGTH = 16;\ndaikon.Tag.VR_UI_MAX_LENGTH = 64;\ndaikon.Tag.VR_UL_MAX_LENGTH = 4;\ndaikon.Tag.VR_UN_MAX_LENGTH = -1;\ndaikon.Tag.VR_US_MAX_LENGTH = 2;\ndaikon.Tag.VR_UT_MAX_LENGTH = -1;\n\n// metadata\ndaikon.Tag.TAG_TRANSFER_SYNTAX = [0x0002, 0x0010];\ndaikon.Tag.TAG_META_LENGTH = [0x0002, 0x0000];\n\n// sublists\ndaikon.Tag.TAG_SUBLIST_ITEM = [0xFFFE, 0xE000];\ndaikon.Tag.TAG_SUBLIST_ITEM_DELIM = [0xFFFE, 0xE00D];\ndaikon.Tag.TAG_SUBLIST_SEQ_DELIM = [0xFFFE, 0xE0DD];\n\n// image dims\ndaikon.Tag.TAG_ROWS = [0x0028, 0x0010];\ndaikon.Tag.TAG_COLS = [0x0028, 0x0011];\ndaikon.Tag.TAG_ACQUISITION_MATRIX = [0x0018, 0x1310];\ndaikon.Tag.TAG_NUMBER_OF_FRAMES = [0x0028, 0x0008];\ndaikon.Tag.TAG_NUMBER_TEMPORAL_POSITIONS = [0x0020, 0x0105];\n\n// voxel dims\ndaikon.Tag.TAG_PIXEL_SPACING = [0x0028, 0x0030];\ndaikon.Tag.TAG_SLICE_THICKNESS = [0x0018, 0x0050];\ndaikon.Tag.TAG_SLICE_GAP = [0x0018, 0x0088];\ndaikon.Tag.TAG_TR = [0x0018, 0x0080];\ndaikon.Tag.TAG_FRAME_TIME = [0x0018, 0x1063];\n\n// datatype\ndaikon.Tag.TAG_BITS_ALLOCATED = [0x0028, 0x0100];\ndaikon.Tag.TAG_BITS_STORED = [0x0028, 0x0101];\ndaikon.Tag.TAG_PIXEL_REPRESENTATION = [0x0028, 0x0103];\ndaikon.Tag.TAG_HIGH_BIT = [0x0028, 0x0102];\ndaikon.Tag.TAG_PHOTOMETRIC_INTERPRETATION = [0x0028, 0x0004];\ndaikon.Tag.TAG_SAMPLES_PER_PIXEL = [0x0028, 0x0002];\ndaikon.Tag.TAG_PLANAR_CONFIG = [0x0028, 0x0006];\ndaikon.Tag.TAG_PALETTE_RED = [0x0028, 0x1201];\ndaikon.Tag.TAG_PALETTE_GREEN = [0x0028, 0x1202];\ndaikon.Tag.TAG_PALETTE_BLUE = [0x0028, 0x1203];\n\n// data scale\ndaikon.Tag.TAG_DATA_SCALE_SLOPE = [0x0028, 0x1053];\ndaikon.Tag.TAG_DATA_SCALE_INTERCEPT = [0x0028, 0x1052];\ndaikon.Tag.TAG_DATA_SCALE_ELSCINT = [0x0207, 0x101F];\ndaikon.Tag.TAG_PIXEL_BANDWIDTH = [0x0018, 0x0095];\n\n// range\ndaikon.Tag.TAG_IMAGE_MIN = [0x0028, 0x0106];\ndaikon.Tag.TAG_IMAGE_MAX = [0x0028, 0x0107];\ndaikon.Tag.TAG_WINDOW_CENTER = [0x0028, 0x1050];\ndaikon.Tag.TAG_WINDOW_WIDTH = [0x0028, 0x1051];\n\n// descriptors\ndaikon.Tag.TAG_PATIENT_NAME = [0x0010, 0x0010];\ndaikon.Tag.TAG_PATIENT_ID = [0x0010, 0x0020];\ndaikon.Tag.TAG_STUDY_DATE = [0x0008, 0x0020];\ndaikon.Tag.TAG_STUDY_TIME = [0x0008, 0x0030];\ndaikon.Tag.TAG_STUDY_DES = [0x0008, 0x1030];\ndaikon.Tag.TAG_IMAGE_TYPE = [0x0008, 0x0008];\ndaikon.Tag.TAG_IMAGE_COMMENTS = [0x0020, 0x4000];\ndaikon.Tag.TAG_SEQUENCE_NAME = [0x0018, 0x0024];\ndaikon.Tag.TAG_MODALITY = [0x0008, 0x0060];\n\n// session ID\ndaikon.Tag.TAG_FRAME_OF_REF_UID = [0x0020, 0x0052];\n\n// study ID\ndaikon.Tag.TAG_STUDY_UID = [0x0020, 0x000D];\n\n// volume ID\ndaikon.Tag.TAG_SERIES_DESCRIPTION = [0x0008, 0x103E];\ndaikon.Tag.TAG_SERIES_INSTANCE_UID = [0x0020, 0x000E];\ndaikon.Tag.TAG_SERIES_NUMBER = [0x0020, 0x0011];\ndaikon.Tag.TAG_ECHO_NUMBER = [0x0018, 0x0086];\ndaikon.Tag.TAG_TEMPORAL_POSITION = [0x0020, 0x0100];\n\n// slice ID\ndaikon.Tag.TAG_IMAGE_NUM = [0x0020, 0x0013];\ndaikon.Tag.TAG_SLICE_LOCATION = [0x0020, 0x1041];\n\n// orientation\ndaikon.Tag.TAG_IMAGE_ORIENTATION = [0x0020, 0x0037];\ndaikon.Tag.TAG_IMAGE_POSITION = [0x0020, 0x0032];\ndaikon.Tag.TAG_SLICE_LOCATION_VECTOR = [0x0018, 0x2005];\n\n// pixel data\ndaikon.Tag.TAG_PIXEL_DATA = [0x7FE0, 0x0010];\n\n\n/*** Static methods ***/\n\n/**\n * Create an ID string based on the specified group and element\n * @param {number} group\n * @param {number} element\n * @returns {string}\n */\ndaikon.Tag.createId = function (group, element) {\n    var groupStr = daikon.Utils.dec2hex(group),\n        elemStr = daikon.Utils.dec2hex(element);\n    return groupStr + elemStr;\n};\n\n\n\ndaikon.Tag.getUnsignedInteger16 = function (rawData, littleEndian) {\n    var data, mul, ctr;\n\n    mul = rawData.byteLength / 2;\n    data = [];\n    for (ctr = 0; ctr < mul; ctr += 1) {\n        data[ctr] = rawData.getUint16(ctr * 2, littleEndian);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getSignedInteger16 = function (rawData, littleEndian) {\n    var data, mul, ctr;\n\n    mul = rawData.byteLength / 2;\n    data = [];\n    for (ctr = 0; ctr < mul; ctr += 1) {\n        data[ctr] = rawData.getInt16(ctr * 2, littleEndian);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getFloat32 = function (rawData, littleEndian) {\n    var data, mul, ctr;\n\n    mul = rawData.byteLength / 4;\n    data = [];\n    for (ctr = 0; ctr < mul; ctr += 1) {\n        data[ctr] = rawData.getFloat32(ctr * 4, littleEndian);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getSignedInteger32 = function (rawData, littleEndian) {\n    var data, mul, ctr;\n\n    mul = rawData.byteLength / 4;\n    data = [];\n    for (ctr = 0; ctr < mul; ctr += 1) {\n        data[ctr] = rawData.getInt32(ctr * 4, littleEndian);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getUnsignedInteger32 = function (rawData, littleEndian) {\n    var data, mul, ctr;\n\n    mul = rawData.byteLength / 4;\n    data = [];\n    for (ctr = 0; ctr < mul; ctr += 1) {\n        data[ctr] = rawData.getUint32(ctr * 4, littleEndian);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getFloat64 = function (rawData, littleEndian) {\n    var data, mul, ctr;\n\n    mul = rawData.byteLength / 8;\n    data = [];\n    for (ctr = 0; ctr < mul; ctr += 1) {\n        data[ctr] = rawData.getFloat64(ctr * 8, littleEndian);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getDoubleElscint = function (rawData) {\n    var data = [], reordered = [], ctr;\n\n    for (ctr = 0; ctr < 8; ctr += 1) {\n        data[ctr] = rawData.getUint8(ctr);\n    }\n\n    reordered[0] = data[3];\n    reordered[1] = data[2];\n    reordered[2] = data[1];\n    reordered[3] = data[0];\n    reordered[4] = data[7];\n    reordered[5] = data[6];\n    reordered[6] = data[5];\n    reordered[7] = data[4];\n\n    data = [daikon.Utils.bytesToDouble(reordered)];\n\n    return data;\n};\n\n\n\ndaikon.Tag.getFixedLengthStringValue = function (rawData, maxLength) {\n    var data, mul, ctr;\n\n    mul = Math.floor(rawData.byteLength / maxLength);\n    data = [];\n    for (ctr = 0; ctr < mul; ctr += 1) {\n        data[ctr] = daikon.Utils.getStringAt(rawData, ctr * maxLength, maxLength);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getStringValue = function (rawData) {\n    var data = daikon.Utils.getStringAt(rawData, 0, rawData.byteLength).split(\'\\\\\'), ctr;\n\n    for (ctr = 0; ctr < data.length; ctr += 1) {\n        data[ctr] = daikon.Utils.trim(data[ctr]);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getDateStringValue = function (rawData) {\n    var dotFormat = (daikon.Tag.getSingleStringValue(rawData)[0].indexOf(\'.\') !== -1),\n        stringData = daikon.Tag.getFixedLengthStringValue(rawData, dotFormat ? 10 : daikon.Tag.VR_DA_MAX_LENGTH),\n        parts = null,\n        data = [],\n        ctr;\n\n    for (ctr = 0; ctr < stringData.length; ctr += 1) {\n        if (dotFormat) {\n            parts = stringData[ctr].split(\'.\');\n            if (parts.length === 3) {\n                data[ctr] = new Date(daikon.Utils.safeParseInt(parts[0]),\n                    daikon.Utils.safeParseInt(parts[1]) - 1,\n                    daikon.Utils.safeParseInt(parts[2]));\n            } else {\n                data[ctr] = new Date();\n            }\n        } else if (stringData[ctr].length === 8) {\n            data[ctr] = new Date(daikon.Utils.safeParseInt(stringData[ctr].substring(0, 4)),\n                daikon.Utils.safeParseInt(stringData[ctr].substring(4, 6)) - 1,\n                daikon.Utils.safeParseInt(stringData[ctr].substring(6, 8)));\n        } else {\n            data[ctr] = Date.parse(stringData[ctr]);\n        }\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getDateTimeStringValue = function (rawData) {\n    var stringData = daikon.Tag.getStringValue(rawData),\n        data = [],\n        ctr,\n        year = null,\n        month = null,\n        date = null,\n        hours = null,\n        minutes = null,\n        seconds = null;\n\n    for (ctr = 0; ctr < stringData.length; ctr += 1) {\n        if (stringData[ctr].length >= 4) {\n            year = parseInt(stringData[ctr].substring(0, 4), 10);  // required\n\n            if (stringData[ctr].length >= 6) {\n                month = daikon.Utils.safeParseInt(stringData[ctr].substring(4, 6)) - 1;\n            }\n\n            if (stringData[ctr].length >= 8) {\n                date = daikon.Utils.safeParseInt(stringData[ctr].substring(6, 8));\n            }\n\n            if (stringData[ctr].length >= 10) {\n                hours = daikon.Utils.safeParseInt(stringData[ctr].substring(8, 10));\n            }\n\n            if (stringData[ctr].length >= 12) {\n                minutes = daikon.Utils.safeParseInt(stringData[ctr].substring(10, 12));\n            }\n\n            if (stringData[ctr].length >= 14) {\n                seconds = daikon.Utils.safeParseInt(stringData[ctr].substring(12, 14));\n            }\n\n            data[ctr] = new Date(year, month, date, hours, minutes, seconds);\n        } else {\n            data[ctr] = Date.parse(stringData[ctr]);\n        }\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getTimeStringValue = function (rawData) {\n    var stringData = daikon.Tag.getStringValue(rawData),\n        data = [],\n        parts = null,\n        ctr,\n        hours = 0,\n        minutes = 0,\n        seconds = 0;\n\n    for (ctr = 0; ctr < stringData.length; ctr += 1) {\n        if (stringData[ctr].indexOf(\':\') !== -1) {\n            parts = stringData[ctr].split(\':\');\n            hours = daikon.Utils.safeParseInt(parts[0]);\n\n            if (parts.length > 1) {\n                minutes = daikon.Utils.safeParseInt(parts[1]);\n            }\n\n            if (parts.length > 2) {\n                seconds = daikon.Utils.safeParseFloat(parts[2]);\n            }\n        } else {\n            if (stringData[ctr].length >= 2) {\n                hours = daikon.Utils.safeParseInt(stringData[ctr].substring(0, 2));\n            }\n\n            if (stringData[ctr].length >= 4) {\n                minutes = daikon.Utils.safeParseInt(stringData[ctr].substring(2, 4));\n            }\n\n            if (stringData[ctr].length >= 6) {\n                seconds = daikon.Utils.safeParseFloat(stringData[ctr].substring(4));\n            }\n        }\n\n        data[ctr] = Math.round((hours * 60 * 60 * 1000) + (minutes * 60 * 1000) + (seconds * 1000));\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getDoubleStringValue = function (rawData) {\n    var stringData = daikon.Tag.getStringValue(rawData),\n        data = [],\n        ctr;\n\n    for (ctr = 0; ctr < stringData.length; ctr += 1) {\n        data[ctr] = parseFloat(stringData[ctr]);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getIntegerStringValue = function (rawData) {\n    var stringData = daikon.Tag.getStringValue(rawData),\n        data = [],\n        ctr;\n\n    for (ctr = 0; ctr < stringData.length; ctr += 1) {\n        data[ctr] = parseInt(stringData[ctr], 10);\n    }\n\n    return data;\n};\n\n\n\ndaikon.Tag.getSingleStringValue = function (rawData) {\n    return [daikon.Utils.trim(daikon.Utils.getStringAt(rawData, 0, rawData.byteLength))];\n};\n\n\n\ndaikon.Tag.getPersonNameStringValue = function (rawData) {\n    var stringData = daikon.Tag.getStringValue(rawData),\n        data = [],\n        ctr;\n\n    for (ctr = 0; ctr < stringData.length; ctr += 1) {\n        data[ctr] = stringData[ctr].replace(\'^\', \' \').replace(/[^\\u00C0-\\u017aa-zA-Z0-9-\\s ]+/g,\'\');\n    }\n\n    return data;\n\n};\n\n\n\ndaikon.Tag.convertPrivateValue = function (group, element, rawData) {\n    var ctr, privReader;\n\n    for (ctr = 0; ctr < daikon.Tag.PRIVATE_DATA_READERS.length; ctr += 1) \n    {\n        privReader = new daikon.Tag.PRIVATE_DATA_READERS[ctr](rawData.buffer);\n        if (privReader.canRead(group, element)) \n        {\n            var str = privReader.readHeader();\n            // Kellner: clean the private string ( see below )\n            //str = daikon.Tag.cleanPrivateHeaderString(str);\n            return str ;\n        }\n    }\n\n    return rawData;\n};\n\n\n/// Kellner\n// If all private data is always read, private data lets the heap explode\n// only extract relevant data\ndaikon.Tag.cleanPrivateHeaderString = function (str) \n{\n\n    var strout = "";\n    var sn = undefined;\n\n    sn = str.match(/DiffusionGradientDirection=([-\\d.\\s]+)\\n/);\n    if(sn != undefined )\n        strout += (sn[0] + "")\n    \n    sn = str.match(/B_value=([-\\d.\\s]+)\\n/);\n    if(sn != undefined )\n        strout += (sn[0] + "")\n    \n    sn  =   str.match(/SliceNormalVector=([-\\d.\\s]+)\\n/);\n    if(sn != undefined )\n        strout += (sn[0] + "")\n    \n    return strout;\n}\n\n/*\n\ndaikon.Tag.converter =\n{\n    AE: function (rawData) { return daikon.Tag.getSingleStringValue(rawData, daikon.Tag.VR_AE_MAX_LENGTH); },\n    AS:function (rawData) { return daikon.Tag.getFixedLengthStringValue(rawData, daikon.Tag.VR_AS_MAX_LENGTH);},\n    AT:function (rawData,littleEndian) {  return daikon.Tag.getUnsignedInteger16(rawData, littleEndian);},\n    CS:function (rawData) { return daikon.Tag.getStringValue(rawData);},\n    DA:function (rawData) { return  daikon.Tag.getDateStringValue(rawData);},\n    DS:function (rawData) {  return daikon.Tag.getDoubleStringValue(rawData);},\n    DT:function (rawData) {  return daikon.Tag.getDateTimeStringValue(rawData);},\n    FL:function (rawData,littleEndian) {  return  daikon.Tag.getFloat32(rawData, littleEndian);},\n    FD:function (rawData,littleEndian) {  return daikon.Tag.getFloat64(rawData, littleEndian);},\n    FE:function (rawData,littleEndian) {  return  daikon.Tag.getDoubleElscint(rawData, littleEndian);},\n    IS:function (rawData) {  return daikon.Tag.getIntegerStringValue(rawData);},\n    LO:function (rawData) {  return  daikon.Tag.getStringValue(rawData);},\n    LT:function (rawData) {  return daikon.Tag.getSingleStringValue(rawData);},\n    OB:function (rawData) {  return  rawData;},\n    OD:function (rawData) {  return  rawData;},\n    OF:function (rawData) {  return  rawData;},\n    OW:function (rawData) {  return  rawData;},\n    PN:function (rawData) {  return  daikon.Tag.getPersonNameStringValue(rawData);},\n    SH:function (rawData) {  return  daikon.Tag.getStringValue(rawData);},\n    SL:function (rawData,littleEndian) {  return  daikon.Tag.getSignedInteger32(rawData, littleEndian);},\n    SQ:function (rawData) {  return  null;},\n    SS:function (rawData,littleEndian) {  return  daikon.Tag.getSignedInteger16(rawData, littleEndian);},\n    ST:function (rawData) {  return  daikon.Tag.getSingleStringValue(rawData);},\n    TM:function (rawData) {  return  daikon.Tag.getTimeStringValue(rawData);},\n    UI:function (rawData) {  return  daikon.Tag.getStringValue(rawData);},\n    UL:function (rawData,littleEndian) {  return  daikon.Tag.getUnsignedInteger32(rawData, littleEndian);},\n    UN:function (rawData) {  return  rawData;},\n    US:function (rawData,littleEndian) {  return  daikon.Tag.getUnsignedInteger16(rawData, littleEndian);},\n    UT:function (rawData) {  return  daikon.Tag.getSingleStringValue(rawData);},\n}\n\n*/\n\n\ndaikon.Tag.convertValue = function (vr, rawData, littleEndian) {\n  //  return daikon.Tag.converter[vr](rawData,littleEndian)\n    \n    var data = null;\n\n    if (vr === \'AE\') {\n        data = daikon.Tag.getSingleStringValue(rawData, daikon.Tag.VR_AE_MAX_LENGTH);\n    } else if (vr === \'AS\') {\n        data = daikon.Tag.getFixedLengthStringValue(rawData, daikon.Tag.VR_AS_MAX_LENGTH);\n    } else if (vr === \'AT\') {\n        data = daikon.Tag.getUnsignedInteger16(rawData, littleEndian);\n    } else if (vr === \'CS\') {\n        data = daikon.Tag.getStringValue(rawData);\n    } else if (vr === \'DS\') {\n        data = daikon.Tag.getDoubleStringValue(rawData);\n    \n/*\n    } else if (vr === \'DA\') {\n        data = daikon.Tag.getDateStringValue(rawData);\n    } else if (vr === \'DT\') {\n        data = daikon.Tag.getDateTimeStringValue(rawData);\n    } else if (vr === \'TM\') {\n        data = daikon.Tag.getTimeStringValue(rawData);\n*/    \n    // do NOT convert nice dicom date and times into time object ...\n    } else if (vr === \'DA\') {\n        data = daikon.Tag.getStringValue(rawData);\n    } else if (vr === \'DT\') {\n        data = daikon.Tag.getStringValue(rawData);\n    } else if (vr === \'TM\') {\n        data = daikon.Tag.getStringValue(rawData);\n    \n\n    } else if (vr === \'FL\') {\n        data = daikon.Tag.getFloat32(rawData, littleEndian);\n    } else if (vr === \'FD\') {\n        data = daikon.Tag.getFloat64(rawData, littleEndian);\n    } else if (vr === \'FE\') {  // special Elscint double (see dictionary)\n        data = daikon.Tag.getDoubleElscint(rawData, littleEndian);\n    } else if (vr === \'IS\') {\n        data = daikon.Tag.getIntegerStringValue(rawData);\n    } else if (vr === \'LO\') {\n        data = daikon.Tag.getStringValue(rawData);\n    } else if (vr === \'LT\') {\n        data = daikon.Tag.getSingleStringValue(rawData);\n    } else if (vr === \'OB\') {\n        data = rawData;\n    } else if (vr === \'OD\') {\n        data = rawData;\n    } else if (vr === \'OF\') {\n        data = rawData;\n    } else if (vr === \'OW\') {\n        data = rawData;\n    } else if (vr === \'PN\') {\n        data = daikon.Tag.getPersonNameStringValue(rawData);\n    } else if (vr === \'SH\') {\n        data = daikon.Tag.getStringValue(rawData);\n    } else if (vr === \'SL\') {\n        data = daikon.Tag.getSignedInteger32(rawData, littleEndian);\n    } else if (vr === \'SQ\') {\n        data = rawData;\n//        data = null;\n    } else if (vr === \'SS\') {\n        data = daikon.Tag.getSignedInteger16(rawData, littleEndian);\n    } else if (vr === \'ST\') {\n        data = daikon.Tag.getSingleStringValue(rawData);\n    } else if (vr === \'UI\') {\n        data = daikon.Tag.getStringValue(rawData);\n    } else if (vr === \'UL\') {\n        data = daikon.Tag.getUnsignedInteger32(rawData, littleEndian);\n    } else if (vr === \'UN\') {\n        data = rawData;\n    } else if (vr === \'US\') {\n        data = daikon.Tag.getUnsignedInteger16(rawData, littleEndian);\n    } else if (vr === \'UT\') {\n        data = daikon.Tag.getSingleStringValue(rawData);\n    }\n\n    return data;\n};\n\n\n/*** Prototype Methods ***/\n\n/**\n * Returns a string representation of this tag.\n * @param {number} [level] - the indentation level\n * @param {boolean} [html]\n * @returns {string}\n */\ndaikon.Tag.prototype.toString = function (level, html) {\n    var valueStr = \'\',\n        ctr,\n        groupStr = daikon.Utils.dec2hex(this.group),\n        elemStr = daikon.Utils.dec2hex(this.element),\n        tagStr = \'(\' + groupStr + \',\' + elemStr + \')\',\n        des = \'\',\n        padding;\n\n    if (level === undefined) {\n        level = 0;\n    }\n\n    padding = "";\n    for (ctr = 0; ctr < level; ctr += 1) {\n        if (html) {\n            padding += "&nbsp;&nbsp;";\n        } else {\n            padding += "  ";\n        }\n    }\n\n    if (this.sublist) {\n        for (ctr = 0; ctr < this.value.length; ctr += 1) {\n            valueStr += (\'\\n\' + (this.value[ctr].toString(level + 1, html)));\n        }\n    } else if (this.vr === \'SQ\') {\n        valueStr = \'\';\n    } else if (this.isPixelData()) {\n        valueStr = \'\';\n    } else if (!this.value) {\n        valueStr = \'\';\n    } else {\n        valueStr = \'[\' + this.value + \']\';\n    }\n\n    if (this.isSublistItem()) {\n        tagStr = "Sequence Item";\n    } else if (this.isSublistItemDelim()) {\n        tagStr = "Sequence Item Delimiter";\n    } else if (this.isSequenceDelim()) {\n        tagStr = "Sequence Delimiter";\n    } else if (this.isPixelData()) {\n        tagStr = "Pixel Data";\n    } else {\n        des = daikon.Utils.convertCamcelCaseToTitleCase(daikon.Dictionary.getDescription(this.group_hex, this.element_hex));\n    }\n\n    if (html) {\n        return padding + "<span style=\'color:#B5CBD3\'>" + tagStr + "</span>&nbsp;&nbsp;&nbsp;" + des + \'&nbsp;&nbsp;&nbsp;\' + valueStr;\n    } else {\n        return padding + \' \' + tagStr + \' \' + des + \' \' + valueStr;\n    }\n};\n\n\n/**\n * Returns an HTML string representation of this tag.\n * @param {number} level - the indentation level\n * @returns {string}\n */\ndaikon.Tag.prototype.toHTMLString = function (level) {\n    return this.toString(level, true);\n};\n\n\n/**\n * Returns true if this is the transform syntax tag.\n * @returns {boolean}\n */\ndaikon.Tag.prototype.isTransformSyntax = function () {\n    return (this.group === daikon.Tag.TAG_TRANSFER_SYNTAX[0]) && (this.element === daikon.Tag.TAG_TRANSFER_SYNTAX[1]);\n};\n\n\n/**\n * Returns true if this is the pixel data tag.\n * @returns {boolean}\n */\ndaikon.Tag.prototype.isPixelData = function () {\n/*    if (this.value && this.value.buffer && this.key != "FileMetaInformationVersion")\n    {\n        if (!(this.group === daikon.Tag.TAG_PIXEL_DATA[0]) && (this.element === daikon.Tag.TAG_PIXEL_DATA[1]))\n                this;\n\n        return true;\n    }*/\n    return (this.group === daikon.Tag.TAG_PIXEL_DATA[0]) && (this.element === daikon.Tag.TAG_PIXEL_DATA[1]);\n};\n\n\n/**\n * Returns true if this tag contains private data.\n * @returns {boolean}\n */\ndaikon.Tag.prototype.isPrivateData = function () {\n    /*jslint bitwise: true */\n    return ((this.group & 1) === 1);\n};\n\n\n/**\n * Returns true if this tag contains private data that can be read.\n * @returns {boolean}\n */\ndaikon.Tag.prototype.hasInterpretedPrivateData = function () {\n    return this.isPrivateData() && daikon.Utils.isString(this.value);\n};\n\n\n/**\n * Returns true if this tag is a sublist item.\n * @returns {boolean}\n */\ndaikon.Tag.prototype.isSublistItem = function () {\n    return (this.group === daikon.Tag.TAG_SUBLIST_ITEM[0]) && (this.element === daikon.Tag.TAG_SUBLIST_ITEM[1]);\n};\n\n\n/**\n * Returns true if this tag is a sublist item delimiter.\n * @returns {boolean}\n */\ndaikon.Tag.prototype.isSublistItemDelim = function () {\n    return (this.group === daikon.Tag.TAG_SUBLIST_ITEM_DELIM[0]) && (this.element === daikon.Tag.TAG_SUBLIST_ITEM_DELIM[1]);\n};\n\n\n/**\n * Returns true if this tag is a sequence delimiter.\n * @returns {boolean}\n */\ndaikon.Tag.prototype.isSequenceDelim = function () {\n    return (this.group === daikon.Tag.TAG_SUBLIST_SEQ_DELIM[0]) && (this.element === daikon.Tag.TAG_SUBLIST_SEQ_DELIM[1]);\n};\n\n\n/**\n * Returns true if this is a meta length tag.\n * @returns {boolean}\n */\ndaikon.Tag.prototype.isMetaLength = function () {\n    return (this.group === daikon.Tag.TAG_META_LENGTH[0]) && (this.element === daikon.Tag.TAG_META_LENGTH[1]);\n};\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.Tag;\n}\n\n},{"./dictionary.js":30,"./siemens.js":38,"./utilities.js":40}],40:[function(require,module,exports){\n\n/*jslint browser: true, node: true */\n/*global require, module */\n\n"use strict";\n\n/*** Imports ***/\nvar daikon = daikon || {};\ndaikon.Utils = daikon.Utils || {};\n\n\ndaikon.Utils.crcTable = null;\n\n\n/*** Static Pseudo-constants ***/\n\ndaikon.Utils.MAX_VALUE = 9007199254740991;\ndaikon.Utils.MIN_VALUE = -9007199254740991;\n\n\n\n/*** Static methods ***/\n\ndaikon.Utils.dec2hex = function (i) {\n    return (i + 0x10000).toString(16).substr(-4).toUpperCase();\n};\n\n\n\n// http://stackoverflow.com/questions/966225/how-can-i-create-a-two-dimensional-array-in-javascript\ndaikon.Utils.createArray = function (length) {\n    var arr = new Array(length || 0),\n        i = length;\n\n    if (arguments.length > 1) {\n        var args = Array.prototype.slice.call(arguments, 1);\n        while(i--) arr[length-1 - i] = daikon.Utils.createArray.apply(this, args);\n    }\n\n    return arr;\n};\n\n\ndaikon.Utils.getStringAt = function (dataview, start, length) {\n    var str = "", ctr, ch;\n\n    for (ctr = 0; ctr < length; ctr += 1) {\n        ch = dataview.getUint8(start + ctr);\n\n        if (ch !== 0) {\n            str += String.fromCharCode(ch);\n        }\n    }\n\n    return str;\n};\n\n\n\ndaikon.Utils.trim = function (str) {\n    return str.replace(/^\\s\\s*/, \'\').replace(/\\s\\s*$/, \'\');\n};\n\n\n\ndaikon.Utils.stripLeadingZeros = function (str) {\n    return str.replace(/^[0]+/g, "");\n};\n\n\n\ndaikon.Utils.safeParseInt = function (str) {\n    str = daikon.Utils.stripLeadingZeros(str);\n    if (str.length > 0) {\n        return parseInt(str, 10);\n    }\n\n    return 0;\n};\n\n\n\ndaikon.Utils.convertCamcelCaseToTitleCase = function (str) {\n    var result = str.replace(/([A-Z][a-z])/g, " $1");\n    return daikon.Utils.trim(result.charAt(0).toUpperCase() + result.slice(1));\n};\n\n\n\ndaikon.Utils.safeParseFloat = function (str) {\n    str = daikon.Utils.stripLeadingZeros(str);\n    if (str.length > 0) {\n        return parseFloat(str);\n    }\n\n    return 0;\n};\n\n\n// http://stackoverflow.com/questions/8361086/convert-byte-array-to-numbers-in-javascript\ndaikon.Utils.bytesToDouble = function (data) {\n    var sign = (data[0] & 1<<7)>>7;\n\n    var exponent = (((data[0] & 127) << 4) | (data[1]&(15<<4))>>4);\n\n    if(exponent == 0) return 0;\n    if(exponent == 0x7ff) return (sign) ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;\n\n    var mul = Math.pow(2,exponent - 1023 - 52);\n    var mantissa = data[7]+\n        data[6]*Math.pow(2,8)+\n        data[5]*Math.pow(2,8*2)+\n        data[4]*Math.pow(2,8*3)+\n        data[3]*Math.pow(2,8*4)+\n        data[2]*Math.pow(2,8*5)+\n        (data[1]&15)*Math.pow(2,8*6)+\n        Math.pow(2,52);\n\n    return Math.pow(-1,sign)*mantissa*mul;\n};\n\n\n\ndaikon.Utils.concatArrayBuffers = function (buffer1, buffer2) {\n    var tmp = new Uint8Array(buffer1.byteLength + buffer2.byteLength);\n    tmp.set(new Uint8Array(buffer1), 0);\n    tmp.set(new Uint8Array(buffer2), buffer1.byteLength);\n    return tmp.buffer;\n};\n\n\n\ndaikon.Utils.concatArrayBuffers2 = function (buffers) {\n    var length = 0, offset = 0, ctr;\n\n    for (ctr = 0; ctr < buffers.length; ctr += 1) {\n        length += buffers[ctr].byteLength;\n    }\n\n    var tmp = new Uint8Array(length);\n\n    for (ctr = 0; ctr < buffers.length; ctr += 1) {\n        tmp.set(new Uint8Array(buffers[ctr]), offset);\n        offset += buffers[ctr].byteLength;\n\n    }\n\n    return tmp.buffer;\n};\n\n\n\ndaikon.Utils.fillBuffer = function (array, buffer, offset, numBytes) {\n    var ctr;\n\n    if (numBytes === 1) {\n        for (ctr = 0; ctr < array.length; ctr+=1) {\n            buffer.setUint8(offset + ctr, array[ctr]);\n        }\n    } else if (numBytes === 2) {\n        for (ctr = 0; ctr < array.length; ctr+=1) {\n            buffer.setUint16(offset + (ctr * 2), array[ctr], true);\n        }\n    }\n};\n\n\n\ndaikon.Utils.fillBufferRGB = function (array, buffer, offset) {\n    var r, g, b, ctr, numElements = (parseInt(array.length / 3));\n\n    for (ctr = 0; ctr < numElements; ctr+=1) {\n        r = array[ctr * 3];\n        g = array[ctr * 3 + 1];\n        b = array[ctr * 3 + 2];\n\n        buffer.setUint8(offset + ctr, parseInt((r + b + g) / 3), true);\n    }\n};\n\n\n\ndaikon.Utils.bind = function (scope, fn, args, appendArgs) {\n    if (arguments.length === 2) {\n        return function () {\n            return fn.apply(scope, arguments);\n        };\n    }\n\n    var method = fn,\n        slice = Array.prototype.slice;\n\n    return function () {\n        var callArgs = args || arguments;\n\n        if (appendArgs === true) {\n            callArgs = slice.call(arguments, 0);\n            callArgs = callArgs.concat(args);\n        } else if (typeof appendArgs === \'number\') {\n            callArgs = slice.call(arguments, 0); // copy arguments first\n            Ext.Array.insert(callArgs, appendArgs, args);\n        }\n\n        return method.apply(scope || window, callArgs);\n    };\n};\n\n\n\ndaikon.Utils.toArrayBuffer = function (buffer) {\n    var ab, view, i;\n\n    ab = new ArrayBuffer(buffer.length);\n    view = new Uint8Array(ab);\n    for (i = 0; i < buffer.length; i += 1) {\n        view[i] = buffer[i];\n    }\n    return ab;\n};\n\n\n\n// http://stackoverflow.com/questions/203739/why-does-instanceof-return-false-for-some-literals\ndaikon.Utils.isString = function (s) {\n    return typeof(s) === \'string\' || s instanceof String;\n};\n\n\n\ndaikon.Utils.swap32 = function (val) {\n    /*jslint bitwise: true */\n    return ((val & 0xFF) << 24) | ((val & 0xFF00) << 8) | ((val >> 8) & 0xFF00) | ((val >> 24) & 0xFF);\n};\n\n\n\ndaikon.Utils.swap16 = function (val) {\n    /*jslint bitwise: true */\n    return ((((val & 0xFF) << 8) | ((val >> 8) & 0xFF)) << 16) >> 16;  // since JS uses 32-bit when bit shifting\n};\n\n\n// http://stackoverflow.com/questions/18638900/javascript-crc32\ndaikon.Utils.makeCRCTable = function(){\n    var c;\n    var crcTable = [];\n    for(var n =0; n < 256; n++){\n        c = n;\n        for(var k =0; k < 8; k++){\n            c = ((c&1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n        }\n        crcTable[n] = c;\n    }\n    return crcTable;\n};\n\ndaikon.Utils.crc32 = function(dataView) {\n    var crcTable = daikon.Utils.crcTable || (daikon.Utils.crcTable = daikon.Utils.makeCRCTable());\n    var crc = 0 ^ (-1);\n\n    for (var i = 0; i < dataView.byteLength; i++ ) {\n        crc = (crc >>> 8) ^ crcTable[(crc ^ dataView.getUint8(i)) & 0xFF];\n    }\n\n    return (crc ^ (-1)) >>> 0;\n};\n\n\n\ndaikon.Utils.createBitMask = function (numBytes, bitsStored, unsigned) {\n    var mask = 0xFFFFFFFF;\n    mask >>>= (((4 - numBytes) * 8) + ((numBytes * 8) - bitsStored));\n\n    if (unsigned) {\n        if (numBytes == 1) {\n            mask &= 0x000000FF;\n        } else if (numBytes == 2) {\n            mask &= 0x0000FFFF;\n        } else if (numBytes == 4) {\n            mask &= 0xFFFFFFFF;\n        } else if (numBytes == 8) {\n            mask = 0xFFFFFFFF;\n        }\n    } else {\n        mask = 0xFFFFFFFF;\n    }\n\n    return mask;\n};\n\n\n\n/*** Exports ***/\n\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports = daikon.Utils;\n}\n\n},{}]},{},[33])(33)\n});\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//            Papaya\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n/*jslint browser: true, node: true */\n/*global daikon */\n\n"use strict";\n\n/*** Imports ***/\nvar papaya = papaya || {};\npapaya.volume = papaya.volume || {};\npapaya.volume.dicom = papaya.volume.dicom || {};\n\n\n/*** Constructor ***/\npapaya.volume.dicom.HeaderDICOM = papaya.volume.dicom.HeaderDICOM || function () {\n    this.series = null;\n    this.seriesMap = [];\n    this.error = null;\n    this.onFinishedHeaderRead = null;\n    this.dialogHandler = null;\n    return this;\n};\n\n\n/*** Static Pseudo-constants ***/\n\npapaya.volume.dicom.HeaderDICOM.ORIENTATION_DEFAULT = "XYZ+--";\npapaya.volume.dicom.HeaderDICOM.SUPPORTED_TRANSFER_SYNTAXES = [\n    // uncompressed\n    "1.2.840.10008.1.2",\n    "1.2.840.10008.1.2.1",\n    "1.2.840.10008.1.2.2",\n\n    // deflated\n    "1.2.840.10008.1.2.1.99",\n\n    // jpeg baseline compressed\n    "1.2.840.10008.1.2.4.50",  // 8-bit\n    "1.2.840.10008.1.2.4.51",  // 8-bit\n\n    // jpeg lossless compressed\n    "1.2.840.10008.1.2.4.57",\n    "1.2.840.10008.1.2.4.70",  // selection 1\n\n    // jpeg 2000 compressed\n    "1.2.840.10008.1.2.4.90",  // lossless\n    "1.2.840.10008.1.2.4.91",\n\n    // rle compressed\n    "1.2.840.10008.1.2.5"\n];\n\n\n/*** Static Methods ***/\n\npapaya.volume.dicom.HeaderDICOM.isThisFormat = function (filename, data) {\n    var buf, offset, magicCookieLength, ctr, cookieCtr = 0, parser, tag;\n\n    // check extension\n    if (filename.indexOf(".dcm") !== -1) {\n        return true;\n    }\n\n    // check for magic number\n    buf = new DataView(data[0]);\n    offset = daikon.Parser.MAGIC_COOKIE_OFFSET;\n    magicCookieLength = daikon.Parser.MAGIC_COOKIE.length;\n\n    for (ctr = 0; ctr < magicCookieLength; ctr += 1) {\n        if (buf.getUint8(offset + ctr) === daikon.Parser.MAGIC_COOKIE[ctr]) {\n            cookieCtr += 1;\n        }\n    }\n\n    if (cookieCtr === 4) {\n        return true;\n    }\n\n    // ok, last shot -- some DICOM don\'t contain magic number, check for valid tags...\n    parser = new daikon.Parser();\n    tag = parser.testForValidTag(buf);\n\n    return ((tag !== null) && (tag.group <= 0x0008) && !parser.hasError());\n};\n\n\n/*** Prototype Methods ***/\n\npapaya.volume.dicom.HeaderDICOM.prototype.setSeries = function (name, value) {\n    var ctr;\n\n    for (ctr = 0; ctr < Object.keys(this.seriesMap).length; ctr += 1) {\n        if (Object.keys(this.seriesMap)[ctr].indexOf(value) !== -1) {\n            this.series = this.seriesMap[Object.keys(this.seriesMap)[ctr]];\n            break;\n        }\n    }\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getDataScaleSlope = function (isElscint, image) {\n    if (isElscint) {\n        return (image.getDataScaleElscint() || 1);\n    }\n\n    return (image.getDataScaleSlope() || 1);\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getDataScaleIntercept = function (isElscint, image) {\n    if (isElscint) {\n        return 0;\n    }\n\n    return (image.getDataScaleIntercept() || 0);\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.finishedHeaderRead = function () {\n    var dialogData, allSeries, ctr;\n\n    if (this.error) {\n        this.onFinishedHeaderRead();\n    } else if (Object.keys(this.seriesMap).length > 1) {\n        this.series = this.seriesMap[Object.keys(this.seriesMap)[0]];\n\n        allSeries = [];\n        for (ctr = 0; ctr < Object.keys(this.seriesMap).length; ctr += 1) {\n            allSeries.push(this.seriesMap[Object.keys(this.seriesMap)[ctr]]);\n        }\n\n        dialogData = {\n            "items": [\n                {"label": "Select:", "field": "series", "options": allSeries}\n            ]\n        };\n\n        this.dialogHandler.showDialog("Select DICOM Series", dialogData, this, papaya.utilities.ObjectUtils.bind(this, this.setSeries),\n            papaya.utilities.ObjectUtils.bind(this, this.finishedSeriesSelection));\n    } else {\n        this.series = this.seriesMap[Object.keys(this.seriesMap)[0]];\n\n        if (this.series.images.length > 0) {\n            this.series.buildSeries();\n\n            if (!this.isTransferSyntaxSupported()) {\n                this.error = new Error("This transfer syntax is currently not supported!");\n            }\n        } else {\n            this.error = new Error("No images found!");\n        }\n\n        this.onFinishedHeaderRead();\n    }\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.isTransferSyntaxSupported = function () {\n    var transferSyntax = this.series.images[0].getTransferSyntax();\n\n    return (papaya.utilities.StringUtils.isStringBlank(transferSyntax) ||\n        papaya.utilities.ArrayUtils.contains(papaya.volume.dicom.HeaderDICOM.SUPPORTED_TRANSFER_SYNTAXES,\n            transferSyntax));\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.finishedSeriesSelection = function () {\n    if (this.series.images.length > 0) {\n        this.series.buildSeries();\n\n        if (!this.isTransferSyntaxSupported()) {\n            this.error = new Error("This transfer syntax is currently not supported!");\n        }\n    } else {\n        this.error = new Error("No images found!");\n    }\n\n    this.seriesMap = null;\n\n    this.onFinishedHeaderRead();\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.readHeaderData = function (data, progressMeter, dialogHandler,\n                                                                     onFinishedHeaderRead) {\n    this.onFinishedHeaderRead = onFinishedHeaderRead;\n    this.dialogHandler = dialogHandler;\n    this.readNextHeaderData(data, 0, progressMeter, papaya.utilities.ObjectUtils.bind(this, this.finishedHeaderRead));\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.readNextHeaderData = function (data, index, progressMeter,\n                                                                         onFinishedHeaderRead) {\n    var image, series;\n\n    if (index >= data.length) {\n        progressMeter.drawProgress(1, "Reading DICOM Headers");\n        onFinishedHeaderRead();\n    } else {\n        image = daikon.Series.parseImage(new DataView(data[index]));\n\n        if (image === null) {\n            this.error = daikon.Series.parserError;\n        } else if (image.hasPixelData()) {\n            series = this.findSeries(image.getSeriesId());\n\n            if (!series) {\n                series = new daikon.Series();\n                this.seriesMap[image.getSeriesId()] = series;\n            }\n\n            series.addImage(image);\n        } else {\n            this.error = new Error("No pixel data found!");\n        }\n\n        if (this.error) {\n            onFinishedHeaderRead();\n        } else {\n            progressMeter.drawProgress(index / data.length, "Reading DICOM Headers");\n            setTimeout(function() {this.readNextHeaderData(data, index + 1, progressMeter,\n                onFinishedHeaderRead);}.bind(this), 0);\n        }\n    }\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getName = function () {\n    var name = this.series.getName();\n\n    if (name) {\n        return name;\n    } else {\n        return null;\n    }\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.findSeries = function (id) {\n    if (Object.keys(this.seriesMap).length === 0) {\n        return null;\n    } else {\n        return this.seriesMap[id];\n    }\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.readImageData = function (progressMeter, onFinishedImageRead) {\n    this.series.concatenateImageData(progressMeter, onFinishedImageRead);\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getImageDimensions = function () {\n    var imageDimensions, numberOfSlices, ctr, size;\n\n    if (this.series.isMosaic) \n    {\n        //numberOfSlices = this.series.images[0].getMosaicCols() * this.series.images[0].getMosaicRows();\n        numberOfSlices = this.series.NumberOfImagesInMosaic;\n        imageDimensions = new papaya.volume.ImageDimensions(parseInt(this.series.images[0].getCols() / this.series.images[0].getMosaicCols()),\n            parseInt(this.series.images[0].getRows() / this.series.images[0].getMosaicRows()), \n            numberOfSlices,\n            this.series.images.length);\n    } else if (this.series.isMultiFrameVolume) {\n        imageDimensions = new papaya.volume.ImageDimensions(this.series.images[0].getCols(),\n            this.series.images[0].getRows(), this.series.numberOfFrames, 1);\n    } else if (this.series.isMultiFrameTimeseries) {\n        imageDimensions = new papaya.volume.ImageDimensions(this.series.images[0].getCols(),\n            this.series.images[0].getRows(), this.series.numberOfFramesInFile, this.series.numberOfFrames);\n    } else if (this.series.isImplicitTimeseries) {\n        imageDimensions = new papaya.volume.ImageDimensions(this.series.images[0].getCols(),\n            this.series.images[0].getRows(), parseInt(this.series.images.length / this.series.numberOfFrames),\n            this.series.numberOfFrames);\n    } else {\n        imageDimensions = new papaya.volume.ImageDimensions(this.series.images[0].getCols(),\n            this.series.images[0].getRows(), this.series.images.length, 1);\n    }\n\n    size = parseInt((imageDimensions.getNumVoxelsSeries() * parseInt(this.series.images[0].getBitsAllocated() / 8)) /\n        this.series.images.length);\n\n    for (ctr = 0; ctr < this.series.images.length; ctr += 1) {\n        if (this.series.images[ctr].getPixelData())\n        {\n            imageDimensions.dataOffsets[ctr] = this.series.images[ctr].getPixelData().offsetValue;\n            imageDimensions.dataLengths[ctr] = size;\n        }\n    }\n\n    return imageDimensions;\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getVoxelDimensions = function () {\n    var voxelDimensions, sliceSpacing, sliceDis, pixelSpacing;\n\n    pixelSpacing = (this.series.images[0].getPixelSpacing() || [0, 0]);\n\n    // kellnere this was / is wrong !!!\n    //sliceSpacing = Math.max(this.series.images[0].getSliceGap(), this.series.images[0].getSliceThickness());\n    \n    // this is the safest way, spm uses this. slice distance is simply SpacingBetweenSlices. \n    // of not available, try to use other stuff.\n\n    /************ sliceSpacing is very unstable (many people find that). Safest way ist to calc dist from ImagePositionPatient ( see below )\n    sliceSpacing = this.series.images[0].gettag(\'SpacingBetweenSlices\');\n    \n    if(sliceSpacing == undefined)\n    {\n        var sgap = this.series.images[0].getSliceGap() || 0;\n        var thick =  this.series.images[0].getSliceThickness() || 0;\n        sliceSpacing = sgap + thick;\n    }\n    *******************************/\n   \n    function fallback(that)\n    {\n            var ip1 = that.series.images[0].getImagePosition();\n            var ip2 = that.series.images[1].getImagePosition();\n            if(ip1 != undefined && ip2 != undefined)\n                var sliceDis =  math.norm( [ ip2[0]- ip1[0],ip2[1]- ip1[1],ip2[2]- ip1[2] ])  ;\n            else\n                var sliceDis = 0;\n\n            if(isNaN(sliceDis))\n                sliceDis = 0;\n\n            sliceSpacing = sliceDis;\n\n    }\n\n\n    if (!this.series.isMosaic & !this.series.isMultiFrame) \n    {\n        if (this.series.images.length > 1)  // multi images. Can get slice dist also from distance of individual slices\n        {\n               fallback(this);\n        }\n        else\n        {\n            sliceSpacing = this.series.images[0].gettag(\'SpacingBetweenSlices\') || 1;\n        }\n    }\n\n    \n\n    if(this.series.isMultiFrame)\n    {\n        if(sliceSpacing == undefined)\n        {\n            // this is wrong in some cases. DICOM slice thickness is a bad tag!!!\n            // use slice positions instead\n            var sgap = this.series.images[0].getSliceGap() || 0;\n            var thick =  this.series.images[0].getSliceThickness() || 0;\n            //sliceSpacing = sgap + thick;\n            \n            sliceSpacing = this.series.MultiFrameSliceThickness || sgap + thick;\n        }\n    }\n   \n   \n    if(sliceSpacing == undefined || isNaN(sliceSpacing) || sliceSpacing==0)\n    {\n      sliceSpacing = this.series.images[0].gettag(\'SpacingBetweenSlices\') || 1;\n    }\n\n    voxelDimensions = new papaya.volume.VoxelDimensions(pixelSpacing[1], pixelSpacing[0], sliceSpacing, this.series.images[0].getTR() / 1000.0);\n\n    if (!voxelDimensions.isValid()) \n    { // some DICOM images don\'t include voxel size?\n        if (voxelDimensions.rowSize === 0) {\n            voxelDimensions.rowSize = 1;\n        }\n\n        if (voxelDimensions.colSize === 0) {\n            voxelDimensions.colSize = 1;\n        }\n\n        if (voxelDimensions.sliceSize === 0) {\n            voxelDimensions.sliceSize = 1;\n        }\n    }\n\n    voxelDimensions.spatialUnit = papaya.volume.VoxelDimensions.UNITS_MM;\n    voxelDimensions.temporalUnit = papaya.volume.VoxelDimensions.UNITS_SEC;\n\n    return voxelDimensions;\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getImageType = function () {\n    var dataTypeDICOM, dataTypeCode, it;\n    dataTypeDICOM = this.series.images[0].getDataType();\n\n    if (dataTypeDICOM === daikon.Image.BYTE_TYPE_INTEGER) {\n        dataTypeCode = papaya.volume.ImageType.DATATYPE_INTEGER_SIGNED;\n    } else if (dataTypeDICOM === daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED) {\n        dataTypeCode = papaya.volume.ImageType.DATATYPE_INTEGER_UNSIGNED;\n    } else if (dataTypeDICOM === daikon.Image.BYTE_TYPE_FLOAT) {\n        dataTypeCode = papaya.volume.ImageType.DATATYPE_FLOAT;\n    } else if (dataTypeDICOM === daikon.Image.BYTE_TYPE_RGB) {\n        dataTypeCode = papaya.volume.ImageType.DATATYPE_RGB;\n    } else {\n        dataTypeCode = papaya.volume.ImageType.DATATYPE_UNKNOWN;\n    }\n\n    it = new papaya.volume.ImageType(dataTypeCode, parseInt(this.series.images[0].getBitsAllocated() / 8),\n        this.series.images[0].littleEndian, false);\n\n    it.rgbBySample = (this.series.images[0].getPlanarConfig() === 1);\n\n    return it;\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getImageRange = function () {\n    var imageRange, gMax, gMin, min, max, ctr, image, windowWidth, windowCenter, center, width, imageDimensions,\n        ctrInner, numMosaicSlicesVolume, numMosaicSlicesTotal, mosaicSlopes = [], mosaicIntercepts = [], numSlices,\n        seriesSlopes, seriesIntercepts, ratio, numSlicesTotal, slopes = [], intercepts = [];\n\n    gMax = 0;\n    gMin = 0;\n\n    for (ctr = 0; ctr < this.series.images.length; ctr += 1) {\n        image = this.series.images[ctr];\n        max = (image.getImageMax() * this.getDataScaleSlope(this.series.isElscint, image)) +\n            (image.getDataScaleIntercept() || 0);\n        min = (image.getImageMin() * this.getDataScaleSlope(this.series.isElscint, image)) +\n            (image.getDataScaleIntercept() || 0);\n\n        if (ctr === 0) {\n            gMax = max;\n            gMin = min;\n        } else {\n            if (max > gMax) {\n                gMax = max;\n            }\n\n            if (min < gMin) {\n                gMin = min;\n            }\n        }\n    }\n\n    windowWidth = 0;\n    windowCenter = 0;\n\n    if (this.series.isElscint) { // Elscint calculates data scales differently\n        for (ctr = 0; ctr < this.series.images.length; ctr += 1) {\n            image = this.series.images[ctr];\n            width = image.getWindowWidth() * image.getDataScaleElscint();\n            center = image.getWindowCenter() * image.getDataScaleElscint();\n\n            if (ctr === 0) {\n                windowWidth = width;\n                windowCenter = center;\n            } else {\n                if (windowCenter < center) {\n                    windowWidth = width;\n                    windowCenter = center;\n                }\n            }\n        }\n    } else {\n        for (ctr = 0; ctr < this.series.images.length; ctr += 1) {\n            image = this.series.images[ctr];\n            width = image.getWindowWidth();\n            center = image.getWindowCenter();\n\n            if (ctr === 0) {\n                windowWidth = width;\n                windowCenter = center;\n            } else {\n                if (windowCenter < center) {\n                    windowWidth = width;\n                    windowCenter = center;\n                }\n            }\n        }\n    }\n\n    imageRange = new papaya.volume.ImageRange(gMin, gMax);\n    imageRange.displayMin = (windowCenter - (windowWidth / 2));\n    imageRange.displayMax = (windowCenter + (windowWidth / 2));\n\n    imageDimensions = this.getImageDimensions();\n\n    if (this.series.isMosaic) {\n        numMosaicSlicesVolume = imageDimensions.slices;\n        numMosaicSlicesTotal = numMosaicSlicesVolume * this.series.images.length;\n\n        for (ctr = 0; ctr < numMosaicSlicesTotal; ctr += 1) {\n            image = this.series.images[parseInt(ctr / numMosaicSlicesVolume)];\n            mosaicSlopes[ctr] = this.getDataScaleSlope(this.series.isElscint, image);\n            mosaicIntercepts[ctr] = this.getDataScaleIntercept(this.series.isElscint, image);\n        }\n\n        imageRange.dataScaleSlopes = mosaicSlopes;\n        imageRange.dataScaleIntercepts = mosaicIntercepts;\n    } else if (this.series.isMultiFrame) {\n        numSlices = imageDimensions.slices * imageDimensions.timepoints;\n        seriesSlopes = [];\n        seriesIntercepts = [];\n        ratio = parseInt(numSlices / this.series.images.length);\n\n        for (ctr = 0; ctr < this.series.images.length; ctr += 1) {\n            for (ctrInner = 0; ctrInner < ratio; ctrInner += 1) {\n                image = this.series.images[ctr];\n                seriesSlopes[(ctr * ratio) + ctrInner] = this.getDataScaleSlope(this.series.isElscint, image);\n                seriesIntercepts[(ctr * ratio) + ctrInner] = this.getDataScaleIntercept(this.series.isElscint, image);\n            }\n        }\n\n        imageRange.dataScaleSlopes = seriesSlopes;\n        imageRange.dataScaleIntercepts = seriesIntercepts;\n    } else if (this.series.isImplicitTimeseries) {\n        numSlicesTotal = imageDimensions.slices * imageDimensions.timepoints;\n        if (this.series.images.length !== numSlicesTotal) {\n            imageRange.setGlobalDataScale(this.getDataScaleSlope(this.series.isElscint, this.series.images[0]),\n                this.getDataScaleIntercept(this.series.isElscint, this.series.images[0]),\n                this.series.numberOfFrames);\n        } else {\n            for (ctr = 0; ctr < this.series.images.length; ctr += 1) {\n                image = this.series.images[ctr];\n                slopes[ctr] = this.getDataScaleSlope(this.series.isElscint, image);\n                intercepts[ctr] = this.getDataScaleIntercept(this.series.isElscint, image);\n            }\n\n            imageRange.dataScaleSlopes = slopes;\n            imageRange.dataScaleIntercepts = intercepts;\n        }\n    } else {\n        for (ctr = 0; ctr < this.series.images.length; ctr += 1) {\n            image = this.series.images[ctr];\n            slopes[ctr] = this.getDataScaleSlope(this.series.isElscint, image);\n            intercepts[ctr] = this.getDataScaleIntercept(this.series.isElscint, image);\n        }\n\n        imageRange.dataScaleSlopes = slopes;\n        imageRange.dataScaleIntercepts = intercepts;\n    }\n\n    imageRange.validateDataScale();\n\n    return imageRange;\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getOrientation = function () {\n    var orientation = this.series.images[0].getOrientation();\n\n    if (orientation === null) {\n        orientation = papaya.volume.dicom.HeaderDICOM.ORIENTATION_DEFAULT;\n    }\n\n    // this fixes the cross-slice orientation sense (usually)\n    orientation = orientation.substring(0, 5) + (this.series.sliceSense ? \'+\' : \'-\');\n\n    return new papaya.volume.Orientation(orientation);\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getOrientationCertainty = function () {\n    var orientation = this.series.images[0].getOrientation();\n\n    if (orientation === null) {\n        return papaya.volume.Header.ORIENTATION_CERTAINTY_UNKNOWN; // orientation could be found\n    } else {\n        if (this.series.isMosaic || this.series.isMultiFrameVolume) {\n            return papaya.volume.Header.ORIENTATION_CERTAINTY_LOW;\n        } else {\n            return papaya.volume.Header.ORIENTATION_CERTAINTY_HIGH;\n        }\n    }\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getOrigin = function () {\n    var m = this.getBestTransform().edges;\n\n    if (m) {\n        var invm = numeric.inv(m);\n        return new papaya.core.Coordinate(invm[0][3], invm[1][3], invm[2][3]);\n    } else {\n        return new papaya.core.Coordinate(0, 0, 0);\n    }\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.hasError = function () {\n    return (this.error !== null);\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getImageDescription = function () {\n    var patientName, patientID, studyTime, studyDate, imageDes, notes = \'\';\n\n    patientName  = this.series.images[0].getPatientName();\n    patientID = this.series.images[0].getPatientID();\n    studyTime = this.series.images[0].getStudyTime();\n    studyDate = this.series.images[0].getStudyDate();\n    imageDes = this.series.images[0].getImageDescription();\n\n    if (patientName) {\n        notes += (" " + patientName);\n    }\n\n    if (patientID) {\n        notes += (" " + patientID);\n    }\n\n    if (studyTime) {\n        notes += (" " + studyTime);\n    }\n\n    if (studyDate) {\n        notes += (" " + studyDate);\n    }\n\n    if (imageDes) {\n        notes += (" " + imageDes);\n    }\n\n    return new papaya.volume.ImageDescription(notes.trim());\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getBestTransform = function () \n{\n    \n    // default: take diagonal RAS matrix\n    var edges = math.diag([-1, -1, 1, 1]);\n    // default: center around image center\n    var imdims = this.getImageDimensions();\n    if(imdims != undefined && imdims.cols !=undefined && imdims.rows != undefined)\n    {\n        edges._data[0][3] = -imdims.cols / 2;\n        edges._data[1][3] = -imdims.rows / 2;\n    }\n\n    var vs = this.getVoxelDimensions();\n    if(vs !=undefined)\n    {\n        var sizecorrection = math.diag([vs.colSize, vs.rowSize, vs.sliceSize, 1  ])\n        edges = math.multiply(edges, sizecorrection)\n    }\n\n\n    // in some cases, images from different planes are just stacked together.\n    // in this case, set at least edges to something valid, otherwise image could not be shown\n    if(this.series.hasBadSlicing != undefined && this.series.hasBadSlicing==true)\n    {\n        // default was set above\n//         var edges = math.diag([-1, -1, 1, 1]);\n//         var r  = math.diag([-1, -1, 1]);\n        //return {edges:edges,rot:r};\n    }\n\n\n    // Kellner\n    if(this.series.images[0].getImageDirections() != undefined)\n    {\n        var cosines = this.series.images[0].getImageDirections().slice(0);\n    }\n    else if ( this.series.images[0].ktags[\'PixelSpacing\'] != undefined ) // XRays\n    {\n        \n        // for xrays we could implement a edges scaling by pixel spacing here, but do we really want this?\n        // not for now\n        //ps = this.series.images[0].ktags[\'PixelSpacing\'].value;\n        var cosines = undefined;\n    }\n    else\n    {\n        var cosines = undefined;\n    }\n    \n    if (cosines && cosines.length >= 6) \n    {\n        var cx = cosines.splice(0,3);\n        var cy = cosines.splice(0,3);\n        var cz;\n\n        var img  = this.series.images[0];\n        if(this.series.isMosaic)\n        {\n            // SIEMENS speciality: SliceNormalVector defines direction of mosaic z\n            var shdr = img.gettag(\'CSAImageHeaderInfo\');\n            //var sn = img.privateDataAll;\n            if(typeof shdr == "string" )\n            {\n                var sn = shdr.match(/SliceNormalVector=([-\\d.\\s]+)\\n/);\n                if(sn != null && sn.length > 1)\n                {\n                    sn = sn[1].split(" ");\n                    cz = [];\n                    cz[0] = parseFloat(sn[0]); \n                    cz[1] = parseFloat(sn[1]);\n                    cz[2] = parseFloat(sn[2]);\n                }\n            }\n        }\n\n        // Next option, and if not isMosaic: Try to use the  sliceVec calculated in buildSeries\n        if(this.series.sliceVec !== undefined)\n        {\n            cz = this.series.sliceVec;\n        } \n        \n        // As a last resort, or for single slice images, Try to generate the slice vector with cross product\n        // this is to be evaluated !!!!\n        // must check the determinant ??\n        if(!cz)\n        { \n                cz = [cx[1] * cy[2] - cx[2] * cy[1],\n                cx[2] * cy[0] - cx[0] * cy[2],\n                cx[0] * cy[1] - cx[1] * cy[0]];\n                \n                //cz[0] = -cz[0]; cz[1] = -cz[1]; cz[2] = -cz[2];\n        }\n\n        var r = [];\n        r[0] = [cx[0],  cy[0],  cz[0]];\n        r[1] = [cx[1],  cy[1],  cz[1]];\n        r[2] = [cx[2],  cy[2],  cz[2]];\n        \n\n        cx = math.multiply(cx,  vs.colSize)._data;\n        cy = math.multiply(cy,  vs.rowSize)._data;\n        cz = math.multiply(cz,  vs.sliceSize)._data;\n\n        // the affine offset\n        var of = this.series.images[0].getImagePosition();\n        \n\n        \n        var edges = [];\n        edges[0] = [cx[0],  cy[0],  cz[0],  of[0]];\n        edges[1] = [cx[1],  cy[1],  cz[1],  of[1]];\n        edges[2] = [cx[2],  cy[2],  cz[2],  of[2]];\n        edges[3] = [0,          0,      0,      1];\n        \n\n\n        if(this.series.isMosaic)\n        {\n            // SPM says siemens has a special convention for ImagePosition in mosaic (and this seems to be true)\n            // It is shifted from the true center of the first slice to the center of the center of the first slice in the mosaic image!\n            // correct for it: use the image direction cosines\n            var rows =   img.getRows();\n            var cols =   img.getCols();  \n            var nrowsmosaic =   img.getMosaicRows();  \n            var ncolsmosaic =   img.getMosaicCols();  \n\n            var truepos =  math.multiply(edges , [(cols -cols/ncolsmosaic )/2, (rows - rows/nrowsmosaic) /2, 0,  1 ]   )._data ;\n\n            edges[0][3] = truepos[0];\n            edges[1][3] = truepos[1];\n            edges[2][3] = truepos[2];\n        }\n\n\n        // go from DICOM LPS to NIFTI RAS with [-1, -1, 1, 1];\n        edges = math.multiply(math.diag([-1, -1, 1, 1]), edges) ;\n        \n   \n    }\n    \n    // the rot field is needed for diffusion in dicomReader.js\n    return {edges:edges,rot:r};\n\n   \n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.getBestTransformOrigin = function () {\n    return this.getOrigin();\n};\n\n\n\npapaya.volume.dicom.HeaderDICOM.prototype.toString = function () {\n    return this.series.images[0].toString();\n}; \n\n\n\n\n\n\n\n\n\n\n\n\n\n/*global */\n\n"use strict";\n\n/*** Imports ***/\nvar papaya = papaya || {};\npapaya.volume = papaya.volume || {};\n\n\n/*** Constructor ***/\npapaya.volume.VoxelDimensions = papaya.volume.VoxelDimensions || function (colSize, rowSize, sliceSize, timeSize) {\n    this.colSize = Math.abs(colSize);\n    this.rowSize = Math.abs(rowSize);\n    this.sliceSize = Math.abs(sliceSize);\n    this.xSize = 0;\n    this.ySize = 0;\n    this.zSize = 0;\n    this.flip = false;\n    this.timeSize = timeSize;\n    this.spatialUnit = papaya.volume.VoxelDimensions.UNITS_UNKNOWN;\n    this.temporalUnit = papaya.volume.VoxelDimensions.UNITS_UNKNOWN;\n};\n\n/*** Static Pseudo-constants ***/\n\npapaya.volume.VoxelDimensions.UNITS_UNKNOWN = 0;\npapaya.volume.VoxelDimensions.UNITS_METER = 1;\npapaya.volume.VoxelDimensions.UNITS_MM = 2;\npapaya.volume.VoxelDimensions.UNITS_MICRON = 3;\npapaya.volume.VoxelDimensions.UNITS_SEC = 8;\npapaya.volume.VoxelDimensions.UNITS_MSEC = 16;\npapaya.volume.VoxelDimensions.UNITS_USEC = 24;\npapaya.volume.VoxelDimensions.UNITS_HZ = 32;\npapaya.volume.VoxelDimensions.UNITS_PPM = 40;\npapaya.volume.VoxelDimensions.UNITS_RADS = 48;\n\npapaya.volume.VoxelDimensions.UNIT_STRINGS = [];\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_UNKNOWN] = "Unknown Unit";\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_METER] = "Meters";\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_MM] = "Millimeters";\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_MICRON] = "Microns";\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_SEC] = "Seconds";\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_MSEC] = "Milliseconds";\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_USEC] = "Microseconds";\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_HZ] = "Hertz";\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_PPM] = "Parts-per-million";\npapaya.volume.VoxelDimensions.UNIT_STRINGS[papaya.volume.VoxelDimensions.UNITS_RADS] = "Radians-per-second";\n\n\n/*** Prototype Methods ***/\n\npapaya.volume.VoxelDimensions.prototype.isValid = function () {\n    return ((this.colSize > 0) && (this.rowSize > 0) && (this.sliceSize > 0) && (this.timeSize >= 0));\n};\n\n\n\npapaya.volume.VoxelDimensions.prototype.getSpatialUnitString = function () {\n    return papaya.volume.VoxelDimensions.UNIT_STRINGS[this.spatialUnit];\n};\n\n\n\npapaya.volume.VoxelDimensions.prototype.getTemporalUnitString = function () {\n    return papaya.volume.VoxelDimensions.UNIT_STRINGS[this.temporalUnit];\n};\n\n\npapaya.volume.VoxelDimensions.prototype.getTemporalUnitMultiplier = function () {\n    if (this.temporalUnit === papaya.volume.VoxelDimensions.UNITS_MSEC) {\n        return 0.001;\n    }\n\n    if (this.temporalUnit === papaya.volume.VoxelDimensions.UNITS_USEC) {\n        return 0.000001;\n    }\n\n    return 1;\n};\n\n\n\n/*jslint browser: true, node: true */\n/*global GUNZIP_MAGIC_COOKIE1, GUNZIP_MAGIC_COOKIE2, Base64Binary, pako, numeric */\n\n"use strict";\n\n/*** Imports ***/\nvar papaya = papaya || {};\npapaya.volume = papaya.volume || {};\n\n\n/*** Constructor ***/\npapaya.volume.Volume = papaya.volume.Volume || function (progressMeter, dialogHandler, params) {\n    this.progressMeter = progressMeter;\n    this.dialogHandler = dialogHandler;\n    this.files = [];\n    this.rawData = [];\n    this.fileLength = 0;\n    this.urls = null;\n    this.fileName = null;\n    this.compressed = false;\n    this.transform = null;\n    this.numTimepoints = 0;\n    this.onFinishedRead = null;\n    this.error = null;\n    this.transform = null;\n    this.isLoaded = false;\n    this.numTimepoints = 1;\n    this.loaded = false;\n    this.params = params;\n\n    this.header = new papaya.volume.Header((this.params !== undefined) && this.params.padAllImages);\n    this.imageData = new papaya.volume.ImageData((this.params !== undefined) && this.params.padAllImages);\n};\n\n\n/*** Static Pseudo-constants ***/\n\npapaya.volume.Volume.PROGRESS_LABEL_LOADING = "Loading";\n\n\n/*** Prototype Methods ***/\n\npapaya.volume.Volume.prototype.fileIsCompressed = function (filename, data) {\n    var buf, magicCookie1, magicCookie2;\n\n    if (filename.indexOf(".gz") !== -1) {\n        return true;\n    }\n\n    if (data) {\n        buf = new DataView(data);\n\n        magicCookie1 = buf.getUint8(0);\n        magicCookie2 = buf.getUint8(1);\n\n        if (magicCookie1 === GUNZIP_MAGIC_COOKIE1) {\n            return true;\n        }\n\n        if (magicCookie2 === GUNZIP_MAGIC_COOKIE2) {\n            return true;\n        }\n    }\n\n    return false;\n};\n\n\n\npapaya.volume.Volume.prototype.readFiles = function (files, callback) {\n    this.files = files;\n    this.fileName = files[0].name;\n    this.onFinishedRead = callback;\n    this.compressed = this.fileIsCompressed(this.fileName);\n    this.fileLength = this.files[0].size;\n    this.readNextFile(this, 0);\n};\n\n\n\npapaya.volume.Volume.prototype.readNextFile = function (vol, index) {\n    var blob;\n\n    if (index < this.files.length) {\n        blob = papaya.utilities.PlatformUtils.makeSlice(this.files[index], 0, this.files[index].size);\n\n        try {\n            var reader = new FileReader();\n\n            reader.onloadend = papaya.utilities.ObjectUtils.bind(vol, function (evt) {\n                if (evt.target.readyState === FileReader.DONE) {\n                    vol.rawData[index] = evt.target.result;\n                    setTimeout(function () {vol.readNextFile(vol, index + 1); }, 0);\n                }\n            });\n\n            reader.onerror = papaya.utilities.ObjectUtils.bind(vol, function (evt) {\n                vol.error = new Error("There was a problem reading that file:\\n\\n" + evt.getMessage());\n                vol.finishedLoad();\n            });\n\n            reader.readAsArrayBuffer(blob);\n        } catch (err) {\n            vol.error = new Error("There was a problem reading that file:\\n\\n" + err.message);\n            vol.finishedLoad();\n        }\n    } else {\n        setTimeout(function () {vol.decompress(vol); }, 0);\n    }\n};\n\n\n\n\n\n\npapaya.volume.Volume.prototype.readEncodedData = function (names, callback) {\n    var vol = null;\n\n    try {\n        this.fileName = names[0];\n        this.onFinishedRead = callback;\n        vol = this;\n        this.fileLength = 0;\n        vol.readNextEncodedData(vol, 0, names);\n    } catch (err) {\n        if (vol) {\n            vol.error = new Error("There was a problem reading that file:\\n\\n" + err.message);\n            vol.finishedLoad();\n        }\n    }\n};\n\n\n\npapaya.volume.Volume.prototype.readNextEncodedData = function (vol, index, names) {\n    if (index < names.length) {\n        try {\n            vol.rawData[index] = Base64Binary.decodeArrayBuffer(papaya.utilities.ObjectUtils.dereference(names[index]));\n            vol.compressed = this.fileIsCompressed(this.fileName, vol.rawData[index]);\n            setTimeout(function () {vol.readNextEncodedData(vol, index + 1, names); }, 0);\n        } catch (err) {\n            if (vol) {\n                vol.error = new Error("There was a problem reading that file:\\n\\n" + err.message);\n                vol.finishedLoad();\n            }\n        }\n    } else {\n        vol.decompress(vol);\n    }\n};\n\n\n\npapaya.volume.Volume.prototype.getVoxelAtIndexNative = function (ctrX, ctrY, ctrZ, timepoint, useNN) {\n    return this.transform.getVoxelAtIndexNative(ctrX, ctrY, ctrZ, 0, useNN);\n};\n\n\n\npapaya.volume.Volume.prototype.getVoxelAtIndex = function (ctrX, ctrY, ctrZ, timepoint, useNN) {\n    return this.transform.getVoxelAtIndex(ctrX, ctrY, ctrZ, timepoint, useNN);\n};\n\n\n\npapaya.volume.Volume.prototype.getVoxelAtCoordinate = function (xLoc, yLoc, zLoc, timepoint, useNN) {\n    return this.transform.getVoxelAtCoordinate(xLoc, yLoc, zLoc, timepoint, useNN);\n};\n\n\n\npapaya.volume.Volume.prototype.getVoxelAtMM = function (xLoc, yLoc, zLoc, timepoint, useNN) {\n    return this.transform.getVoxelAtMM(xLoc, yLoc, zLoc, timepoint, useNN);\n};\n\n\n\npapaya.volume.Volume.prototype.hasError = function () {\n    return (this.error !== null);\n};\n\n\n\npapaya.volume.Volume.prototype.getXDim = function () {\n    return this.header.imageDimensions.xDim;\n};\n\n\n\npapaya.volume.Volume.prototype.getYDim = function () {\n    return this.header.imageDimensions.yDim;\n};\n\n\n\npapaya.volume.Volume.prototype.getZDim = function () {\n    return this.header.imageDimensions.zDim;\n};\n\n\n\npapaya.volume.Volume.prototype.getXSize = function () {\n    return this.header.voxelDimensions.xSize;\n};\n\n\n\npapaya.volume.Volume.prototype.getYSize = function () {\n    return this.header.voxelDimensions.ySize;\n};\n\n\n\npapaya.volume.Volume.prototype.getZSize = function () {\n    return this.header.voxelDimensions.zSize;\n};\n\n\n\npapaya.volume.Volume.prototype.decompress = function (vol) {\n    if (vol.compressed) {\n        try {\n            pako.inflate(new Uint8Array(vol.rawData[0]), null, this.progressMeter,\n                function (data) {vol.finishedDecompress(vol, data.buffer); });\n        } catch (err) {\n            console.log(err);\n        }\n    } else {\n        setTimeout(function () {vol.finishedReadData(vol); }, 0);\n    }\n};\n\n\n\npapaya.volume.Volume.prototype.finishedDecompress = function (vol, data) {\n    vol.rawData[0] = data;\n    setTimeout(function () {vol.finishedReadData(vol); }, 0);\n};\n\n\n\npapaya.volume.Volume.prototype.finishedReadData = function (vol) {\n    vol.header.readHeaderData(vol.fileName, vol.rawData, this.progressMeter, this.dialogHandler,\n        papaya.utilities.ObjectUtils.bind(this, this.finishedReadHeaderData));\n};\n\n\n\npapaya.volume.Volume.prototype.finishedReadHeaderData = function () {\n    this.rawData = null;\n\n    if (this.header.hasError()) {\n        this.error = this.header.error;\n        console.error(this.error.stack);\n        this.onFinishedRead(this);\n        return;\n    }\n\n    this.header.imageType.swapped = (this.header.imageType.littleEndian !== papaya.utilities.PlatformUtils.isPlatformLittleEndian());\n\n    var name = this.header.getName();\n\n    if (name) {\n        this.fileName = this.header.getName();\n    }\n\n    this.header.readImageData(this.progressMeter, papaya.utilities.ObjectUtils.bind(this, this.finishedReadImageData));\n};\n\n\n\npapaya.volume.Volume.prototype.finishedReadImageData = function (imageData) {\n    this.imageData.readFileData(this.header, imageData, papaya.utilities.ObjectUtils.bind(this, this.finishedLoad));\n};\n\n\n\npapaya.volume.Volume.prototype.finishedLoad = function () {\n    if (!this.loaded) {\n        this.loaded = true;\n        if (this.onFinishedRead) {\n            if (!this.hasError()) {\n                this.transform = new papaya.volume.Transform(papaya.volume.Transform.IDENTITY.clone(), this);\n                this.numTimepoints = this.header.imageDimensions.timepoints || 1;\n                this.applyBestTransform();\n            } else {\n                console.log(this.error);\n            }\n\n            this.isLoaded = true;\n            this.rawData = null;\n            this.onFinishedRead(this);\n        }\n    }\n};\n\n\n\npapaya.volume.Volume.prototype.setOrigin = function (coord) {\n    var coordNew = this.header.orientation.convertCoordinate(coord, new papaya.core.Coordinate(0, 0, 0));\n    this.header.origin.setCoordinate(coordNew.x, coordNew.y, coordNew.z);\n};\n\n\n\npapaya.volume.Volume.prototype.getOrigin = function () {\n    return this.header.orientation.convertCoordinate(this.header.origin, new papaya.core.Coordinate(0, 0, 0));\n};\n\n\n\npapaya.volume.Volume.prototype.applyBestTransform = function () {\n    var bestXform = this.header.getBestTransform().edges;\n\n    if (bestXform !== null) {\n        this.transform.worldMatNifti = numeric.inv(bestXform);\n        this.setOrigin(this.header.getBestTransformOrigin());\n        this.transform.updateWorldMat();\n    }\n};\n\n\n\npapaya.volume.Volume.prototype.isWorldSpaceOnly = function () {\n    /*jslint bitwise: true */\n\n    var nifti, foundDataOrderTransform = false;\n\n    if (this.header.fileFormat instanceof papaya.volume.nifti.HeaderNIFTI) {\n        nifti = this.header.fileFormat;\n\n        if (nifti.nifti.qform_code > 0) {\n            foundDataOrderTransform |= !nifti.qFormHasRotations();\n        }\n\n        if (nifti.nifti.sform_code > 0) {\n            foundDataOrderTransform |= !nifti.sFormHasRotations();\n        }\n\n        return !foundDataOrderTransform;\n    }\n\n    return false;\n};\n\n\n\n\n\n\n/*jslint browser: true, node: true */\n/*global */\n\n"use strict";\n\n/*** Imports ***/\nvar papaya = papaya || {};\npapaya.volume = papaya.volume || {};\n\n\n/*** Constructor ***/\npapaya.volume.ImageType = papaya.volume.ImageType || function (datatype, numBytes, littleEndian, compressed) {\n    this.datatype = datatype;\n    this.numBytes = numBytes;\n    this.littleEndian = littleEndian;\n    this.swapped = false;\n    this.compressed = compressed;\n    this.rgbBySample = false;\n};\n\n\n/*** Static Pseudo-constants ***/\n\npapaya.volume.ImageType.DATATYPE_UNKNOWN = 0;\npapaya.volume.ImageType.DATATYPE_INTEGER_SIGNED = 1;\npapaya.volume.ImageType.DATATYPE_INTEGER_UNSIGNED = 2;\npapaya.volume.ImageType.DATATYPE_FLOAT = 3;\npapaya.volume.ImageType.DATATYPE_RGB = 4;\npapaya.volume.ImageType.MAX_SUPPORTED_BYTES_FLOAT = 8;\npapaya.volume.ImageType.MAX_SUPPORTED_BYTES_INTEGER = 4;\n\n\n/*** Prototype Methods ***/\n\npapaya.volume.ImageType.prototype.isValid = function () {\n    return (\n    (this.datatype <= papaya.volume.ImageType.DATATYPE_RGB) &&\n    (this.datatype > papaya.volume.ImageType.DATATYPE_UNKNOWN) &&\n    (this.numBytes > 0) &&\n    (((this.datatype === papaya.volume.ImageType.DATATYPE_FLOAT) && (this.numBytes <= papaya.volume.ImageType.MAX_SUPPORTED_BYTES_FLOAT)) ||\n    ((this.datatype !== papaya.volume.ImageType.DATATYPE_FLOAT) && (this.numBytes <= papaya.volume.ImageType.MAX_SUPPORTED_BYTES_INTEGER)))\n    );\n};\n\n\n\npapaya.volume.ImageType.prototype.getTypeDescription = function () {\n    if (this.datatype === papaya.volume.ImageType.DATATYPE_INTEGER_SIGNED) {\n        return "Signed Integer";\n    }\n\n    if (this.datatype === papaya.volume.ImageType.DATATYPE_INTEGER_UNSIGNED) {\n        return "Unsigned Integer";\n    }\n\n    if (this.datatype === papaya.volume.ImageType.DATATYPE_FLOAT) {\n        return "Float";\n    }\n\n    if (this.datatype === papaya.volume.ImageType.DATATYPE_RGB) {\n        return "RGB";\n    }\n\n    return "Unknown";\n};\n\n\n\npapaya.volume.ImageType.prototype.getOrderDescription = function () {\n    if (this.numBytes > 1) {\n        if (this.littleEndian) {\n            return "Little Endian";\n        }\n\n        return "Big Endian";\n    }\n\n    return null;\n};\n\n\n\n/*jslint browser: true, node: true */\n/*global */\n\n"use strict";\n\n/*** Imports ***/\nvar papaya = papaya || {};\npapaya.volume = papaya.volume || {};\n\n\n/*** Constructor ***/\npapaya.volume.ImageType = papaya.volume.ImageType || function (datatype, numBytes, littleEndian, compressed) {\n    this.datatype = datatype;\n    this.numBytes = numBytes;\n    this.littleEndian = littleEndian;\n    this.swapped = false;\n    this.compressed = compressed;\n    this.rgbBySample = false;\n};\n\n\n/*** Static Pseudo-constants ***/\n\npapaya.volume.ImageType.DATATYPE_UNKNOWN = 0;\npapaya.volume.ImageType.DATATYPE_INTEGER_SIGNED = 1;\npapaya.volume.ImageType.DATATYPE_INTEGER_UNSIGNED = 2;\npapaya.volume.ImageType.DATATYPE_FLOAT = 3;\npapaya.volume.ImageType.DATATYPE_RGB = 4;\npapaya.volume.ImageType.MAX_SUPPORTED_BYTES_FLOAT = 8;\npapaya.volume.ImageType.MAX_SUPPORTED_BYTES_INTEGER = 4;\n\n\n/*** Prototype Methods ***/\n\npapaya.volume.ImageType.prototype.isValid = function () {\n    return (\n    (this.datatype <= papaya.volume.ImageType.DATATYPE_RGB) &&\n    (this.datatype > papaya.volume.ImageType.DATATYPE_UNKNOWN) &&\n    (this.numBytes > 0) &&\n    (((this.datatype === papaya.volume.ImageType.DATATYPE_FLOAT) && (this.numBytes <= papaya.volume.ImageType.MAX_SUPPORTED_BYTES_FLOAT)) ||\n    ((this.datatype !== papaya.volume.ImageType.DATATYPE_FLOAT) && (this.numBytes <= papaya.volume.ImageType.MAX_SUPPORTED_BYTES_INTEGER)))\n    );\n};\n\n\n\npapaya.volume.ImageType.prototype.getTypeDescription = function () {\n    if (this.datatype === papaya.volume.ImageType.DATATYPE_INTEGER_SIGNED) {\n        return "Signed Integer";\n    }\n\n    if (this.datatype === papaya.volume.ImageType.DATATYPE_INTEGER_UNSIGNED) {\n        return "Unsigned Integer";\n    }\n\n    if (this.datatype === papaya.volume.ImageType.DATATYPE_FLOAT) {\n        return "Float";\n    }\n\n    if (this.datatype === papaya.volume.ImageType.DATATYPE_RGB) {\n        return "RGB";\n    }\n\n    return "Unknown";\n};\n\n\n\npapaya.volume.ImageType.prototype.getOrderDescription = function () {\n    if (this.numBytes > 1) {\n        if (this.littleEndian) {\n            return "Little Endian";\n        }\n\n        return "Big Endian";\n    }\n\n    return null;\n};\n\n\n\n/*jslint browser: true, node: true */\n/*global */\n\n"use strict";\n\n/*** Imports ***/\nvar papaya = papaya || {};\npapaya.volume = papaya.volume || {};\n\n\n/*** Constructor ***/\npapaya.volume.ImageDimensions = papaya.volume.ImageDimensions || function (cols, rows, slices, timepoints) {\n    this.cols = cols;\n    this.rows = rows;\n    this.slices = slices;\n\n    this.colsOrig = cols;\n    this.rowsOrig = rows;\n    this.slicesOrig = slices;\n\n    this.xDim = -1;\n    this.yDim = -1;\n    this.zDim = -1;\n    this.timepoints = timepoints || 1;\n    this.dataOffsets = [];  // offset of image data from start of file\n    this.dataLengths = [];  // length of image data\n};\n\n\n/*** Prototype Methods ***/\n\npapaya.volume.ImageDimensions.prototype.padIsometric = function (vd) {\n    var id = this,\n        cols = id.cols,\n        rows = id.rows,\n        slices = id.slices,\n        colExt = (cols * vd.colSize),\n        rowExt = (rows * vd.rowSize),\n        sliceExt = (slices * vd.sliceSize),\n        largestDim = Math.max(Math.max(colExt, rowExt), sliceExt),\n        colDiff = parseInt((largestDim - colExt) / vd.colSize / 2, 10),\n        rowDiff = parseInt((largestDim - rowExt) / vd.rowSize / 2, 10),\n        sliceDiff = parseInt((largestDim - sliceExt) / vd.sliceSize / 2, 10);\n\n    this.cols = (cols+2*colDiff);\n    this.rows = (rows+2*rowDiff);\n    this.slices = (slices+2*sliceDiff);\n};\n\n\n\npapaya.volume.ImageDimensions.prototype.getNumVoxelsSeries = function () {\n    return this.cols * this.rows * this.slices * this.timepoints;\n};\n\n\n\npapaya.volume.ImageDimensions.prototype.getNumVoxelsSlice = function () {\n    return this.rows * this.cols;\n};\n\n\n\npapaya.volume.ImageDimensions.prototype.getNumVoxelsVolume = function () {\n    return this.rows * this.cols * this.slices;\n};\n\n\n\npapaya.volume.ImageDimensions.prototype.isValid = function () {\n    return ((this.cols > 0) && (this.rows > 0) && (this.slices > 0) && (this.timepoints > 0) &&\n        (this.dataOffsets[0] >= 0) && (this.dataLengths[0] >= 0));\n};\n\n\n/*** Exports ***/\nvar moduleType = typeof module;\nif ((moduleType !== \'undefined\') && module.exports) {\n    module.exports.ImageDimensions = papaya.volume.ImageDimensions;\n}\n\n\n\n\n\n\n\n\n/***\n   Copyright 2013 Teun Duynstee\n   Licensed under the Apache License, Version 2.0 (the "License");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n     http://www.apache.org/licenses/LICENSE-2.0\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an "AS IS" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n*/\nvar firstBy = (function() {\n\n    function identity(v){return v;}\n\n    function ignoreCase(v){return typeof(v)==="string" ? v.toLowerCase() : v;}\n\n    function makeCompareFunction(f, opt){\n        opt = typeof(opt)==="number" ? {direction:opt} : opt||{};\n        if(typeof(f)!="function"){\n            var prop = f;\n            // make unary function\n            f = function(v1){return !!v1[prop] ? v1[prop] : "";}\n        }\n        if(f.length === 1) {\n            // f is a unary function mapping a single item to its sort score\n            var uf = f;\n            var preprocess = opt.ignoreCase?ignoreCase:identity;\n            f = function(v1,v2) {return preprocess(uf(v1)) < preprocess(uf(v2)) ? -1 : preprocess(uf(v1)) > preprocess(uf(v2)) ? 1 : 0;}\n        }\n        if(opt.direction === -1) return function(v1,v2){return -f(v1,v2)};\n        return f;\n    }\n\n    /* adds a secondary compare function to the target function (`this` context)\n       which is applied in case the first one returns 0 (equal)\n       returns a new compare function, which has a `thenBy` method as well */\n    function tb(func, opt) {\n        var x = typeof(this) == "function" ? this : false;\n        var y = makeCompareFunction(func, opt);\n        var f = x ? function(a, b) {\n                        return x(a,b) || y(a,b);\n                    }\n                  : y;\n        f.thenBy = tb;\n        return f;\n    }\n    return tb;\n})();\n\nif (typeof module == \'object\')\n module.exports.papaya = papaya;\n'},function(t,n){t.exports='\n\n\nif (typeof electron == "undefined")\n    electron = false;\n\n\nif (typeof module != "undefined" && !electron)\n{\n\n    var KissFFT = require("../../htdocs/imgproc/kissFFT_main.js");\n\n    if (typeof daikon == "undefined")\n        daikon = require(\'./daikon\');\n\n    if (daikon.papaya != undefined)\n        papaya = daikon.papaya;\n\n    var math = require("../../src/node/kmath.js");\n    var path = require("path");\n\n    function fullfile(arr)\n    {\n      if (!Array.isArray(arr))\n        return arr;\n      f = \'\';\n      for (var  k = 0; k < arr.length-1;k++)\n        f += arr[k] + \'/\';\n      f += arr[arr.length-1];\n\n      f = f.replace(/\\/\\//g,\'/\');\n\n      return f;\n    }\n\n\n    function pid_hashfun(type,str,callback)\n    {\n        if(type.toLowerCase() == \'nohash\')\n        {\n            callback( str );        \n        }\n        else\n        {    \n            var crypto = require(\'crypto\');\n            var shasum = crypto.createHash(\'sha1\')\n            shasum.update(str )\n            callback(shasum.digest(\'hex\'));        \n        }\n    }\n\n    module.exports =\n    {\n        dicomReader:DicomReader(),\n        dicomReaderFun:DicomReader\n    }\n\n\n}\n\nif (typeof pid_hashfun == "undefined" && typeof SubtleCrypto != "undefined")\n{\n\n    function pid_hashfun(type,str,callback)\n    {\n        if(type.toLowerCase() == \'nohash\')\n        {\n            callback(str)\n        }\n        else\n        {\n            function f(str) {\n            return crypto.subtle.digest("SHA-1", new TextEncoder("utf-8").encode(str)).then(buf => {\n                return Array.prototype.map.call(new Uint8Array(buf), x=>((\'00\'+x.toString(16)).slice(-2))).join(\'\');\n            });\n            }\n            f(str).then(callback);\n        }\n    }\n}\n\n\n\n\n\n\nfunction DicomReader()\n{\n    var that = new Object();\n\n    // store all found series in this Object, indexed by suid\n    var series = {} ;\n    \n    // async Solution: keep track of the read files\n    var fileList;\n   // var filesDone;\n\n    var progress = function(x) {\n        if (x != undefined)\n         console.log(x) };\n    var error_report = {};\n\n    that.whendone = undefined;\n    \n    // can call this by an on drop / load event\n    function readMultiFiles(files, whendone,progressSpinner)\n    {\n      // for debugging load script already in index.php\n      if( typeof daikon == "undefined")\n          scriptLoader.loadScript("dicom/daikon.js", scriptLoaded);\n      else\n          scriptLoaded();\n\n      function scriptLoaded()\n      {\n         \n        progress = progressSpinner;\n        series = {};\n        that.series = series;\n        //filesDone  = [];\n        that.whendone  = whendone;\n\n\n        //var files = ev.target.files;\n        fileList   = files;\n\n        var numfiles = files.length;        \n        \n        function readSeries() {\n            if (files.length>0) \n            {\n                if (progress)\n                    progress("Reading Headers " + math.round(100*(1-files.length/numfiles)) + "%");\n                var file = files[0];\n                files = files.slice(1);\n\n                var reader = new FileReader();\n                reader.onloadend = function (evt) \n                {\n                    if (evt.target && evt.target.readyState === FileReader.DONE) \n                    {\n                        readSingleDICOM(file.name, evt.target.result, readSeries);\n                    }\n                    else if (this.customBuffer)\n                    {\n                        readSingleDICOM(file.filename, this.customBuffer.buffer, readSeries)\n                    }\n                 };\n                readBufferFromFile(reader, file )\n\n            }        \n            else\n               dicom2nii(whendone );  \n        }                \n        readSeries();\n      }\n        \n\n    }\n    that.readMultiFiles = readMultiFiles;\n    that.transform_suidmap = {}\n\n    // parse the dicom content\n    function readSingleDICOM(name, buf, callback) \n    {   \n        // function reads a single file, gathers important tags and appends it to the series array\n        var data = new DataView(buf);\n        daikon.Parser.verbose = false;\n\n        var image = daikon.Series.parseImage(data);\n        if (image == undefined)\n        { \n            error_report.daikon = true;\n            if (callback)\n                callback(false)\n            return false;\n        }\n           \n        // sort the images according to patient, StudyInstanceUID\n        // for now, only use the suid;\n        var suid = image.getSeriesInstanceUID();\n\n        // in strange cases, images can have same suid but different geometries... use some advanced other tags for key\n        if(1)\n        {\n            var sizehash = "";\n            sizehash += image.gettag("Rows") + "x" + image.gettag("Columns");\n            var x = image.gettag("ImageOrientationPatient");\n            if(x!=undefined)\n                for(var k=0; k<x.length; k++)\n                    sizehash += x[k].toFixed(3);\n            suid += sizehash + image.gettag("SegmentLabel");\n        }\n\n        function done()\n        {\n            series[suid].daikonseries.addImage(image);\n            if (callback)\n                callback(true)\n            return true\n        }\n    \n        // no valid dicom file, or no suid in this file. abort\n        if(image.getSeriesInstanceUID() !== null) \n        {    \n            if(series[suid] === undefined) // start a new series\n            {\n                series[suid] = {};\n                series[suid].daikonseries = new daikon.Series();\n                series[suid].seriesDescription =  image.getSeriesDescription() || "noDescription";\n                series[suid].seriesNumber = image.getSeriesNumber() || "0";;\n                series[suid].AcquisitionNumber = image.gettag("AcquisitionNumber")\n                series[suid].PatientID = image.getPatientID() || "nopatientid";\n                series[suid].AccessionNumber = image.gettag("AccessionNumber")\n                series[suid].originalStudyID = image.gettag("StudyID");\n\n                series[suid].image0 = image;\n                \n                if (image.ktags.FrameOfReferenceTransformMatrix)\n                {\n\n                    for (var k = 0; k < image.ktags.ReferencedSOPInstanceUID.multival.length;k++)\n                        that.transform_suidmap[image.ktags.ReferencedSOPInstanceUID.multival[k]] = image;\n                }\n\n                var studydate = image.getStudyDate() || "00000000";\n                var studytime = image.getStudyTime() || "";\n                \n                if(studytime==undefined)\n                    studytime = studytime;\n                else\n                    studytime = studytime.split(\'.\')[0];\n\n                var studydatetime = (studydate +  studytime).toString();\n\n                series[suid].studydatetime = studydatetime;\n                series[suid].StudyDate = studydate;\n                series[suid].StudyTime =  image.getStudyTime();\n\n                series[suid].PatientName = image.getPatientName() || "NoPatientName";\n                var names =  series[suid].PatientName.split(" ");\n                series[suid].GivenName = names[1];\n                series[suid].FamilyName = names[0];\n             \n\n                series[suid].ProtocolName = image.gettag("ProtocolName")\n                series[suid].ImageType = image.gettag("ImageType")\n                series[suid].Rows = image.gettag("Rows")\n                series[suid].Columns = image.gettag("Columns")\n\t\t        series[suid].filepath = name; \n                series[suid].seriesInstanceUID = suid;\n                series[suid].diffusion = false;\n                series[suid].bDirections = [];\n                series[suid].bMatrix = [];\n                series[suid].bValue = [];\n                series[suid].ImageOrientationPatient = image.gettag("ImageOrientationPatient");\n                series[suid].SeriesInstanceUID = image.getSeriesInstanceUID();\n                series[suid].StudyInstanceUID = image.gettag(\'StudyInstanceUID\');\n                series[suid].imagePathList = [name];\n\n                // this is the default for the studyID\n                series[suid].StudyID = studydatetime;\n\n\n                if (typeof projectInfo == "object" && projectInfo.jsondesc)\n                {\n                    if (projectInfo.jsondesc.StudyID_type != undefined && projectInfo.jsondesc.StudyID_type != "studydatetime")\n                    {\n                        var sid = image.gettag(projectInfo.jsondesc.StudyID_type);\n                        if (sid != undefined)\n                            series[suid].StudyID = sid;\n                        else\n                            console.warn("Custom StudyID type: \'" + projectInfo.jsondesc.StudyID_type + "\' not extisting in dicom header, falling back to default");\n\n                    }\n\n                    if (projectInfo.jsondesc.PatientID_type != undefined)                    \n                    {\n                        var piz;\n                        if (projectInfo.jsondesc.PatientID_type == "studydatetime")\n                            piz = studydatetime;\n                        else\n                            piz = image.gettag(projectInfo.jsondesc.PatientID_type);\n                            \n                        if (piz != undefined)\n                            series[suid].PatientID = piz;\n                        else\n                            console.warn("Custom PatientID type: \'" + projectInfo.jsondesc.PatientID_type + "\' not extisting in dicom header, falling back to default");\n\n                    }\n\n                    // get rid of all non-alphanumerics in PIZ/SID\n                    series[suid].PatientID = series[suid].PatientID.replace(/\\W/g,\'\');\n                    series[suid].StudyID = series[suid].StudyID.replace(/\\W/g,\'\');\n                    series[suid].PatientID = series[suid].PatientID.replace(/\\_/g,\'-\');\n                    series[suid].StudyID = series[suid].StudyID.replace(/\\_/g,\'-\');\n\n                    image.ktags.PatientID.value[0] = series[suid].PatientID;\n                    image.ktags.StudyID.value[0] = series[suid].StudyID\n\n\n                    if (projectInfo.jsondesc.anonymization && typeof pid_hashfun != "undefined")\n                    {\n\n                        pid_hashfun(projectInfo.jsondesc.anonymization.type,series[suid].PatientID,function(ppid)\n                        {\n                            var keylength=10;\n\n                            if (projectInfo.jsondesc.anonymization.key_length != undefined)\n                                keylength = projectInfo.jsondesc.anonymization.key_length\n                            ppid = ppid.substring(0,keylength);\n                            \n                            series[suid].PatientID = ppid;\n                            series[suid].PatientName =ppid;\n//                            series[suid].GivenName = ppid.substring(0,10)\n//                            series[suid].FamilyName = "Anonymous"\n                            series[suid].FamilyName = ppid.substring(0,10)\n                            series[suid].GivenName = "";\n                            \n                            image.ktags.PatientName.value[0] = series[suid].FamilyName + " " + series[suid].GivenName\n                            image.ktags.PatientID.value[0] = series[suid].PatientID;\n\n                            return done();\n\n                        });\n                    }\n                    else\n                       return  done();\n                }\n                else\n                    return  done();\n\n\n            }\n            else\n            {\n                //remember all original image paths for sorting purposes\n                series[suid].imagePathList.push( name );\n                return done()\n            }\n\n\n/*\n            var siemens = image.gettag(\'CSAImageHeaderInfo\');\n            if(typeof siemens == "string" )\n            {\n                sn = siemens.match(/DiffusionGradientDirection=([-\\d.\\s]+)\\n/);\n                var bdir;\n                var bmat;\n                var bv = 0;\n                if (sn && sn.length > 1)\n                {\n                    bdir = sn[1].split(" ");\n                    series[suid].diffusion = true;\n                    var bval = siemens.match(/B_value=([-\\d.\\s]+)\\n/);\n                    if (bval && bval.length > 1)\n                         bv = parseFloat(bval[1].trim());\n                    var bmat_ = siemens.match(/B_matrix=([-\\d.\\s]+)\\n/);\n                    if (bmat_ != null)\n                    {\n                      bmat_ = bmat_[1].split(" ");\n                      bmat = [[parseFloat(bmat_[0].trim()),parseFloat(bmat_[1].trim()),parseFloat(bmat_[2].trim())],\n                          [parseFloat(bmat_[1].trim()),parseFloat(bmat_[3].trim()),parseFloat(bmat_[4].trim())],\n                          [parseFloat(bmat_[2].trim()),parseFloat(bmat_[4].trim()),parseFloat(bmat_[5].trim())]];\n                    }\n                    else\n                      bmat = [];\n\n\n\n                }\n                else\n                    bdir = ["0","0","0"];\n                series[suid].bMatrix.push(bmat);                \n                series[suid].bDirections.push(bdir);                \n                series[suid].bValue.push(bv);\n                console.log(bv);\n            }\n*/\n\n            // to save memory, otherwise even smallest images kill the task\n            // no, do not, need it later when building series for e.g. for slice normal vector\n            //delete image.ktags.CSAImageHeaderInfo.value;\n            //delete image.ktags.CSASeriesHeaderInfo.value;\n\n        }\n        else\n        {\n           if (callback)\n                callback(false)            \n\t       return false;\n        }\n\n     }\n        \n    // helper function for a file reader, taken from somewhere\n    function makeSlice(file, start, length) \n    {\n        var fileType = (typeof File);\n        if (fileType === \'undefined\') {\n            return function () {};\n        }\n        if (File.prototype.slice) {\n            return file.slice(start, start + length);\n        }\n        if (File.prototype.mozSlice) {\n            return file.mozSlice(start, length);\n        }\n        if (File.prototype.webkitSlice) {\n            return file.webkitSlice(start, length);\n        }\n        return null;\n    }\n \n    that.readSingleDICOM = readSingleDICOM;\n        \n    function dicom2nii(whendone,finalcallback)\n    {\n            var suidList = Object.getOwnPropertyNames(series);\n            var numItems = suidList.length;\n            if (numItems == 0)\n            {\n                progress();\n                whendone(undefined, error_report);\n                if (finalcallback)\n                    finalcallback();\n                \n                return;\n            }\n     \n\n            // SPECIALITY: time series as multiple series, for example as in DCE vibe: must glue to one single series\n            // find out what belongs together: check if a series with same num of images is there. if yes, make a time series.\n            if( 1 )\n            {\n                var newlist = {};\n                for(var k=0; k<suidList.length; k++ )\n                {\n                    // key will be number series desription + num of images + difference between seriesNumber + acquisitonNumber + ImageOrientationPatient\n                    var ss = series[suidList[k]];\n                    if(ss.seriesDescription.search(/^GRASP/)==0 || ss.seriesDescription.search(/^Brain_0_5_CE/)==0)\n                        var key = \'GRASP\' + ss.daikonseries.images.length + ( parseInt(ss.seriesNumber) - parseInt(ss.AcquisitionNumber) ) +ss.ImageOrientationPatient + ss.Rows + ss.Columns;\n                    else if (ss.daikonseries.images[0].gettag(\'Modality\')== \'SR\'  | ss.daikonseries.images[0].fromRDA)\n                        var key = ss.SeriesInstanceUID;\n                    else\n                        var key = ss.seriesDescription + ss.daikonseries.images.length + ( parseInt(ss.seriesNumber) - parseInt(ss.AcquisitionNumber) ) +ss.ImageOrientationPatient + ss.Rows + ss.Columns;\n               \n                    key += ss.daikonseries.images[0].gettag(\'SegmentLabel\')\n\n\n\n                    if(newlist[key] == undefined)\n                        newlist[key] = ss;\n                    else\n                       newlist[key].daikonseries.images =  newlist[key].daikonseries.images.concat( ss.daikonseries.images );\n                }\n                var newlist2 = {};\n                var newkeys = Object.getOwnPropertyNames(newlist);\n                for(var k=0; k<newkeys.length; k++ )\n                {\n                    var temp = newlist[newkeys[k]];\n                    newlist[temp.seriesInstanceUID] = temp;\n                    delete newlist[newkeys[k]];\n                }\n                series = newlist;\n                suidList = Object.getOwnPropertyNames(series);\n            }\n\n            /******************************* \n             run again over all series, might happen that 2 series will have same filename (for example different views in DX )\n            *******************************/\n            var fnlist = {};\n            for(var k=0; k<suidList.length; k++ )\n            {\n                var temp = series[suidList[k]];\n                var fnkey = temp.StudyInstanceUID + temp.seriesDescription + temp.ProtocolName + temp.seriesNumber;\n                if( fnlist[fnkey] != undefined)\n                {\n                    if( fnlist[fnkey].length == 1 )\n                        series[ fnlist[fnkey][0] ].seriesSuffix = ("_a00");\n                    temp.seriesSuffix = ("_a0" + (fnlist[fnkey].length)) ;\n                    \n                    fnlist[fnkey].push(suidList[k]);\n                }\n                else\n                {\n                    fnlist[fnkey] = [suidList[k]];\n                    temp.seriesSuffix = "";\n                }\n            }\n\n            convertSeries();\n\n            function convertSeries()\n            {\n                    if (progress)\n                    {\n                       if (suidList.length == numItems)\n                          progress("Creating Nifti");\n                       else\n                          progress("Creating Niftis " + math.round(100*(1-suidList.length/numItems))+"%");\n                    }\n\n                    var item = series[suidList[0]];\n                    suidList = suidList.slice(1);\n                    \n\n                    var mypapaya = undefined;\n                    var myRT = undefined;\n                    try \n                    {\n                        if (item.daikonseries.buildSeries() != "noimage")\n                        {\n                            mypapaya =  new papaya.volume.dicom.HeaderDICOM();\n                            mypapaya.series = item.daikonseries;\n                            item.type = \'nii\';\n                        }\n                        else if(item.daikonseries.images[0].gettag(\'Modality\') == "RTSTRUCT")\n                        {\n                            // no nice implementation of RT struct (see also below)\n                           item.buffer = prepareRTstruct(item);\n                           item.type = \'rtstruct\';\n                        }\n\n                    } \n                    catch(err) \n                    {\n                        console.log(err);\n                        if (suidList.length > 0)\n                            convertSeries();\n                        else\n                        {\n                            if (finalcallback)\n                                finalcallback();\n                            progress();\n                        }\n                        return;    \n                    }\n                    try \n                    {\n                        if (mypapaya)  // if image data was found\n                        {\n                            mypapaya.readImageData(null, function (imageData) \n                            { \n                                // create the raw nii buffer\n                                mypapaya.imageData = imageData;\n                                mypapaya.fromRDA = item.image0.fromRDA\n                                var nifti = getNiftiBuffer(mypapaya);  \n                                item.buffer = nifti.buffer\n                                item.edges = nifti.edges;\n\n                                var info = item.daikonseries.imageInfo;\n\n                                \n                                if (info.diffusion)\n                                {\n                                    var rot  = mypapaya.getBestTransform().rot;\n                                    var bX = "";\n                                    var bY = "";\n                                    var bZ = "";\n                                    var bV = "";\n                                    var bM = "";\n                                    var bmrtrix = "";\n                                    for (var k = 0; k < info.bDirections.length;k++)\n                                    {\n                                        var d = info.bDirections[k];\n                                        d = [parseFloat(d[0]),parseFloat(d[1]),parseFloat(d[2])];\n                                        bmrtrix+= (d[0].toFixed(5) + " " + d[1].toFixed(5) + " " + d[2].toFixed(5) + " " +  info.bValue[k].toFixed(5) + "\\n");\n\n                                        d = math.multiply(math.Transpose(math.matrix(rot)),math.matrix(d))._data;\n                                        bX += d[0] + " ";\n                                        bY += d[1] + " ";\n                                        bZ += d[2] + " ";\n                                        bV += info.bValue[k] + " ";\n\n                                        var d = info.bMatrix[k];\n                                        var R = math.matrix(rot);\n                                        if(d!=undefined && d.length > 0)\n                                        {\n                                            d = math.multiply(math.multiply(math.Transpose(R),d),R)._data;\n                                            bM += d[0][0]  + " " + d[0][1] + " " + d[0][2] + " " +\n                                                  d[1][0] + " " + d[1][1] + " " + d[1][2] + " " +\n                                                  d[2][0]  + " " + d[2][1] + " " + d[2][2] + " \\n";\n                                        }\n                                        else\n                                            bM += "0 0 0 0 0 0 0 0 0 \\n";\n\n                                    }\n                                    item.bval = bV;\n                                    item.bvec = bX + "\\n" + bY + "\\n" + bZ + "\\n";\n                                    item.bmat = bM; \n                                    item.bmrtrix = bmrtrix; \n                                    item.diffusion = true;\n\t\t\t\t                    console.log("diffusion info found");\n                                }\n\n                                item.imageDimensions = mypapaya.getImageDimensions();\n\n                                // is this a (perfusion, fmri) - timeseries?\n                                // if yes, write the exact slice timing later as a .time file\n                                if ( ( (item.ImageType && item.ImageType.indexOf(\'PRIMARY\') > -1 && \n                                        (item.ImageType.indexOf(\'PERFUSION\')> -1 || item.ImageType.indexOf(\'ECHO_00\')> -1  ) )  \n                                       | item.daikonseries.images[0].gettag(\'Modality\') == \'CT\'\n                                       | item.seriesDescription.search(\'perf\') != -1\n                                       | item.seriesDescription.search(\'cmrr\') != -1\n                                     )\n                                    &&  item.imageDimensions.timepoints > 5 )\n                                    item.isTimeSeries = 1;\n                                else\n                                    item.isTimeSeries = 0;\n\n                                // create a javascript nifti object\n                                // item.nii =  parse( item.buffer   ) ;\n\n                                if(whendone)\n                                    whendone(item, error_report);\n\n                                if (suidList.length > 0)\n                                    convertSeries();\n                                else\n                                {\n                                    if (finalcallback)\n                                        finalcallback();\n                                    progress();\n                                }\n                            });\n                        }\n                        else if(item.daikonseries.images[0].gettag(\'Modality\') && item.daikonseries.images[0].gettag(\'ContentSequence\') )\n                        {\n                            // structured report content (SR) ContentSequence\n                            /*  \n                            http://dicom.nema.org/dicom/2013/output/chtml/part05/sect_7.5.html\n\n                            (0040,a730) SQ (Sequence with explicit length #=6)      # 2060, 1 ContentSequence\n                              \n                              (fffe,e000) na (Item with explicit length #=4)          # 152, 1 Item\n                                (0040,a010) CS [HAS CONCEPT MOD]                        #  16, 1 RelationshipType\n                                (0040,a040) CS [CODE]                                   #   4, 1 ValueType\n                                (0040,a043) SQ (Sequence with explicit length #=1)      #  50, 1 ConceptNameCodeSequence\n                                  (fffe,e000) na (Item with explicit length #=3)          #  42, 1 Item\n                                    (0008,0100) SH [121049]                                 #   6, 1 CodeValue\n                                    (0008,0102) SH [DCM]                                    #   4, 1 CodingSchemeDesignator\n                                    (0008,0104) LO [Sprache]                                #   8, 1 CodeMeaning\n                                  (fffe,e00d) na (ItemDelimitationItem for re-encoding)   #   0, 0 ItemDelimitationItem\n                                (fffe,e0dd) na (SequenceDelimitationItem for re-encod.) #   0, 0 SequenceDelimitationItem\n                                (0040,a168) SQ (Sequence with explicit length #=1)      #  50, 1 ConceptCodeSequence\n                                  (fffe,e000) na (Item with explicit length #=3)          #  42, 1 Item\n                                    (0008,0100) SH [de]                                     #   2, 1 CodeValue\n                                    (0008,0102) SH [ISO639_2]                               #   8, 1 CodingSchemeDesignator\n                                    (0008,0104) LO [Deutsch]                                #   8, 1 CodeMeaning\n                                  (fffe,e00d) na (ItemDelimitationItem for re-encoding)   #   0, 0 ItemDelimitationItem\n                                (fffe,e0dd) na (SequenceDelimitationItem for re-encod.) #   0, 0 SequenceDelimitationItem\n                              (fffe,e00d) na (ItemDelimitationItem for re-encoding)   #   0, 0 ItemDelimitationItem\n                              (fffe,e000) na (Item with explicit length #=4)          # 238, 1 Item\n                                \n                                ... next item\n\n\n                              (fffe,e000) na (Item with explicit length #=5)          # 966, 1 Item\n                                (0040,a010) CS [CONTAINS]                               #   8, 1 RelationshipType\n                                (0040,a040) CS [CONTAINER]                              #  10, 1 ValueType\n                                (0040,a043) SQ (Sequence with explicit length #=1)      #  48, 1 ConceptNameCodeSequence\n                                  (fffe,e000) na (Item with explicit length #=3)          #  40, 1 Item\n                                    (0008,0100) SH [121077]                                 #   6, 1 CodeValue\n                                    (0008,0102) SH [DCM]                                    #   4, 1 CodingSchemeDesignator\n                                    (0008,0104) LO [Befund]                                 #   6, 1 CodeMeaning\n                                  (fffe,e00d) na (ItemDelimitationItem for re-encoding)   #   0, 0 ItemDelimitationItem\n                                (fffe,e0dd) na (SequenceDelimitationItem for re-encod.) #   0, 0 SequenceDelimitationItem\n                                (0040,a050) CS [SEPARATE]                               #   8, 1 ContinuityOfContent\n                                (0040,a730) SQ (Sequence with explicit length #=1)      # 852, 1 ContentSequence\n                                  (fffe,e000) na (Item with explicit length #=2)          # 844, 1 Item\n                                    (0040,a040) CS [TEXT]                                   #   4, 1 ValueType\n                                    (0040,a160) UT [Der Patient lehnt eine Kontrastmittel-Gabe ab.\n\n                            */\n                            \n                            var srjson = \n                            {\n                                StudyDate: item.daikonseries.images[0].gettag(\'StudyDate\'),\n                                StudyTime: item.daikonseries.images[0].gettag(\'StudyTime\'),\n                                SeriesDate: item.daikonseries.images[0].gettag(\'SeriesDate\'),\n                                SeriesTime: item.daikonseries.images[0].gettag(\'SeriesTime\'),\n                                PatientID: item.daikonseries.images[0].gettag(\'PatientID\'),\n                                PatientName: item.daikonseries.images[0].gettag(\'PatientName\'),\n                                AccessionNumber: item.daikonseries.images[0].gettag(\'AccessionNumber\'),\n                            };\n\n                            srjson.CompletionFlag = item.daikonseries.images[0].gettag(\'CompletionFlag\') && item.daikonseries.images[0].gettag(\'CompletionFlag\') == "COMPLETE";\n                            srjson.VerificationFlag = item.daikonseries.images[0].gettag(\'VerificationFlag\') && item.daikonseries.images[0].gettag(\'VerificationFlag\') == "VERIFIED";\n\n                            var srhtml = "";\n                            var srtxt = "";\n\n                            var lastkey = "nokey";\n                            \n                            var isCONTAINER = false;\n\n                            var verbose = 0;\n                            \n                            function parseItem(parent, item)\n                            {\n                                if(1)//item.id == "FFFEE000" && item.sublist)\n                                {\n                                    var temp = item.value; \n                                    for(var z=0; z<temp.length; z++)\n                                    {\n                                        //console.log("" + temp[z].id + " " + temp[z].vr + " " + temp[z].value )\n                                        //console.log(" PARSING::: " + temp[z].id + " " + temp[z].vr + " "  )\n\n                                       if( (temp[z].id == "0040A040" &&  temp[z].value[0] == "CONTAINER") ) // RelationshipType\n                                       {\n                                           isCONTAINER = true;\n                                       }\n\n//                                         else if( temp[z].id == "0040A040" ) // ValueType\n                                        \n                                        \n                                        if(  temp[z].sublist ) // ContentSequence => type SQ\n                                        {\n                                            parseItem(item, temp[z])\n                                        }\n                                        if( temp[z].id == "00080104" && isCONTAINER ) // This seems to be a title, for example "Befund"\n                                        {\n                                            srhtml += "<h3>" + temp[z].value + "</h3>";\n                                            srtxt += "\\n" + temp[z].value + "\\n================================";\n                                            lastkey = temp[z].value;\n                                            if(verbose)\n                                                console.log("=============== " + temp[z].value  + " ===============")\n                                        }\n                                        // SRTextValue This is a content text we are looking for\n                                        // go back in tree to find the correct id\n                                        if( temp[z].id == "0040A160" && isCONTAINER ) \n                                        {\n                                            srhtml += "<p>" + temp[z].value + "</p>";\n                                            srtxt += "\\n" + temp[z].value + "\\n";\n                                            \n                                            srjson[lastkey] = temp[z].value[0]\n                                            isCONTAINER = false;\n                                            \n                                            if(verbose)\n                                                console.log("" + temp[z].value )\n                                        }\n                                    }\n                                }\n                            }\n\n                            var root = item.daikonseries.images[0].gettag(\'ContentSequence\');\n                            // walk over all items\n                            if(verbose)\n                                console.log("//////////////  SR fields  //////////////////////");\n\n                            if(1) // print completed / verified\n                            {\n                                srhtml += "<div>";    \n                                if(srjson.CompletionFlag)\n                                    srhtml += "<span class=\'sr_ok\'>COMPLETED</span>";\n                                else\n                                    srhtml += "<span class=\'sr_not_ok\'>NOT COMPLETED</span>";\n\n                                if(srjson.VerificationFlag)\n                                    srhtml += "<span class=\'sr_ok\'>VERIFIED</span>";\n                                else\n                                    srhtml += "<span class=\'sr_not_ok\'>NOT VERIFIED</span>";\n\n                                srhtml += "</div>";    \n\n                                //srhtml += "<div class=\'sr_info_patient\'><span>Patient: "+  +" </span><div>";\n                                srhtml += "<div class=\'sr_info_date\'>StudyDate: "+srjson.StudyDate+", ReportDate:" +  srjson.SeriesDate + " </div>";\n                            }\n\n                            for(var k=0; k<root.length; k++)\n                            {\n                                // this is really a valid item (which again is a sublist)\n                                parseItem(srjson, root[k])\n                            }\n                            \n                            if(verbose)\n                            {\n                                console.log("" + srtxt);\n                                console.log("==============================");\n                                console.log(srjson);\n                            }\n\n\n                            // only save verified or completed reports\n                            if( (srjson.VerificationFlag || srjson.CompletionFlag) )\n                            {\n                                item.isStructuredReport = true;\n                                item.daikonseries.srjson = srjson;\n                                item.daikonseries.srhtml = srhtml;\n                                item.daikonseries.srtxt  = srtxt;\n                            }\n\n\n                            if(whendone)\n                                whendone(item, error_report);\n                            if (suidList.length > 0) // convert next item\n                            {\n                               convertSeries();\n                            }\n                            else\n                            {\n                                if (finalcallback)\n                                    finalcallback();\n                                progress();\n                            }\n\n                        } // end  of structured report if\n                        else // other data (RT struct ?)\n                        {\n                             // RT struct is badly implemented with "noimage" check\n                             // must distinguish between "noimage" and other Rt rtstruct\n                             // switch of registration of "noPixelDataImages" for now\n                             \n                             \n                             if(whendone)\n                                    whendone(item, undefined);\n                             \n\n                            if (suidList.length > 0)\n                            {\n                               convertSeries();\n                            }\n                            else\n                            {\n                                if (finalcallback)\n                                    finalcallback();\n                                progress();\n                            }\n                        }\n\n                    } \n                    catch(err) \n                    {\n                        error_report.daikon = true;\n                        console.log(err);\n                        if(whendone)\n                             whendone(item, error_report);\n                        if (suidList.length > 0)\n                            convertSeries();\n                        else\n                        {\n                            if (finalcallback)\n                                finalcallback();\n                            progress();\n                        }\n                        return;        \n                    }\n                \n            }\n\n    }\n\n\n    function getNiftiBuffer(mypapaya)\n    {\n\n        // this is a default nifti buffer in uint8 representation.\n        var niihdr = [92,1,0,0,117,105,110,116,49,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,0,1,0,16,0,16,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,16,0,0,0,0,0,128,191,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,111,110,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,128,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,191,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,191,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,105,49,0,0,0,0,0];  \n        //var buffer = Uint8Array.from(niihdr).buffer;\n        var buffer = (new Uint8Array(niihdr)).buffer;\n\n        var sx,sy,sz,st,st2, vx,vy,vz, edges, datatype; \n        var littleEndian = true;\n\n        // assume uint16 as default           \n        var datatype = 512;       \n\n\n        var imgSize = mypapaya.getImageDimensions();\n        var voxSize = mypapaya.getVoxelDimensions();\n\n        sx =  imgSize.cols;\n        sy =  imgSize.rows;\n        sz =  imgSize.slices;\n        st =  imgSize.timepoints;\n        st2 =  1;\n        \n        vx =  voxSize.colSize;\n        vy =  voxSize.rowSize;\n        vz =  voxSize.sliceSize;\n\n\n        if (mypapaya.fromRDA)\n        {\n            datatype = 64;\n            st =  imgSize.timepoints/2;\n            st2 = 2;\n        }\n\n\n        edges = mypapaya.getBestTransform().edges;\n        // permutationOrder gives the order in which the real world is stored in the array\n\n        if (edges == undefined | edges == null)\n        {\n            // DICOM default is LPS, in nifti we have RAS, so -1 -1  1  shall be nifti default\n            edges =  math.diag([-1, -1, 1, 1]);;\n        }\n\n\n    //  this was just a test try forget it.\n    //  var A = edges.slice(0,3);\n    //  var permutationOrder = [findIndexOfGreatest(A[0].slice(0,3)), findIndexOfGreatest(A[1].slice(0,3)), findIndexOfGreatest(A[2].slice(0,3) )];\n\n    //  permutationOrder  = [1,2,0];\n\n        // adapt the offsets\n    //  var offs = [0, 0, 0, 0];\n    //  // slice axis up side down\n    //  var sliceAdd =  -(sz-1) * vz;\n    //  var sliceIndex = permutationOrder[2];\n    //  // y axis exchange\n    //  var yAdd =  -(sy-1) * vy;\n    //  var yIndex = permutationOrder[1];\n\n    //  edges[sliceIndex][3] =  edges[sliceIndex][3] +  sliceAdd;\n    //  edges[yIndex][3]     =  edges[yIndex][3] +  yAdd;\n        //console.log(edges[2]);\n\n                     // linearize     \n\n\n  // set the  header to nifti header\n       var view = new DataView(buffer);\n\n\n       var signum_edges = Math.sign(math.det(edges._data));\n\n       var qquat = sform2quaternion(edges);\n\n       view.setFloat32(256, qquat.q[0], littleEndian);\n       view.setFloat32(260, qquat.q[1], littleEndian);\n       view.setFloat32(264, qquat.q[2], littleEndian);\n       view.setFloat32(268, edges._data[0][3], littleEndian);\n       view.setFloat32(272, edges._data[1][3], littleEndian);\n       view.setFloat32(276, edges._data[2][3], littleEndian);\n\n       var edges_ = edges;\n                        \n       edges = edges._data;\n\n       // nifti standard is row-wise storage, edges already come in this from from daikon.js\n       edges = edges[0].concat(edges[1]).concat(edges[2]).concat(edges[3]);\n\n       var ndims = st>1?4:3;\n       ndims = st2>1?5:ndims;\n\n      \n       // sizes\n       view.setInt32(0, 348,  littleEndian )\n       view.setInt16(40, ndims,  littleEndian )\n       view.setInt16(42, sx,  littleEndian )\n       view.setInt16(44, sy,  littleEndian )\n       view.setInt16(46, sz,  littleEndian )\n       view.setInt16(48, st,  littleEndian )\n       view.setInt16(50, st2,  littleEndian )\n\n       // edges\n       var srow = new Float32Array(12);\n       for(var i=0; i<12; i++) \n            srow[i] = view.setFloat32(280+4*i, (edges[i]), littleEndian)\n\n\n\n\n \n\n\n\n       // ====== apply some other important stuff\n       // set the magic number to n+1\n       view.setInt32(344, 1848324352,  !littleEndian )\n       // set vox offset to 352\n       view.setFloat32(108, 352, littleEndian) \n\n\n       // pixdims\n       view.setFloat32(76, signum_edges,  littleEndian ) // this is the qfac. Only set, if qform is provided??\n       view.setFloat32(80, vx,  littleEndian )\n       view.setFloat32(84, vy,  littleEndian )\n       view.setFloat32(88, vz,  littleEndian )\n\n       // qform=0, \n       view.setInt16(252, 0,  littleEndian )\n\n       var dcm = mypapaya.series.images[0];\n\n       // window\n        // E. Kellner\n        // in some DICOMS, this is ugly set. So do not use this feature.\n        if(0)\n        {\n            var w = mypapaya.series.images[0].ktags[\'WindowWidth\'];\n            var c = mypapaya.series.images[0].ktags[\'WindowCenter\'];\n            if(c !=undefined && w != undefined)\n            {\n                c = c.value;\n                w = w.value;\n                if(Array.isArray(c)){ c=c[0]; w=w[0];}\n                var cal_max = c+w/2;\n                var cal_min = c-w/2;\n                view.setFloat32(124, cal_max, littleEndian)\n                view.setFloat32(128, cal_min, littleEndian)\n            }\n        }\n\n        // Slice Timing \n        var sliceDuration =  mypapaya.series.sliceDuration ;\n        if ( sliceDuration != undefined   && !isNaN( sliceDuration ) )\n             view.setFloat32(132, sliceDuration, littleEndian)\n\n\n       // date type and conversion of little / big endian (if required)\n       var dcmdatatype  = dcm.getDataType();\n       var dcmnumBytes  = dcm.getBitsAllocated() / 8;\n       var dcmendianess = dcm.littleEndian;\n       if(dcmnumBytes > 1 && dcmendianess != littleEndian) // endianess conversion required \n       {    \n            var dataView = new DataView( mypapaya.imageData );\n            var mask = daikon.Utils.createBitMask(dcm.getBitsAllocated() / 8, dcm.getBitsStored(), dcmdatatype === daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED);\n            for (var ctr = 0; ctr < mypapaya.imageData.byteLength; ctr += dcmnumBytes) \n            {\n                if( dcmdatatype == 4  ) // float\n                {\n                    var rawValue = dataView.getFloat32(ctr , dcmendianess);\n                    dataView.setFloat32(ctr, (rawValue & mask), littleEndian);\n                }\n                else if( dcmdatatype == 2  ) // INT \n                {\n                    var rawValue = dataView.getInt16(ctr , dcmendianess);\n                    dataView.setInt16(ctr, (rawValue & mask), littleEndian);\n                }\n                else // ( dcmdatatype == 3 ) // UINT or other\n                {\n                    var rawValue = dataView.getUint16(ctr , dcmendianess);\n                    dataView.setUint16(ctr, (rawValue & mask), littleEndian);\n                }\n            }\n   \n       }\n       /* dicom data types\n                daikon.Image.BYTE_TYPE_INTEGER = 2;\n                daikon.Image.BYTE_TYPE_INTEGER_UNSIGNED = 3;\n                daikon.Image.BYTE_TYPE_FLOAT = 4;\n                daikon.Image.BYTE_TYPE_COMPLEX = 5;\n                daikon.Image.BYTE_TYPE_RGB = 6;\n\n          nifti data types\n                    #define NIFTI_TYPE_UINT8           2 /! unsigned char. /\n                    #define NIFTI_TYPE_INT16           4 /! signed short. /\n                    #define NIFTI_TYPE_INT32           8 /! signed int. /\n                    #define NIFTI_TYPE_FLOAT32        16 /! 32 bit float. /\n                    #define NIFTI_TYPE_COMPLEX64      32 /! 64 bit complex = 2 32 bit floats. /\n                    #define NIFTI_TYPE_FLOAT64        64 /! 64 bit float = double. /\n                    #define NIFTI_TYPE_RGB24         128 /! 3 8 bit bytes. /\n                    #define NIFTI_TYPE_INT8          256 /! signed char. /\n                    #define NIFTI_TYPE_UINT16        512 /! unsigned short. /\n                    #define NIFTI_TYPE_UINT32        768 /! unsigned int. /\n                    #define NIFTI_TYPE_INT64        1024 /! signed long long. /\n                    #define NIFTI_TYPE_UINT64       1280 /! unsigned long long. /\n                    #define NIFTI_TYPE_FLOAT128     1536 /! 128 bit float = long double. /\n                    #define NIFTI_TYPE_COMPLEX128   1792 /! 128 bit complex = 2 64 bit floats. /\n                    #define NIFTI_TYPE_COMPLEX256   2048 /! 256 bit complex = 2 128 bit floats /\n      */\n\n       // not all datatypes are implemented yet\n       if(     dcmdatatype == 3 & dcmnumBytes == 1)   // uint8\n            datatype = 2;\n       else if(dcmdatatype == 3 & dcmnumBytes == 2)   // uint16\n            datatype = 512;\n       else if(dcmdatatype == 2 & dcmnumBytes == 1)   // int8 \n            datatype = 256;\n       else if(dcmdatatype == 2 & dcmnumBytes == 2)   // int16\n            datatype = 4;\n       else if(dcmdatatype == 4 )   // float32\n            datatype = 16;\n       else if(dcmdatatype == 6 )   // rgb24\n            datatype = 128;\n\n\n\n       // ********************** data (re)-scaling ************************************\n       var hh        = mypapaya.series.images[0];\n       var slope     = hh.getDataScaleSlope() || 1;\n       var intercept = hh.getDataScaleIntercept() || 0;\n\n        // data scaling. Might be different for each slice (for example PET)! In this case, must scale data in place and convert to float.\n        // for now, do it only for PET (migh also be necessary for other modalities)\n        // could also be implemented more efficiently in daikon in the loops, but then we must modify many dicom tags ...?\n        if(hh.gettag("Modality") == "PT")\n        {\n            var mustrescale = false;\n            for(var k=1; k<mypapaya.series.images.length; k++)\n            {\n                if(mypapaya.series.images[k-1].getDataScaleSlope() != mypapaya.series.images[k].getDataScaleSlope() || mypapaya.series.images[k-1].getDataScaleIntercept() != mypapaya.series.images[k].getDataScaleIntercept())\n                {\n                    mustrescale = true;\n                    break\n                 }\n            }\n            if(mustrescale)\n            {\n\n                var numsamples = sx*sy*sz*st;\n                var samplesperslice = sx*sy;\n\n                var newbuffer = new Float32Array(numsamples)\n\n\n                var dataView = new DataView( mypapaya.imageData );\n                for (var k = 0; k < sz; k+=1) \n                {\n                    var slope = mypapaya.series.images[k].getDataScaleSlope();\n                    var inter = mypapaya.series.images[k].getDataScaleIntercept();\n\n                    for(var z=0; z<samplesperslice; z++)\n                    {\n                        var kk = (k*samplesperslice+z);\n                        if( datatype == 2 || datatype == 512 ) // uint 8/16\n                        {\n                            newbuffer[kk]= dataView.getUint16(kk*dcmnumBytes , littleEndian)*slope+inter;\n                        }\n                        else if(datatype == 256 || datatype == 4 ) // int 8/16\n                        {\n                            newbuffer[kk]= dataView.getInt16(kk*dcmnumBytes , littleEndian)*slope+inter;\n                        }\n                        else if( dcmdatatype == 4  ) // float\n                        {\n                            newbuffer[kk]= dataView.getFloat32(kk*dcmnumBytes , littleEndian)*slope+inter;\n                        }\n                    }\n                }\n\n                mypapaya.imageData = newbuffer.buffer;\n                datatype = 16;\n                slope = 1;\n                intercept = 0;\n            }\n\n            // SUVbw units\n            if(hh.gettag(\'Units\') == "BQML" )\n            {\n                if(hh.gettag(\'PatientWeight\')) \n                {\n                    // RadionuclideTotalDose in subgroup, take from tagsflat\n                    if(hh.tagsFlat["00181074"] && hh.tagsFlat["00181074"].value )\n                    {\n                        // formula for SUVbw\n                        var fac = parseInt(hh.gettag(\'PatientWeight\'))*1000 / parseInt(hh.tagsFlat["00181074"].value);\n                        //console.log(fac)\n                        slope*=fac;\n                    }\n\n                }\n\n            }\n\n                \n        }\n\n\n        view.setFloat32(112, slope,  littleEndian )\n        view.setFloat32(116, intercept,  littleEndian )\n       \n        view.setInt16(70, datatype, littleEndian) \n\n       \n       // combine the header and the imageData\n       var tmp = new Uint8Array(buffer.byteLength + mypapaya.imageData.byteLength);\n       tmp.set(new Uint8Array(buffer), 0);\n       tmp.set(new Uint8Array(mypapaya.imageData), buffer.byteLength);\n       \n       return {buffer:tmp , edges:edges_};\n    }\n\n\n    // function called  from the file manager\n    that.loadDicoms = function (params, callback)\n    {\n        // callback if a series was found. Build the nifti and send to callback\n        function whendone(tseries, error_report)\n        {\n            if(error_report !=undefined )\n            {\n                if(error_report.daikon !=undefined )\n                {\n                    alertify.error("Error when reading one or more DICOM files.")\n                }\n            }\n\n            if (tseries == undefined)\n            {\n                callback([]); \n                return;\n            }\n\n            var fobj = {};\n\t\t    fobj.URLType  = \'localfile\';\n            \n            var fpattern;\n            if (typeof projectInfo != "undefined" && projectInfo.jsondesc)\n                fpattern = projectInfo.jsondesc.filename_creation_pattern;\n            if (fpattern == undefined)\n                 fpattern = "/<ProtocolName>/<Modifier>s<seriesNumber><seriesSuffix>";\n\n            if (fpattern.substring(fpattern.length-3) == "nii")\n                fpattern = fpattern.substring(0,fpattern.length-4)\n\n            var outfi = that.mapFilePatternToName(fpattern, tseries)\n\n            /* replace evil characters in filename  \\W is alphanumeric + underscore \n               maybe this should be done on the filename only, to keep the true description?? \n               or maybe do it in on php move_uploaded_file?\n               */ \n            tseries.seriesDescription = tseries.seriesDescription.replace(/\\W/gi, ""); \n            tseries.ProtocolName      = tseries.ProtocolName.replace(/\\W/gi, ""); \n            var type = tseries.type || "nii";\n\n            var paths = outfi.substring(1).split("/");\n\n            fobj.filename = paths[paths.length-1] + "." +  type;\n            if (paths.length > 1)\n                 fobj.SubFolder = paths.splice(0,paths.length-1).join("/");\n\n            var fileinfo = {};\n            tseries.PatientID = tseries.PatientID || "noPatientID";\n\t\n\t           \n            fileinfo.patients_id = tseries.PatientID.replace(/[^a-zA-Z0-9]/g,"");\n            fileinfo.studies_id = "#"+tseries.StudyID.replace(/[^a-zA-Z0-9]/g,"");\n            var names = tseries.PatientName.split(" ")\n            fileinfo.FamilyName = names[0];\n            fileinfo.GivenName = names[1];\n            fileinfo.Sex = "N";\n            fileinfo.SeriesDescription = tseries.seriesDescription;\n            \n     \n            fobj.fileinfo = fileinfo;\n            fobj.fileID = \'localfile_\' + tseries.seriesInstanceUID ;\n            fobj.buffer = tseries.buffer;\n\n            var flist = [fobj];\n\n            function addonInfo(content,ext)\n            {\n                var fobj_add = $.extend({},fobj);\n                fobj_add.filename = fobj_add.filename.replace(".nii","." + ext)\n                fobj_add.buffer =content;\n                fobj_add.fileID += "_" + ext ;\n                flist.push(fobj_add);\n\n            }\n\n\n            if (tseries.diffusion)\n            {\n                addonInfo(tseries.bvec,"bvec");\n                addonInfo(tseries.bval,"bval");\n\n            }\n\n            if (typeof projectInfo != "undefined" && projectInfo.jsondesc && projectInfo.jsondesc.writeFilespec && projectInfo.dictionary)\n            {\n                  var bidsinfo = that.mapBidsInfo(tseries);                \n                  addonInfo(JSON.stringify(bidsinfo),\'json\');\n            }\n\n\n            if (callback)                 \n                callback(flist); \n            \n            if(dicomFileList[0] != undefined )\n                dicomFileList[0].progressSpinner();\n            \n\n\n\n            \n         } \n\n        if (params.length ==0)\n        {\n            callback([]);\n            return false;\n        }\n            \n        if (params[0].progressSpinner)\n            params[0].progressSpinner(\'Checking dicom files ...\');\n\n        dicomFileList = that.checkForDicomData(params);\n        if(dicomFileList.length == 0)\n        {\n            if (params[0].progressSpinner)\n                params[0].progressSpinner();\n            callback([]);\n            return;\n        }\n\n\n        dicomFileList[0].progressSpinner(\'Converting dicoms ...\');\n        readMultiFiles(dicomFileList, whendone,dicomFileList[0].progressSpinner );\n    }\n\n\n\n    // simply filter dicom extensions from file param list and return the file entries\n    that.checkForDicomData =  function(params) \n    {\n\n            var dicomList = [];\n\t\t\tvar exts = [\'dcm\',\'DCM\',\'ima\',\'IMA\',"rda"];\t\n            for(var k=0;k<params.length;k++)\n            {\n                if(params[k].filename)\n                {            \n                    for(var j=0;j<exts.length;j++)\n                    {\n                        if(params[k].filename.search("\\\\." + exts[j] ) > -1 ||  params[k].filename.search(/\\./) == -1 )  // allow also dicoms with no extension! \n                        {\n                             dicomList.push( params[k] );\n                             break;\n                        }\n                    }\n                }\n            }\n            return dicomList;\n    }\n   \n\n\n\n\n\n\n\n    that.mapBidsInfo = function(item)\n    {\n\n          var res = {}\n          try{\n            var img = item.daikonseries.images[0]\n          }\n          catch(err)\n          {\n              return  {msg:"no valid header"};\n          }\n\n          function mapit(s)\n          {         \n              for (var k in s)\n              {\n                  res[k] = img.gettag(s[k]);             \n                  if (res[k] == undefined)\n                  {\n                    var r = img.tags[s[k]];\n                    if (r != undefined)\n                      r = r.value;\n                    if (r != undefined && r.length > 0)\n                      res[k] = r[0]\n                  }\n              }\n          }\n\n          var dictionary = projectInfo.dictionary;\n          if (dictionary == undefined)\n            return {msg:"no info"};\n\n          var imageAttributes = dictionary.imageAttributes;\n\n          var t = that.map2BIDS(item);\n\n\n          mapit(imageAttributes.common);\n          if (t.modality != undefined)\n            mapit(imageAttributes[t.modality]);\n\n\n          return res;\n\n    }\n\n    that.map2BIDS =function(item)\n    {\n\n          var dictionary = projectInfo.dictionary;\n          if (dictionary == undefined)\n            return {folder:"dictFolderUNDEFINED",modality:"dictModalityUNDEFINED"}\n\n              var keys = Object.keys(dictionary.series_map);\n\n                  var found = undefined;\n                  for (var k = 0; k < keys.length;k++)\n                  {\n                      if (dictionary.series_map[keys[k]] == "true")\n                      {\n                         return {folder:"misc",modality:item.ProtocolName} \n                      }\n                      else                  \n                      {\n\n                        var mods = Object.keys(dictionary.series_map[keys[k]]);\n                        for (var l = 0; l < mods.length;l++)\n                        {\n\n                          var tags = Object.keys(dictionary.series_map[keys[k]][mods[l]]);\n                          if (keys[k] == "dti" && item.diffusion != false)\n                             found = true;\n                          else\n                          {\n                            for (var j = 0; j < tags.length;j++)\n                            { \n                                if (item[tags[j]])\n                                {\n                                    var pats = dictionary.series_map[keys[k]][mods[l]][tags[j]];\n                                    for (var i = 0; i < pats.length;i++)\n                                    {\n                                       if (item[tags[j]].search(pats[i]) > -1)\n                                       {\n                                          found = true;\n                                          break;\n                                       }\n                                    }\n                                    if (found)\n                                      break\n                                }\n                            }\n                          }\n                          if (found)\n                            break\n\n                        }\n                      }\n                      if (found != undefined)\n                      {\n                        return {folder:keys[k],modality:mods[l]};\n                      }\n                  }\n        return {folder:"bids_folder_undefined",modality:"bids_modality"}\n\n      }\n\n\n    that.mapFilePatternToName = function(fileName_pattern, item,outpath)\n    {\n\n               if (fileName_pattern == \'FILENAME\')\n               {\n                  var fname = path.basename(item.filepath)       ;\n                  fname = fname.replace("\\.dcm","");\n                  fname = fname.replace("\\.DCM","");\n                  fname = fname.replace("\\.ima","");\n                  fname = fname.replace("\\.IMA","");\n                  fname =  fname.replace(/\\./g,"");\n                  outfile = fullfile([outpath,fname+".nii"]);\n                  console.log(\'srcfilename used:\' + outfile);\n               }    \n               else\n               {\n                   // generate filename\n\n                  item[\'seriesDescription\'] = item[\'seriesDescription\'].replace(/[^\\w\\-]/gi, "_")\n                  item[\'ProtocolName\']      = item[\'ProtocolName\'].replace(/[^\\w\\-]/gi, "_")   \n                  item[\'seriesDescription\'] = item[\'seriesDescription\'].replace(/[\\_]+/g, "_")\n                  item[\'ProtocolName\'] = item[\'ProtocolName\'].replace(/[\\_]+/g, "_")                   \n                  item[\'Modifier\'] = item[\'seriesDescription\'].replace(item[\'ProtocolName\'],\'\');\n                  item[\'seriesDescription\'] =  item[\'seriesDescription\'].replace(item[\'Modifier\'],\'\');\n\n                   if (item[\'Modifier\'][0] == \'_\') \n                      item[\'Modifier\'] = item[\'Modifier\'].substring(1);\n                  if (item[\'Modifier\'] != "")\n                     item[\'Modifier\'] = item[\'Modifier\'] + "_";\n\n                  try {\n                      if (item.daikonseries.images[0].tags[\'00620002\'])\n                      {\n                          if (item.daikonseries.images[0].ktags.PointCoordinatesData)\n                          {\n                              item[\'Modifier\'] = item.daikonseries.images[0].tags[\'00620002\'].value[0].value[3].value \n                              item[\'ProtocolName\'] = "TCK"                  \n                          }\n                          else\n                          {\n                              item[\'Modifier\'] = item.daikonseries.images[0].tags[\'00620002\'].value[0].value[3].value  + "_mask_"\n                              item[\'ProtocolName\'] = "SEG"                  \n                          }\n                      }}\n                  catch(err) {}\n\n\n                  if (item[\'seriesNumber\'])\n                    item[\'seriesNumber\'] =  ("00000" + item[\'seriesNumber\']).slice(-3);\n\n                  if (item[\'seriesSuffix\'])\n                    item[\'seriesNumber\'] +=  item[\'seriesSuffix\'];\n\n                  var matches = fileName_pattern.match(/\\<\\w+\\>/g);\n                  var fname = fileName_pattern;\n                  if (matches != undefined)\n                      for (var j = 0; j < matches.length; j++)\n                      {\n                         var key = matches[j].substr(1,matches[j].length-2);\n                         if (key == "DICTfolder")\n                         {\n                             fname = fname.replace(matches[j],that.map2BIDS(item).folder) ;\n                         }\n                         else if (key == "DICTmodality")\n                         {\n                             fname = fname.replace(matches[j],that.map2BIDS(item).modality) ;\n                         }\n                         else if (item[key] == undefined)\n                         {\n                              console.warn(key + " is undefined for " + item.filepath );\n                              fname = fname.replace(matches[j],\'undefined\');\n                         }\n                         else\n                              fname = fname.replace(matches[j],item[key]);\n                      }\n\n                  if (outpath != undefined)\n                        outfile =  fullfile([outpath,fname]);\n                  else\n                        outfile = fname\n                \n                  outfile =  outfile.replace(/\\ /g,"_");\n\n              }\n              return outfile;\n    }\n\n\n\n\n\n\n    that.dicom2nii = dicom2nii;\n    return that;\n\n}\n\n\n//  static function pre - check for dicom files in a dropped List / folder.\n// DicomReader.checkForDicomData = function (params) \n// {\n\n//             var dicomList = [];\n//             for(var k=0;k<params.length;k++)\n//             {\n//                 if(params[k].filename)\n//                 {\n//                     if(params[k].filename.search(".dcm") > -1) // \n//                          dicomList.push( params[k].file );\n//                 }\n//             }\n\n//             if(dicomList.length > 0)\n//                 return  dicomList;\n//             else\n//                 return ; // \n// }\n\n\n\nfunction roughSizeOfObject( object ) {\n\n    var objectList = [];\n\n    var recurse = function( value )\n    {\n        var bytes = 0;\n\n        if ( typeof value === \'boolean\' ) {\n            bytes = 4;\n        }\n        else if ( typeof value === \'string\' ) {\n            bytes = value.length * 2;\n        }\n        else if ( typeof value === \'number\' ) {\n            bytes = 8;\n        }\n        else if\n        (\n            typeof value === \'object\'\n            && objectList.indexOf( value ) === -1\n        )\n        {\n            objectList[ objectList.length ] = value;\n\n            for( i in value ) {\n                bytes+= 8; // an assumed existence overhead\n                bytes+= recurse( value[i] )\n            }\n        }\n\n        return bytes;\n    }\n\n    return recurse( object );\n}\n\n\nfunction dicomParseReport(tag)\n{\n    /*    \n    codepieces to parse to content of a dicom REPORT (SR) file\n    from AGFA IMPAX dicom images\n\n\n    "0040" : // Report\n    {                  \n        "A730" : ["SQ", "REPORT"],\n    },\n\n\n\n     dumpTag(image.ktags[\'REPORT\']);\n\n    */\n\n\n\n    var html = "";\n\n    if(Array.isArray(tag.value))\n    {\n        for(var k=0;k<tag.value.length; k++)\n        {\n            dumpTag(tag.value[k]);\n        }\n    }\n    else\n    {\n        var tagstring = (daikon.Utils.dec2hex(tag.group))+\',\'+ (daikon.Utils.dec2hex(tag.element));\n        var val =  arrayBufferToString(tag.value.buffer);\n\n        // 0040,0043 and value contains AGFA4ISOFT --\x3e sectionTitle\n        // 0040,A050 --\x3e separator\n        // 0040,A160 --\x3e text\n\n        if(tagstring == \'0040,0042\') // title\n        {\n            var str = val.split(\'AGFA4ISOFT\');\n            html += "<hr>";\n            html += "<div class=\'\'>" + str[1] + "</div>";\n        }\n        if(tagstring == \'0040,A050\') // sep\n        {\n            \n        }\n        if(tagstring == \'0040,A160\') // content\n        {\n            html += "<div class=\'\'>" + val + "</div>";\n            \n        }\n    }\n\n    function arrayBufferToString(buffer)\n    {\n        var arr = new Uint8Array(buffer);\n        var str = String.fromCharCode.apply(String, arr);\n        return str;\n    }\n\n\n    console.log(html);\n    return html;\n\n}\n\n\nfunction treeifyTagStruct(tag)\n{\n\n    if (tag.value != undefined)\n    {\n        if (Array.isArray(tag.value))\n        {\n            if (tag.value.length == 0 )\n                return \n            if (tag.value[0].key == undefined)\n            {\n                if (tag.value.length == 1)\n                    return tag.value[0]\n                else\n                    return tag.value;\n            }\n            else\n            {\n                var tree = {};\n                for (var k = 0; k < tag.value.length;k++)\n                {\n                    if (tag.value[k].key !=undefined)\n                    {\n                        var key;\n                        if (tag.value[k].key == "PrivateData")\n                            key = tag.value[k].id;\n                        else\n                            key = tag.value[k].key;\n                        var val = treeifyTagStruct(tag.value[k]);\n                        if (tree[key] == undefined)\n                            tree[key] = val;\n                        else\n                        {\n                            var sup = tree[key];\n                            if (Array.isArray(sup))\n                                sup.push(val);\n                            else\n                            {\n                                var arr = [];\n                                arr[0] = sup;\n                                arr[1] = val;\n                                tree[key] = arr;\n                            }\n\n                        }\n                    }\n                    else\n                        return tag.value[k];\n                }\n                return tree;\n            }\n        }\n        else\n            return treeifyTagStruct(tag.value);\n            \n    }\n    else \n        return tag;\n    \n}\n\n\nfunction prepareRTstruct(item)\n{\n\n    var x = [];\n    for (var k = 0 ; k < item.daikonseries.images.length; k++)\n    {\n        try {\n            var rt =treeifyTagStruct(item.daikonseries.images[k].ktags.ROIContourSequence).node\n            var names = item.daikonseries.images[k].ktags.ROIName\n            for (var j = 0; j < rt.length; j++)\n            {\n                rt[j].name = names.multival[j][0]\n            }\n\n            x = x.concat(rt);\n        }\n        catch (err) {\n            err;\n\n        }\n    }\n   \n\n\n    var bbox_min_glob = [Infinity,Infinity,Infinity];\n    var bbox_max_glob = [-Infinity,-Infinity,-Infinity];\n\n    for (var k = 0; k < x.length; k++)\n    {\n       var c = x[k].ContourSequence.node;\n       for (var j = 0; j < c.length; j++)\n       {\n           var l = c[j].ContourData;\n           var len = l.length/3;\n           var bbox_min = [Infinity,Infinity,Infinity];\n           var bbox_max = [-Infinity,-Infinity,-Infinity];\n           for (var i = 0;i < len;i++)\n           {\n              // l[3*i+2] -= 1600;\n               for (var r = 0; r < 3;r++)\n               {\n                  bbox_min[r] = Math.min(l[3*i+r],bbox_min[r]);\n                  bbox_max[r] = Math.max(l[3*i+r],bbox_max[r]);\n               }\n           }\n           c[j].bbox_min  = bbox_min;\n           c[j].bbox_max  = bbox_max;\n\n\n           for (var r = 0; r < 3;r++)\n           {\n              bbox_min_glob[r] = Math.min( bbox_min_glob[r],bbox_min[r]);\n              bbox_max_glob[r] = Math.max( bbox_max_glob[r],bbox_max[r]);\n           }\n\n       }\n    }\n\n    x.min = bbox_min_glob;\n    x.max = bbox_max_glob;\n\n    return {min:bbox_min_glob,max:bbox_max_glob,Contours:x };\n\n}\n\n\nsform2quaternion = function(mat)\n{\n \n   var vox = [ (math.norm([mat._data[0][0],mat._data[1][0],mat._data[2][0] ])),\n               (math.norm([mat._data[0][1],mat._data[1][1],mat._data[2][1] ])),\n               (math.norm([mat._data[0][2],mat._data[1][2],mat._data[2][2] ])),1];\n   var ivox = [1/vox[0],1/vox[1],1/vox[2],1]\n   var R = math.inv(math.multiply(mat,math.diag(ivox)));\n\n   var sign = Math.sign(math.det(R));\n\n   R = math.multiply(math.diag([1, 1, sign, 1]),R);\n\n   var Rxx = R._data[0][0];\n   var Rxy = R._data[0][1];\n   var Rxz = R._data[0][2];\n   var Ryx = R._data[1][0];\n   var Ryy = R._data[1][1];\n   var Ryz = R._data[1][2];\n   var Rzx = R._data[2][0];\n   var Rzy = R._data[2][1];\n   var Rzz = R._data[2][2];\n   var trace = Rxx+Ryy+Rzz;\n\n\n   var w = 0;\n   if (trace+1 > 0)\n      w = Math.sqrt( trace + 1 ) / 2;\n\n   var x = Math.sqrt( 1 + Rxx - Ryy - Rzz ) / 2;\n   var y = Math.sqrt( 1 + Ryy - Rxx - Rzz ) / 2;\n   var z = Math.sqrt( 1 + Rzz - Ryy - Rxx ) / 2;\n\n\n   if (w >= x && w >= y && w >= z)\n   {\n        x = ( Rzy - Ryz ) / (4*w);\n        y = ( Rxz - Rzx ) / (4*w);\n        z = ( Ryx - Rxy ) / (4*w);\n   }\n\n   if (x >= w && x >= y && x >= z)\n   {\n        w = ( Rzy - Ryz ) / (4*x);\n        y = ( Rxy + Ryx ) / (4*x);\n        z = ( Rzx + Rxz ) / (4*x);\n   }\n\n   if (y >= w && y >= x && y >= z)\n   {\n        w = ( Rxz - Rzx ) / (4*y);\n        x = ( Rxy + Ryx ) / (4*y);\n        z = ( Ryz + Rzy ) / (4*y);\n   }\n\n   if (z >= w && z >= x && z >= x)\n   {\n        w = ( Ryx - Rxy ) / (4*z);\n        x = ( Rzx + Rxz ) / (4*z);\n        y = ( Ryz + Rzy ) / (4*z);\n   }\n   var eps = 0.0000000001;\n\n   var quatern_b = -x * Math.sign(w-eps);\n   var quatern_c = -y * Math.sign(w-eps);\n   var quatern_d = -z * Math.sign(w-eps);   \n\n   var qquat = { q: [quatern_b,quatern_c,quatern_d],\n            pixdim: [sign,vox[0],vox[1],vox[2]] };\n\n/*\nvar q = qquat.q\nvar a = Math.sqrt(Math.max(0.0,1.0-(q[0]*q[0]+q[1]*q[1]+q[2]*q[2])));\nvar b = q[0];\nvar c = q[1];\nvar d = q[2];\nvar pixdim = qquat.pixdim;\nvar qfac = pixdim[0];\n   var a = Math.sqrt(Math.max(0.0,1.0-(b*b+c*c+d*d)))\n  var e = [\n      [pixdim[1]*(a*a+b*b-c*c-d*d),pixdim[1]*(2*b*c+2*a*d),pixdim[1]*(2*b*d-2*a*c)],\n      [pixdim[2]*(2*b*c-2*a*d),pixdim[2]*(a*a+c*c-b*b-d*d),pixdim[2]*(2*c*d+2*a*b)],\n      [qfac*pixdim[3]*(2*b*d+2*a*c),qfac*pixdim[3]*(2*c*d-2*a*b),qfac*pixdim[3]*(a*a+d*d-c*c-b*b)]]\n\nconsole.log(print_matrix(e));\n*/\n\n\n   return qquat;\n}\n\n\nfunction merge_series()\n{\n\t/* \n\t\tmerge series based on some tag expressions\n\t\texample: \n\t\t\tASL Hadamard: Must even merge only a subset of series\n\t\t\tFlatpanel CT\n\t\t\n\t\tGlue all series with same tags (or same up to an increment) together\n\t\t\tneed a mapping for correct AcquisitionTime, ContentTime etc. \n\t\t\tWhere to define?\n\n\t\t\tSELECT SeriesGroups having SAME(SeriesDescription*, ProtocolName*) SELECT 2:end ORDER by SeriesTime, WHERE DIFF(SeriesTime) < 5sec\n\n\t\tOnly select groups with n>1\n\t\t\t\n\t\tCheck if can be glued (same spatiel orientation + image matrix) \n\n\n\t\ta) need some regexp\n\t\t\tVPCT 5.0  1\n\t\t\tVPCT 5.0  2\n\t\t\tVPCT 5.0  3\n\t\tb) maybe should not glue all of them. \n\t\t\tA range?  1:end-2 or 2:end for hadamard (need also a sortorder then)\n\t\t\tSome time logic?\n\t\t \t\t\n\t\t\n\t\t=> SeriesDescription="SAME"\t\n\t\t \n\t*/\n\n\n\n}\n\n'},function(t,n,e){(n=e(3)(!1)).push([t.i,".alertify,\n.alertify-show,\n.alertify-log {\n\t-webkit-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1.275);\n\t   -moz-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1.275);\n\t    -ms-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1.275);\n\t     -o-transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1.275);\n\t        transition: all 500ms cubic-bezier(0.175, 0.885, 0.320, 1.275); /* easeOutBack */\n}\n.alertify-hide {\n\t-webkit-transition: all 250ms cubic-bezier(0.600, -0.280, 0.735, 0.045);\n\t   -moz-transition: all 250ms cubic-bezier(0.600, -0.280, 0.735, 0.045);\n\t    -ms-transition: all 250ms cubic-bezier(0.600, -0.280, 0.735, 0.045);\n\t     -o-transition: all 250ms cubic-bezier(0.600, -0.280, 0.735, 0.045);\n\t        transition: all 250ms cubic-bezier(0.600, -0.280, 0.735, 0.045); /* easeInBack */\n}\n.alertify-log-hide {\n\t-webkit-transition: all 500ms cubic-bezier(0.600, -0.280, 0.735, 0.045);\n\t   -moz-transition: all 500ms cubic-bezier(0.600, -0.280, 0.735, 0.045);\n\t    -ms-transition: all 500ms cubic-bezier(0.600, -0.280, 0.735, 0.045);\n\t     -o-transition: all 500ms cubic-bezier(0.600, -0.280, 0.735, 0.045);\n\t        transition: all 500ms cubic-bezier(0.600, -0.280, 0.735, 0.045); /* easeInBack */\n}\n.alertify-cover {\n\tposition: fixed; z-index: 99999;\n\ttop: 0; right: 0; bottom: 0; left: 0;\n\tbackground-color:white;\n\tfilter:alpha(opacity=0);\n\topacity:0;\n}\n\t.alertify-cover-hidden {\n\t\tdisplay: none;\n\t}\n.alertify {\n\tposition: fixed; z-index: 99999;\n\ttop: 50px; left: 50%;\n\twidth: 550px;\n\tmargin-left: -275px;\n\topacity: 1;\n}\n\t.alertify-hidden {\n\t\t-webkit-transform: translate(0,-150px);\n\t\t   -moz-transform: translate(0,-150px);\n\t\t    -ms-transform: translate(0,-150px);\n\t\t     -o-transform: translate(0,-150px);\n\t\t        transform: translate(0,-150px);\n\t\topacity: 0;\n\t\tdisplay: none;\n\t}\n\t/* overwrite display: none; for everything except IE6-8 */\n\t:root *> .alertify-hidden {\n\t\tdisplay: block;\n\t\tvisibility: hidden;\n\t}\n.alertify-logs {\n\tposition: fixed;\n\tz-index: 5000;\n\tbottom: 10px;\n\tright: 10px;\n\twidth: 300px;\n\tpointer-events:none;\n\t\n}\n.alertify-logs-hidden {\n\tdisplay: none;\n}\n\t.alertify-log {\n\t\tdisplay: block;\n\t\tmargin-top: 10px;\n\t\tposition: relative;\n\t\tright: -300px;\n\t\topacity: 0;\n\t}\n\t.alertify-log-show {\n\t\tright: 0;\n\t\topacity: 1;\n\t}\n\t.alertify-log-hide {\n\t\t-webkit-transform: translate(300px, 0);\n\t\t   -moz-transform: translate(300px, 0);\n\t\t    -ms-transform: translate(300px, 0);\n\t\t     -o-transform: translate(300px, 0);\n\t\t        transform: translate(300px, 0);\n\t\topacity: 0;\n\t}\n\t.alertify-dialog {\n\t\tpadding: 25px;\n\t}\n\t\t.alertify-resetFocus {\n\t\t\tborder: 0;\n\t\t\tclip: rect(0 0 0 0);\n\t\t\theight: 1px;\n\t\t\tmargin: -1px;\n\t\t\toverflow: hidden;\n\t\t\tpadding: 0;\n\t\t\tposition: absolute;\n\t\t\twidth: 1px;\n\t\t}\n\t\t.alertify-inner {\n\t\t\ttext-align: center;\n\t\t}\n\t\t.alertify-text {\n\t\t\tmargin-bottom: 15px;\n\t\t\twidth: 100%;\n\t\t\t-webkit-box-sizing: border-box;\n\t\t\t   -moz-box-sizing: border-box;\n\t\t\t        box-sizing: border-box;\n\t\t\tfont-size: 100%;\n\t\t}\n\t\t.alertify-buttons {\n\t\t}\n\t\t\t.alertify-button,\n\t\t\t.alertify-button:hover,\n\t\t\t.alertify-button:active,\n\t\t\t.alertify-button:visited {\n\t\t\t\tbackground: none;\n\t\t\t\ttext-decoration: none;\n\t\t\t\tborder: none;\n\t\t\t\t/* line-height and font-size for input button */\n\t\t\t\tline-height: 1.5;\n\t\t\t\tfont-size: 100%;\n\t\t\t\tdisplay: inline-block;\n\t\t\t\tcursor: pointer;\n\t\t\t\tmargin-left: 5px;\n\t\t\t}\n\n@media only screen and (max-width: 680px) {\n\t.alertify,\n\t.alertify-logs {\n\t\twidth: 90%;\n\t\t-webkit-box-sizing: border-box;\n\t\t   -moz-box-sizing: border-box;\n\t\t        box-sizing: border-box;\n\t}\n\t.alertify {\n\t\tleft: 5%;\n\t\tmargin: 0;\n\t}\n}\n",""]),t.exports=n},function(t,n,e){(n=e(3)(!1)).push([t.i,"/**\n * Default Look and Feel\n */\n.alertify,\n.alertify-log {\n\tfont-family: sans-serif;\n\tcolor:black;\n}\n.alertify {\n\tbackground: #FFF;\n\tborder: 10px solid #333; /* browsers that don't support rgba */\n\tborder: 10px solid rgba(0,0,0,.7);\n\tborder-radius: 8px;\n\tbox-shadow: 0 3px 3px rgba(0,0,0,.3);\n\t-webkit-background-clip: padding;     /* Safari 4? Chrome 6? */\n\t   -moz-background-clip: padding;     /* Firefox 3.6 */\n\t        background-clip: padding-box; /* Firefox 4, Safari 5, Opera 10, IE 9 */\n}\n\n.alertify select {\nmargin:5px;\nmargin-bottom:20px;\nmargin-left:15px;\nmin-width:100px;\nwidth:auto;\nfont-size:16px;\n}\n\n\t.alertify-text {\n\t\tborder: 1px solid #CCC;\n\t\tpadding: 10px;\n\t\tborder-radius: 4px;\n\t}\n\t.alertify-button {\n\t\tborder-radius: 4px;\n\t\tcolor: #FFF;\n\t\tfont-weight: bold;\n\t\tpadding: 6px 15px;\n\t\ttext-decoration: none;\n\t\ttext-shadow: 1px 1px 0 rgba(0,0,0,.5);\n\t\tbox-shadow: inset 0 1px 0 0 rgba(255,255,255,.5);\n\t\tbackground-image: -webkit-linear-gradient(top, rgba(255,255,255,.3), rgba(255,255,255,0));\n\t\tbackground-image:    -moz-linear-gradient(top, rgba(255,255,255,.3), rgba(255,255,255,0));\n\t\tbackground-image:     -ms-linear-gradient(top, rgba(255,255,255,.3), rgba(255,255,255,0));\n\t\tbackground-image:      -o-linear-gradient(top, rgba(255,255,255,.3), rgba(255,255,255,0));\n\t\tbackground-image:         linear-gradient(top, rgba(255,255,255,.3), rgba(255,255,255,0));\n\t}\n\t.alertify-button:hover,\n\t.alertify-button:focus {\n\t\toutline: none;\n\t\tbackground-image: -webkit-linear-gradient(top, rgba(0,0,0,.1), rgba(0,0,0,0));\n\t\tbackground-image:    -moz-linear-gradient(top, rgba(0,0,0,.1), rgba(0,0,0,0));\n\t\tbackground-image:     -ms-linear-gradient(top, rgba(0,0,0,.1), rgba(0,0,0,0));\n\t\tbackground-image:      -o-linear-gradient(top, rgba(0,0,0,.1), rgba(0,0,0,0));\n\t\tbackground-image:         linear-gradient(top, rgba(0,0,0,.1), rgba(0,0,0,0));\n\t}\n\t.alertify-button:focus {\n\t\tbox-shadow: 0 0 15px #2B72D5;\n\t}\n\t.alertify-button:active {\n\t\tposition: relative;\n\t\tbox-shadow: inset 0 2px 4px rgba(0,0,0,.15), 0 1px 2px rgba(0,0,0,.05);\n\t}\n\t\t.alertify-button-cancel,\n\t\t.alertify-button-cancel:hover,\n\t\t.alertify-button-cancel:focus {\n\t\t\tbackground-color: #FE1A00;\n\t\t\tborder: 1px solid #D83526;\n\t\t}\n\t\t.alertify-button-ok,\n\t\t.alertify-button-ok:hover,\n\t\t.alertify-button-ok:focus {\n\t\t\tbackground-color: #5CB811;\n\t\t\tborder: 1px solid #3B7808;\n\t\t}\n\n.alertify-log {\n\tbackground: #1F1F1F;\n\tbackground: rgba(0,0,0,.9);\n\tpadding: 15px;\n\tborder-radius: 4px;\n\tcolor: #FFF;\n\ttext-shadow: -1px -1px 0 rgba(0,0,0,.5);\n}\n\t.alertify-log-error {\n\t\tbackground: #FE1A00;\n\t\tbackground: rgba(254,26,0,.9);\n\t}\n\t.alertify-log-success {\n\t\tbackground: #5CB811;\n\t\tbackground: rgba(92,184,17,.9);\n\t}",""]),t.exports=n},function(t,n,e){(n=e(3)(!1)).push([t.i,'\r\n/************* some important colors: ********************\r\n\r\n\r\n  BACKGROUNDS     \r\n      windowbackground  ::   darker color for backgrounds. \r\n             hsl(0, 0%, 22%);\r\n              \r\n             dialog_generic bg ...\r\n\r\n      patienttable background\r\n             hsl(0, 0%, 35%);\r\n\r\n    \r\n      bordercolor    \r\n             hsl(0,0%,60%)\r\n\r\n\r\n  MENUES\r\n      menucolor  :: main, standard some blue\r\n          #226699\r\n          hsl(206, 64%, 37%)\r\n      \r\n      submenucolor :: main menu, sub menu, standard some gray\r\n          #F0F0FF   old\r\n          hsl(0,0%,90%)\r\n      \r\n      submenucolor_hover\r\n          hsl(0,0%,70%)\r\n\r\n\r\n      menucolor_context\r\n          F0F0FF\r\n\r\n\r\n   SHADOWS\r\n      boxshadow\r\n         box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); \r\n\r\n\r\n\r\n**************************************************************/\r\n\r\n\r\n\r\n\r\nbody.wait, body.wait *{\r\n    cursor: wait !important;   \r\n}\r\n\r\ntextarea\r\n{\r\n  tab-size:4;\r\n}\r\n\r\n.Kjobinfo\r\n{\r\n  position:absolute;\r\n  padding:0px;\r\n  top:100px;\r\n  left:100px;\r\n  z-index:99999999;\r\n  color:black;\r\n  opacity:1;\r\n  max-height:60%;\r\n  max-width:60%;\r\n  overflow:hidden;\r\n\r\n  width:60%;\r\n  height:60%;\r\n  left:20%;\r\n  top:20%;\r\n  border:5px solid;\r\n  border-color: hsl(0,0%,50%);\r\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/ \r\n  background:white;\r\n  \r\n  fdisplay:flex;\r\n  fflex-direction:column;\r\n\r\n\r\n  -webkit-touch-callout: text;/* iOS Safari */\r\n  -webkit-user-select: text;/* Chrome/Safari/Opera */\r\n  -khtml-user-select: text;/* Konqueror */\r\n  -moz-user-select: text;/* Firefox */\r\n  -ms-user-select: text;/* IE/Edge */\r\n  user-select: text;\r\n}\r\n\r\n.Kjobinfo .Kjobinfo_title\r\n{\r\n  display:inline-block;\r\n  font-weight:bold;\r\n  color:black;\r\n  border:1.5px solid #777;\r\n  \r\n  background:hsl(0,0%,90%);\r\n  padding:2px 2px 2px;\r\n  margin:3px;\r\n  cursor:pointer;\r\n  box-shadow: 2px 2px 2px #999;\r\n  border-radius:3px;\r\n\r\n  min-width:150px !important;\r\n}\r\n\r\n.Kjobinfo .Kjobinfo_title.selected\r\n{\r\n   background-color:yellow;\r\n   box-shadow: 0px 0px 0px; \r\n  \r\n}\r\n\r\n.Kjobinfo .Kjobinfo_title:hover\r\n{\r\n   background-color:yellow;\r\n}\r\n\r\n\r\n\r\n.Kjobinfo .fa:hover\r\n{\r\n    background-color:#113355; /*highlight*/\r\n\r\n}\r\n\r\n.Kjobinfo .fa\r\n{\r\n  position:absolute;\r\n  padding:3px;\r\n  top:0%;  \r\n  right:0%;\r\n  width:20px;\r\n  height:20px;\r\n  line-height:20px;\r\n  text-align:center;\r\n  background:green;\r\n  color:white;\r\n  z-index:9999999999;\r\n  background:#226699; /*menucolor*/\r\n}\r\n\r\n.Kjobinfo .fa-spinner\r\n{\r\n  background:red;\r\n  top:50%;\r\n  left:50%;\r\n  font-size:50px;\r\n  width:50px;;\r\n  height:50px;\r\n  line-height:50px;\r\n  color:black;\r\n  border-radius:20px;\r\n  background: rgba(168,168,168,.3);\r\n\r\n}\r\n\r\n\r\n.Kjobinfo .fa-refresh\r\n{\r\n  right:30px;\r\n}\r\n\r\n\r\n.KjobinfoContent\r\n{\r\n  _position:absolute;  \r\n  overflow:auto;  \r\n  width:100%;\r\n  height:calc(100% - 30px);\r\n}\r\n\r\n\r\n\r\nbody  a\r\n{\r\n  text-decoration:none;\r\n  color: black;\r\n}\r\n\r\nbody  a:visited\r\n{\r\n  text-decoration:none;\r\n  color: black;\r\n}\r\n\r\nbody  a:hover\r\n{\r\n  text-decoration:none;\r\n}\r\n\r\n\r\n\r\n.KTreeSymbol\r\n{\r\n  \r\n}\r\n\r\n.KTreeExpander\r\n{\r\n  \r\n}\r\n.KTreeExpander:hover\r\n{\r\n  \r\n}\r\n\r\n\r\n.KCheckBox\r\n{\r\n  dmargin-top:5px;\r\n  spadding: 2px 4px 2px 4px;\r\n}\r\n\r\n#frame\r\n{\r\n  display:block;\r\n  position: absolute;\r\n  top:0;\r\n  left: 0;\r\n  color:none;\r\n  width: 100%;\r\n  height: 100%;\r\n  padding: 38px 0px 0px 0px ;\r\n  border: 0px solid green;\r\n  -webkit-box-sizing: border-box;\r\n  -moz-box-sizing: border-box;\r\n  box-sizing: border-box;\r\n\r\n}\r\n\r\n#container\r\n{\r\n  -webkit-box-sizing: border-box;\r\n  -moz-box-sizing: border-box;\r\n  box-sizing: border-box;\r\n  display: table;\r\n  position:relative;\r\n  background-color: none;\r\n  z-index:1;\r\n  color: white;\r\n  width: 100%;\r\n  max-width: 100%;\r\n  height: auto;\r\n  margin:auto;\r\n  border: 0px solid #949494;\r\n  border-collapse: collapse;\r\n  overflow:hidden;\r\n}\r\n\r\n\r\n#myKView\r\n{\r\n  position:absolute;\r\n\r\n  top:0px;\r\n}\r\n\r\n.containerDIV\r\n{\r\n  display: table-cell;\r\n  margin:0;\r\n  padding:0;\r\n  width:20%;\r\n  height: 100%;\r\n\r\n  vertical-align:top;\r\n  white-space: nowrap;\r\n  border: 0px solid;\r\n  border-collapse: collapse;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n.localfiletable\r\n{\r\n  color:white;\r\n  __overflow:scroll;\r\n  cursor:default;\r\n  __width:10px;\r\n  border-collapse:collapse;\r\n  position:relative;\r\n\r\n}\r\n\r\n.localfiletable .dummymessage\r\n{\r\n  margin:15px;\r\n  font-size:16px;\r\n  line-height:19px;\r\n}\r\n\r\n.localfiletable.tablelayoutfixed\r\n{\r\n  table-layout:fixed;  \r\n\r\n}\r\n\r\n.localfiletable td \r\n{\r\n  border: 1px solid #BBB;\r\n  padding-left:8px;\r\n  padding-right:1px;\r\n  vertical-align:middle;\r\n  box-sizing: border-box;\r\n  text-overflow:ellipsis;\r\n  overflow:hidden;\r\n  white-space:nowrap;\r\n  position:relative;\r\n\r\n}\r\n.localfiletable td > div\r\n{\r\n  position:absolute;\r\n  top:1px;\r\n   \r\n}\r\n\r\n.localfiletable i\r\n{\r\n\r\n  margin-left:-5px !important;  \r\n  _margin-right:-3px;\r\n  padding:1px 1px 1px 0px;\r\n  display:inline-flex;\r\n  align-items:center;\r\n  justify-content:center; \r\n  text-align:left;\r\n}\r\n\r\n.localfiletable .tablebutton\r\n{\r\n  border-radius:4px;\r\n  background:linear-gradient(to top left, #113355, #4466AA); /*toolbutton*/\r\n  color:#BBB;\r\n\r\n}\r\n\r\n\r\n.localfiletable .tablebutton.selected\r\n{\r\n  border-radius:4px;\r\n  background:yellow;\r\n  border:1px solid black;\r\n  color:black;\r\n  border-collapse:collapse;  \r\n}\r\n\r\n\r\n.localfiletable .tablebutton:hover\r\n{\r\n  background:#AAAAAA;\r\n  color:black;\r\n}\r\n\r\n\r\n.localfiletable i:hover\r\n{\r\n  color:hsl(0,0%,40%);\r\n}\r\n\r\n.localfiletable .fa-close\r\n{\r\n  ccolor:black;    \r\n}\r\n\r\n.localfiletable .fa-close:hover\r\n{\r\n  color:red;    \r\n}\r\n\r\n\r\n.localfiletable tr \r\n{\r\n  background:hsl(0,0%,95%);\r\n  color:black;\r\n \r\n}\r\n.localfiletable tr:hover\r\n{\r\n  background:hsl(0,0%,90%);\r\n}\r\n\r\n.localfiletable tr.modified\r\n{\r\n  background:#B00;\r\n  color:white;\r\n}\r\n\r\n\r\n.localfiletable tr.selected\r\n{\r\n  color:black; \r\n  background:hsl(60, 100%, 90%);\r\n}\r\n.localfiletable tr.selected:hover\r\n{\r\n   background:hsl(60, 50%, 88%);\r\n}\r\n\r\n.localfiletable tr.islandrow\r\n{\r\n  font-style:italic;\r\n  color:rgb(50,50,50) ;\r\n}\r\n\r\n.opthide\r\n{ \r\n  display:none;\r\n}\r\n\r\n.localfiletable tr.current\r\n{\r\n  color:black; \r\n  background:hsl(10, 100%, 90%) !important;\r\n}\r\n\r\n.localfiletable tr.selectedGray\r\n{\r\n  color:#113355; /*highlight*/\r\n  __font-weight:bold;\r\n}\r\n\r\n.localfiletable thead tr\r\n{\r\n  dborder:7px solid green;\r\n}\r\n\r\n.localfiletable thead tr td\r\n{\r\n  background:#404055; /*tablehead*/\r\n  color:white;\r\n  cursor:inherit;\r\n  position:relative;\r\n  /* this does the trick with disapparing border in relative position */\r\n  border: 1px solid hsl(0,0%,0%);\r\n  padding-left:9px;\r\n  _-border-bottom: 1px solid hsl(0,0%,60%);\r\n  gbox-shadow: inset 1px 1px 0px  0px hsl(0,0%,60%);\r\n\r\n\r\n}\r\n\r\n.localfiletable tbody select\r\n{\r\n  width:100%;\r\n  margin:0px 0px 0px -4px;\r\n  background:none;\r\n}\r\n\r\n.localfiletable tbody input[type=\'checkbox\']\r\n{\r\n  margin:1px 1px 1px 4px;\r\n}\r\n\r\n\r\n.localfiletable td.fixedwidth\r\n{\r\n  text-overflow:clip;\r\n  /*\r\n  width:auto;\r\n  padding:0px;\r\n  text-align: center;\r\n  vertical-align:middle;\r\n  */\r\n}\r\n\r\n\r\n\r\n#KJobinfoTooltip\r\n{\r\n  position:absolute;\r\n  z-index:9999;\r\n  background:yellow;\r\n  color:black;\r\n}\r\n\r\n\r\n#MetaKeySearch > .keydiv\r\n{\r\n  \r\n  position:relative;\r\n  width:100%;\r\n  height:200px !important; \r\n  overflow:scroll;\r\n  background:hsl(0,0%,62%)!important;\r\n  text-align:left;\r\n  border:1px solid black;\r\n  margin-bottom:10px;\r\n}\r\n\r\n#MetaKeySearch > .buttondiv\r\n{\r\n  height:40px;\r\n  position:relative;\r\n  margin:4px;\r\n  text-align:left;\r\n\r\n}\r\n\r\n#MetaKeySearch > .buttondiv  input\r\n{\r\n  width:50px;\r\n}\r\n#MetaKeySearch > .buttondiv  span\r\n{\r\n  padding-right:30px;\r\n}\r\n\r\n\r\n#MetaKeySearch > .buttondiv  .fa\r\n{\r\n  background:gray;\r\n  padding:4px;\r\n  margin-right:5px;\r\n  border-radius:4px;\r\n  border: 1px solid hsl(0,0%,0%);\r\n  color:white;\r\n  box-shadow: 2px 1px 1px #888;\r\n    \r\n}\r\n\r\n#MetaKeySearch > .buttondiv > .fa:hover\r\n{\r\n  background:lightgray;  \r\n  box-shadow: 2px 1px 1px #888;\r\n  color:black;\r\n\r\n}\r\n\r\n\r\n\r\n#MetaKeySearch div.selected\r\n{\r\n  background:lightblue;\r\n}\r\n\r\n\r\n\r\n/* the main (file) search bar */\r\n.KSearchFieldContainer \r\n{\r\n  position: relative;\r\n  display:flex;\r\n  background:hsl(0,0%,62%)!important;\r\n}\r\n\r\n.KSearchField_filterList\r\n{\r\n  _width:27px;\r\n  height:22px;\r\n  width:100%;\r\n  display:flex;\r\n  align-items:center;\r\n  justify-content:center; \r\n  margin:1px 0px 1px 0px;\r\n  cursor: default;\r\n}\r\n\r\n\r\n.KSearchField_filterList  > ul\r\n{\r\n  visibility:hidden;\r\n  opacity:0;\r\n  transition:visibility  ease-in 0.3s,opacity 0.3s ease-in;\r\n}\r\n\r\n.KSearchField_filterList:hover  > ul\r\n{\r\n   /*display:block;*/\r\n   visibility:visible;\r\n   opacity:1;\r\n   transition-delay:0.2s;\r\n}\r\n\r\n.KSearchField_filterList  > ul > li > span\r\n{\r\n   overflow:hidden;\r\n   text-overflow:ellipsis;\r\n   max-width:300px;\r\n}\r\n\r\n.KSearchField_filterList  > ul > li  > span > span:nth-child(2)\r\n{\r\n  display:inline-block;\r\n}\r\n\r\n.KSearchField_filterList > i\r\n{\r\n  font-size:15px;\r\n  __color:white;\r\n}\r\n\r\n\r\n\r\n#KSearchFieldGeneral\r\n{\r\n  width: 100%;\r\n  height: 24px;\r\n  flex-grow:1;\r\n  ddisplay:flex;\r\n  position: relative;\r\n}\r\n\r\n.KSearchFieldGeneral_after\r\n{\r\n  position:absolute;\r\n  right:0px;\r\n  width:10px; /*scrollbarwidth*/\r\n  height:24px;\r\n  background:#226699; /*menucolor*/\r\n  background:hsl(0,0%,30%); \r\n}\r\n\r\n.KSearchField_clear\r\n{\r\n  color:black;\r\n  background:white;\r\n  border-radius:22px;\r\n  position:absolute;\r\n  width:20px;\r\n  right:28px;\r\n  height:20px;\r\n  top:2px;\r\n}\r\n.KSearchField_clear:hover\r\n{\r\n  background:darkred;\r\n  color:white;\r\n}\r\n\r\n.hover_bg_gray\r\n{\r\n  background:hsl(0,0%,72%)!important;\r\n}\r\n\r\n.hover_bg_gray:hover\r\n{\r\n  background:hsl(0,0%,48%)!important;\r\n}\r\n\r\n.fa_container\r\n{\r\n  display:inline-flex;\r\n  align-items:center;\r\n  justify-content:center;\r\n}\r\n\r\n.fa_container > i\r\n{\r\n  _background:red;\r\n  padding:0px 4px;\r\n}\r\n\r\n\r\n\r\n/* ================================ patient table =============================*/\r\n\r\n.patientTableTopTools\r\n{\r\n  overflow:hidden;\r\n}\r\n\r\n.patientTableTopTools .menu_generic li\r\n{\r\n  padding-left: 4px; \r\n  padding-right: 4px; \r\n  border:0px solid green;\r\n}\r\n\r\n.patientTableTopTools .menu_generic li.active\r\n{\r\n background:darkred;\r\n}\r\n\r\n\r\n#patientTableInnerContainer\r\n{\r\n\r\nbackground: hsl(0, 0%, 35%);\r\n\r\nborder-collapse:collapse;\r\n\r\nborder-top: 1px solid black;\r\n\r\nborder: 0px solid white;\r\n\r\nwidth:100%;\r\n\r\nheight:100%;\r\n\r\nposition:relative;\r\n\r\ndisplay: inline-table;\r\n}\r\n\r\n#patientTableInnerContainer > div\r\n{\r\n  sssbackground-color: hsl(0, 0%, 35%);\r\n  width:100%;\r\n  height:20px;\r\n  border:0px solid gray; /* top tool row*/\r\n\r\n}\r\n\r\n#patientTableLowerContainer\r\n{\r\n  width:400px;\r\n  height:auto;\r\n  border:0px solid darkgray;\r\n  __overflow:hidden;\r\n  position:relative;\r\n\r\n}\r\n\r\n#patientThumbContainer\r\n{\r\n  overflow-y:scroll;\r\n  overflow-x:hidden;\r\n  height:auto;\r\n  %background: linear-gradient(to top left, #999, #777);\r\n}\r\n\r\n#patientThumbBackButton\r\n{\r\n  display:none;\r\n  font-size:15px;\r\n  border: 2px solid yellow;\r\n  border-radius:4px;\r\n  background:lightgray;\r\n  color:black;\r\n  width:auto;\r\n  margin:2px;\r\n  padding:4px;\r\n  margin-bottom:5px;\r\n  box-shadow: 4px 3px 1px #000;\r\n}\r\n\r\n#patientThumbBackButton:hover\r\n{\r\n  background:black;\r\n  color:white;\r\n  cursor:pointer;\r\n}\r\n\r\n\r\n.patientTable_timeMarker\r\n{\r\n  background:#007A29;\r\n  background:darkcyan;\r\n  _color:white!important;\r\n _font-weight:bold;\r\n}\r\n\r\n.patientTable_timeMarker  span\r\n{\r\n color:hsl(0,0%,90%);\r\n font-style:italic;\r\n padding-left:5px;\r\n font-weight:normal;\r\n}\r\n\r\n\r\n\r\n#patientTableWrap \r\n{\r\n  overflow:auto;\r\n  position:relative;\r\n  cursor:default;\r\n}\r\n\r\n.ANULL\r\n{\r\nopacity:0.1;\r\n\r\n}\r\n\r\n.stickytable \r\n{\r\n  white-space:nowrap;\r\n  padding:0;\r\n  position: relative;\r\n  sborder-collapse:collapse;\r\n  box-sizing: border-box;\r\n  font-size:11pt;\r\n  border: 0px solid black;\r\n  width:20px;\r\n  cursor:inherit;\r\n}\r\n\r\n.stickytable.tablelayoutfixed\r\n{\r\n  table-layout:fixed;  \r\n\r\n}\r\n\r\n.stickytable  td \r\n{\r\n   position: relative; /*why does this have to turned off to make job tooltip working?*/\r\n   border-left:1px solid #aaa;\r\n   border-bottom:1px solid #aaa;\r\n   box-sizing: border-box;\r\n   border-collapse: collapse;\r\n   overflow:hidden;\r\n   min-width:24px;\r\n   text-overflow: ellipsis;\r\n}\r\n\r\n.stickytable tbody td\r\n{\r\n   padding-left:8px;\r\n   padding-right:0px;\r\n   padding-top:2px;\r\n   padding-bottom:2px;  \r\n      \r\n} \r\n \r\n\r\n.stickytable tbody td:first-child i\r\n{\r\n  color:gray;\r\n  margin:2px;\r\n  margin-top:4px;\r\n}\r\n\r\n.stickytable tbody:not(.nohover)  td:hover\r\n{\r\n\r\n  overflow: visible; \r\n  z-index:10;\r\n  background:inherit;\r\n  \r\n\r\n\r\n}\r\n\r\n.stickytable tbody:not(.nohover) td:hover > span\r\n{\r\n  \r\n  position:relative;\r\n  overflow: visible; \r\n  background:inherit;\r\n}\r\n\r\n.stickytable tbody:not(.nohover) td:hover >  span.large\r\n{\r\n  white-space:normal;\r\n \r\n}\r\n\r\n\r\n/*\r\ntd.fileCell\r\n{\r\n  overflow: visible; \r\n \r\n}\r\n\r\ntd.fileCell  > span\r\n{\r\n  z-index:10;\r\n  padding-right:5px;\r\n  \r\n  position:relative;\r\n  background:white;\r\n  \r\n}\r\n\r\n*/\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n.fileCell\r\n{\r\n  -webkit-touch-callout: none;\r\n  -webkit-user-select: none;\r\n  -khtml-user-select: none;\r\n  -moz-user-select: none;\r\n  -ms-user-select: none;\r\n   user-select: none; /* disable marking of content */\r\n   ddbackground:white;\r\n\r\n}\r\n\r\n/*\r\n.td_Filename span\r\n{\r\n  cursor:pointer;\r\n}\r\n.td_CombinedName span\r\n{\r\n  cursor:pointer;\r\n}\r\n.td_StudyDescription span\r\n{\r\n  cursor:pointer;\r\n}\r\n*/\r\n\r\n.td_StudyID span\r\n{\r\n user-select:text;  \r\n}\r\n\r\n.td_PIZ span\r\n{\r\n user-select:text;  \r\n}\r\n\r\n\r\npp.stickytable .row_selected td:hover > span\r\n{\r\n  background:#F0F0FF; /*tableentry*/\r\n  color:black;\r\n  \r\n}\r\n\r\npp.stickytable .row_selected td:hover\r\n{\r\n  background:#F0F0FF; /*tableentry*/\r\n  color:black;\r\n}\r\n\r\n.stickytable tbody:not(.nohover) tr:hover \r\n{\r\n  opacity:0.9;   \r\n \r\n}\r\n\r\n.stickytable tr \r\n{\r\n  color:black;\r\n}\r\n\r\n\r\n.patienttable_button \r\n{\r\n  background-color:\t#FCFCFC;\r\n}\r\n.patienttable_button td\r\n{\r\n  font-size:8px;\r\n  overflow:visible;\r\n  color:#444;\r\n}\r\n\r\n.patienttable_button span\r\n{\r\nbackground:#eee;\r\npadding:1px;\r\nmargin-left:3px;\r\npadding-left:3px;\r\npadding-right:3px;\r\nborder-radius:2px;\r\nborder:1px solid #666;\r\n}\r\n.patienttable_button:hover span\r\n{\r\n background:yellowgreen !important;\r\n color:black;\r\n}\r\n\r\n.patienttable_button\r\n{\r\n  overflow:visible;\r\n}\r\n\r\n.patientTableHeaderCell:first-child i\r\n{\r\n  vertical-align:middle;\r\n  line-height:24px;\r\n  padding:0px !important;\r\n}\r\n.patientTableHeaderCell:first-child span\r\n{\r\n  padding:0px !important;\r\n}\r\n\r\n\r\n.patientTableHeaderCell > span > span\r\n{\r\n  cursor:pointer;\r\n  width:98%;\r\n  display:inline-block;  \r\n  text-align:left;\r\n}\r\n\r\n.patientTableHeaderCell > span\r\n{\r\n  display:block;\r\n  width:auto;\r\n  padding-left:4px;\r\n  height:24px;\r\n  cursor:inherit;\r\n  \r\n  border:1px solid !important;\r\n  border-color:black !important;\r\n  margin:-1px;\r\n  margin-right:-1.5px;  \r\n\r\n  text-overflow:ellipsis;\r\n  overflow:hidden;\r\n\r\n  vertical-align:middle;\r\n  line-height:24px;\r\n\r\n}\r\n\r\n.ptable_col_dragover \r\n{\r\n  background:#880\r\n}\r\n\r\n.ptable_col_dragover > span\r\n{\r\n  background:#880;\r\n}\r\n\r\n\r\n.patientTableHeaderCell\r\n{\r\n  z-index:2;\r\n  background:#444;\r\n  color:white;\r\n  border-right: 0px solid green;\r\n  cursor:inherit;\r\n  border:0px solid !important;\r\n\r\n}\r\n\r\n.patientTableHeaderSearchCell\r\n{\r\n  background:#AAA;\r\n  color:black;\r\n  padding-left:1px !important;\r\n  padding-right:0px !important;\r\n  border:0px solid !important;\r\n  text-align:center;\r\n}\r\n\r\n\r\n.stickytable .row_selected\r\n{\r\n  background-color:#113355 !important; /*highlight*/\r\n  color: white;\r\n\r\n}\r\n\r\n.stickytable td i:nth-child(2)\r\n{\r\n  margin-left:7px\r\n}\r\n\r\n.stickytable td a\r\n{\r\n  color:inherit;\r\n}\r\n\r\n\r\n\r\n\r\n.stickytable thead td\r\n{\r\n  z-index:11;\r\n}\r\n\r\n.patientTableHeaderSearch > td > span > i\r\n{\r\n margin-left:-2px;\r\n}\r\n\r\n\r\n.patientTableHeaderSearch > td \r\n{\r\n  line-height:24px;\r\n  z-index:1;\r\n}\r\n\r\n.patientTableHeaderSearch input\r\n{\r\n  width:100%;\r\n  height:100%;\r\n  margin:0px;\r\n  padding: 3px;\r\n  border:none;\r\n  color:#171717;\r\n  font-weight:normal;\r\n  -webkit-box-sizing: border-box;\r\n  -moz-box-sizing: border-box;\r\n  box-sizing: border-box;\r\n  font-size: 15px;\r\n  background: linear-gradient(to top left, #FFFFFF, #CFCFCF);\r\n  cursor:inherit;\r\n\r\n  height:22px !important;\r\n \r\n}\r\n\r\n.patientTableHeaderCell \r\n{\r\n  line-height:24px;\r\n  margin:2px;\r\n  text-align:center;\r\n}\r\n\r\n.patientRow\r\n{\r\n  background-color:#999;\r\n}\r\n\r\n.patientTableHeaderRow\r\n{\r\n  color: white;\r\n  font-weight: bold;\r\n  font-size:11pt;\r\n  cursor:inherit;\r\n}\r\n\r\n\r\n.studyRow\r\n{\r\n  background-color:\t#D0D0D0  ;\r\n}\r\n\r\n.fileRow\r\n{\r\n  background-color:\t#FCFCFC;\r\n}\r\n\r\n.aggregateRow\r\n{\r\n  color: gray !important;\r\n}\r\n\r\n.rowSelected\r\n{  \r\n  background:#226699; /*menucolor*/ \r\n  color:white !important;\r\n}\r\n\r\n\r\n.subfolderRow\r\n{\r\n  background-color:\t#E8E8E8    ;\r\n}\r\n\r\n.fileRow a:hover\r\n{\r\n  color:black!important;\r\n  cursor: pointer;\r\n}\r\n\r\n.studyCell .fa-circle:hover\r\n{\r\n\tcolor:hsl(0,0%,30%);\r\n\tcursor:pointer;\r\n}\r\n.studyCell .fa-circle-o:hover\r\n{\r\n\tcolor:hsl(0,0%,50%);\r\n\tcursor:pointer;\r\n}\r\n\r\n\r\n#project_indicator\r\n{\r\n  \r\n    padding-left:10px;\r\n    padding-right:10px;\r\n  \r\n  \r\n  \r\n\r\n}\r\n\r\n\r\n.leveltab\r\n{\r\n\r\n  font-size:14px;\r\n  border-top:1px solid lightgray !important; \r\n  border-left:1px solid lightgray !important; \r\n  border-right:1px solid lightgray !important; \r\n    background:linear-gradient(to top left, #113355, #4466AA); /*toolbutton*/\r\n  border-top-left-radius:10px !important;\r\n  border-top-right-radius:10px !important;\r\n  border-bottom-left-radius:0px !important;\r\n  border-bottom-right-radius:0px !important;\r\n  margin-left:2px;\r\n  margin-right:2px;\r\n  height:24px !important;\r\n  top:5px;\r\n  color:lightgray !important;\r\n  opacity:0.6;\r\n \r\n}\r\n\r\n.leveltab.current\r\n{\r\n  color:white !important;\r\n  opacity:1;\r\n}\r\n\r\n.leveltab:hover\r\n{\r\ncolor:black !important;\r\n}\r\n\r\nselect\r\n{\r\n  border-radius:0px;\r\n  box-shadow: 0;\r\n  border:none;\r\n  -webkit-touch-callout: none;\r\n  -webkit-user-select: none;\r\n  -khtml-user-select: none;\r\n  -moz-user-select: none;\r\n  -ms-user-select: none;\r\n  user-select: none;\r\n\r\n}\r\n\r\n\r\n\r\n/*.menu_context li:after { clear: both; }*/\r\n\r\n\r\n/*\r\n.jobTable\r\n{\r\n  margin:auto;\r\n  border-collapse: collapse;\r\n  padding:50px;\r\n  background-color: white;\r\n  border: 1px solid black;\r\n  color:black;\r\n\r\n}\r\n\r\n.jobTable th\r\n{\r\n  background-color:#4C4C4C;\r\n  color: white;\r\n  font-size:11pt;\r\n  font-weight:bold;\r\n  border-bottom: 1px solid black;\r\n  padding: 5px 10px;\r\n  border-right:1px solid;\r\n  text-align:left;\r\n  margin-top:30px;\r\n}\r\n\r\n\r\n\r\n.jobTable td\r\n{\r\n  border-bottom: 1px solid;\r\n  padding: 4px 10px;\r\n  border-right:1px solid;\r\n  text-align:left;\r\n  margin-top:30px;\r\n}\r\n\r\n.jobTable td input\r\n{\r\n margin:0px;\r\n padding:4px;\r\n background:#f2f2f2;\r\n border:none;\r\n width:100%;\r\n  box-sizing: border-box;\r\n    -moz-box-sizing: border-box;\r\n    -webkit-box-sizing: border-box;\r\n\r\n}\r\n\r\n*/\r\n\r\n\r\n\r\n#gridjobtableContainer\r\n{\r\n height:100%;\r\n}\r\n\r\n#gridjobtable\r\n{\r\n  overflow:scroll;\r\n  width:100%;\r\n  position:relative;\r\n  height:100%;\r\n}\r\n\r\n.jobTable \r\n{\r\n  border:0px solid green;\r\n  height:auto;\r\n  width:100%;\r\n  position:relative;\r\n  background-color: #000000;\r\n  font-size:12px;\r\n  -webkit-box-sizing: border-box;\r\n  -moz-box-sizing: border-box;\r\n  box-sizing: border-box;\r\n  z-index:5;\r\n  border-collapse: collapse;\r\n  overflow:scroll;\r\n\r\n}\r\n\r\n.jobTable.tablelayoutfixed\r\n{\r\n  table-layout:fixed;  \r\n}\r\n\r\ntr.TEST \r\n{\r\n  background:magenta !important;\r\n}\r\n\r\ntr.DONE \r\n{\r\n  background:#333 !important;\r\n  color:#7AA !important;\r\n\r\n}\r\n\r\n\r\ntr.TEST .gridactionbutton .fa-refresh \r\n{\r\n   display:none;\r\n}\r\n\r\n\r\ntr:not(.TEST) .gridactionbutton .fa-times\r\n{\r\n   display:none;\r\n}\r\n\r\n.gridactionbutton i\r\n{\r\n  background:lightgray;\r\n  border-radius:2px;\r\n  padding:4px;\r\n  cursor:pointer;\r\n}\r\n\r\n.gridactionbutton i:hover\r\n{\r\n  background:darkgray;\r\n  color:white;\r\n  cursor:pointer;\r\n\r\n}\r\n\r\n.gridactionbutton\r\n{\r\n  white-space:nowrap;\r\n  overflow:hidden;\r\n}\r\n\r\n.jobTable td \r\n{\r\n \r\n  border-left:1px solid #aaa;\r\n  border-bottom:1px solid #aaa;\r\n  padding-left:8px;\r\n  padding-right:8px;\r\n  box-sizing: border-box;\r\n  border-collapse: collapse;\r\n  max-width:150px;\r\n  position:relative;\r\n\r\n}\r\n\r\n.jobTable td > span\r\n{\r\n\r\n  overflow:hidden;\r\n  display:block;\r\n  cursor:default;\r\n  text-overflow: ellipsis;\r\n  white-space: nowrap;\r\n  margin: -1px; \r\n}\r\n\r\n\r\n.jobTable tbody td:hover > span\r\n{\r\n  width:initial;\r\n  position:relative;\r\n  overflow: visible; \r\n  z-index:1;\r\n  display: inline-block;\r\n  border: 1px dotted;\r\n  margin: -2px; \r\n  background:#F0F0FF;\r\n\r\n}\r\n\r\n.jobTable tbody td:hover > span.link\r\n{\r\n  cursor:pointer;\r\n  color:blue;\r\n  \r\n}\r\n\r\n\r\n.jobTable tr \r\n{\r\n  background:#F0F0FF;\r\n  color:black;\r\n    cursor:inherit;\r\n\r\n  \r\n}\r\n\r\n.jobTable tr.selected\r\n{\r\n  color:black; \r\n  background:lightblue;   \r\n}\r\n\r\n\r\n.jobTable  tr\r\n{\r\n    overflow:auto;\r\n    text-overflow: ellipsis;\r\n    \r\n}\r\n\r\n\r\n\r\n.jobTable thead td\r\n{\r\n\r\n  z-index:2;\r\n  background:#404055; \r\n  color:white;\r\n  border-right: 0px solid green;\r\n  cursor:inherit;\r\n \r\n}\r\n\r\n.jobTableSearchCell  input\r\n{\r\n  width:100%;\r\n}\r\n\r\n.jobTableSearchCell\r\n{\r\n  background:#AAA;\r\n  color:black;\r\n  padding-left:1px !important;\r\n  padding-right:0px !important;\r\n  border:0px solid !important;\r\n  text-align:center;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/* KCommandDialog  */\r\n\r\n.KCommandDialogListDIV\r\n{\r\n  background:gray;\r\n  overflow-y:auto !important;\r\n/*\r\n  width:220px;\r\n  height:100%;\r\n  top:35px;\r\n  position:absolute;\r\n*/\r\n\r\n}\r\n\r\n.KCommandDialogGridContainer\r\n{\r\n  position:relative;\r\n  display:flex;\r\n  flex-direction:row;\r\n  box-sizing:border-box;\r\n}\r\n\r\n/* tool bar left */\r\n.KCommandDialogGridContainer > div:first-child\r\n{\r\n  flex-grow:0;\r\n  width:40px;\r\n  display:flex;\r\n  flex-direction:column;\r\n  background:hsl(0,0%,30%);\r\n}\r\n\r\n.KCommandDialogGridContainer > div:last-child\r\n{\r\n  flex-grow:1;\r\n  width:100%;\r\n}\r\n\r\n.KCommandDialogGridContainer > div:last-child table\r\n{\r\n  width:100%!important;\r\n  __height:100%!important;\r\n}\r\n\r\n/* to be deleted\r\n.KCommandDialogGridDIV_inner\r\n{\r\n  height:100%;\r\n  width:100%;\r\n  position:absolute;\r\n}\r\n\r\n.KCommandDialogGridDIV_inner tr,th,td\r\n{\r\n  height:10px !important; \r\n}\r\n\r\n\r\n.KCommandDialogGridDIV\r\n{\r\n  background:gray;\r\n  width:calc(100% - 30px);\r\n  left:30px;\r\n  height:20%;\r\n  bottom:-2px;\r\n  position:absolute;\r\n  z-index:100;\r\n  \r\n\r\n}\r\n*/\r\n\r\n.KCommandPatientSelection\r\n{\r\n  position:absolute;\r\n  top:-40px;\r\n  right:-95%;\r\n  transform: translate(-100%,0%);\r\n  margin-left:10px ;\r\n  margin-right:10px ;\r\n  padding-left:10px;\r\n  padding-right:10px;\r\n  padding-bottom:1px !important;\r\n  height:18px !important;\r\n  width:fit-content;\r\n  margin-top:2px;\r\n  margin-bottom:5px;\r\n  font-size:14px;\r\n  border: 1px dashed #0F0 ;\r\n  box-sizing:border-box;\r\n  pointer-events:none;\r\n\r\n  border-radius:6px !important; \r\n  background:green;\r\n  position:relative;\r\n  z-index:99999;\r\n  opacity:0.5;\r\n}\r\n\r\n.KCommandPatientSelection.missing\r\n{\r\n  background:red;\r\n  border: 0px ;\r\n}\r\n\r\n\r\n\r\n.isDragged\r\n{\r\n  opacity:1;  \r\n  \r\n  border: 2px dashed #0FF !important;\r\n\r\n}\r\n.isDraggedOver\r\n{\r\n  \r\n  yborder-top: 2px dashed #0F0 !important;\r\n\r\n}\r\n\r\n.KMenuSeparator\r\n{\r\n  opacity:1s;\r\n  margin-right:5px;\r\n  margin-left:5px;\r\n  _background:black;\r\n  border-right:1px solid hsl(0,0%,80%)!important;\r\n}\r\n\r\n.KCmdGridButton\r\n{\r\n  \r\n  background:#AAA;\r\n  width:24px;\r\n  height:24px;\r\n  border-radius:4px;\r\n  margin:4px;\r\n  color:black;\r\n  white-space:nowrap;\r\n  \r\n}\r\n.KCmdGridButton i\r\n{\r\n  padding: 4px 5px ;\r\n  font-size:18px;\r\n}\r\n.KCmdGridButton:hover\r\n{\r\n  background:#777;\r\n  color:white;\r\n  cursor:pointer;\r\n}\r\n\r\n\r\n.KCommandDialogwithGrid\r\n{\r\n  height:calc(80% - 30px) !important;\r\n}\r\n\r\n\r\n.KCommandDialogListDIV li\r\n{\r\n  font-size:13px !important;\r\n  height:25px !important;\r\n}\r\n\r\n.KCommandDialog\r\n{\r\n  overflow-y:scroll!important;\r\n  /*\r\n  overflow-x:hidden !important;\r\n  left:220px;\r\n  width: calc(100% - 220px);\r\n  */\r\n}\r\n\r\n\r\n.KCommandDetails\r\n{\r\n  font-weight: normal;\r\n  color:white;\r\n}\r\n.KCommandDetails li\r\n{\r\n  list-style: none;\r\n  padding-left: 5px;\r\n}\r\n.KCommandDetails ol\r\n{\r\n  padding-left: 15px;\r\n}\r\n\r\n\r\n.KCommandList\r\n{\r\n  display:table-cell;\r\n  font-weight: normal;\r\n  color:black;\r\n\r\n}\r\n\r\n.KCommandList  ol\r\n{\r\n  padding-left: 15px;\r\n  border: 0px solid white;\r\n}\r\n\r\n.KCommandList > ol\r\n{\r\n  padding-left: 0px;\r\n  border: 0px solid white;\r\n}\r\n\r\n\r\n\r\n.KCommandList li\r\n{\r\n  cursor:pointer;\r\n  list-style: none;\r\n  padding: 5px 5px 5px 5px;\r\n  background: -moz-linear-gradient(top,  #229966, #5C85AD); /* for firefox 3.6+ */\r\n\r\n}\r\n.KCommandList  li:hover\r\n{\r\n  background: -moz-linear-gradient(top,  #669acc, #669acc); /* for firefox 3.6+ */\r\n  background: #669acc;\r\n\r\n}\r\n\r\n.KNodeRow \r\n{\r\n\r\n  background: hsl(0,0%,35%)!important;\r\n}\r\n\r\n.KNodeRow > .td\r\n{\r\n  dpadding-left:20px!important;\r\n  sborder-top:1px solid gray;\r\n}\r\n\r\n.banned\r\n{\r\n opacity:0.4;\r\n}\r\n\r\n.KCmdvalidate_top\r\n{\r\n right:70px !important;\r\n}\r\n\r\n.KCmdvalidatefull\r\n{\r\n  top:4px;\r\n  margin-right:5px;\r\n}\r\n\r\n.KCmdvalidate\r\n{\r\n  position:absolute;\r\n  right:70px;\r\n  text-shadow: 1px 1px 1px black;\r\n  color:#F22;\r\n  padding:1px;\r\n\r\n  cursor:pointer;\r\n\r\n}\r\n\r\n.KCmdvalidate:not(.KCmdok):hover\r\n{\r\n  background:lightgray;\r\n  border: 1px solid black;\r\n  border-radius:3px;\r\n}\r\n\r\n.KCmdok\r\n{\r\n  color:#AFA;\r\n  cursor:default;\r\n\r\n}\r\n\r\n.KChildRow0.hidden\r\n{  \r\n  display:none !important;\r\n}\r\n\r\n\r\n.KChildRow1 > .td:first-child\r\n{\r\n  padding-left:90px!important;\r\n  background: hsl(0,0%,35%)!important;\r\n\r\n}\r\n\r\n.KChildRow1 > .td\r\n{\r\n  _background: hsl(0,0%,39%)!important;\r\n}\r\n\r\n\r\n.KChildRow1 > .td:last-child\r\n{\r\n  dpadding-bottom:20px!important;\r\n\r\n}\r\n\r\n /* this was a try to have additinal container. Must rebuild whole commanddialog for this\r\n.KCmdArgListContainer\r\n{\r\n  border: 0px solid red;\r\n  border-bottom: 1px solid black;\r\n  padding: 15px 10px 45px;\r\n  padding: 0px 0px 0px;\r\n  \r\n  width:100%;\r\n  box-sizing:border-box;\r\n  background: linear-gradient( to bottom right , hsl(0, 0%,22%), hsl(0, 0%,35%)); \r\n\r\n}\r\n\r\n*/\r\n\r\n.KCmdBatchgroup\r\n{\r\n  margin-left: 1% !important;\r\n   background:#333 !important;\r\n   border-bottom: 5px solid black;\r\n  width:98% !important;\r\n \r\n}\r\n\r\ndiv.KCmdBatchgroup \r\n{\r\n   border: 2px solid #EEE;\r\n   margin-top:30px !important;\r\n}\r\n\r\n.KCmdBatchgroup div .td\r\n{\r\n  background:#000 !important;\r\n}\r\n\r\n.KCmdLoopgroup div .td\r\n{\r\n  background:#AAA !important;\r\n}\r\n\r\n.KCmdArgListTable /*single list item */\r\n{\r\n\r\nbox-shadow: 2px 1px 2px hsla(0, 0%, 0%, .4);\r\n\r\ndisplay: table;\r\ntable-layout:fixed;\r\nborder-collapse:collapse;\r\n\r\nwidth:95%;\r\n\r\nmargin-left: 4%;\r\n\r\nmargin-top:1%;\r\n\r\npadding: 0px;\r\n\r\nfont-size: 12px;\r\n\r\ncolor: white;\r\n\r\nwhite-space:nowrap;\r\n\r\nbox-sizing:border-box;\r\n\r\nsborder-top: 1px solid hsl(0,0%,39%);\r\n\r\nborder-radius:0px; /*borderradius*/\r\n\r\nbackground-color: linear-gradient( to bottom right , hsl(0, 0%,22%), hsl(0, 0%,45%)); /*blockbackground*/\r\n}\r\n\r\n\r\n.KCmd_successfully_created {\r\n   -webkit-animation-name: blinker;\r\n   -webkit-animation-iteration-count:infinite;\r\n   -webkit-animation-duration: 3s;\r\n   \r\n}\r\n\r\n.KCmdwrap div\r\n{\r\n  background:#555 !important;\r\n  color:white;\r\n}\r\n\r\n/* SID and PIZ and VAR selectors are special */\r\n.KCmdvariableSID, .KCmdvariablePID \r\n{\r\n  border:none;\r\n  background:none;\r\n  \r\n}\r\n\r\n.KCmdvariableSID.inactive, .KCmdvariablePID.inactive\r\n{\r\n  opacity:0.3;\r\n  pointer-events:none;\r\n}\r\n\r\nselect option.optionerror\r\n{\r\n  color:red;\r\n}\r\n\r\nselect option.noerror\r\n{\r\n  color:black;\r\n}\r\n\r\nselect.optionerror\r\n{\r\n  color:red;\r\n}\r\n\r\n.error_blinker {\r\n  animation: blinker 1s linear infinite;\r\n}\r\n\r\n@keyframes blinker {  \r\n  50% { opacity: 1; background:#EE1; color: }\r\n}\r\n\r\n\r\n.KCmdvariablePID .tr .td, \r\n.KCmdvariablePID .tr .td \r\n{\r\n  padding:0px 0px 0px 10px;\r\n}\r\n\r\n.KCmdArgListTable:first-of-type:visible \r\n{ \r\n  dmargin-top:20px;\r\n}\r\n\r\n\r\n\r\n\r\n.KCmdArgListTable .tr\r\n{\r\n  display: table-row;\r\n  font-size:12px !important;\r\n  cursor:default;\r\n  border-top:1px solid hsl(0, 0%,30%); \r\n}\r\n\r\n.KCmdArgListTable .tr:first-child\r\n{\r\n}\r\n\r\n\r\n/* title row first cell */\r\n.KCmdArgListTable_titleRow  .td\r\n{\r\n  padding-left:0px!important;  \r\n  font-style:normal;\r\n  font-weight:bold;\r\n  position:relative;\r\n  font-size:12px;\r\n  background:#222 !important;\r\n  color:#FFE;\r\n}\r\n\r\n\r\n/* add a small fading border at bottom */\r\n._noneed_KCmdArgListTable_titleRow .td:first-child:before\r\n{\r\n    content:\'\';\r\n    position:absolute;\r\n    width:500px;;\r\n    height:0px;\r\n    background:linear-gradient(to right, hsl(0,0%,39%), hsl(0,0%,22%));\r\n    bottom:0px;\r\n    left:0;\r\n}\r\n\r\n\r\n\r\n/* second row margin top */\r\n.KCmdArgListTable .tr:nth-child(2) .td\r\n{\r\n  padding-top:3px;\r\n}\r\n\r\n/* last row with margin */\r\n.KCmdArgListTable .tr:last-child .td\r\n{\r\n  padding-bottom:3px;\r\n}\r\n\r\n\r\n\r\n.KCmdArgListTable .td:first-child\r\n{\r\n  width:36%;\r\n  padding-left:22px;\r\n}\r\n\r\n.KCmdToolSaveButton.modified\r\n{\r\n  background:rgb(200,50,50) !important;\r\n}\r\n\r\n\r\n.KCustomName\r\n{\r\n  display:inline-block;\r\n  min-width:100px;\r\n  background:#555;\r\n  color:orange;\r\n  margin-left:0px;\r\n  margin-top:2px;\r\n  padding-left:3px;\r\n  float:left;\r\n  text-align:left;\r\n\r\n}\r\n\r\n.td:first-child .KCustomName\r\n{\r\n  float:none;  \r\n  color:yellow;\r\n}\r\n\r\nli.KStudyTagOnSuccess\r\n{\r\n  width:auto;\r\n}\r\nli.KStudyTagOnSuccess >input\r\n{\r\n  width:100px;\r\n  background:lightgray;\r\n  position:absolute;\r\n  right:5px;\r\n  top:2px;\r\n}\r\n\r\nli.KStudyTagOnSuccess >textarea\r\n{\r\n  width:100px;\r\n  background:lightgray;\r\n  position:absolute;\r\n  height:15px;\r\n  right:5px;\r\n  top:3px;\r\n  resize: none;\r\n  overflow:hidden;\r\n\r\n}\r\n\r\n\r\nli.KStudyTagOnSuccess >textarea:hover\r\n{\r\n  position:absolute;\r\n  width:300px;\r\n  height:100px;\r\n  transition-delay:0.5s;\r\n  \r\n}\r\n\r\n\r\n.KCmdArgListTable .fullspan\r\n{\r\n  display: cell;  \r\n  width:267%;\r\n  \r\n  background:gray;\r\n  margin-left:20px;\r\n  margin-top:10px;\r\n  margin-bottom:10px;\r\n}\r\n\r\n.KCmdFileref\r\n{\r\n  float:right\r\n}\r\n\r\n.Kargtype\r\n{\r\n}\r\n\r\n.KCmdArgListTable .td\r\n{\r\n  position:relative;\r\n  display: table-cell;\r\n  padding:1px;\r\n  padding-left:10px;\r\n  text-align:left;\r\n  border-radius:0px; /*borderradius*/\r\n  white-space: nowrap;\r\n  vertical-align:middle;\r\n  background:none;\r\n}\r\n\r\n.KCmdArgListTable .CodeMirror\r\n{\r\n  dwidth:calc(100% - 55px);\r\n}\r\n\r\n.CodeMirror {\r\n}\r\n\r\n.CodeMirror-scroll {\r\n\r\n}\r\n\r\n.KCmdHeadSeparatorStyle > ul > li > ul \r\n{\r\n  font-size:12px;\r\n\r\n}\r\n\r\n\r\n.KCmdHeadSeparatorStyle > ul > li > ul  li\r\n{\r\n  height:22px;\r\n \r\n}\r\n\r\n.KCmdHeadSeparatorStyle > ul > li > a >.fa\r\n{\r\n  background-color:#113355; /*highlight*/\r\n  border: 1px solid gray;\r\n  padding-top:3px;\r\n  padding-bottom:3px;\r\n  border-radius:5px;\r\n}\r\n.KCmdHeadSeparatorStyle > ul > li:hover > a > .fa\r\n{\r\ncolor:yellow !important;\r\n}\r\n\r\n\r\n.KCmdArgListTable .flexlr\r\n{\r\n  border: 0px solid red;\r\n  display:flex;\r\n  flex-direction: row;\r\n  width:100%;\r\n \r\n}\r\n\r\n.KCmdArgListTable .flexlr div:last-child\r\n{\r\n    aflex-grow:1;\r\n    atext-align:center;\r\n    afont-size:9px; \r\n}\r\n\r\n.KCmdArgListTable .flexlr div:first-child\r\n{\r\n    flex-grow:1;\r\nllcolor:green;\r\npadding-right:20px;\r\n}\r\n\r\n\r\n.KCmdArgListTable input, .KCmdArgListTable textarea\r\n{\r\n\r\n  font-size:14px;\r\n  border: 1px solid hsl(0, 0%,22%);\r\n  border-radius:2px;\r\n  padding: 1px 1px;\r\n  \r\n  background: hsl(0,0%,93%);\r\n  efont-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\r\n  color:black;\r\n  width:calc(99% - 49px)!important;\r\n  box-sizing:border-box;\r\n}\r\n\r\n.KCmdArgListTable textarea\r\n{\r\n  resize:vertical;\r\n  height:20px;\r\n  \r\n}\r\n\r\n.KCmdArgListTable input:hover \r\n{\r\n    box-shadow:  0 0 2px 2px rgba(82,168,236,.9);\r\n}\r\n\r\n.KCmdArgListTable select\r\n{\r\n  width:fit-content;\r\n  border-radius:3px;\r\n  __height:20px;\r\n  padding:2px 0px;\r\n  font-size:9px;\r\n  background: hsl(0,0%,93%);\r\n  margin-left: 2px;\r\n  margin-top: 0px;\r\n}\r\n\r\n.KCmdArgListTable_fixedWidth\r\n{\r\n  display:inline-block;\r\n  min-width:50px;\r\n}\r\n.KCmdFilerefSpan__\r\n{\r\n  float:right;\r\n  clear:both;\r\n}\r\n\r\n\r\n.KCmdHeadSeparatorStyle\r\n{\r\n  height:30px;\r\n  border:0px;\r\n  margin-top:10px;\r\n  margin-left:0px;\r\n  \r\n}\r\n\r\n#KCmdHeadFinalSpacer\r\n{\r\nheight:200px\r\n}\r\n\r\n#KCmdHeadSeparatorAggregate\r\n{\r\n  margin-top:10px;\r\n\r\n}\r\n\r\n.KCmdBatch\r\n{\r\n  height:520px;\r\n  overflow-y:scroll;\r\n  padding-top:5px;\r\n  padding-left:5px;\r\n\r\n}\r\n\r\n\r\n\r\n.KCmdToolBar\r\n{\r\n  border: 0px solid red;\r\n  justify-content:right;\r\n  text-align:right!important;\r\n  padding:0px!important;\r\n  width:100px;\r\n\r\n}\r\n\r\n\r\n.KCmdTool\r\n{\r\n  border: 1px solid #000;\r\n  cursor: pointer;\r\n  padding: 4px 4px;\r\n  margin:none;\r\n  background:none;\r\n  border-radius:20%;\r\n  \r\n}\r\n\r\n.KCmdTool.inprogress\r\n{  \r\n  -webkit-animation: blink 1s linear infinite;\r\n  -moz-animation: blink 1s linear infinite;\r\n  animation: blink 1s linear infinite;\r\n    \r\n}\r\n\r\n.KCmdTool.enabled\r\n{\r\n  background:yellow !important;\r\n  color:black !important;\r\n}\r\n\r\n\r\n.KCmdTool:hover\r\n{\r\n  background-color:#113355; /*highlight*/\r\n  border: 1px solid #666;\r\n  color:yellow;\r\n}\r\n\r\n.KValidate\r\n{\r\n  padding:2px;\r\n  margin-right:10px;\r\n  margin-top:3px;\r\n   background-color:#113355; /*highlight*/\r\n\r\n  float:right;\r\n}\r\n\r\n/* smaller buttons in file rows */\r\n.KChildRow0 .KCmdTool\r\n{\r\n  padding: 2px 6px;\r\n}\r\n\r\n\r\n\r\n\r\n.dialog_generic_frame\r\n{\r\n  position:absolute;\r\n  height:80%;\r\n  width:80%;\r\n  left: 300px;\r\n  top: 80px;\r\n  display: none;\r\n  border: 1px solid;\r\n  border-color:#666666; /*bordercolor*/\r\n  background:hsl(0, 0%, 22%); /*windowbackground*/\r\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/ \r\n  z-index:900;\r\n  border-radius:0px; /*borderradius*/\r\n  overflow:hidden;\r\n}\r\n\r\n\r\n.dialog_generic_menu\r\n{\r\n  position: absolute;\r\n  top: 0px;\r\n  height:30px;\r\n  width:100%;\r\n\r\n}\r\n\r\n\r\n.dialog_generic_resizeTriangle\r\n{\r\n  position:absolute;\r\n  background-color:none;\r\n  height:0px;\r\n  width:0px;\r\n  bottom:0px;\r\n  border-bottom: 30px solid;\r\n  border-color:#666666; /*bordercolor*/\r\n  border-left: 30px solid transparent;\r\n  right:0px;\r\n  display: block;\r\n  z-index:901;\r\n  opacity:0.5;\r\n  cursor: se-resize;\r\n}\r\n.dialog_generic_resizeTriangle:hover\r\n{  \r\n  border-color:#113355; /*highlight*/\r\n  border-bottom: 30px solid;\r\n    border-left: 30px solid transparent;\r\n\r\n }\r\n\r\n.dialog_generic_resizeTriangle_hovered\r\n{  \r\n  border-color:#113355; /*highlight*/\r\n  border-bottom: 30px solid;\r\n    border-left: 30px solid transparent;\r\n}\r\n\r\n.dialog_generic_container\r\n{\r\n  position:relative;\r\n  display: block;\r\n  overflow:auto;\r\n  resize: none;\r\n  background-color:none;\r\n  /*height:100%;*/\r\n  top:30px;\r\n  height: -moz-calc(100% - 31px);\r\n  height: -webkit-calc(100% - 31px);\r\n  height: calc(100% - 31px);\r\n\r\n  font-size:11pt;\r\n  color: hsl(0,0%,90%);\r\n/*\r\n  display:flex;\r\n  flex-direction:column;\r\n  background:green;\r\n*/\r\n}\r\n  /*\r\n.dialog_generic_container > div\r\n{\r\n  background:red;\r\n  flex-grow:1;\r\n  _height:100%;\r\n}\r\n\r\n  */\r\n\r\n.dialog_generic_container a.link \r\n{\r\n  color: hsl(5, 100%, 25%);\r\n}\r\n.dialog_generic_container a.link:visited\r\n{\r\n  color: hsl(5, 100%, 25%);\r\n}\r\n.dialog_generic_container a.link:hover\r\n{\r\n  color: hsl(5, 100%, 15%);\r\n}\r\n\r\n\r\n\r\n.popupDIV\r\n{\r\n  background-color:#1a334c; \r\n  font-size:11pt;\r\n  color: lightgray;\r\n  text-indent: 0px;\r\n  text-align:left;\r\n  padding:0px;\r\n  border: 1px solid #1a334c;\r\n  height:90%;\r\n  width:70%;\r\n  position:absolute;\r\n  margin-left: 100px;\r\n  display: none;\r\n  top: 50px;\r\n  z-index:900;\r\n  oooverflow-y:auto;\r\n  oooverflow-x:scroll;\r\n  resize: both;\r\n}\r\n\r\n\r\n.popupDIV header\r\n{\r\n  color:white;\r\n}\r\n\r\n.popupDIV table\r\n{\r\n  white-space: nowrap;\r\n}\r\n.popupDIV  table  td:last-child\r\n{\r\n  text-align:left;\r\n}\r\n\r\n\r\n.innerScrollContainerDIV\r\n{\r\n  height: -moz-calc(100% - 30px);\r\n  height: -webkit-calc(100% - 30px);\r\n  height: calc(100% - 30px);\r\n  overflow-x:scroll;\r\n  overflow-y:scroll;\r\n}\r\n\r\n\r\n\r\n\r\n.menuDIV\r\n{\r\n  background: #229966; /* for non-css3 browsers */\r\n  margin-bottom: 0px;\r\n  width:100%;\r\n  height:30px;\r\n  color:white;\r\n  text-shadow: 1px 1px 1px black;\r\n  font-size:15pt;\r\n  border-bottom:0px solid ;\r\n  text-align:left;\r\n  text-indent: 0px;\r\n  z-index:99;\r\n}\r\n\r\n\r\n\r\n/* this is already the ul */\r\n.menu_generic\r\n{\r\n  position:relative;\r\n  font-size:17px; \r\n  display: block;\r\n  dsheight: 5px;;\r\n  width:  100%;\r\n  margin: 0px;\r\n  padding: 0px;\r\n  border: 0px solid green;\r\n  background:#226699; /*menucolor*/\r\n  dtext-shadow: 1px 1px 1px #333333;\r\n  white-space:nowrap;\r\n  border-radius:0px; /*borderradius*/\r\n  \r\n}\r\n\r\n\r\n\r\n.menu_generic li\r\n{\r\n  padding-left:5px;\r\n  padding-right:5px;\r\n  float: left;\r\n  position: relative;\r\n  list-style: none;\r\n  border: none;\r\n  z-index:99; /* this is important !!!! since the main frame is filling whole window */\r\n  cursor:pointer;\r\n  color: white;\r\n  border-radius:0px; /*borderradius*/\r\n  color:whitesmoke;\r\n  height:100%; /* needed if i\'s are contained*/\r\n\r\n  display: flex;\r\n  justify-content: center; /* align horizontal */\r\n  align-items: center; /* align vertical */\r\n\r\n  height:30px;\r\n  line-height: 30px;\r\n\r\n  \r\n}\r\n\r\n.menu_generic li.logo\r\n{\r\n  padding: 0px 0px;\r\n  fwidth:100px;\r\n  display:flex;\r\n  align-items:center;\r\n}\r\n\r\n.menu_generic li.logo >  div\r\n{\r\n  box-sizing:border-box;\r\n  margin:auto;\r\n  \r\n  height:29px;\r\n  dwidth:100%;\r\n  overflow:hidden;\r\n  position:relative;\r\n  display:flex;\r\n  justify-content:center;\r\n}\r\n.menu_generic li.logo > div > img\r\n{\r\n  box-sizing:border-box;\r\n  height:100%;\r\n  border:0px solid white;\r\n  /*position:relative;\r\n  top:50%;\r\n  left:50%;*/\r\n}\r\n\r\n.menu_generic li.icon_only\r\n{\r\n  padding:6px 12px;\r\n}\r\n\r\n\r\n.menu_generic li.menu_generic_disabled\r\n{\r\n  color:grey;\r\n  text-shadow:none;\r\n  pointer-events:none;\r\n  cursor: move;\r\n  __line-height:30px;\r\n}\r\n\r\n.menu_generic li.menu_generic_labelname\r\n{\r\n  color:whitesmoke;\r\n  text-shadow:none;\r\n  pointer-events:none;\r\n  doverflow: hidden;\r\n  z-index:0;\r\n}\r\n\r\n.menu_generic li.menu_generic_devtool\r\n{\r\n  color:orange; \r\n  font-size:13px;\r\n}\r\n\r\n.menu_generic li.inactive \r\n{\r\n  __color:whitesmoke;\r\n  __opacity:0.3;\r\n  pointer-events:none;\r\n}\r\n\r\n\r\n.menu_generic li.menu_generic_tabbed\r\n{\r\n  border-top-left-radius:4px;\r\n  border-top-right-radius:4px;\r\n  color:hsl(0,0%,20%);\r\n  text-shadow:none;\r\n  pointer-events:none;\r\n  cursor: default;\r\n  background:hsl(0, 0%,80%); \r\n\r\n}\r\n\r\n\r\n/* main level link */\r\n.menu_generic li a\r\n{\r\n   display: block;\r\n   color: inherit;\r\n   background:none;\r\n}\r\n\r\n.menu_generic ul\r\n{\r\n  left:0; \r\n\r\n}\r\n\r\n.menu_generic ul.rightmenu\r\n{\r\n  left:initial;\r\n  right:0; \r\n}\r\n\r\n/* level 2 list */\r\n.menu_generic ul\r\n{\r\n  background:#F0F0FF; /*submenucolor*/\r\n  margin: 0;\r\n  padding: 0;\r\n  min-width: 180px;\r\n  position: absolute;\r\n  border: solid 0px #b4b4b4;\r\n  border-radius:0px; /*borderradius*/\r\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/   \r\n  transition:visibility  ease-out 210ms, opacity  210ms ease-out ;\r\n  top: 100%; /* this is really important for other menu sizes. Otherwise, it will be fixed */\r\n\r\n  visibility:hidden;\r\n  opacity:0;\r\n\r\n  \r\n}\r\n\r\n\r\n.menu_generic ul.small\r\n{\r\n  font-size:14px;  \r\n}\r\n\r\n.menu_generic ul.small > li\r\n{\r\n  height:23px;\r\n}\r\n\r\n\r\n.menu_generic .hidden\r\n{\r\n  display:none;\r\n}\r\n\r\n.menu_generic .more\r\n{\r\n  color:gray;\r\n}\r\n\r\nshit.menu_generic.menu_scrollable > li > ul\r\n{\r\n  max-height:600px;\r\n  voverflow-y:auto;\r\n  overflow-x:hidden;\r\n\r\n}\r\n\r\n.projectsearch input\r\n{\r\n  color:gray;\r\n  margin-top:6px;\r\n  margin-bottom:3px;\r\n}\r\n\r\n.projectsearch .fa-search\r\n{\r\n  color:gray;\r\n  padding-left:6px;\r\n  padding-right:2px;\r\n}\r\n\r\n\r\n.submenu_scrollable \r\n{\r\n  max-height:600px;\r\n  overflow-y:auto;\r\n  overflow-x:hidden;\r\n\r\n}\r\n\r\n/* dropdown */\r\n.menu_generic li:hover > ul , .menu_generic li.jsHover > ul\r\n{\r\n  visibility:visible; \r\n  opacity:1;\r\n  __transition:visibility  ease-out 0s,opacity 0.5s ease-out;\r\n   transition-delay:0.2s;\r\n}\r\n\r\n.menu_generic a \r\n{\r\n  width:100%;\r\n/*\r\n  vertical-align: center;\r\n  padding:  0px 0px;\r\n  dbackground:white;\r\n  sborder-color:red;\r\n  sborder: solid 1px;\r\n  height:30px;\r\n  line-height: 30px;\r\n  */\r\n}\r\n\r\n\r\n/* main level li hover */\r\n.menu_generic > li:not(.nohover):hover  , li.jsHover\r\n{\r\n  background:#F0F0FF; /*submenucolor*/\r\n  _text-shadow: 1px 1px 1px rgba(255, 255, 255, .8);\r\n  color:hsl(0,0%,20%);\r\n  text-decoration:none;\r\n  z-index:100; /* this is important !!!! since the main frame is filling whole window */\r\n  \r\n  transition:background 0s linear;\r\n\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n/*\r\n   -webkit-transition: .5s all;   \r\n    -webkit-transition-delay: 5s; \r\n    -moz-transition: .5s all;   \r\n    -moz-transition-delay: 5s; \r\n    -ms-transition: .5s all;   \r\n    -ms-transition-delay: 5s; \r\n    -o-transition: .5s all;   \r\n    -o-transition-delay: 5s; \r\n    transition: .5s all;   \r\n    transition-delay: 5s; \r\n*/\r\n/* sublevel li hover*/\r\n.menu_generic  li  > ul:hover >li:not(.nohover):hover\r\n{\r\n  background:hsl(0,0%,70%); /*submenucolor_hover*/\r\n  color: #FFF !important;\r\n  text-shadow:none;\r\n\r\n\r\n}\r\n\r\n\r\n.menu_generic > li > ul >li\r\n{\r\n  ___background-color:#F0F0FF; /*submenucolor*/\r\n  margin:0px;\r\n  margin-right:0px;\r\n}\r\n\r\n\r\n.menu_generic > li > a > i\r\n{\r\n  _line-height:30px;\r\n  _height:100%;\r\n  text-align:center;\r\n  width:30px;\r\n}\r\n\r\n\r\n.menu_generic > li > ul >li > i\r\n{\r\n  line-height:30px;\r\n  text-align:center;\r\n\r\n}\r\n\r\n\r\n.menu_generic ul li\r\n{\r\n  float: none;\r\n  width:auto;\r\n  text-shadow: 0 1px 0px rgba(255,255,255, .1);\r\n  apadding:10px 10px 10px 10px;\r\n  display:flex;\r\n  color: #444;\r\n}\r\n\r\n.menu_generic.small ul\r\n{\r\n  font-size:13px;\r\n}\r\n\r\n\r\n\r\n.menu_generic.small ul li\r\n{\r\n  apadding:4px 0px 4px 10px;  \r\n}\r\n\r\n/* second menu expand to right horizontal */\r\n.menu_generic > li > ul > li >ul\r\n{\r\n  left: 100% ;\r\n  top:0;\r\n  width:auto;\r\n\r\n}\r\n\r\n.menu_generic > li > ul > li > a > i\r\n{\r\n\r\n}\r\n\r\n.menu_generic > li > ul > li > a > span\r\n{ \r\n  float: left;\r\n}\r\n\r\n.menu_generic > li > ul > li > a > i:nth-child(2)\r\n{\r\n  position:relative;\r\n  float:right;\r\n  line-height:30px;\r\n  text-align:center;\r\n\r\n}\r\n\r\n\r\n.menu_generic > li > ul > li > ul > li > i\r\n{\r\n  line-height:30px;\r\n  text-align:center;\r\n  \r\n}\r\n\r\n.menu_generic > li > ul i:first-child\r\n{\r\n  dmargin-left:20px;\r\n  flex-grow:1;\r\n  bborder:1px solid green;\r\n  text-align:right;\r\n}\r\n\r\n\r\n\r\n\r\n/* clearfix: insert somethig after the content of each elemnt */\r\n.menu_generic:after\r\n{\r\n  content: ".";\r\n  display: block;\r\n  clear: both;\r\n  visibility: hidden;\r\n  line-height: 0;\r\n  height: 0;\r\n}\r\n\r\n\r\n.menu_generic .inverted_white\r\n{\r\n  color: white;\r\n}\r\n.menu_generic .inverted_red\r\n{\r\n  aabackground: #aaaaaa;\r\n  color:white;\r\n}\r\n.menu_generic .inverted_green\r\n{\r\n  background: green;\r\n  color:white;\r\n}\r\n\r\n.menu_generic ul li .usercmdshortcut\r\n{\r\n  padding: 0px 3px;\r\n  float:right;\r\n}\r\n\r\n.menu_generic ul li .usercmdshortcut:hover\r\n{\r\n  color:black;\r\n}\r\n\r\n.menu_generic .roitoolbutton\r\n{\r\n  float:right;\r\n  height:20px;\r\n  padding:6px 12px;\r\n  margin:0px;\r\n}\r\n\r\n\r\n.menu_generic .roitoolbutton.selected\r\n{\r\n  color: white;\r\n  text-shadow: 3px 3px 3px black;  \r\n}\r\n\r\n.menu_generic .roitoolbutton input\r\n{\r\n  width:40px;\r\n  margin-top:-1px;\r\n}\r\n.RoiTool_topmenu\r\n{\r\n    background: linear-gradient(to top left, #44A, #66B) !important;\r\n  \r\n}\r\n\r\n.FormTool_topmenu\r\n{\r\n   background: linear-gradient(to top left, #F55, #A55)  !important;\r\n}\r\n\r\n\r\n.Obj3DTool_topmenu\r\n{\r\n    background: #E98 !important;\r\n    color:black !important;  \r\n}\r\n.Obj3DTool_topmenu li\r\n{\r\n    color:black !important;    \r\n}\r\n\r\n.AtlasTool_topmenu\r\n{\r\n    background: linear-gradient(to top left, #FF7, #FFF) !important;\r\n}\r\n.AtlasTool_topmenu li\r\n{\r\n    color:black !important;    \r\n}\r\n\r\n\r\n\r\n.KToolsTopMenu li\r\n{\r\n   padding:0px 3px;\r\n  height:25px;\r\n  line-height:25px;\r\n\r\n}\r\n\r\n.KToolsTopMenu .draganddrop\r\n{\r\n   display:flex;\r\n   padding:2px 3px;\r\n   box-sizing:border-box;   \r\n   flex-direction:vertical;\r\n}\r\n.KToolsTopMenu .draganddrop i\r\n{\r\n   background: linear-gradient(to top left, #998D7A, #AAAAAA);\r\n   border-radius:2px;\r\n   border:solid 1px white;\r\n   color:yellow !important;\r\n   padding:2px 3px;\r\n}\r\n\r\n\r\n.tool_menu_generic\r\n{\r\n  display:flex;\r\n  justify-content:center;\r\n  border:0px solid white;\r\n  align-items:center;\r\n  overflow:hidden;\r\n\r\n}\r\n.tool_menu_generic li\r\n{\r\n  border:0px solid red;  \r\n}\r\n\r\n\r\n.patientTableNavigator\r\n{\r\n  margin:0px;\r\n  height:5px;\r\n  display:flex;\r\n}\r\n\r\n.__patientTableNavigator  li\r\n{\r\n  display: block; \r\n  float: left;\r\n  box-sizing:border-box;\r\n  border-collapse:collapse;\r\n  \r\n}\r\n\r\n/*  create some rudimentary styling for our tooltip class */\r\n\r\n.tooltip{\r\n    display: inline;\r\n    position: relative;\r\n}\r\n/*\r\n.tooltip:hover:after{\r\n    background: #333;\r\n    background: rgba(0,0,0,.8);\r\n    border-radius: 5px;\r\n    bottom: 26px;\r\n    color: #fff;\r\n    content: attr(title);\r\n    left: 20%;\r\n    padding: 5px 15px;\r\n    position: absolute;\r\n    z-index: 98;\r\n    width: 220px;\r\n    content: attr(title);\r\n}\r\n*/\r\n\r\n.KSortDir\r\n{\r\n  background: whitesmoke;\r\n  margin: 1px;\r\n  padding: 1px;\r\n  font-size: 8px;\r\n  border: 2px solid lightgray;\r\n  ggtext-shadow: 1px 1px 1px gray;\r\n  border-radius:30%;\r\n  box-shadow: 1px 1px 1px lightgray;\r\n  color:gray;\r\n  height:auto;  \r\n  sfloat:right;\r\n  ddisplay:inline-block;\r\n}\r\n\r\n.KSortDir:hover\r\n{\r\n  background: gray;\r\n  color:black;\r\n}\r\n\r\n\r\n\r\n.KJobAction\r\n{\r\n  background: whitesmoke;\r\n  margin: 1px;\r\n  padding: 1px;\r\n  font-size: 8px;\r\n  border: 2px solid lightgray;\r\n  ggtext-shadow: 1px 1px 1px gray;\r\n  border-radius:30%;\r\n  box-shadow: 1px 1px 1px lightgray;\r\n  color:gray;\r\n  height:auto;  \r\n  \r\n}\r\n\r\n.KJobAction:hover\r\n{\r\n  background: gray;\r\n  color:black;\r\n}\r\n\r\n\r\n.KTextButton\r\n{\r\n  background: whitesmoke;\r\n  margin: 0px;\r\n  padding: 0px;\r\n  font-size: 12px;\r\n  border: 2px solid lightgray;\r\n  ggtext-shadow: 1px 1px 1px gray;\r\n  border-radius:30%;\r\n  box-shadow: 1px 1px 1px lightgray;\r\n  color:gray;\r\n  height:auto;\r\n}\r\n\r\n.KTextButton.selected\r\n{\r\n  background: red;\r\n  margin: 0px;\r\n  padding: 0px;\r\n  font-size: 12px;\r\n  border: 2px solid lightgray;\r\n  text-shadow: none;\r\n  border-radius:30%;\r\n  box-shadow: 1px 1px 1px lightgray;\r\n  color:black;\r\n  height:auto;\r\n}\r\n\r\n\r\n.aggregateTag \r\n{\r\n background: #FFF !important;\r\n color:red !important;\r\n padding-left:0px !important;\r\n font-size:10px !important;\r\n border-radius:2px; \r\n border: 0px !important;\r\n\r\n}\r\n\r\n.cellEditable\r\n{\r\n\r\n  color:black;\r\n  background:#EED;\r\n\r\n \r\n}\r\n\r\n\r\n.patienttable_subfoldercount\r\n{\r\n  float:right;\r\n  font-size:10px;\r\n  margin-right:4px;\r\n  color:#888 !important;\r\n}\r\n\r\ntd .aggregateTag \r\n{\r\n \r\n  float:right;\r\n  padding-right:5px;\r\n  padding-left:5px !important;\r\n}\r\n\r\n.fiberTag \r\n{\r\n background: linear-gradient(to top left, #FEA, #FAA) !important;\r\n color:black !important;\r\n}\r\n\r\n.workstateTag \r\n{\r\n background: linear-gradient(to top left, #AEF, #AAF) !important;\r\n color:black !important;\r\n}\r\n\r\n\r\n.imgTag \r\n{\r\n background: linear-gradient(to top left, #AAF, #AFF) !important;\r\n color:black !important;\r\n}\r\n\r\n\r\n.AtlasTag\r\n{\r\n background: linear-gradient(to top left, #FF7, #FFF) !important;\r\n color:black !important;\r\n}\r\n\r\n.MaskTag\r\n{\r\n background: linear-gradient(to top left, #AAF, #99F)  !important;\r\n   color:black  !important;\r\n}\r\n\r\n.AnoTag\r\n{\r\n background: linear-gradient(to top left, #8A8, #8C8)  !important;\r\n\r\n   color:black  !important;\r\n}\r\n\r\n.FormTag\r\n{\r\n background: linear-gradient(to top left, #D99, #F55)  !important;\r\n \r\n   color:black  !important;\r\n}\r\n\r\n.KTagFile\r\n{\r\n  background: whitesmoke;\r\n  margin: 1px;\r\n  padding: 1px;\r\n  font-size: 8px;\r\n  border: 2px solid lightgray;\r\n  \r\n  border-radius:30%;\r\n  box-shadow: 1px 1px 1px lightgray;\r\n  color:gray;\r\n  height:auto;\r\n}\r\n\r\n\r\n.KTagPatient\r\n{\r\n\r\n  background: white;\r\n  margin: 1px;\r\n  padding: 0px;\r\n  sfont-size: 8px;\r\n  border: 2px solid darkgray;\r\n  border-radius:5px;\r\n  padding-left:2px;\r\n  padding-right:2px;\r\n  fbox-shadow: 1px 1px 1px lightgray;\r\n  color:black;\r\n  height:auto;\r\n}\r\n\r\n.KTag \r\n{\r\n  line-height:10px;\r\n\r\n}\r\n#KJobinfoTooltip > ul /* this is for the tooltip on the running jobs*/\r\n{\r\n  position:absolute;\r\n  font-size:15px;\r\n  list-style:none;\r\n  background:white;\r\n  padding:0px;\r\n  margin:0px;\r\n  z-index:9999;\r\n}\r\n#KJobinfoTooltip > ul >li  /* this is for the tooltip on the running jobs*/\r\n{\r\n  background: lightyellow;\r\n  padding:5px;\r\n  z-index:99999;\r\n  white-space: nowrap;\r\n  cursor:pointer;\r\n  \r\n}\r\n\r\n#KJobinfoTooltip > ul >li > span\r\n{\r\n  background: gray;\r\n  border: 2px solid darkgray;\r\n  margin-left:10px;\r\n  color :white;\r\n  border-radius:4px;\r\n  padding-left:2px;\r\n  padding-right:2px;\r\n}\r\n#KJobinfoTooltip > ul >li > span:hover\r\n{\r\n  background: lightgray;\r\n}\r\n\r\n\r\n\r\n\r\n\r\n#standardTooltip \r\n{\r\n  position:absolute;\r\n  z-index:9999;\r\n  background:#333;\r\n  padding-top:1px;\r\n  padding-bottom:1px;\r\n  padding-left:5px;\r\n  padding-right:5px;\r\n  border-radius:5px;\r\n  border: 1px solid darkgray;\r\n  font-size:16px;\r\n\r\n  color:white;\r\n  opacity:0.8;\r\n  max-width:300px;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n.KTagWaiting\r\n{\r\n  background: yellow;\r\n  margin: 1px;\r\n  padding: 1px;\r\n  font-size: 10px;\r\n  border: 1px solid darkgray;\r\n  border-radius:50%;\r\n  color:black;\r\n  display:none;\r\n}\r\n\r\n\r\n\r\n@keyframes blink {  \r\n  0% { background: #0F0; color:black; }\r\n  50% { background: #050; color:black; }\r\n  100% { background: #0F0; color:black; }\r\n}\r\n\r\n\r\n\r\n\r\n.KTagRunning\r\n{\r\n  background: green;\r\n  margin: 1px;\r\n  padding: 1px;\r\n  font-size: 8px;\r\n  border: 2px solid darkgray;\r\n  ggtext-shadow: 1px 1px 1px gray;\r\n  border-radius:50%;\r\n  fbox-shadow: 1px 1px 1px lightgray;\r\n  color:black;\r\n  display:none;\r\n  z-index:9999999999;\r\n  \r\n  -webkit-animation: blink 1s linear infinite;\r\n  -moz-animation: blink 1s linear infinite;\r\n  animation: blink 1s linear infinite;\r\n  \r\n}\r\n\r\n.KTagError\r\n{\r\n  background: red;\r\n  margin: 1px;\r\n  padding: 1px;\r\n  font-size: 8px;\r\n  border: 2px solid darkgray;\r\n  ggtext-shadow: 1px 1px 1px gray;\r\n  border-radius:50%;\r\n  fbox-shadow: 1px 1px 1px lightgray;\r\n  color:black;\r\n  display:none;\r\n}\r\n\r\n.KTagSuspended\r\n{\r\n  background: orange;\r\n  margin: 1px;\r\n  padding: 1px;\r\n  font-size: 8px;\r\n  border: 2px solid darkgray;\r\n  ggtext-shadow: 1px 1px 1px gray;\r\n  border-radius:50%;\r\n  fbox-shadow: 1px 1px 1px lightgray;\r\n  color:black;\r\n  display:none;\r\n}\r\n\r\n.KTagRegistered\r\n{\r\n  background: white;\r\n  margin: 1px;\r\n  padding: 1px;\r\n  font-size: 8px;\r\n  border: 2px solid darkgray;\r\n  ggtext-shadow: 1px 1px 1px gray;\r\n  border-radius:50%;\r\n  fbox-shadow: 1px 1px 1px lightgray;\r\n  color:black;\r\n  display:none;\r\n}\r\n\r\n\r\n\r\n#KStatusBar\r\n{\r\n  overflow:hidden;\r\n}\r\n\r\n#KStatusBar:hover\r\n{\r\n  cursor:default;\r\n\r\n}\r\n\r\n\r\n.patientTableEditMode\r\n{\r\n  background:hsl(0, 0%, 22%); /*windowbackground*/\r\n  overflow:hidden;\r\n  font-size:15px;\r\n}\r\n.patientTableEditMode li:hover i\r\n{\r\n color:hsl(0,0%,50%); \r\n}\r\n\r\n\r\n#patientTableEditModeTextFirst\r\n{\r\n  margin :1px;\r\n  margin-left:4px;\r\n}\r\n#patientTableEditModeTextSecond\r\n{\r\n  margin :1px;\r\n  margin-left:4px;\r\n}\r\n\r\n\r\n\r\n.testag\r\n{\r\n  color : red;\r\n  background:green;\r\n  \r\n}\r\n\r\n\r\n.listFrame\r\n{\r\n  display:flex;\r\n  border-top:1px solid hsl(0, 0%,70%);\r\n}\r\n\r\n.listFrame > div\r\n{\r\n  height:100%;\r\n  align-self:  flex-start ;\r\n  overflow-y:auto; \r\n}\r\n.listFrame > div:nth-child(2)\r\n{ \r\n  margin-top:-0px;\r\n  min-width:200px;\r\n  dflex-grow:1;\r\n  border:0px solid red;\r\n}\r\n\r\n\r\n.listFrame > div:last-child\r\n{\r\n  flex-grow:1;\r\n  border-left: 1px solid gray;\r\n}\r\n\r\n\r\n\r\n\r\n.listFrame_left\r\n{\r\n\r\n  \r\n  border:0px solid green;\r\n  padding:0px;\r\n  margin:0px;\r\n  min-width:190px;\r\n}\r\n\r\n.listFrame_left li\r\n{\r\n  position: relative;\r\n  list-style: none;\r\n  border: none;\r\n  cursor:pointer;\r\n\r\n  color: #444;\r\n  display:flex;\r\n  flex-wrap: nowrap;\r\n  border-radius:0px; /*borderradius*/\r\n  background:#F0F0FF; /*menucolor_context*/\r\n}\r\n\r\n\r\n.listFrame_left li:hover\r\n{\r\n  background: #a1a1a1; /* for non-css3 browsers */\r\n  color: #444;\r\n}\r\n\r\n\r\n.listFrame_left li.active\r\n{\r\n  background:#226699; /*menucolor*/\r\n  color:white;\r\n  border-top:0px solid gray;\r\n}\r\n\r\n\r\n.listFrame_left li > div\r\n{\r\n  display:flex;\r\n  text-align:right;\r\n  border:0px solid;\r\n  height:30px;\r\n  padding:5px;\r\n  font-size:15px;\r\n  align-items:center;\r\n}\r\n\r\n.listFrame_left li > div:first-child\r\n{\r\n  flex-grow:1;\r\n\r\n}\r\n\r\n\r\n.listFrame_left li > div:last-child\r\n{\r\n  align-self: flex-end; \r\n}\r\n\r\n.autoloadersnapshot\r\n{\r\n   position:absolute;\r\n   \r\n}\r\n\r\n.listFrame_left.apply li\r\n{\r\n  background: hsl(120, 100%, 25%);\r\n  color:white;\r\n  padding:0px;\r\n  margin:15px;\r\n  margin-top:32px;\r\n  border-radius:15px;\r\n}\r\n.listFrame_left.apply li:hover\r\n{\r\n  dbackground: hsl(120, 100%, 30%);\r\n  opacity:.87;\r\n  ddcolor:black;\r\n}\r\n\r\n.listFrame_left.apply li  div\r\n{\r\n  text-align:center;\r\n  __position:relative;\r\n  __left:-30%;\r\n  display:inline;\r\n}\r\n\r\n.listFrame_left i\r\n{\r\n  padding: 8px; \r\n  font-size:16px;\r\n}\r\n\r\n.listFrame_left i:hover\r\n{\r\n  color: white; \r\n}\r\n.listFrame_left li.active i:hover\r\n{\r\n  color: black; \r\n}\r\n.listFrame_left i.activecheck\r\n{\r\n  __border-radius:50%;\r\n  __box-shadow: inset 0 0 20px green;\r\n  visibility:visible;\r\n}\r\n\r\n\r\n.KFormItemSettings .KFormItem_label\r\n{\r\n  width:40%;\r\n\r\n}\r\n\r\n.KFormItem\r\n{\r\n  padding:5px 5px;\r\n  margin:0px;\r\n  font-size:15px;\r\n}\r\n\r\n\r\n.KFormTitle\r\n{\r\n  margin-left:10px;\r\n}\r\n\r\n.KFormItem_rating\r\n{\r\n  border:px solid white;\r\n  width:auto;\r\n  display:inline-block;\r\n}\r\n\r\n.KFormItem label\r\n{\r\n  min-width: 150px;\r\n  position:relative;\r\n}\r\n\r\n.KFormItem_label /* this extra class is necessary for vertical layouts, see below*/\r\n{\r\n  display: inline-block; \r\n  text-align:left;\r\n  margin-right:10px;\r\n  text-align:right;\r\n  vertical-align:top;\r\n  position:relative;\r\n  font-weight:bold;\r\n\r\n}\r\n\r\n\r\n.KFormItem table\r\n{\r\n  border:1px solid gray;\r\n  padding:0px 5px 5px 5px;\r\n  border-collapse:collapse;\r\n  table-layout:fixed;\r\n}\r\n\r\n.KFormItem table  td\r\n{\r\n  padding:px;\r\n  width:37px;\r\n  text-align:center;\r\n}\r\n\r\n.KFormItem table tr:first-child td\r\n{\r\n  border-bottom:1px solid gray;\r\n\r\n}\r\n\r\n\r\n.KFormItem .small\r\n{\r\n  font-weight:normal;\r\n  font-size:12px;\r\n  padding:0px;\r\n  margin:-2px 3px -5px 2px;\r\n}\r\n\r\n.KFormItem input:hover \r\n{\r\n    -webkit-box-shadow:  0 0 2px 2px rgba(82,168,236,.9);\r\n\r\n}\r\n.KFormItem input[type=range]:hover\r\n{\r\n  -webkit-box-shadow:none;\r\n}\r\n\r\n.KFormItem input[type=radio],input[type=checkbox] \r\n{\r\n  transform: scale(1.5);\r\n  -webkit-transform: scale(1.5);\r\n  margin:5px 8px;\r\n}\r\n.KFormItem input[type=text], .KFormItem input[type=number], .KFormItem input[type=password]\r\n{\r\n  width:200px;\r\n  border-radius:4px; /*borderradius_tool*/\r\n\r\n}\r\n\r\n.KFormItem \r\n{\r\n __white-space:nowrap;\r\n}\r\n\r\n.KFormItem textarea.intentfield\r\n{\r\n  position:absolute;\r\n  height:12px !important;\r\n  width:60px !important;\r\n  resize:none;\r\n  overflow:hidden;\r\n  background:lightyellow;\r\n}\r\n\r\n.KFormItem textarea.intentfield:hover\r\n{\r\n  height:200px !important;\r\n  width:66% !important;\r\n  z-index:2;\r\n  resize:both;\r\n  overflow:scroll;\r\n  \r\n}\r\n\r\n.KFormItem textarea\r\n{\r\n  font-family:Courier New;\r\n  font-weight:bold;\r\n  height:auto;\r\n  width:70%;\r\n  \r\n  border-radius:4px; /*borderradius_tool*/\r\n\r\n}\r\n\r\n /* give this class to a parent of form to have labels vertical above elements */\r\n.KFormVertical .KFormItem_label\r\n{\r\n  _display:block;\r\n  _text-align:left;\r\n  _font-weight:bold;\r\n  ___border-top:1px solid hsl(0,0%,33%);\r\n}\r\n\r\n.KFormVertical select, .KFormVertical input, .KFormVertical input[type=radio], .KFormVertical input[type=checkbox],  .KFormVertical .KFormItem_rating, .KForm_markerpointrow\r\n{\r\n  margin-left:20px;\r\n}\r\n.KFormVertical .KFormItem_textdiv\r\n{\r\n  display:block;\r\n}\r\n.KFormVertical .markerpointrowd\r\n{\r\n  width:auto;\r\n  display:inline-block;\r\n}\r\n\r\n\r\n.KFormSeparator\r\n{\r\n  height:2px;\r\n  display:block;\r\n  background: gray;\r\n  opacity:.5;\r\n  dborder-radius:4px; /*borderradius_tool*/\r\n  margin-top:10px;\r\n  margin-bottom:10px;\r\n  box-sizing:border-box;\r\n  \r\n}\r\n\r\n.KFormInfo\r\n{\r\n  float: left;\r\n  font-size: 16px;\r\n  font-weight:bold;\r\n  color:yellow;\r\n  padding: 3px;\r\n\r\n}\r\n\r\n\r\n\r\n\r\n.KFormItem_formarray /* box for subform with dynamic number of fields */\r\n{\r\n  border:0px solid red;\r\n  font-size:14px;\r\n  font-weight:bold;\r\n  position:relative;\r\n  ___display:inline-block;\r\n  padding:9px 0px; \r\n  min-width:200px;\r\n}\r\n\r\n.KFormItem_formarray_menu\r\n{\r\n  min-height:20px;\r\n}\r\n\r\n.KFormItem_formarray_subform\r\n{\r\n  border:0px solid orange;\r\n  position:relative;\r\n  padding-left:30px;\r\n  _border-top:1px solid gray;\r\n  background: linear-gradient( to bottom right , hsl(0, 0%,22%), hsl(0, 0%,35%)); /*blockbackground*/\r\n  box-sizing:border-box;\r\n}\r\n\r\n.KFormItem_formarray_tool  /* create / delete new element */\r\n{\r\n  border:0px solid green;\r\n  display:inline-block;\r\n  font-size: 14px;\r\n  width: auto;\r\n  height: auto;\r\n  min-width:12px;\r\n  text-align:center;\r\n  background:none;\r\n  position:absolute;\r\n  top:0px;\r\n  right:0px;\r\n  padding-left:10px;\r\n  cursor:default;\r\n  ddfont-style:italic;\r\n}\r\n.KFormItem_formarray_autoid\r\n{\r\n  color:orange;\r\n  right:30px;\r\n  top:5px;\r\n\r\n}\r\n.KFormItem_formarray_tool  i\r\n{\r\n  margin-left:0px;\r\n  padding:6px 8px;\r\n \r\n}\r\n.KFormItem_formarray_tool i:hover\r\n{\r\n  background: #113355;\r\n  background:#226699; /*menucolor*/\r\n}\r\n\r\n\r\n.KFormItem_formarray_selectormenu\r\n{\r\n  position:absolute;\r\n  top:10px;\r\n  z-index:50;\r\n  _background:hsl(0,0%,50%);\r\n}\r\n\r\n.KFormItem_formarray_highligterline\r\n{\r\n  height:6px;\r\n  width:100%;\r\n}\r\n\r\n.KFormItem_formarray_selectormenu > div \r\n{\r\n  width:15px;\r\n  height:15px;\r\n  padding:4px;\r\n  border-right:1px solid hsl(0,0%,90%);\r\n}\r\n\r\n.KFormItem_formarray_selectormenu > div > div\r\n{\r\n  margin:0px;\r\n  width:15px;\r\n  height:15px;\r\n}\r\n\r\n.KFormItem_formarray_selectormenu > div:hover\r\n{\r\n  background:hsl(0,0%,40%);\r\n}\r\n\r\n.KFormItem_formarray_selectormenu > div.active\r\n{\r\n  border:1px solid hsl(0,0%,90%);\r\n  border-right:none;\r\n}\r\n.KFormItem_formarray_selectormenu > div.active > div\r\n{\r\n   width:20px;\r\n}\r\n\r\n\r\n.autoloaderitem\r\n{\r\n  __display: inline-block;\r\n}\r\n\r\n.autoloaderitem.KFormItem\r\n{\r\n  align-items:center;\r\n  vertical-align:top;\r\n}\r\n\r\n.autoloaderitem label\r\n{\r\n  __min-width: 0px !important;\r\n}\r\n\r\n.autoloaderitem input\r\n{\r\n  width:60px !important; \r\n\r\n}\r\n\r\n.autoloadvaroption\r\n{\r\n  width:95%;\r\n  height:25px;\r\n\r\n}\r\n.autoloadvaroption > span\r\n{\r\n  margin-left:20px;\r\n}\r\n\r\n.optioncolsel > div\r\n{\r\n  top:6px;\r\n}\r\n\r\n.autoloaderDIV\r\n{\r\n  position:relative;\r\n  margin:0px;\r\n  background:#113355; /*highlight*/\r\n  background: linear-gradient( to bottom right , hsl(0, 0%,22%), hsl(0, 0%,35%)); /*blockbackground*/\r\n  border-radius:0px;  \r\n  align-items:center;\r\n\r\n}\r\n\r\n.autoloaderToolbar\r\n{\r\n  position:absolute;\r\n  top:0;\r\n  right:0;\r\n  border:0px solid green;\r\n \r\n}\r\n.autoloaderToolbar  i\r\n{\r\n  padding: 10px 12px;; \r\n  font-size:20px;\r\n}\r\n\r\n.autoloaderToolbar  i:hover\r\n{\r\n   background:#226699; /*menucolor*/\r\n}\r\n\r\n\r\n.NiceButton > div /* this is a button*/\r\n{\r\n  display:block;\r\n  margin:8px 10px 8px 0px;\r\n  width:100%;\r\n  color:white;\r\n  font-size:25px;\r\n  text-align: center;\r\n  border : 0px solid white;\r\n  padding: 20px  0px;\r\n  cursor: pointer;\r\n  font-weight:normal;\r\n  overflow:hidden;\r\n  vertical-align: middle;\r\n\r\n  text-shadow:0px 2px 26px gray;\r\n  border-radius:3px;\r\n  box-shadow:2px 2px 5px 1px ;\r\n\r\n  background:#226699; /*menucolor*/\r\n}\r\n\r\n\r\n.NiceButton > div.green\r\n{\r\n  background: #008000; /* Old browsers */\r\n  background: linear-gradient(to bottom, #009900 50%,#008000 50%); /* W3C, IE10+*/\r\n}\r\n.NiceButton > div.green:hover\r\n{\r\n  background: #008000; /* Old browsers */\r\n}\r\n\r\n\r\n[draggable] {\r\n  -moz-user-select: none;\r\n  -khtml-user-select: none;\r\n  -webkit-user-select: none;\r\n  user-select: none;\r\n  /* Required to make elements draggable in old WebKit */\r\n  -khtml-user-drag: element;\r\n  -webkit-user-drag: element;\r\n}\r\n\r\n#dragimg {\r\n    position: absolute;\r\n    top: -1000;\r\n    right: 0;\r\n    z-index: -99;\r\n    padding:4px;\r\n    color:yellow;\r\n    background:#226699; /*menucolor*/\r\n    border:1px solid gray;\r\n    \r\n\r\n}\r\n\r\n.dragbox\r\n{\r\n    position: absolute;\r\n    z-index: 9999;\r\n    padding:4px;\r\n    background:none;\r\n    border:1px solid yellow;\r\n    pointer-events:none;\r\n}\r\n\r\n\r\n.modernbuttongroup\r\n{\r\n  display:flex;\r\n  flex-wrap: wrap;\r\n  _justify-content:center;\r\n  padding:10px 20px;\r\n}\r\n\r\n.modernbutton\r\n{\r\n  cursor: pointer;\r\n  background:hsl(206, 64%, 37%); /*modernbutton*/\r\n  opacity:0.8;\r\n  margin:8px;\r\n  min-width:200px;\r\n  height:40px;\r\n  line-height:40px;\r\n  text-align:center;\r\n  position:relative;\r\n  font-size:16px;\r\n  color:white;\r\n  font-weight:normal;\r\n  border-radius:5px;\r\n  white-space:nowrap;\r\n}\r\n\r\n.modernbutton.small\r\n{\r\n  min-width:50px;\r\n  padding:0px 10px;\r\n  height:30px;\r\n  line-height:30px;\r\n  text-align:center;\r\n  position:relative;\r\n  font-size:14px;\r\n}\r\n\r\n.modernbutton.tiny\r\n{\r\n  min-width:20px;\r\n  padding:0px 2px;\r\n  height:15px;\r\n  line-height:15px;\r\n  text-align:center;\r\n  position:relative;\r\n  font-size:12px;\r\n  margin:0px;\r\n}\r\n\r\n.modernbutton.auth\r\n{\r\n  left:20%;\r\n}\r\n\r\n.modernbutton.inactive\r\n{\r\n  opacity:0.2;\r\n  pointer-events:none;\r\n}\r\n\r\n.modernbutton i\r\n{\r\n  padding-right:10px;\r\n}\r\n\r\n\r\n.modernbutton:hover\r\n{\r\n opacity:1;\r\n}\r\n\r\n\r\n.authDialog\r\n{\r\n  position:absolute;\r\n  transform: translate(-50%, -50%);\r\n  left:50%;\r\n  top:40%;\r\n\r\n  \r\n}\r\n\r\n.green\r\n{\r\n  background: hsl(120, 100%, 25%);\r\n}\r\n.green:hover\r\n{\r\n  background: hsl(120, 100%, 27%);\r\n}\r\n.yellow\r\n{\r\n  background: hsl(50, 100%, 40%);\r\n}\r\n.yellow:hover\r\n{\r\n  background: hsl(50, 100%, 48%);\r\n}\r\n\r\n.red\r\n{\r\n  background: hsl(5, 100%, 25%);\r\n}\r\n.red:hover\r\n{\r\n  background: hsl(5, 100%, 30%);\r\n}\r\n\r\n.orange\r\n{\r\n  background: hsl(36, 100%, 50%)\r\n}\r\n.orange:hover\r\n{\r\n  background: hsl(36, 100%, 55%)\r\n}\r\n\r\n.pink\r\n{\r\n  background:hsl(322, 81%, 43%);\r\n}\r\n.pink:hover\r\n{\r\n  background: hsl(322, 81%, 53%)\r\n}\t \r\n\r\n.gray\r\n{\r\n  background: hsl(0, 0%, 50%);\r\n}\r\n.gray:hover\r\n{\r\n  background: hsl(0, 0%, 60%);\r\n}\r\n.darkgray\r\n{\r\n  background: hsl(0, 0%, 30%);\r\n}\r\n.darkgray:hover\r\n{\r\n  background: hsl(0, 0%, 35%);\r\n}\r\n\r\n.nocolor\r\n{\r\n  background: none;\r\n}\r\n.nocolor:hover\r\n{\r\n  background: none;\r\n}\r\n\r\n\r\n\r\n.loginContainer\r\n{\r\n  padding: 35px 15px;\r\n  margin:auto;\r\n  font-size:15px;\r\n  width: 450px;\r\n  margin-top: 100px;\r\n  text-align:center;\r\n  color: white;\r\n  \r\n  display: flex;\r\n  flex-direction:column;\r\n  justify-content: center; /* align horizontal */\r\n  align-items: center; /* align vertical */\r\n  color:white;\r\n  dfont-size:12px;\r\n  text-align: center;\r\n  vertical-align:middle;\r\n\r\n  border:2px solid;\r\n  border-color:#666666; /*bordercolor*/\r\n  border-radius:20px ;\r\n  background:hsl(0, 0%, 22%); /*windowbackground*/\r\n\r\n\r\n\r\n\r\n}\r\n\r\n.loginContainer a\r\n{\r\n  color:white!important;\r\n}\r\n\r\n.loginContainerFlex\r\n{\r\n  border:px solid red;\r\n  box-sizing:border-box;\r\n\r\n  display: flex;\r\n  justify-content: center; /* align horizontal */\r\n  align-items: center; /* align vertical */\r\n  margin:10px;\r\n  \r\n  min-width:300px;\r\n  font-size:17px;\r\n  text-align: center;\r\n  vertical-align:middle;\r\n  font-weight:normal;\r\n  border-radius:5px ;\r\n  \r\n  padding:10px;\r\n\r\n  color:white;\r\n  position:relative;\r\n  line-height:20px;\r\n} \r\n\r\n\r\n\r\ninput.loginContainerFlex \r\n{\r\n  border-radius:0px;\r\n\r\n  font-size:17px;\r\n  padding:6px 15px;\r\n  text-align:left;\r\n  -webkit-box-shadow: 0 0 0px 1000px #e6e6e6 inset;\r\n  border:2px solid #4d4d4d;\r\n  color:black;\r\n  display:block;\r\n  _width:90%;\r\n  margin:10px auto;\r\n  width:95%;\r\n}\r\n\r\n\r\ninput:required \r\n{ \r\n  \r\n}\r\n\r\ninput.loginContainerFlex:focus\r\n{\r\n  box-shadow: 0 0 0px 1000px hsl(0,0%,90%) inset;\r\n}\r\n\r\ninput.readonly\r\n{\r\n  -webkit-box-shadow: 0 0 0px 1000px hsl(0,0%,70%) inset;\r\n  box-shadow: 0 0 0px 1000px hsl(0,0%,70%) inset!important;\r\n  box-sizing:border-box;\r\n} \r\n\r\n.loginContainer .switcher\r\n{\r\n  width:320px;\r\n  line-height:20px;\r\n  display:flex;\r\n  font-size:18px;\r\n  margin: 0px 0px 30px 0px;\r\n  flex-direction:horizontal;\r\n  align-items:center;\r\n  justify-content:center;\r\n}\r\n\r\n.loginContainer .switcher:nth-of-type(2)\r\n{\r\n  border-bottom:1px solid hsl(0,0%,52%);\r\n}\r\n\r\n.loginContainer .switcher > div\r\n{\r\n  background:hsl(0,0%,32%);\r\n  border-radius:8px 8px 0px 0px;\r\n  flex-grow:1;\r\n  margin:0px 20px;\r\n  height:35px;\r\n  display:flex;\r\n  align-items:center;\r\n  justify-content:center;\r\n  cursor:pointer;\r\n\r\n}\r\n\r\n.loginContainer .switcher div:hover\r\n{\r\n  background:hsl(0,0%,39%);\r\n}\r\n\r\n.loginContainer .switcher .active\r\n{\r\n  background: hsl(120, 100%, 25%);\r\n  background:hsl(0,0%,52%);\r\n  font-weight:bold;\r\n}\r\n\r\n.loginContainer .switcher .active:hover\r\n{\r\n  background: hsl(120, 100%, 27%);\r\n  background:hsl(0,0%,62%);\r\n  font-weight:bold;\r\n}\r\n\r\n/* Let\'s get this party started */\r\n::-webkit-scrollbar {\r\n    width: 10px;\r\n    \r\n}\r\n\r\n \r\n::-webkit-scrollbar-track {\r\n    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.2); \r\n    -webkit-border-radius:0px; /*borderradius*/\r\n    border-radius:0px; /*borderradius*/\r\nbackground-clip:padding-box;    \r\n}\r\n \r\n::-webkit-scrollbar-thumb {\r\n    -webkit-border-radius:0px; /*borderradius*/\r\n    border-radius:0px; /*borderradius*/\r\n    background:#226699; /*menucolor*/\r\n    -webkit-box-shadow: inset 0 0 6px rgba(0,0,0,0.5);\r\n}\r\n::-webkit-scrollbar-thumb:window-inactive {\r\n\tbackground:#226699; /*menucolor*/\r\n}\r\n\r\n::-webkit-scrollbar-corner {\r\n  background: transparent\r\n}\r\n\r\n#KProgressFrame,#KLoadingFrame\r\n{\r\n  position:absolute;\r\n  color:#F0F0FF; /*menucolor_context*/  \r\n  background:#113355; /*highlight*/\r\n  width:100%;\r\n  height:100%;\r\n  opacity:1;\r\n  z-index:500;\r\n}\r\n\r\n#KLoadingFrame\r\n{\r\n  display:none;\r\n  z-index:501;\r\n}\r\n\r\n#KLoadingFrameText\r\n{\r\n  position:absolute;\r\n  transform: translate(-50%, -50%);\r\n  left:50%;\r\n  top:70%;\r\n  color:white;\r\n  opacity:1;\r\n  z-index:9999999999;\r\n}\r\n\r\n\r\n#KLoadingFrameText.CVR\r\n{\r\n  max-width:70%;\r\n  overflow:scroll;\r\n  max-height:30%;\r\n  white-space: pre  ;\r\n}\r\n\r\n#KLoadingFrameTypeString\r\n{\r\n  position:absolute;\r\n  transform: translate(-50%, -50%);\r\n  left:50%;\r\n  top:65%;\r\n  color:white;\r\n  opacity:0.3;\r\n  z-index:9999999999;\r\n  font-size:20px;\r\n  \r\n}\r\n\r\n#KLoadingFrame,#KProcFrame .thespinner\r\n{\r\n  position:absolute;\r\n  transform: translate(-50%, -50%);\r\n  left:50%;\r\n  top:50%; \r\n}\r\n\r\n#KLoadingFrame .thespinner\r\n{\r\n  position:absolute;\r\n  transform: translate(-50%, -50%);\r\n  left:50%;\r\n  top:50%; \r\n}\r\n\r\n\r\n\r\n#KProgressFrame .fa-spinner\r\n{\r\n  position:absolute;\r\n  left:40%;\r\n  top:45%;\r\n  opacity:0.9;\r\n  z-index:99999999999999;\r\n  \r\n}\r\n#KProgressFrame .fa-close\r\n{\r\n  position:absolute;\r\n  left:85%;\r\n  top:90%;\r\n  opacity:0.1;\r\n\r\n  z-index:99999999999999;\r\n  \r\n}\r\n#KProgressFrame .fa-close:hover\r\n{\r\n  position:absolute;\r\n  left:85%;\r\n  top:90%;\r\n  opacity:0.9;\r\n  color:red;\r\n  \r\n  z-index:99999999999999;\r\n  \r\n}\r\n\r\n\r\n\r\n#KLoadingFrame .fa-close\r\n{\r\n  position:absolute;\r\n  right:2%;\r\n  top:2%;\r\n  opacity:0.2;\r\n  z-index:99999999999999;  \r\n}\r\n\r\n#KLoadingFrame .fa-close:hover\r\n{\r\n  opacity:0.6;\r\n}\r\n\r\n\r\n\r\n.fileupload_tool\r\n{\r\n  height:17px;\r\n  horizontal:center;\r\n  padding-top:3px;\r\n  padding-right:2px;\r\n  padding-left:2px;\r\n  margin-left:5px;\r\n  background:#226699; /*menucolor*/\r\n  float:right;\r\n  \r\n}\r\n\r\n.fileupload_tool:hover\r\n{\r\n  background:#113355; /*highlight*/\r\n  \r\n}\r\n\r\n.modalWindow\r\n{\r\n  position:absolute;\r\n  width:100%;\r\n  height:100%;\r\n  top:0px;\r\n  background: rgba(100,100,100,0.95);\r\n  z-index:999999;\r\n  margin:0px;\r\n  text-align:center;\r\n  vertical-align:middle;\r\n  box-sizing:border-box;\r\n  display:flex;\r\n  justify-content:center;\r\n}\r\n\r\n.modalWindow > div /* this is the container*/\r\n{\r\n  background: gray;\r\n  __width:600px;\r\n  max-width:80%;\r\n  height:90%;\r\n  padding:30px;\r\n  margin:50px;\r\n  border:1px solid;\r\n  border-radius:10px;\r\n  text-align:left;\r\n  box-sizing:border-box;\r\n\r\n  display: flex;\r\n  flex-direction:column;\r\n}\r\n\r\n.modalWindow_controls \r\n{\r\n  display:flex;\r\n  flex-direction:row;\r\n  justify-content: center; /* align horizontal */\r\n  align-items: center; /* align vertical */\r\n}\r\n\r\n.modalWindow_controls > div\r\n{\r\n  flex-grow:1;\r\n  max-width:500px;\r\n}\r\n\r\n.modalWindow_message \r\n{\r\n  height: 20px;\r\n  padding:20px 10px 20px 10px;\r\n  font-size:18px;\r\n  color:rgba(200,0,0,1);;\r\n}\r\n\r\n.modalWindow_title\r\n{\r\n  line-height:35px;\r\n  font-size:30px;\r\n  margin-bottom:10px;\r\n  border-bottom:1px solid;\r\n}\r\n\r\n/* this is a standard notification with chapters and so on in modal window */\r\n.modalWindow_notificationText\r\n{\r\n  width:90%;\r\n  overflow:auto;\r\n  margin:20px auto;\r\n  font-size:18px;\r\n  line-height:22px;\r\n}\r\n\r\n.modalWindow_notificationText p\r\n{\r\n  margin-left:30px;\r\n  margin-bottom:10px;\r\n}\r\n\r\n\r\n.fileDropper\r\n{\r\n  padding:10px 10px;\r\n  margin: 0px 0px;\r\n}\r\n.fileDropper > div:first-child /* drop area */\r\n{\r\n  position:relative;\r\n  height:230px;\r\n  font-size:22px;\r\n  line-height:1.7;\r\n  text-align:center;\r\n  font-weight:bold;\r\n  color:lightgray;\r\n  vertical-align:middle;\r\n  border-radius:8px;\r\n  border:3px dashed;\r\n  background: rgba(39, 39, 39, 0.3);\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center; /* align horizontal */\r\n  align-items: center; /* align vertical */\r\n  margin: 20px 0px;\r\n}\r\n\r\n.fileDropper > div:first-child .progressSpinner /* drop area */\r\n{\r\n  top:0px;\r\n  position:absolute;\r\n  background:gray;\r\n  opacity:.9;\r\n  display:flex;\r\n  justify-content: center; /* align horizontal */\r\n  align-items: center; /* align vertical */\r\n  width: 100%;\r\n  height:100%;\r\n  color:green;\r\n\r\n}\r\n\r\n.fileDropper table td\r\n{\r\n  font-size:16px;\r\n  padding: 5px 10px 0px 0px;\r\n  width:100%;\r\n}\r\n\r\n.fileDropper table td i\r\n{\r\n}\r\n\r\n.fileDropper table td i:hover\r\n{\r\n  color:darkred;\r\n}\r\n\r\n.fileDropper table thead td\r\n{\r\n  font-weight:bold;\r\n  border-bottom: 1px solid white;\r\n  white-space:nowrap;\r\n  min-width:15px;\r\n}\r\n\r\n#powerdbydpx\r\n{\r\n  font-size:10px;\r\n  align-self: flex-start;\r\n  position:relative;\r\n  bottom:-60px;\r\n}\r\n\r\n#powerdbydpx a\r\n{\r\n  color:gray;\r\n  cursor:pointer;\r\n}\r\n\r\n\r\n\r\n\r\n.instanceselector\r\n{\r\n  padding: 65px 15px;\r\n  margin:auto;\r\n  font-size:15px;\r\n  width: 650px;\r\n  margin-top: 100px;\r\n  text-align:center;\r\n  color: white;\r\n  \r\n  display: flex;\r\n  flex-direction:column;\r\n  justify-content: center; /* align horizontal */\r\n  align-items: center; /* align vertical */\r\n  color:white;\r\n  dfont-size:12px;\r\n  text-align: center;\r\n  vertical-align:middle;\r\n\r\n  border:8px solid;\r\n  border-color:#666666; /*bordercolor*/\r\n  border-radius:20px ;\r\n  background:hsl(0, 0%, 22%);; /*windowbackground*/\r\n\r\n}\r\n\r\n\r\n.instanceselector .instancebox /* one selection */ \r\n{\r\n\r\n  display:flex;\r\n  vertical-align:middle;\r\n  flex-direction: column;\r\n  justify-content: center; /* align horizontal */\r\n  align-items: center; /* align vertical */\r\n  border: 0px solid red;\r\n  margin-top:20px;\r\n  width: 80%;\r\n  height:100%;\r\n\r\n}\r\n\r\n.instanceselector .instancebox .instanceelement /* one selection */ \r\n{\r\n\r\n  position:relative;\r\n  height:auto;\r\n  text-align:center;\r\n  \r\n  color:lightgray;\r\n  vertical-align:middle;\r\n  border-radius:8px;\r\n  border:0px solid;\r\n  background: #226699;\r\n  display: flex;\r\n  flex-direction: column;\r\n  justify-content: center; /* align horizontal */\r\n  align-items: center; /* align vertical */\r\n  margin: 30px 30px;\r\n  padding: 10px 10px;\r\n}\r\n.instanceselector .instancebox .instanceelement:hover /* one selection */ \r\n{\r\n  background: #1c537d;\r\n}\r\n\r\n.instanceselector .instancebox .instanceelement > div:nth-child(1) /* one selection */ \r\n{\r\n  font-size:25px;\r\n  font-weight:bold;\r\n  padding: 10px 10px;\r\n}\r\n.instanceselector .instancebox .instanceelement > div:nth-child(2) /* one selection */ \r\n{\r\n  font-size:15px;\r\n  color: #b3b3b3;\r\n}\r\n\r\n\r\n\r\n.centerdummy\r\n{\r\n   position: absolute;\r\n   z-index:999;\r\n   left:70%;\r\n   top:40%;\r\n}\r\n\r\n#KStartTour\r\n{\r\n   position:absolute;\r\n   transform: translate(-50%, -50%);\r\n   left:50%;\r\n   top:40%; \r\n   z-index:999;\r\n   color:black;\r\n   opacity:0.9;\r\n   background:lightgray;\r\n   border-radius:10px;\r\n   border: solid 2px green;\r\n   padding:20px;\r\n   font-size:20px;\r\n   line-height:1.3;\r\n}\r\n\r\n#KStartTour .modernbutton\r\n{\r\n   width:100px;\r\n   transform: translate(-50%, 0);\r\n   left:50%;\r\n   margin-top:30px;\r\n\r\n}\r\n\r\n\r\n.cancelTour\r\n{\r\n   position:absolute;\r\n   z-index:9999;\r\n   right:0%;\r\n   bottom:0%;\r\n   padding:4px;\r\n   margin:10px;\r\n   margin-bottom:13px;\r\n   background:lightgray;\r\n   opacity:0.8;\r\n   cursor:pointer;\r\n   border-radius:2px;\r\n   border: solid 2px green;\r\n   color:black;\r\n}\r\n\r\n.cancelTour:hover\r\n{\r\n  color:white !important;\r\n  background:red !important;\r\n}\r\n\r\n\r\n#KHighlighter\r\n{\r\n  position:absolute;\r\n  z-index:99999;\r\n  background:none;\r\n  color:black;\r\n  width:100%;\r\n  box-sizing:border-box;\r\n  border: 1px solid yellow;\r\n  background:yellow;\r\n  opacity:0.4;\r\n  pointer-events:none;\r\n  border-radius:4px;\r\n\r\n}\r\n\r\n.KRoistat\r\n{\r\n  \r\n  padding-left:20px;\r\n}\r\n\r\n.KRoistat_sub\r\n{\r\n  \r\n  padding-left:20px;\r\n}\r\n\r\n.mirror_roi_dimspan > span\r\n{\r\n  display:inline-block;\r\n  background:white; \r\n  min-width:25px;\r\n  height:19px;\r\n  padding:0px 5px;;\r\n  box-sizing:border-box;\r\n  border-radius:5px;\r\n  border:1px solid hsl(0,0%,0%);\r\n  background:hsl(0,0%,90%)!important;\r\n  text-align:center;\r\n}\r\n\r\n.mirror_roi_dimspan > span:hover\r\n{\r\n  background:hsl(0,0%,60%)!important;\r\n}\r\n\r\n\r\n\r\n.KJSONEditor\r\n{\r\n  box-sizing:border-box;\r\n  padding:0px;\r\n  display:flex;\r\n  flex-direction:column;\r\n  height:100%;\r\n  border:0px solid green;\r\n}\r\n\r\n.KJSONEditor textarea\r\n{\r\n  box-sizing:border-box;\r\n  width:100%;\r\n  flex-grow:1;\r\n  __dmin-height:500px;\r\n  \r\n  font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\r\n  font-size:13px;\r\n  padding:10px;\r\n  background: hsl(0,0%,26%);\r\n  color:hsl(0,0%,80%);\r\n  resize:none;\r\n  border:none;\r\n  ___box-shadow: inset 0 1px 19px 7px hsla(0,0%,23%,1);\r\n\r\n}\r\n\r\n.KJSONEditor_log\r\n{\r\n  width:100%;\r\n  min-height:30px;\r\n  padding:3px;\r\n  box-sizing:border-box;\r\n  __font-weight:bold;\r\n  background: hsl(0,0%,22%);\r\n  color: white;\r\n  font-weight:bold;\r\n }\r\n\r\n\r\n/* this is the ul */\r\n.KList\r\n{\r\n  position:relative;\r\n  display: block;\r\n  height: 100%;\r\n  width:  100%;\r\n  margin: 0px;\r\n  padding: 0px;\r\n  white-space:nowrap;\r\n \r\n}\r\n\r\n\r\n.KList a\r\n{\r\n  color:inherit;\r\n}\r\n.KList li\r\n{\r\n  padding:0px 9px ;\r\n  position: relative;\r\n  list-style: none;\r\n  display:inline-flex;\r\n  fjustify-content:space-between;\r\n  align-items:center;\r\n  height:100%;\r\n  fwidth:100%;\r\n  border-right: 1px solid gray;\r\n  border-collapse:collapse;\r\n  box-sizing:border-box;\r\n  z-index:99; /* this is important !!!! since the main frame is filling whole window */\r\n  cursor:pointer;\r\n  color: whitesmoke;\r\n  font-size:17px;\r\n  background:#226699; /*menucolor*/\r\n  __background:#226699; /*menucolor*/\r\n\r\n}\r\n\r\n.KList.KList_noflex li\r\n{\r\n    \r\n  overflow:hidden;\r\n  width:100%;\r\n}\r\n\r\n.KList li:hover\r\n{\r\n  __background:#F0F0FF; /*submenucolor*/\r\n  background:#226699; /*menucolor*/\r\n}\r\n.KList li.active\r\n{\r\n  background:hsl(0,0%,23%);\r\n  font-weight:bold;\r\n}\r\n.KList li.active:hover\r\n{\r\n  background:hsl(0,0%,60%);\r\n  background:#226699; /*menucolor*/\r\n  color:hsl(0, 0%, 90%);;\r\n}\r\n\r\n.KList li a\r\n{\r\n   flex-grow:1;\r\n   text-align:left;\r\n\r\n}\r\n.KList li i\r\n{\r\n   flex-grow:0;\r\n   text-align:right;\r\n   display:block;\r\n\t_right:5px;\r\n\t_top:4px;\r\n\tbackground:#DDD;\r\n\tpadding:3px;\r\n\tmargin-right:1px;\r\n\tborder-radius:4px;\r\n\tcolor:black !important;\r\n}\r\n\r\n.KList li i:hover\r\n{\r\n  color:red!important;\r\n}\r\n\r\n.flexright\r\n{  \r\n  flex-grow:1;\r\n  text-align:right;\r\n}\r\n\r\n\r\n\r\n/* inverted color scale */\r\n.KList_inverted li\r\n{\r\n   background:#F0F0FF; /*submenucolor*/\r\n   color:hsl(0,0%,0%);\r\n}\r\n.KList_inverted li:hover\r\n{\r\n  background:#F0F0FF; /*submenucolor*/\r\n}\r\n.KList_inverted li.active\r\n{\r\n  background:hsl(206, 64%, 37%); /*modernbutton*/\r\n  color:white;\r\n}\r\n.KList_inverted li.active:hover\r\n{\r\n  background:hsl(206, 64%, 42%); /*modernbutton*/\r\n}\r\n\r\n.KList_vertical li\r\n{\r\n  display:flex;\r\n  border-bottom:1px solid hsl(0, 0%,70%);\r\n  border-right:none;\r\n  height:33px;\r\n  \r\n}\r\n\r\n.KList_vertical li > div\r\n{\r\n  height:100%;\r\n  align-self:  flex-start ;\r\n  overflow-y:auto; \r\n}\r\n\r\n\r\n.KList_roundish \r\n{\r\n  background:none;\r\n  border-bottom:0px solid hsl(0, 0%,0%);\r\n  border-collapse:collapse;\r\n}\r\n\r\n.KList_roundish li \r\n{\r\n  padding:5px 15px;\r\n  margin:10px 8px 0px 10px;\r\n  margin:10px 10px 0px 0px;\r\n  _border-radius:10px;\r\n  _border-top-left-radius:4px;\r\n  _border-top-right-radius:4px;\r\n  border-top:1px solid hsl(0,0%,40%);\r\n  border-left:1px solid hsl(0,0%,50%);\r\n  border-right:1px solid hsl(0,0%,50%);\r\n  box-sizing:border-box;\r\n  border-collapse:collapse;\r\n  box-shadow: inset 0 -9px 12px -9px hsla(0,0%,3%, 0.7);\r\n  height:30px;\r\n  background:hsl(0, 0%, 12%);\r\n}\r\n\r\n.KList_roundish li.active\r\n{\r\n  border-bottom:none;\r\n  box-shadow: none;\r\n}\r\n\r\n.KList_static li\r\n{\r\n  cursor:default;\r\n}\r\n\r\n.KList_static li.active\r\n{\r\n  background:initial;\r\n}\r\n\r\n\r\nli.KListSpacer  \r\n{\r\n  background:none;\r\n  height:50px;\r\n  text-align:right;\r\n  padding-left:5px;\r\n  padding-top:20px;\r\n  font-style:italic;\r\n  font-weight:bold;\r\n}\r\nli.KListSpacer  a\r\n{\r\n  color:white;\r\n}\r\nli.KListSpacer:hover\r\n{\r\n  background:none;\r\n  cursor:default;\r\n}\r\n\r\n\r\n.KListItem.unsaved\r\n{\r\n  background:rgb(200,50,50);\r\n}\r\n\r\n.KListItem.unsaved i.fa-save\r\n{\r\n  background:rgb(200,50,50)!important;\r\n}\r\n\r\n.KListItem .cmdsavebut\r\n{\r\n  display:none;\r\n}\r\n.KListItem.unsaved .cmdsavebut\r\n{\r\n  display:block;\r\n}\r\n\r\n.KListItem_subgroup\r\n{\r\n\tpadding-left:0px;\r\n\r\n}\r\n.KListItem_subgroup i\r\n{\r\n\tbackground:none!important;\r\n\r\n}\r\n.KListItem_subgroup > li:first-child\r\n{\r\n\tbackground:hsl(0,0%,80%);\r\n}\r\n.KListItem_subitem\r\n{\r\n\tpadding-left:20px!important;\t\r\n}\r\n\r\n\r\n.KListItem.unsaved:hover\r\n{\r\n  background:rgb(200,50,50);\r\n}\r\n\r\n/* horizontal layout with left menu */\r\n\r\n.KListView\r\n{\r\n  display:flex;\r\n  background:none;\r\n  height:100%;\r\n  border-top:1px solid hsl(0, 0%,70%);\r\n  box-sizing:border-box;\r\n}\r\n\r\n.KListView > div\r\n{\r\n  height:100%;\r\n  align-self:flex-start ;\r\n  box-sizing:border-box;\r\n  overflow-y:auto; \r\n}\r\n.KListView > div:nth-child(1)\r\n{ \r\n  margin-top:-0px;\r\n  min-width:200px;\r\n}\r\n\r\n.KListView > div:nth-child(2)\r\n{\r\n  flex-grow:1;\r\n  border-left: 1px solid hsl(0, 0%,70%);\r\n}\r\n\r\n\r\n/* vertical layout with last child 100% and scroll */\r\n.KFlexVertical\r\n{\r\n  display:flex;\r\n  flex-direction:column;\r\n  overflow:hidden!important;\r\n  height:100%;\r\n}\r\n\r\n.KFlexVertical > div\r\n{\r\n  display:block;\r\n  box-sizing:border-box;\r\n}\r\n.KFlexVertical > div:last-child\r\n{\r\n  flex-grow:1;\r\n  height:100%;\r\n  overflow:scroll!important;\r\n}\r\n\r\n.spinnerbar\r\n{\r\n  display:inline-block;\r\n  border-color:yellow;\r\n  margin-top:3px;\r\n  border: solid 1px;\r\n  width:100px;\r\n  opacity:0.9;\r\n  height:10px;\r\n\r\n}\r\n\r\n.innerbar\r\n{\r\n  jdisplay:inline-block;\r\n  background:yellow;\r\n  opacity:0.7;\r\n  height:100%;\r\n  width:10%;\r\n}\r\n\r\n.KSyncBar\r\n{\r\n  border: solid 1px;\r\n  border-color:yellow;\r\n  border-radius:4px;\r\n  position:absolute;\r\n  height:30px;\r\n  background:green;\r\n  z-index:9999999;\r\n  width:50%;\r\n  right:2%;\r\n  bottom:2%;\r\n  overflow:hidden;\r\n  white-space: nowrap;\r\n  max-width:500px;\r\n   \r\n}\r\n\r\n.KSyncBar.upload\r\n{\r\n background:darkblue;\r\n}\r\n\r\n.KSyncBar .fa\r\n{\r\n  position:relative;\r\n  left:7px;\r\n  top:4px;\r\n}\r\n\r\n.KSyncBar .spinnerbar\r\n{\r\n  position:relative;\r\n  left:10px;\r\n  top:5px;\r\n}\r\n\r\n.KSyncBar .uploadtext\r\n{\r\n  white-space: nowrap;\r\n  position:relative;\r\n  left:20px;\r\n  top:4px;\r\n  color:yellow;\r\n  opacity:0.9;\r\n\r\n  border-radius:4px;\r\n  padding:3px;\r\n  display:inline-block;\r\n  \r\n}\r\n\r\n.KSyncBar .fa-close\r\n{\r\n   position:absolute;\r\n   left:95%;\r\n   top:7px;\r\n   background:yellow;\r\n   color:black;\r\n   padding:2px;\r\n   border-radius:2px;\r\n   opacity:0.7;\r\n   cursor:pointer;\r\n}\r\n\r\n.KSyncBar .fa-close:hover\r\n{\r\n  background:red;\r\n  color:white;\r\n}\r\n\r\n.KSyncBar .abortTitle\r\n{\r\n  position:absolute;\r\n  right:40px;\r\n  top:7px;\r\n}\r\n\r\n\r\n\r\n.terms_of_usage\r\n{\r\n  max-width:600px; \r\n  font-size:14px; \r\n  font-weight:normal; \r\n  text-align:justify;\r\n}\r\n\r\n\r\n/* notify changes */\r\n.notifyjs-corner\r\n{\r\n  margin-top:35px!important;\r\n}\r\n.notifyjs-DPX-base \r\n{\r\n  white-space: nowrap;\r\n  background-color: lightblue;\r\n  padding: 15px;\r\n  font-size:18px;\r\n  border-radius:5px;\r\n}\r\n.notifyjs-DPX-error \r\n{\r\n  color: white;\r\n  background-color: darkred;\r\n}\r\n.notifyjs-DPXMORE-error \r\n{\r\n  color: white;\r\n  background-color: darkred;\r\n  opacity:0.5;\r\n}\r\n\r\n.inactive_menu_point\r\n{\r\n  opacity:0.4;\r\n  pointer-events:none;\r\n}\r\n\r\n\r\n.emptylist\r\n{\r\n font-family:cursive;\r\n font-size:10px;\r\n}\r\n\r\n\r\n.KMouseSliderBtn\r\n{\r\n  position:relative;\r\n  width:15px;\r\n  text-align:center;\r\n  background:hsl(0,0%,50%);\r\n  __z-index:1;\r\n  right:-1px;\r\n  _height:9%;\r\n  display:inline-block;\r\n}\r\n.KMouseSliderBtn:hover\r\n{\r\n  background: hsl(0,0%,60%);\r\n}\r\n.KMouseSliderBtn i\r\n{\r\n  padding:3px;\r\n  font-size:14px;\r\n  dcolor: hsl(0,0%,0%);\r\n}\r\n\r\n\r\n\r\n.KMouseSliderIndicator\r\n{\r\n  z-index:40;\r\n  position:absolute;\r\n  width:4px;\r\n  height:4px;\r\n  border:0px solid red;\r\n  pointer-events:none;\r\n}\r\n\r\n.KMouseSliderIndicator_bg\r\n{\r\n  position:absolute;\r\n  height:100px;\r\n  width:12px;\r\n  border:0px solid red;\r\n  background:hsla(70,80%,80%, 1);\r\n  border-radius:6px;\r\n  bottom:0;\r\n  pointer-events:none;\r\n  transform: translate(-50%,0);\r\n  box-sizing:border-box;\r\n\r\n  __background:hsl(206, 64%, 32%); \r\n\r\n}\r\n\r\n.KMouseSliderIndicator_ball\r\n{\r\n  width:14px;\r\n  height:14px;\r\n  position:absolute; \r\n  border-radius:20px;\r\n  transform: translate(-50%,-25%);\r\n  box-sizing:border-box;\r\n\r\n  background:hsla(206, 64%, 37%,1); \r\n  -webkit-box-shadow:  0 0 5px 2px rgba(82,168,236,.9);\r\n  box-shadow:  0 0 5px 2px rgba(82,168,236,.9);\r\n\r\n}\r\n\r\n.KMouseSliderIndicator_currentval\r\n{\r\n  position:relative;\r\n  font-size:14px;\r\n  font-weight:bold;\r\n  z-index:5;\r\n  background:hsla(0,0%,20%,.8);\r\n  dtransform: translate(-50%,0);\r\n  width:30px;\r\n}\r\n\r\n.KMouseSliderIndicator_center\r\n{\r\n  width:6px;\r\n  height:4px;\r\n  position:absolute; \r\n  background:hsla(0, 0%, 27%,.5); \r\n  border-radius:0px;\r\n  transform: translate(-50%,0);\r\n}\r\n\r\n\r\n.KMouseSliderIndicator i\r\n{\r\n  position:absolute;\r\n  color:black;\r\n  width:100%;\r\n  text-align:center;\r\n  font-size:9px;\r\n}\r\n\r\n\r\n.alphaSlider\r\n{\r\n width:45px;\r\n float:right;\r\n font-size:13px;\r\n opacity:0.4;\r\n margin-top:-3px;\r\n \r\n}\r\n\r\n/*************  SBOX ***************   */\r\n.sbox\r\n{\r\n  position:absolute;\r\n  height: 500px;\r\n  width:500px;\r\n  top:100px;\r\n  left:100px;\r\n  z-index:1;\r\n  box-sizing:border-box;\r\n  resize:both;\r\n\r\n  border:1px solid white;\r\n\r\n}\r\n\r\n.sbox_vert\r\n{\r\n  position:relative;\r\n  overflow:hidden;\r\n  display:flex;\r\n  flex-direction:column;\r\n  resize: both;\r\n  height:100%;\r\n  box-sizing:border-box;\r\n\r\n  _background:red!important;\r\n  _border:2px solid yellow;\r\n\r\n}\r\n\r\n\r\n.sbox_horz\r\n{\r\n  position:relative;\r\n  overflow:hidden;\r\n  display:flex;\r\n  flex-direction:row;\r\n  box-sizing:border-box;\r\n\r\n  _background:gray;\r\n  _border:1px solid green;\r\n\r\n}\r\n\r\n\r\n.sbox_fixed\r\n{\r\n  height:100px;\r\n  flex-grow:0;\r\n  flex-shrink:0;\r\n  overflow:hidden;\r\n\r\n  _border:1px solid white;\r\n\r\n}\r\n\r\n.sbox_resizable\r\n{\r\n  flex-grow:1;  \r\n  overflow:hidden;\r\n}\r\n\r\n\r\n.resizer_horz_placeholder\r\n{\r\n  width:0px;\r\n  position:relative;\r\n  flex-grow:0;\r\n}\r\n\r\n\r\n.resizer_horz\r\n{\r\n  width:10px;\r\n  height:100%;\r\n  position:absolute;\r\n  transform: translate(-52%, 0);\r\n  cursor:ew-resize;\r\n  z-index:1;\r\n  border: 0px solid white;\r\n\r\n  _background:magenta;\r\n\r\n}\r\n\r\n\r\n.resizer_vert_placeholder\r\n{\r\n  width:100%;\r\n  height:0px;\r\n  position:relative;\r\n  flex-grow:0;\r\n}\r\n\r\n\r\n.resizer_vert\r\n{\r\n  width:100%;\r\n  height:10px;\r\n  position:absolute;\r\n  z-index:200;\r\n  transform: translate(0, -52%);\r\n  cursor:ns-resize;\r\n\r\n  _background:magenta;\r\n\r\n}\r\n\r\n.resizer_horz:hover\r\n{\r\n  background:rgba(82,168,236,1);\r\n -webkit-box-shadow:  0 0 10px 2px rgba(82,168,236,1);\r\n -box-shadow:  0 0 10px 2px rgba(82,168,236,1);\r\n}\r\n.resizer_vert:hover\r\n{\r\n  background:rgba(82,168,236,1);\r\n -webkit-box-shadow:  0 0 10px 2px rgba(82,168,236,1);\r\n -box-shadow:  0 0 2px 3px rgba(82,168,236,1);\r\n\r\n}\r\n.resizer_hovered\r\n{\r\n  background:rgba(82,168,236,1);\r\n -webkit-box-shadow:  0 0 10px 2px rgba(82,168,236,1);\r\n -box-shadow:  0 0 10px 2px rgba(82,168,236,1);\r\n}\r\n\r\n/*************  end of sbox ***************   */\r\n\r\n\r\n\r\n.KSwitch \r\n{\r\n  width: 40px;\r\n  height: 15px;\r\n  position: relative;\r\n  \r\n  box-shadow: inset 0px 1px 1px rgba(0, 0, 0, 0.5), 0px 1px 0px rgba(100, 100, 100, 0.6);\r\n  background:hsl(0,0%,50%);\r\n  _border:1px solid;\r\n  border-radius:20px;\r\n\r\n \r\n}\r\n\r\n.KSwitch:hover\r\n{\r\n  background:hsl(0,0%,58%);\r\n}\r\n\r\n\r\n\r\n.KSwitch_button\r\n{\r\n  _position:absolute;\r\n  background:linear-gradient(to top left, #555555, #FFFFFF); /*toolbutton*/\r\n  width:16px;\r\n  height:16px;\r\n  border-radius:10px;\r\n  top:2px;\r\n  transition: all 250ms ease;\r\n  margin-left:2px;\r\n}\r\n\r\n.KSwitch_disabled\r\n{\r\n}\r\n\r\n.KSwitch_enabled\r\n{\r\n  background:linear-gradient(to top left, #113355, #4488FF); /*toolbutton*/\r\n  margin-left: calc(100% - 18px);\r\n}\r\n\r\n.admin_dialog_logfilecontent\r\n{\r\n  overflow:auto;\r\n  white-space:nowrap;\r\n  background:white;\r\n  color:black;\r\n  height:100%;\r\n  padding:4px;\r\n  -webkit-touch-callout: text;/* iOS Safari */\r\n  -webkit-user-select: text;/* Chrome/Safari/Opera */\r\n  -khtml-user-select: text;/* Konqueror */\r\n  -moz-user-select: text;/* Firefox */\r\n  -ms-user-select: text;/* IE/Edge */\r\n  user-select: text;\r\n\r\n}\r\n.admin_dialog_logfilecontent a\r\n{\r\n  color:green;\r\n  cursor:pointer;\r\n}\r\n\r\n.admin_dialog_logfile_tools\r\n{\r\n  position:absolute;\r\n  top:40px;\r\n  right:0px;\r\n  opacity:1;\r\n}\r\n\r\n.Kpatientbarbutton\r\n{\r\n  background:transparent !important;\r\n}\r\n\r\n.Kpatientbarbutton .fa\r\n{\r\n box-sizing:border-box;\r\n border:0px solid white;\r\n border-radius: 3px;\r\n background:gray;\r\n padding-top:2px;\r\n padding-bottom:1px;\r\n box-shadow: 2px 2px 2px hsla(0, 0%, 0%, 1);\r\n}\r\n\r\n.Kpatientbarbutton .fa-plus\r\n{\r\n  width:50px;\r\n}\r\n\r\n.Kpatientbarbutton:hover .fa\r\n{\r\n  background:white !important;\r\n  box-shadow: 2px 2px 2px hsla(0, 0%, 0%, 0);\r\n\r\n}\r\n\r\n\r\n\r\n\r\n\r\n/* ///// IHE */\r\n\r\n\r\n\r\n.KViewPort_formViewer header.level1\r\n\t{\r\n\tfont-family:"Arial";\r\n\tfont-size:medium;\r\n\tfont-weight:bold;\r\n\tmargin-top: 0.3cm;\r\n\tmargin-bottom: 0.0cm;\r\n\t}\r\n.KViewPort_formViewer header.level2\r\n\t{\r\n\ttext-align:left;\r\n\tfont-family:"Arial";\r\n\tfont-size:small;\r\n\tfont-weight:bold;\r\n\tmargin-top: 0.3cm;\r\n\tmargin-bottom: 0.0cm;\r\n\t}\r\n.KViewPort_formViewer section.level1\r\n\t{\r\n\t} \r\n.KViewPort_formViewer section.level2\r\n\t{\r\n\tpadding-left: 0.8cm;\r\n\t} \r\n\r\n\r\n\r\n\r\n.KViewPort_formViewer  section.level2\r\n\t{\r\n\tpadding-left: 0.8cm;\r\n\t} \r\n.KViewPort_formViewer p\r\n\t{\r\n\tpadding-left: 0.8cm;\r\n\tmargin-top: 0.0cm;\r\n\tmargin-bottom: 0.0cm;\r\n\t}\r\n.KViewPort_formViewer table, .KViewPort_formViewer tr, .KViewPort_formViewer td, .KViewPort_formViewer th\r\n\t{\r\n\tbackground-color:#E6E6E6;\r\n\tborder:1px solid black;\r\n\tborder-collapse: collapse;\r\n\tpadding: 0.1cm; \r\n\tmargin-left: 0.8cm;\r\n\t}\r\n\r\ntemplate-head, template_data, template_UI, template_name, exam_characteristics, exam_code, term, code_meaning, code_value, coding_scheme_designator, exam_code, modality, body_site, subspecialty, contrast, gender, indication, patient_life_stage, provider_group, owner, contributors, parent_template, sanctioning_body, language, top_level_flag, creation_date, revision_number, retired_flag\r\n\t{\r\n\tdisplay: none; \r\n\t}\r\n.KViewPort_formViewer  section_data, template_section_name, template_section_required, template_section_interleaved, template_section_level\r\n\t{\r\n\tdisplay: none; \r\n\t}\r\n.KViewPort_formViewer  textarea\r\n\t{\r\n\twidth: 90%; height: 80px;\r\n\tdisplay:block;\r\n\t}\r\n\t\r\n.KViewPort_formViewer  input[type="text"]\r\n\t{\r\n\twidth: 50em;\r\n\t}\r\n.KViewPort_formViewer  input[type="number"]\r\n\t{\r\n\twidth: 6em;\r\n\t}\r\n.KViewPort_formViewer  select {\r\n\tmax-width: 55em;\r\n\t\r\n}\t\r\n\r\n.pacsquery_tools_container\r\n{\r\n  _background:red;\r\n  _width:400px;\r\n  position:relative;\r\n  height:99%;\r\n}\r\n\r\n.pacsquery_rightcontainer\r\n{\r\n  flex-grow:1;\r\n   height:100%;\r\n}\r\n\r\n.pacsquery_rightcontainer > div:first-child\r\n{\r\n  min-height:90px;\r\n  flex-grow:0;\r\n}\r\n\r\n.pacsquery_resultscontainer table\r\n{\r\n  width:100%;\r\n}\r\n\r\n.fpacsquery_resultscontainer table td:first-child\r\n{\r\n  width:10px; \r\n  max-width:10px;\r\n  min-width:10px; \r\n}\r\n\r\n.pacsquery_tools\r\n{\r\n  background:hsla(0, 0%, 22%, .5);\r\n  padding:0px; \r\n  width:150px;\r\n \r\n  display:flex;\r\n  padding:2px 10px;\r\n  flex-direction:column;\r\n  height:100%;\r\n  border-right:1px solid hsl(0,0%,50%);  \r\n}\r\n\r\n.pacsquery_tools select\r\n{\r\n  height:22px;\r\n}\r\n\r\n.pacsquery_tools_caption\r\n{\r\n  margin-top:5px;\r\n  border-top:1px solid hsl(0,0%,50%);  \r\n  padding:4px;\r\n}\r\n\r\n.pacsquery_dropindicator\r\n{\r\n  position:absolute;\r\n  height:100%;\r\n  width: 100%;\r\n  text-align:middle;\r\n  align-items:middle;\r\n  text-align:center;\r\n  vertical-align:middle;\r\n  padding-top:20%;\r\n  font-size:30px;\r\n  z-index:2;\r\n  background:hsla(0,0%,50%,.8);\r\n  display:none;\r\n  line-height:40px;\r\n}\r\n\r\n.pacsquery_progressbox\r\n{\r\n  position:absolute;\r\n  bottom:100px;\r\n  right:20px;\r\n  padding:10px;\r\n  min-width:180px;\r\n  min-height:80px;\r\n\r\n  border: solid 1px;\r\n  border-color:yellow;\r\n  border-radius:6px;\r\n  background:green;\r\n  z-index:9999999;\r\n  overflow:hidden;\r\n  white-space: nowrap;\r\n  max-width:500px;\r\n\r\n\r\n}\r\n\r\n\r\n\r\n.pacsquery_progressbox table\r\n{\r\n  width:100%;\r\n}\r\n.pacsquery_progressbox td:nth-child(2)\r\n{\r\n  text-align:right;\r\n  font-weight:bold;\r\n}\r\n.pacsquery_title\r\n{\r\n  font-weight:bold;\r\n  border-bottom:1px solid yellow;\r\n  margin-bottom:5px;\r\n  padding:2px;\r\n}\r\n\r\n.pacsquery_dumplist\r\n{\r\n  display:flex;\r\n  flex-direction:column;\r\n  border:1px solid gray;\r\n  border-collapse:collapse;\r\n  min-width:300px;\r\n  margin:10px;\r\n\r\n}\r\n.pacsquery_dumplist > div:first-child\r\n{\r\n  background:gray;\r\n}\r\n.pacsquery_dumplist table\r\n{\r\n  border:1px solid gray;\r\n  border-collapse:collapse;\r\n  width:100%;\r\n\r\n}\r\n.pacsquery_dumplist table td\r\n{\r\n  border:1px solid gray;\r\n  border-collapse:collapse;\r\n \r\n}\r\n\r\n.pacsquery_studiestable \r\n{\r\n  white-space:nowrap;\r\n  position: relative;\r\n  box-sizing: border-box;\r\n  font-size:11pt;\r\n  width:20px;\r\n}\r\n\r\n\r\n.pacsquery_studiestable  td \r\n{\r\n   text-overflow: clip!important;\r\n   _padding:1px 5px;\r\n}\r\n \r\n\r\n.pacsquery_graydiv_search\r\n{\r\n  position:absolute;\r\n  display:flex;\r\n  flex-direction:column;\r\n  align-items:center;\r\n  width:100%;\r\n  height:100%;\r\n  background:hsla(0,0%,0%,.8);\r\n  top:0px;\r\n  text-align:center;\r\n}\r\n.pacsquery_graydiv_search > div\r\n{\r\n  _margin:auto;\r\n  _width:100%;\r\n}\r\n\r\n#KProcFrame\r\n{\r\n  top:0;\r\n  left:0;\r\n  position:absolute;\r\n  color:#F0F0FF; \r\n  background:linear-gradient(to top left, #113355, #4466AA);\r\n  width:100%;\r\n  height:100%;\r\n  opacity:1;\r\n  z-index:1600;\r\n   border: 1px solid green;\r\n}\r\n\r\n.Kautoexecform .KFormItem\r\n{\r\n  posiction:relative;\r\n  bsackground:red;\r\n  display:inline-block;\r\n\r\n}\r\n\r\n.Kautoexecform .selectuserbatch\r\n{\r\n  font-size:18px !important;\r\n}\r\n.Kautoexecform input\r\n{\r\n  width:20px !important;\r\n}\r\n.Kautoexecform textarea\r\n{\r\n  height:30px !important;\r\n  width:350px !important;\r\n}\r\n\r\n.Kautoexecform label\r\n{\r\n  width:40px;\r\n}\r\n\r\n/********************************\r\n   KTagPanel    \r\n*********************************/\r\n.KTagPanel_tagcontainer\r\n{\r\n\tdisplay:flex;\r\n\tflex-direction:row;\r\n\tmin-width:220px!important;\r\n}\r\n\r\n.KTagPanel_taglistdiv\r\n{\r\n\tborder-right:1px solid hsl(0,0%,70%);\r\n\tflex-grow:1;\r\n}\r\n\r\n.KTagPanel_taglisttitle\r\n{\r\n\tfont-weight:bold;\r\n\tborder-bottom:1px solid hsl(0,0%,70%);\r\n\twhite-space:nowrap;\r\n\tpadding:1px 3px;\r\n}\r\n.KTagPanel_taglisttitle i\r\n{\r\n\tpadding:2px 7px;\r\n\tborder-radius:6px;\r\n}\r\n.KTagPanel_taglisttitle i:hover\r\n{\r\n\t_background:hsl(0,0%,20%);\r\n\tcolor:hsl(0,0%,60%);\r\n\tcursor:pointer;\r\n}\r\n\r\n.KTagPanel_editbox\r\n{\r\n\tposition:absolute;\r\n\tbackground: hsl(0,0%,50%);\r\n\twidth:100%;\r\n\tmin-height:300px;\r\n\tdisplay:flex;\r\n\tflex-direction:column;\r\n\tleft:-0%;\r\n\ttop:25px;\r\n\r\n}\r\n.KTagPanel_editbox > div:first-child \r\n{\r\n\tdisplay:flex;\r\n\tflex-direction:row;\r\n\theight:100%;\r\n}\r\n\r\n\r\n.KTagPanel_editbox textarea\r\n{\r\n\tflex-grow:1;\r\n\tbox-sizing:border-box;\r\n    resize:vertical;\r\n    min-height:200px;\r\n}\r\n\r\n.KTagPanel_taglist\r\n{\r\n\tdisplay:flex;\r\n\tflex-direction:column;\r\n}\r\n\r\n.KTagPanel_tagitem \r\n{\r\n\tdisplay:flex;\r\n\talign-items:center;\r\n\tcursor:pointer;\r\n}\r\n\r\n.KTagPanel_tagitem .KTagPatient:hover\r\n{\r\n    box-shadow:  0 0 5px 3px rgba(82,168,236,.9);\r\n}\r\n\r\n.KTagPanel_tagitem i\r\n{\r\n\tcolor:lightgreen;\r\n} \r\n\r\n.KTagPanel_tagitem_disabled .KTagPatient\r\n{\r\n\tbackground:hsl(0,0%,30%);\r\n\tcolor:hsl(0,10%,80%);\r\n\tborder-color:hsl(0,0%,50%);\r\n}\r\n\r\n.KTagPanel_tagitem_shortcut\r\n{\r\n\tpadding: 0px 5px;\r\n\tfont-size:12px;\r\n}\r\n\r\n\r\n/********************************\r\n   KExcelList    \r\n*********************************/\r\n\r\n.KExcelList_tcontainer\r\n{\r\n\tdisplay:flex;\r\n\theight:100%;\r\n}\r\n\r\n.KExcelList_icontainer\r\n{\r\n\tmargin-right:5px;\r\n\t_border-right:1px solid hsl(0,0%,40%);\r\n\theight:100%;\r\n\tmin-width:170px;\r\n}\r\n.KExcelList_icontainer_toolbar\r\n{\r\n\theight:100px;\r\n\tdisplay:flex;\r\n\tflex-direction:column;\r\n\tmargin:0px;\r\n\tjustify-content:center;\r\n}\r\n\r\n.KExcelList_icontainer_toolbar .modernbutton\r\n{\r\n\tborder-radius:4px;\r\n\tmargin:4px;\r\n\tline-height:1;\r\n\theight:15px;\r\n\tcursor:pointer;\r\n\tpadding:3px 8px;;\r\n}\r\n\r\n.KExcelList_summary\r\n{\r\n\tbackground:hsl(0,5%,60%);\r\n\tcolor:black;\r\n\tpadding:0px 4px;\r\n\theight:32px;\r\n\tfont-size:12px;\r\n}\r\n\r\n.KExcelList_tcontainer textarea\r\n{\r\n\tresize:none;\r\n\ttext-overflow:hidden;\r\n\tfont-size:12px;\r\n\tdisplay:block;\r\n\twidth:100%;\r\n\tborder:none;\r\n\tbox-sizing:border-box;\r\n\t_margin:auto;\r\n\r\n}\r\n\r\n.KExcelList_ititle\r\n{\r\n\tfont-size:20px;\r\n\ttext-align:center;\r\n\tbackground:#527527;\r\n\tpadding:4px;\r\n}\r\n\r\n.KExcelList_tcontainer table\r\n{\r\n\tborder-collapse:collapse;\r\n\tbackground:hsl(0,0%,80%);\r\n\tcolor:hsl(0,0%,10%);\r\n\twidth:100%;\r\n}\r\n.KExcelList_tcontainer table td\r\n{\r\n\tborder:1px solid hsl(0,0%,50%);\r\n\tborder-collapse:collapse;\r\n\tmargin:0px;\r\n\tpadding:2px 3px;\r\n\tfont-size:14px;\r\n\ttext-overflow:hidden;\r\n}\r\n\r\n.patientTableContextmenu hr\r\n{\r\n\tmargin:1px;\r\n}\r\n',""]),t.exports=n},function(t,n,e){(n=e(3)(!1)).push([t.i,'#KView_mainFrame\n{\n   -webkit-touch-callout: none;\n    -webkit-user-select: none;\n    -khtml-user-select: none;\n    -moz-user-select: none;\n    -ms-user-select: none;\n    user-select: none;\n\n  position:relative;\n  display: table;\n  border:0px solid white;\n  margin: 0px;\n  background-color: none;\n  height:100%;\n  width:100%;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n\n  font-family: Arial, sans-serif;  \n\n\n}\n\n#KView_mainSpinner\n{\n  top:50%;\n  left:100px;\n  position:absolute;\n  font-size:20px;\n}\n\n.BORDER_BOX\n{\n -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n\n}\n\n.KView_DIVCell\n{\n  line-height:1;\n  background:black;\n  display:table-cell;\n  border: 0px solid yellow;\n  vertical-align: top;\n  height: 100%;\n  border-collapse:collapse;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n}\n\n.KView_viewportNumerator\n{\n    position:absolute;\n    top:50%;\n    left:50%;\n    z-index:1;\n    font-size:30px;\n    color:  yellow;\n    transform: translate(-50%,-50%);\n    opacity:0.25;\n    pointer-events:none;\n    text-align:center;\n\n}\n\n\n/*\n#KViewPort_container_number1 {   background-color:#111; }\n#KViewPort_container_number2 {   background-color:#111; }\n#KViewPort_container_number5 {   background-color:#111; }\n#KViewPort_container_number6 {   background-color:#111; }\n#KViewPort_container_number9 {   background-color:#111; }\n#KViewPort_container_number11 {   background-color:#111; }\n#KViewPort_container_number15 {   background-color:#222; }\n#KViewPort_container_number16 {   background-color:#111; }\n#KViewPort_container_number17 {   background-color:#222; }\n*/\n\n\n\n.KView_viewportNumerator img\n{\n  \n   width:100%;\n/*    position:absolute;\n    z-index:1;\n    width:80%;\n    height:80%;\n    sfont-size:300px;\n    color:  #229966;\n    transform: translate(-50%,-50%);\n    opacity:0.12;\n    pointer-events:none;\n    */\n\n  /*\n  position:absolute;\n  left:20%; \n  top:20%; \n  width:120%\n  */\n}\n\n.dropindicator_general_vert\n{\n    position:absolute;\n    \n    height:100%; /* do not! sizing wrong!!*/\n    __width:100%;\n    height:calc(85%);\n    \n    z-index:900;\n    padding:0px; /*this important! for size calculations!*/\n    _margin:39px;\n    \n    display:flex;\n    flex-direction: column;\n    align-items:   center; \n    justify-content: center;\n    \n    background: rgba(100, 100, 100, 0.8);\n    box-sizing:border-box;\n}\n\n.dropindicator_general_vert > div\n{\n  font-size:18px;\n  line-height:20px;\n  text-align:center;\n  text-shadow: 1px 1px 1px #000;\n  font-weight:normal;\n  color:  lightgray;\n  border-radius:8px;\n  padding:15px;\n  margin: 10px 10px;;\n  background: rgba(139, 0, 0, 0.6);\n\n  display: flex;\n  justify-content: center; \n  align-items: center; \n  flex-grow:1;\n  dmin-width:400px;\n  width:70%;\n  height:100%;\n}\n.dropindicator_general_vert > div:hover\n{\n  background: rgba(0,139,139,0.6);\n}\n\n\n\n\n\n.KView_viewportdropIndicator\n{\n    position:absolute;\n    top:50%;\n    right:0%;\n    z-index:90000;\n    transform: translate(00%,-50%);\n    padding:20px;\n    display:flex;\n    flex-wrap: nowrap;\n    flex-direction: column;\n    align-items: flex-end; \n    justify-content:         flex-end;\n    background: rgba(0, 0, 100, 0.0);\n    width: calc(200px - 2px) !important;\n    height:calc(100% - 2px) !important;\n    box-sizing:border-box;\n    __border:1px solid red;\n}\n\n.KView_viewportdropIndicator > div\n{\n  box-sizing:content-box;\n  line-height:1;\n  font-size:18px;\n  line-height:auto;\n  text-align:center;\n  text-shadow: 1px 1px 1px #000;\n  font-weight:normal;\n  vertical-align:middle;\n  color:  lightgray;\n  border: 0px solid rgba(0,139,139,.8);\n  border-radius:8px;\n  padding:15px;\n  padding-top:30px;\n  margin: 10px;\n  background: none;\n  background: rgba(139, 0, 0, 0.6);\n\n  edisplay: flex;\n  justify-content: center; \n  align-items: center; \n\n  height:70px !important;\n\n}\n\n\n.KView_viewportdropIndicator > div > div\n{\n  \n  width:100%;\n  font-size:15px;\n  border:1px solid gray;\n  border-radius:3px;\n  height:23px !important;\n  white-space: nowrap;\n  padding:1px;\n  padding-left:6px;\n  padding-right:6px;\n  margin-top:10px;\n  margin-left:-5px;\n     \n}\n\n\n/* autoloader dropper */\n.KView_autoloader_dropIndicator\n{\n    position:absolute;\n    z-index:9990099;\n    padding:0px;\n    margin:0px;\n    display:flex;\n    flex-direction:column;\n    background: rgba(00, 10, 00, 0.7);\n    box-sizing:border-box;\n    border:0px solid red;\n    font-size:15px;\n}\n\n.KView_autoloader_dropIndicator > div\n{\n  padding-top:10px;\n  text-align:center;\n  line-height:15px;;\n}\n\n/* this is the container for the elements*/\n.KView_autoloader_dropIndicator > div:nth-child(2)\n{\n  flex-grow:1;\n  display:flex;\n  flex-direction: horizontal;\n  dbackground:red;\n  flex-wrap:wrap;\n  border:0px solid green;\n\n}\n\n/* this is an element*/\n.KView_autoloader_dropIndicator > div > div\n{\n \n  font-weight:normal;\n  color:  hsl(0,0%,90%);\n  border: 0px solid rgba(0,139,139,.8);\n  border-radius:18px;\n  \n  margin: 30px;\n  padding-top:20px;\n  background: rgba(139, 0, 0, 0.6);\n  box-shadow: none; /*0px 0px 30px 20px rgba(130, 0, 0, 0.6);*/\n  \n  display: flex;\n  flex-direction: column;\n  djustify-content: center; /* align horizontal */\n  align-items: center; /* align vertical */\n  flex-grow:0;\n  min-width:300px;\n  max-height:400px;\n\n  _max-width:400px;\n}\n\n.KView_autoloader_dropIndicator > div > div:hover\n{\n  /* what a pitty this does not work on a drag event, need dragster! */\n}\n\n.KView_autoloader_dropIndicator > div > div > div\n{\n  padding:5px;\n  margin:5px;\n  background: rgba(53, 0, 0, 0.9);\n  line-height:25px;\n  border-radius:10px;\n  text-align:left;\n\n}\n.KView_autoloader_dropIndicator > div > div > div:first-child\n{\n  font-size:20px;\n  background:none;\n  text-shadow: 1px 1px 1px #000;\n\n}\n.KView_autoloader_dropIndicator > div > div > div:last-child\n{\n  font-size:20px;\n  background:none;\n  text-shadow: 1px 1px 1px #000;\n  display:none;\n\n}\n\n\n\n\n\n\n\n#KView_viewportContainer\n{\n  margin-top:0px;\n  border:0px solid yellow;\n  doverflow: hidden;\n  display: flex;\n  height:100%;\n  width:100% ;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n   flex-wrap: wrap;\n  dbackground: #001122;\n  position:relative;\n\n  \n}\n\n.KViewPort_container.resizebar-x\n{\n  border-right: 3px solid #990;\n}\n.KViewPort_container.resizebar-y\n{\n  border-top: 3px solid #990;\n}\n\n\n.KViewPort_container\n  {\n    position: relative;\n    background-color:black;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    border-collapse:collapse;\n    overflow:hidden;\n    vertical-align:top;\n    border:1px solid hsla(206, 64%, 37%,0.3);\n    margin: 0px;\n    flex: 1 1 auto;\n    min-width:20px;\n    min-height:20px;\n\n   -webkit-user-select: none;/* Chrome/Safari/Opera */\n     \n}\n\n\n#KView_toolbarLeft\n{\n  margin-left:-2px;\n  height: 100%;\n  width: 35px;\n  padding: 0px;\n  color:white;\n  border: none;\n  display: inline-block;\n    -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  position:relative;\n  \n}\n\n.KView_toolbarLeft_disableDIV\n{\n  position:absolute;\n  background:hsla(0,0%,20%,.9);\n  z-index:;\n  top:0px;\n  left:2px;\n  width:32px;\n  height:100%;\n\n}\n\n.KView_toolbarTop_disableDIV\n{\n  position:absolute;\n  background:hsla(0,0%,20%,.8);\n  z-index:;\n  top:0px;\n  left:0px;\n  width:100%;\n  height:300%;\n  overflow:show;\n  z-index:20;\n}\n\n\n#autoloaderButtonDIV > ul ul\n{\n/*  transform: translate(0%, -50%);*/\n}\n\n\n/*empty placeholder with zero height*/\n.resizer_vertical\n{\n  height:100%;\n  width:0px;\n  position:absolute;\n  background:red;\n  z-index:30000;\n  left:0px;\n  top:0px;\n}\n/* the hover area */\n.resizer_vertical > div\n{\n  width:8px;\n  height:100%;\n  background:none;\n  position:relative;\n  transform: translate(0px, 0);\n  cursor:ew-resize;\n}\n/*the hover glow*/\n.resizer_vertical > div > div\n{\n  width:2px;\n  height:100%;\n  background:none;\n  position:relative;\n  transform: translate(3px, 0%);\n}\n.resizer_vertical > div:hover > div\n{\n    background:rgba(82,168,236, 1);\n   -webkit-box-shadow:  0 0 2px 2px rgba(82,168,236, 1);\n}\n\n\n.ddresizer_vertical\n{\n  position:absolute;\n  height:100%;\n  width:1px;\n  background: red;\n  left:0px;\n  top:0px;\n}\n\n\n.KView_tool\n{\n  line-height:1;\n  box-sizing:content-box;\n  color:white;\n  position:relative;\n  float: none;\n  margin: 0px 3px 3px 3px;\n  font-size: 20px;\n  font-weight:bold;\n  _font-family: cursive;\n  border: 0px solid gray;\n  width: 20px;\n  height: 20px;\n  background-color:#b1b1b1;\n  display: block;\n  text-align: center;\n  vertical-align: center;\n  padding: 5px;\n  border-radius:0px; /*borderradius_button*/\n  wbox-shadow:2px 2px 2px 0px #444444;\n  cursor: default;\n}\n\n.KView_tool_small\n{\n  margin-top:2px;\n  \n  width:10px;\n  height:11px;\n  margin-left:0px;\n  font-size:12px;\n  background:#444;\n  \n}\n\n.KToolsTopMenu > li:nth-child(2)\n{\n  margin-left:35px;\n}\n\n.KToolsTopMenu \n{\n  font-size:14px;\n  z-index:2;\n  background:#551111; /*toolstopmenucolor*/\n\n}\n\n.KToolsdragger > i \n{\n   color:white;\n   margin: 5px 0px 0px 8px;\n\n}\n.KToolsdragger\n{\n  \n  height:23px;\n  width:30px;\n  height:25px;  \n  background:rgba(50,50,50,0.5);\n  display:inline-block;\n  position:absolute;\n  z-index:3;\n  border-radius:5px;\n}\n\n.KTool_leftdiv\n{\n  margin-top:25px;\n  fbackground: linear-gradient(to bottom, #111 0%, #333 100%);\n  position:absolute;\n  width:21px;\n  height: auto;\n  opacity:0.1;\n  right:0px;  \n  border-left: 1px solid white;\n  z-index:0;\n r-moz-border-image: -moz-linear-gradient(top, #3acfd5 0%, #3a4ed5 100%);\n  r-webkit-border-image: -webkit-linear-gradient(top, #3acfd5 0%, #3a4ed5 100%);\n  border-image: linear-gradient(to bottom, #111 0%, #333 100%);\n  border-image-slice: 1;\n  \n  opacity:0.1;\n  padding-top:5px;\n  padding-bottom:5px;\n  padding-left:2px;\n  background: #111;\n}\n\n\n.KTool_leftdiv.LDvisible\n{\n  opacity:1;\n  width:21px;\n}\n\n.KViewPort_container > .annotation_tool > .KTool_leftdiv\n{\n  right:5px;\n\n}\n\n\n\n.KView_tool.inactive\n{\n  pointer-events:none;\n  opacity:0.5;\n}\n\n.KView_tool_blue\n{\n   background:#226699; /*menucolor*/\n}\n\n.KView_tool:hover\n{\n  background-color:#ebebeb;\n  color: black;\n\n}\n\n.KView_tool  > ul\n{\n  visibility:hidden;\n  opacity:0;\n  transition:visibility  ease-in 0.3s,opacity 0.3s ease-in;\n}\n\n.KView_tool:hover  > ul\n{\n   /*display:block;*/\n   visibility:visible;\n   opacity:1;\n   transition-delay:0.2s;\n}\n\n\n.KView_tool_enabled:hover\n{\n   background:#113355; /*highlight*/\n   color: rgb(200,200,200);\n}\n\n\n.KView_tool_enabled\n{ \n   background:linear-gradient(to top left, #113355, #4466AA); /*toolbutton*/\n   hbackground:#113355; /*highlight*/\n   aaacolor:black;\n}\n\n.KView_tool_enabled_green\n{\n  background:hsl(120, 100%, 25%)!important;\n}\n\n\n.KView_tool_menu\n{\n  position: absolute;\n  z-index: 9999;\n  padding: 0 ;\n  margin: 0;\n  height: auto;\n  width:auto;\n  left:100%;\n  top:0;\n\n  background: #E6E6E6;\n  color: black;\n\n  white-space: nowrap;\n  font-size:14px;\n  font-weight:normal;\n  text-shadow: 0 1px 1px rgba(255, 255, 255, .9);\n  text-align: left;\n  border-radius:0px; /*borderradius*/\n  box-shadow: 10px 10px 15px hsla(0, 0%, 15%, .7); \n\n\n}\n\n\n\n.KTool_leftdiv .KView_tool_menu\n{\n  left:initial;\n  right:100%;\n}\n\n\n\n\n.KView_tool_menu li\n{\n  padding:  7px 8px 6px 8px;\n  margin: 0;\n  dheight: 20px;\n  position: relative;\n  list-style: none;\n  border: none;\n  background: #E6E6E6;\n  border: none;\n  color: #666;\n  display:flex;\n  flex-direction:horizontal;\n}\n\n.KView_tool_menu li .KView_tool_menu_titleedit\n{\n  margin-right:8px;\n  margin-left:0px;\n}\n\n.KView_tool_menu  i\n{\n  border:0px solid black;\n  text-align:right;\n  margin-left:15px;\n  font-size:13px;\n}\n.KView_tool_menu  i.fa-power-off:hover\n{\n  color:red;\n}\n.KView_tool_menu i:hover\n{\n  color:hsl(0,0%,60%);\n  color: hsl(206, 64%, 77%);\n  _text-shadow: 0 1px 1px rgba(0, 0, 0, .5);\n}\n\n.KView_tool_menu li >  span\n{\n  flex-grow:1;\n}\n\n\n.KView_tool_menu span\n{\n    white-space: nowrap;\n}\n\n.KView_tool_menu  ul\n{\n  padding: 0;\n}\n.KView_tool_menu li ul\n{\n  display: none;\n}\n\n.KView_tool_menu li:hover\n{\n  background:#113355; /*highlight*/\n  color: #FFF !important;\n  text-shadow: 0 1px 1px rgba(0, 0, 0, .1);\n}\n\n.KView_tool_menu > li:first-of-type   \n{\n  border-bottom: 1px solid gray; \n}\n\n.KView_tool_menu > li:first-of-type:hover   \n{\n  background:initial;\n  color: #666!important;\n  text-shadow: initial!important;\n}\n\n.KView_tool_menu li:hover > ul\n{\n  display:block;\n  \n}\n\n.KView_tool_menu  li > ul\n{\n  float:left;\n  position:absolute;\n  top:0;\n  left:100%;\n}\n\n\n.KView_tool_menu li:after \n{ \n  clear: both; \n}\n\n.KView_tool_menu_layoutSelectorParent\n{\n  height:173px;\n}\n\n\n.KView_tool_menu_layoutSelectorTable\n{width:90px;height:142px;border:0px solid green;border-spacing: 3px;display:inline-block;box-sizing:content-box;line-height:1;border-collapse: separate;text-indent: initial;/* white-space: normal; *//* line-height: normal; *//* font-weight: normal; *//* font-size: medium; *//* font-style: normal; */color: -internal-quirk-inherit;/* text-align: start; *//* border-spacing: 2px; *//* font-variant: normal; */}\n\n.floatports \n{\n  position:relative;\n  top:3px;\n  margin-left:5px;\n  \n}\n\n.floatports .fa\n{\n    border:1px solid #666666;\n    background:lightgray;\n    width:20px;\n    text-align:center;\n    margin:2px;\n    border-radius:3px;\n    padding:3px 0px 3px 0px;\n}\n\n.floatports .fa:hover\n{\n  background:darkgray;\n  color:white;\n}\n\n\n.vertport\n{\n  position:relative;\n  _background:red;\n  display:inline-block;\n  border:1px solid #666666;\n  height:134px;  \n  width:20px;\n  top:0px !important;\n  margin:3px;\n}\n\n.KView_tool_menu_layoutSelectorTable  td\n{\n  height:21px;\n  width: 20px;\n  border:2px solid #666666;\n  box-sizing:border-box;\n\n  \n}\n\n.KView_tool_menu_layoutSelectorTable_td_hovered\n{\n  background:black !important;\n  \n}\n\n\n.KView_tool_menu_layoutSelectorTable_active\n{\n  background:gray;\n  position:relative;\n  _left:100px;\n}\n\n\n\n.KView_tool_sep\n{\n   margin: 10px 3px 3px 3px;\n\n   background-color:green;\n   acolor:black;\n}\n\n\n\n\n\n\n\n.KViewPort_canvas\n{\n  border:0px solid white;\n  height:100%;\n  width:100%;\n  margin-top: 0px;\n  margin-top: 0px;\n  z-index: 1;\n  image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */\n  image-rendering: -webkit-optimize-contrast; /* Safari                        */\n  image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */\n  image-rendering: pixelated;\n  ttttransform: scale(1, -1);\n  \n  position:absolute;\n\n  background-color:none;\n\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n\n}\n\n.KViewPort_canvas_pixelated\n{\n  image-rendering: auto;\n}\n\n\n.KViewPort_canvas3D\n{\n  border:0px solid white;\n  height:100%;\n  width:100%;\n  margin-top: 0px;\n  margin-top: 0px;\n  z-index: 1;\n  image-rendering: -moz-crisp-edges;          /* FF 6.0+                       */\n  image-rendering: -webkit-optimize-contrast; /* Safari                        */\n  image-rendering: -o-crisp-edges;            /* OS X & Windows Opera (12.02+) */\n  image-rendering: pixelated;\n\n  position:absolute;\n  top:0px;\n\n   background-color:none;\n\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  cursor:default;\n\n}\n\n\n\n.KViewPort_overlay_canvas\n{\n  border:5px solid white;\n  height:100%;\n  width:100%;\n  z-index: 999;\n\n  background-color: rgba(255,2,255,0.4);\n\n  position:relative;\n\n  background-color:none;\n  box-sizing: border-box;\n\n\n}\n\n\n\n\n.KViewPort_description\n{\n  border:0px solid blue;\n  background-color:none;\n  display: inline-block;\n  position:absolute;\n  z-index:3;\n  text-align:left;\n  padding: 8px;\n  color: white;\n  font-size: 15pt;\n  font-weight:normal;\n}\n\n\n\n.KViewPort_textBox\n{\n  color:#C1C1C1;\n  border: none;\n  width: 100%;\n  height: 100%;\n  display: block;\n  padding:20px;\n  margin-top: 25px;\n}\n\n.KViewPort_textBox textarea\n{\n  font-size: 16px;\n  background-color:black;\n  color:#F0F0F0;\n  width: 90%;\n  height: 90%;\n  min-height: 150px;\n\n  padding:0px;\n  margin-bottom: 10px;\n  border: 0px solid gray;\n\n}\n\n\n.KViewPort_title\n{\n font-size:15px; \n z-index:1;\n color:yellow;\n padding:1px 4px; \n background: rgba(100,100,100,.2);\n position:relative;\n top:3px;\n left:2px;\n text-shadow:1px 1px 1px hsl(0,0%,10%);\n}\n\n.KViewPort_img\n{\n  border:0px solid green;\n  cursor: pointer;\n  position:absolute;\n  background-color:none;\n\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  __height:calc(100% - 40px) !important;  \n  __top:25px !important;\n}\n\n\n.KViewPort_tableViewer_outerDiv\n{\n  overflow:scroll;\n  width:100%;\n  position:relative;\n  height:95%;\n  top:8px;\n}\n\n.KViewPort_tableViewer \n{\n\n  border:0px solid green;\n  height:auto;\n  width:100%;\n  position:relative;\n  background-color: #000000;\n  font-size:12px;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  z-index:5;\n  border-collapse: collapse;\n  overflow:scroll;\n}\n\n.KViewPort_tableViewer.tablelayoutfixed\n{\n  table-layout:fixed;  \n}\n\n.KViewPort_tableViewer td \n{\n border-left:1px solid #aaa;\n border-bottom:1px solid #aaa;\n padding-left:8px;\n padding-right:8px;\n box-sizing: border-box;\n border-collapse: collapse;\n max-width:150px;\n position:relative;\n overflow:hidden;\n}\n\n.KViewPort_tableViewer td > span\n{\n\n  overflow:hidden;\n  display:block;\n  pointer-events:none;\n  text-overflow: ellipsis;\n  white-space: nowrap;\n  margin: -1px; \n}\n\n\n.KViewPort_tableViewer tbody td:hover > span\n{\n  width:initial;\n  position:relative;\n  overflow: visible; \n  background:#F0F0FF; /*submenucolor*/  \n  z-index:1;\n  display: inline-block;\n  border: 1px dotted;\n  margin: -2px; \n\n}\n\n.KViewPort_tableViewer \n{\n  background:#F0F0FF; /*tableentry*/\n}\n.KViewPort_tableViewer tr \n{\n  dbackground:#F0F0FF; /*tableentry*/\n  color:black;\n  cursor:inherit;\n}\n\n.KViewPort_tableViewer tr.selected\n{\n  color:black; \n  background:lightblue;   \n}\n\n\n.KViewPort_tableViewer tr.selectedBold\n{\n  color:black; \n  background:lightgreen;\n}\n\n\n.KViewPort_tableViewer  tr\n{\n    overflow:auto;\n    text-overflow: ellipsis;\n}\n\n.KViewPort_tableViewer  tr.excluded\n{\n  background:red;\n}\n\n.KViewPort_tableViewer thead\n{\n  background:lightgray;\n}\n\n.KViewPort_tableViewer thead td\n{\n\n  z-index:2;\n  color:black;\n  border-right: 1px solid green;\n  cursor:inherit;\n  background:lightgray;\n\n \n}\n.tabcolselected\n{ \n  background-color:yellow !important;\n}\n.tabcolselectedALT\n{ \n  background-color:green !important;\n}\n\n.KchartOptions:hover\n{\n  width:30%;\n  height:auto;  \n  opacity:1;\n\n}\n\n.KchartOptions > div\n{\n  display:none;\n}\n\n.KchartOptions:hover > div\n{\n  display:block;\n}\n.KchartOptions\n{\n  position:absolute !important;\n  z-index:100;\n  background:lightgray;\n  margin-top:2px;\n  margin-right:2px;\n  border-radius:5px !important;\n  border:3px solid gray;\n  padding:3px !important;\n  right:0px;\n  height:20px;\n  overflow:hidden;\n  width:20px;\n  height:20px;\n  opacity:0.3;\n  color:black !important;\n  box-shadow: 2px 2px 9px gray;\n\n\n}\n\n\n.Kchartstats\n{\n  position:absolute !important;\n  z-index:100;\n  background:lightgray;\n  margin-top:2px;\n  margin-right:2px;\n  border-radius:5px !important;\n  border:3px solid gray;\n  padding:3px !important;\n  left:0px;\n  height:20px;\n  overflow:hidden;\n  width:20px;\n  height:20px;\n  opacity:0.3;\n  color:black !important;\n  box-shadow: 2px 2px 9px gray;\n    \n\n\n}\n\n.Kchartstats:hover,.visible\n{\n  width:50%;\n  height:auto;  \n  opacity:1;\n\n}\n\n.Kchartstats.visible > div\n{\n  display:block;\n}\n.Kchartstats:hover > div\n{\n  display:block;\n}\n\n\n\n\n.Kchartstats > div > div\n{\n  margin-left:20px;\n \n}\n.Kchartstats > div > div:first-child\n{\n  margin-left:0px;\n\n  font-weight:bold;\n}\n\n.Kchartstats > div\n{\n  display:none;\n  margin-top:5px;\n}\n\n\n.KViewPort_txtViewer\n{\n  display:inline-block;\n  padding:4px;\n  margin:2px;\n  margin-top:8px;\n  border:3px solid gray;\n  height:calc(100% - 30px) !important;  \n\n  width:100%;\n  position:relative;\n  background-color: hsl(0,0%,60%);\n  color:black;\n  scolor: #CCCC00;\n  font-size:14px;\n  overflow:auto;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  white-space:pre-wrap;\n\n}\n\n.KViewPort_txtViewer h3 \n{\n  padding:2px 4px;\n  margin:10px 2px 2px 0px;\n  _background:hsl(0,0%,50%);\n  border-bottom:1px solid hsl(0,0%,30%);\n}\n\n.KViewPort_txtViewer div\n{\n  padding:2px 0px;\n  margin:10px 2px 2px 0px;\n  font-size:14px;\n  font-weight:bold;\n}\n\n.KViewPort_txtViewer .sr_ok\n{\n  background:green;\n  color:white;\n  padding:2px;\n  margin-right:10px;\n  border-radius:4px;\n  font-weight:bold;\n}\n.KViewPort_txtViewer .sr_not_ok\n{\n  background:red;\n  color:white;\n  padding:2px;\n  margin-right:10px;\n  border-radius:4px;\n  font-weight:bold;\n}\n\n.KViewPort_txtViewer p\n{\n  margin:5px;\n  margin-left:10px;\n  color:hsl(0,0%,8%);\n  __background:green;\n}\n\n\n.KViewPort_jsonViewer\n{\n  width:100%;\n\n  height:calc(100% - 0px) !important;  \n  margin-top:-17px;\n  padding-top:20px;\n\n  position:relative; \n  background:hsl(0, 0%, 22%); /*windowbackground*/\n  __color: black;\n  font-size:12px;\n\n  overflow:auto;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n\n}\n\n\n.KViewPort_formViewer\n{\n  width:100%;\n  display:flex;\n  flex-direction:column;\n  flex-grow:1;\n  height:calc(100% - 0px) !important;\n    \n  margin-top:20px;\n  padding-bottom:40px;\n  padding-top:20px;\n\n  position:relative; \n  background: linear-gradient( to bottom right , hsl(0, 0%,22%), hsl(0, 0%,35%)); /*blockbackground*/\n\n  __color: black;\n  font-size:12px;\n\n  z-index:0;\n  overflow:auto;\n  box-sizing: border-box;\n\n\n}\n.KViewPort_formViewer_pinfobar\n{\n\n\n  position:absolute;\n  top:20px;\n  width:100%;\n  color:#EE6 !important;\n  padding-left:4px;\n  font-size:12px;\n  box-sizing: border-box;\n  dheight:90px;\n  border-bottom:1px solid hsl(0, 0%,42%);\n  margin-top:-20px;\n  margin-bottom:10px;\n  z-index:2;\n  cursor:default;\n  background:#222;\n\n}\n\n\n.KViewPort_ViewerJS\n{\n  border:0px solid green;\n  height:calc(100% - 30px) !important;  \n  width:100%;\n  position:relative;\n  overflow:none;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n\n}\n\n\n.KViewPort_zoomedPort\n{\n  border:1px solid;\n  border-color:#666666; /*bordercolor*/\n  z-index: 1000;\n  visibility: hidden;\n  padding:auto;\n  height: -moz-calc(100% -0px);\n  height: -webkit-calc(100% -0px);\n  /*minus8*/\n  position: absolute;\n  margin:2px;\n  margin-left:2px;\n  sleft:0 ;\n  htop:0;\n  dddtransform: translate(-50%, 0);\n\n \n  background-color:black;\n   -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  overflow:hidden;\n\n}\n\n\n\n.KViewPort_canvascontainer\n{\n  position:relative;\n  soverflow: hidden;\n  padding:0px;\n  border:0px solid green;\n  width: 100%;\n  height:100%;\n  top: 0px;\n }\n\n.floatingViewporthidetitle .KViewPort_container\n{\n  box-sizing:border-box;\n  border:2px solid gray !important;\n  border-radius:10px;\n  box-shadow: 2px 2px 9px hsla(0,0%,50%,.7);\n  \n}\n\n.KViewPort_icontainer\n{\n  /*z-index:2;*/\n  border:0px solid;\n  border-color:#666666; /*bordercolor*/\n  width:100%;\n  dheight:100%;\n  top:0px;\n  left:0px;\n  overflow:hidden; \n  position:relative;\n  display: block;\n  background-color:black;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  box-sizing: border-box;\n  vertical-align:top;\n  border-radius:0px; /*borderradius*/\n}\n\n.noBorder\n{\n  border: 0px solid !important;\n}\n\n\n.KViewPort_toolbar\n{\n  border: 0px solid #FFFF75;\n  xbackground-color:yellow;\n  vertical-align: top;\n  position: absolute;\n  right:0;\n  display:block;\n  z-index:3;\n  text-align:right;\n  color: none;\n  padding: 0px;\n  cursor: default;\n  pointer-events:none;\n}\n\n.KViewPort_statusbar\n{\n  opacity:0.4;\n  text-align:right;\n  position:absolute;\n  bottom:0px;\n  right:0px;\n  width:30%;\n  min-width:200px;\n  z-index:500;\n\n\n}\n\n.KViewPort_layoutbar\n{\n\n  ffloat: right;\n  border: 0px solid #FFFF75;\n  vertical-align: top;\n  position: absolute;\n  right:0;\n  bottom:10%;\n  margin-left:auto;\n  margin-right:0px;\n  display: inline-block;\n\n  text-align:right;\n  color: none;\n  padding: 0px;\n  cursor: default;\n  z-index:3;\n\n}\n\n.thumb3d\n{\n  background:red;\n  height:30px !important;\n  width:30px !important;\n\n}\n\n.layout3dshortcut\n{\n  font-size:12px !important;\n  background:gray;\n  border-radius:2px !important;\n}\n\n.KViewPort_tool_layout\n{\n  font-size: 18px;\n  \n  margin: 3px;\n  border: 0px solid gray;\n  width: auto;\n  height: auto;\n  min-width:15px;\n  text-align:center;\n  \n  color:#FFF;\n  display: block;\n  padding: 3px;\n  font-family: Arial, sans-serif;  \n  border-radius:0px; /*borderradius_smallbutton*/\n  text-shadow:1px 1px 1px hsl(0,0%,30%);\n\n  \n\n}\n\n.KViewPort_tool_layout i\n{\n  margin:auto;\n}\n\n.KViewPort_tool_layout svg\n{  \n  transform:scale(1.7);\n  margin-bottom:4px;\n}\n\n.KViewPort_tool_layout:hover\n{\n  \n  color:orange;\n}\n\n.KViewPort_tool b\n{\n  font-family: Arial, sans-serif;  \n}\n\n.KViewPort_tool\n{\n  line-height:1;\n  box-sizing:content-box;\n  font-size: 14px;\n  margin: 0px;\n  border: 0px solid transparent;\n  min-width:15px;\n  text-align:center;\n  background:linear-gradient(to top left, #113355, #4466AA); /*toolbutton*/\n  color:#BBB;\n  padding: 3px 6px 5px 6px;\n  border-radius:0px; /*borderradius_smallbutton*/\n  width: auto;\n  height: 15px;\n  overflow:hidden;\n  pointer-events:all;\n  \n  display:inline-block;\n\n\n}\n\n.KViewPort_tool > div\n{\n\n}\n\n\n\n.KViewPort_movie_tool\n{\n  font-size: 12px;\n  min-width:15px;\n  text-align:center;\n  background:linear-gradient(to top left, #113355, #4466AA); /*toolbutton*/\n  color:#BBB;\n  display: inline-block;\n  padding: 3px;\n  font-family: Arial, sans-serif;  \n}\n\n.KViewPort_movie_tool:hover\n{\n  background:#AAAAAA;\n  color:black;\n}\n\n.KTimeRangeSlider:hover::after\n{\n  content:"use mousewheel";\n  position:absolute;\n  top:-18px;\n  font-size:15px;\n  color:white;\n}\n\n.KViewPort_tool_cmap .fa-empty\n{\n  opacity:0.5;\n  border-radius:2px;\n  background: red; /* For browsers that do not support gradients */\n  /* For Safari 5.1 to 6.0 */\n  xbackground: -webkit-linear-gradient(top,red,orange,yellow,green,lightblue);\n  /* For Opera 11.1 to 12.0 */\n  xbackground: -o-linear-gradient(top,red,orange,yellow,green,lightblue);\n  /* For Fx 3.6 to 15 */\n  xbackground: -moz-linear-gradient(top,red,orange,yellow,green,lightblue);\n  /* Standard syntax */\n  background: linear-gradient(to top,red,orange,yellow,green,lightblue);\n  color:black;\n}\n\n\n.KColorMenuItem\n{\n  position:absolute;\n  height:25px;\n  left:0;\n  top:-5px;\n  opacity:0.4;\n  width:95%;\n}\n\n.KViewPort_tool:hover\n{\n  background:#AAAAAA;\n  color:black;\n}\n\n.KViewPort_tool.overlaycaption\n{\n   background:linear-gradient(to top left, #008D7A, #80B2E6); /*overlay*/\n}\n.KViewPort_tool.overlay\n{\n   background:linear-gradient(to top left, #008D7A, #80B2E6); /*overlay*/\n}\n.KViewPort_tool.overlay:hover\n{\n  background:#AAAAAA;\n}\n\n.KViewPort_tool.overlay .fa\n{\n  pointer-events:none;\n}\n\n\n.KViewPort_tool.draganddrop\n{\n   background: linear-gradblackient(to top left, #998D7A, #AAAAAA);\n   border-bottom-left-radius:10px;\n   border:solid 1px gray;\n   color:yellow !important;\n   \n   height:13px;\n   margin-bottom:0px;\n   font-size: 13px;   \n   \n  \n}\n.KTool_hidden\n{\n  opacity:0;\n  min-width:0px !important;\n  width:0px;\n  transition : all 0.5s ease-in;\n}\n\n.KTool_displaynone\n{\n  display:none;\n}\n\n.KToolbarSep\n{\n  position:relative;\n  display:block;\n  dpointer-events:all;\n  border: 0px solid black;\n  eebackground: linear-gradient(-90deg, #AAA, #111); \n  opacity:1;\n  white-space: nowrap;\n  padding-bottom:2px;\n}\n\n.Kmintoolsep\n{\n   position:relative;\n   top:-6px;\n   left:-20px;\n   pointer-events:all; \n   display:inline-block;\n}\n\n\n.KViewPort_tool\n{\n  position:relative;\n}\n\n.Kmintoolsep .fa\n{\n    color:gray;\n    font-weight:bold;\n}\n\n.Kmintoolsep .fa:hover\n{\n   color:orange;\n}\n.KToolbarSep.minimized \n{\n  left:2px;\n  min-height:20px;\n  max-height:40px;\n  overflow-y:scroll;\n  padding-right:0px;\n  margin-right:0px;\n  \n\n}\n\n.KToolbarSep.minimized > .caption\n{\n   line-height:4px;\n   font-weight:bold;\n}\n\n.KToolbarSep.minimized > div:not(.Kmintoolsep) > .fa\n{\n   line-height:5px !important;\n   font-size:6px;\n   \n}\n\n.KToolbarSep.minimized > .Kmintoolsep\n{\n  left:-10px;   \n  top:2px;\n}\n\n\n.KToolbarSep.minimized > div:not(.Kmintoolsep)\n{\n  height:5px;\n  padding:2px;\n  font-size:9px;\n\n}\n\n\n.KToolbar_sticky:hover\n{\n  opacity:1;\n  background:transparent !important;\n  color:orange;\n}\n.KToolbar_sticky\n{\n  opacity:0.4; \n  background:transparent;\n  color:gray;\n  width:30px;\n  float:right;\n}\n\n.KViewPort_tool.surface\n{\n   background: linear-gradient(to top left, #998D7A, #AA6);\n   color:black;\n}\n.KViewPort_tool.fibers\n{\n   background: linear-gradient(to top left, #998D7A, #FAA);\n   color:black;\n}\n\n\n.KViewPort_tool.roi\n{\n   background: linear-gradient(to top left, #77F, #99F);\n   color:black;\n}\n\n.KViewPort_tool.atlas\n{\n   background: linear-gradient(to top left, #FF7, #FFF);\n   color:black;\n}\n\n\n.KViewPort_tool.cmat\n{\n   background: linear-gradient(to top left, #AA1, #FFF);\n   color:black;\n}\n.KViewPort_tool.current\n{\n   background: linear-gradient(to top left, #FFFFAA, #FFFFFF);\n}\n.KViewPort_tool.current:hover\n{\n    background: linear-gradient(to top left, #FFFFFF, #FFFFFF);\n}\n\n.KViewPort_tool.caption\n{\n   background: linear-gradient(to top left, #444444, #666666);\n   color:white;\n   opacity:0.8;   \n   font-size: 14px;   \n   height:14px;\n   padding-top:3px;\n   padding-bottom:6px;\n\n}\n\n.KViewPort_tool.caption.equalwidth\n{\n   width:80px;\n   text-overflow:ellipsis;\n   text-align:left;\n}\n\n.KViewPort_tool.caption.current\n{\n   background:  linear-gradient(to top left, #FFFFAA, #FFFFFF);\n   color:black;\n\n}\n\n.KViewPort_tool.caption.current\n{\n  opacity:1 !important;\n}\n\n\n.KViewPort_tool.caption.highlight\n{\n  background:#99C2EB;\n\n}\n\n\n\n.KViewPort_tool.fibers.disabled:hover\n{\n   background: linear-gradient(to top left, #444444, #666666);\n}\n.KViewPort_tool:hover\n{\n  background:#99C2EB;\n}\n\n.KViewPort_tool.notsaved\n{\n  background:#FF6644;\n  color:black;\n\n}\n\n\n.KViewPort_tool_enabled\n{\n   background: #e60000 !important;\n   background: darkred !important;\n}\n\n\n.KViewPort_roiview_timeindicator.roi\n{\n  width:25px;\n  pointer-events:all; \n  background:hsl(0,0%,30%);\n  color:hsl(0,0%,90%);\n  font-weight:bold;\n  cursor:ns-resize;\n}\n\n\n\n.KViewPort_scrollAccelerator\n{\n  border:0px solid red;\n  color: red;\n  font-size: 11pt;\n  opacity:.5;\n  width:100px;\n  height:20px;;\n  position:absolute;\n  right:5px;\n  bottom:-20px;\n  pointer-events:none\n}\n\n\n.KViewPort_infoDIV\n{\n \n  float: left;\n  font-size: 8pt;\n  line-height:9pt;\n  border: 0px solid blue;\n  width: auto;\n  height: auto;\n  display: inline;\n  text-align: left;\n  vertical-align: top;\n  padding: 3px;\n  color: yellow;\n  z-index:2;\n  position:absolute;\n  background-color: rgba(0,0,0,0.2);\n  pointer-events:all;\n  \n  cursor: default; /* fallback if grab cursor is unsupported */\n  cursor: grab;\n  cursor: -moz-grab;\n  cursor: -webkit-grab;\n}\n\n.zoomPortButton:hover \n{\n  background:green;\n  cursor:pointer;\n}\n\n.zoomPortButton\n{\n  border:1px solid;\n  padding:5px;\n  border-radius:3px;\n  background: rgba(128,128,1,0.3);\n\n}\n\n.KViewPort_sliceOutsideRange\n{\n  font-size: 25px;\n  position:absolute;\n  top:5px;\n  left:40%;\n  font-color:20px;\n  pointer-events:none;\n  z-index: 1000;\n  background:hsla(0,0%,10%,.6)\n}\n\n.KViewPort_spinner\n{\n  float: left;\n  font-size: 10pt;\n  border: 0px solid blue;\n  width: auto;\n  height: auto;\n  display: none;\n  text-align: left;\n  vertical-align: top;\n  padding: 3px;\n  color: yellow;\n  z-index:9999;\n  background-color: rgba(0,0,0,0.5);\n  white-space:nowrap;\n\n\n  position:absolute;\n\n  transform: translate(-50%, -50%);\n\n\n}\n\n.KSpinner_abortloading \n{\n  display:inline;\n  color:red;\n  opacity:0.4;\n}\n\n.KSpinner_abortloading:hover\n{\n  display:inline;\n  color:red;\n  opacity:1;\n}\n\n\n.KViewPort_autoLoaderLiveEdit\n{\n  position:absolute;\n  __background-color: rgba(139, 0, 0, 0.6);\n  background-color: rgba(0, 0, 0, 0.6);\n\n  border:0px solid white;\n  top:70px;\n  left:10px;\n  z-index:1000;\n  font-size:15px;\n  border-radius:5px;\n\n}\n.KViewPort_autoLoaderLiveEdit > div\n{\n  border-top:1px solid gray;\n  min-height:70px;\n\n}\n\n.KViewPort_autoLoaderLiveEdit textarea\n{\n  width:300px;\n  height:30px;\n  background: rgba(200, 200, 200, 1);\n  font-size:10px;\n}\n.KViewPort_autoLoaderLiveEdit textarea\n{\n\n}\n\n.KViewPort_autoLoaderLiveEdit .loadEdit_close\n{\n  position:absolute;\n  top:0px;\n  right:1px;\n  background:darkred;\n  padding:5px;\n  width:18px;\n  height:18px;\n  font-size:20px;\n  border-radius:0px;\n}\n\n.KViewPort_autoLoaderLiveEdit .loadEdit_close:hover\n{\n  color:gray;\n}\n\n\n/* *************************************** */\n/* small dot in the middle */\n.haircross_new\n{\n  position:absolute;\n  width:8px;\n  height:8px;\n  border: 0px solid white;\n  z-index:10;\n  \n  left:200px;\n  top:200px;\n  transform: translate(-50%, -50%) rotate(60deg);\n\n  display:block;\n  opacity: 1;\n  background:green/*debug*/;\n  background:none;\n\n  pointer-events: none;\n}\n\n/* center line */\n.haircross_new .centerline\n{\n    height: 5000px;\n    width:2px;\n    position:absolute;\n    transform:translate(1px,-50%);\n    background:#FF0000;\n    border: 1px solid #FFFF00;\n    opacity: .3;\n    pointer-events:none;\n    _box-sizing:border-box;\n    _background:blue; /*debbuging */\n}\n\n\n/* an invisible but large background container for easier grabbing */\n/* give the grabber a top/ bottom and height to customize */\n.haircross_new  .grabberbg\n{\n  position:absolute;\n  width: 25px;\n  height:30px;\n  transform:translate(-10px, 0%);\n  background:cyan; /*for debbuging */\n  background:none;\n  opacity:1;\n  pointer-events: all;\n\n}\n\n/* opacity calculations are expensive ... */\n/*.haircross_new .grabberbg:hover i*/\n.haircross_new .grabberbg i\n{\n  visibility:visible;\n}\n\n.visibility_isvisible\n{\n  visibility:visible!important;\n}\n\n/* the inner marker line */\n.haircross_new  * > div\n{\n  height:2px;\n  width:25px;\n\n  margin:auto;\n  background:none;\n  background:#FFF000;\n  background: rgba(82,168,236,1);;\n  opacity:.7;\n  transform:translate(0px, 15px);\n}\n\n.haircross_new  .rotator > div\n{\n  width:15px;\n}\n\n\n.haircross_new  i\n{\n\n  position:absolute;\n  transform:translate(1px,4px);\n  border-radius:18px;\n  padding:3px;\n  margin:2px;\n  background: black;\n  color:yellow;\n  font-size:15px;\n  top:0px;\n  visibility:hidden;\n  _opacity: 1;\n  _transition: all 200ms ease-out;\n  _transition-delay: 10ms;\n}\n\n\n/* *************************************** */\n\n.haircrossFocus\n{\n\n  border: 1px solid #FF0000;\n  background-color:blue;\n  position: absolute;\n  height: 18px;\n  width: 18px;\n  display: block;\n  z-index:11;\n  top:1000px;\n  left:1000px;\n  opacity:0.4;\n  border-radius: 50%;\n  display:none;\n  pointer-events:none;\n  transform:translate(-50%,-50%) ;\n\n}\n\n/*haircrossFocus_new*/\n.haircrossFocus_new\n{\n  position: absolute;\n  display: flex;\n  align-items:center;\n  justify-content:center;\n  z-index:11;\n  top:1000px;\n  left:1000px;\n  display:none;\n  pointer-events:all;\n\n  width:3000px;\n  height:3000px;\n  transform:translate(-50%,-50%);\n  _background:red;\n\n}\n\n.haircrossFocus_new i\n{\n  position:absolute;\n  opacity:0.8;\n  color:rgba(250,250,00,.9);\n  background:hsl(0,0%,10%);  \n  _text-shadow: 8px 8px 8px hsla(0,0%,0%,.5);\n  border-radius:50%;\n  width:50px;\n  height:50px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  transform:translate(-50%,-50%);\n  left:50%;\n  top:50%; \n  pointer-events:all;\n  __pointer-events:none;\n}\n\n.haircrossFocus_new > i\n{\n  position:absolute;\n  font-size:40px;\n  text-shadow: 8px 8px 8px hsla(0,0%,0%,.8);\n  border:2px solid yellow;\n}\n\n\n.haircrossFocus_new > i > i\n{\n  sdisplay:none;\n  width:24px;\n  height:24px;\n  font-size:12px;\n  opacity:1;\n  background:hsl(0,0%,15%);  \n}\n\n.haircrossFocus_new  i:hover i\n{\n  background:red;\n}\n\n.haircrossFocus_new  div\n{\n  border-radius:50%;\n  border:2px dashed yellow;\n  position:absolute;\n  transform:translate(-50%,-50%);\n  left:50%;\n  top:50%;\n  opacity:1;\n  width:100px;\n  height:100px;\n  box-shadow: 2px 2px 9px hsla(0,0%,100%,.7);\n  display:none;\n\n}\n\n/*end of haircrossFocus_new*/\n\n\n\n\n#KseriesViewerMin\n{\n  position: absolute;\n  top:180px;\n  left:400px;\n}\n\n#KseriesViewerMax\n{\n  position: absolute;\n  top:0px;\n  left:400px;\n}\n\n#KseriesViewerCurrent\n{\n  position: absolute;\n  border: 1px solid #FF0000;\n  width:1px;\n  height:20px;\n  background-color:green;\n  top:0px;\n  left:200px;\n}\n\n#KseriesViewer\n{\n  border: 0px solid #FF0000;\n  background:#226699; /*menucolor*/\n  position: absolute;\n  height: 180px;\n  width: 400px;\n  display: none;\n  z-index:9;\n  opacity:0.5;\n  top:30px;\n  left:30px;\n}\n\n.histogram\n{\n\n  border: 0px;\n  background:#226699; /*menucolor*/\n  position: absolute;\n  display: none;\n  z-index:9;\n  opacity:0.5;\n  bottom:2px;\n  border-radius:0px; /*borderradius_button*/\n  \n}\n.histoname > div\n{\n\n}\n\n.histoname\n{\n  position:absolute;\n  color:yellow;\n  font-size:13px;  \n  top:-20px;\n  width:100%;\n  text-shadow: 1px 2px 2px black;\n  \n  overflow:hidden;\n  pointer-events:none;  \n  \n}\n\n.mosaicbar\n{\n\n  border: 1px;\n  \n  position: absolute;\n  width:40%;\n  height:4px;\n  background-color:gray;\n  display: none;\n  z-index:9;\n  opacity:1;\n  bottom:13px;\n  left:30%;\n  border-radius:0px; /*borderradius_button*/\n  \n}\n\n\n.mosaicslider\n{\n background-color:blue;\n position:relative;\n width:20%;\n top:30%;\n left:30%;\n height:200%;\n opacity:0.5;\n transform: translate(0%, -30%);\n border-radius:0px; /*borderradius_button*/\n    cursor:-webkit-grab;\n}\n\n.mosaicdragleft\n{\n  position:absolute;\n  width:3px;\n  height:100%;\n  background-color:gray;\n  cursor:ew-resize;\n}\n\n.mosaicdragright\n{\n  position:absolute;\n  width:3px;\n  height:100%;\n  right:0px;\n  background-color:gray;\n  cursor:ew-resize;\n}\n\n.colorbar\n{\n\n  border: 1px solid #333333;\n  background-color:darkblue;\n  position: absolute;\n  display: none;\n  z-index:9;\n  opacity:1;\n  bottom:0px;\n  cursor:pointer;\n}\n\n.colorbar  canvas\n{\n}\n\n\n\n.clim\n{\n  vertical-align: top;\n  position: absolute;\n  height: 40px;\n  width: 15px;\n  display: inline-block;\n  z-index:9999;\n  text-align:right;\n  color: none;\n  top:0px;\n  left:-0px;\n  transform:translate(-50%,0%);\n  opacity:1;\n  cursor:ew-resize;\n  background:none;\n}\n\n.clim > div\n{\n  position: absolute;\n  height: 100%;\n  transform:translate(-50%,0%);\n  left:50%;\n  width: 3px;\n  _background:blue;  \n}\n\n.clim:hover > .climL\n{\n  _box-shadow:  0 0 4px 3px #00FF00;\n  width:6px;\n}\n.clim:hover > .climR\n{\n  _box-shadow:  0 0 4px 3px #FF0000;\n  width:6px;\n}\n\n.climL\n{\n  background-color:#00FF00;\n}\n\n.climR\n{\n  background-color:#FF0000;\n}\n\n\n.climhistotxt\n{\n  padding:0px 0px 0px 5px !important;\n}\n\n\n.climtxt\n{\n  position: absolute;\n  display: inline-block;\n  text-shadow: 0 1px 1px red;\n  font-size:10px;\n\n  z-index:9;\n  color:yellow;\n  top:25% ;\n  height:15px !important;\n  padding:0px 0px 0px 15px ;\n  opacity:1;\n  cursor:text;\n\n}\n\n\n\n\n\n.tooltip2\n{\n  position: absolute;\n  height:90px;\n  left: -00%;\n  background: #ffcb66;\n  padding: 5px 15px;\n  color: black;\n  -webkit-border-radius: 10px;\n  -moz-border-radius : 10px;\n  border-radius : 10px;\n  swhite-space: nowrap;\n  sopacity: 1;\n\n  z-index: 99999999;\n  -swebkit-transition: all 0.4s ease;\n  -smoz-transition : all 0.4s ease; transition : all 0.4s ease;\n}\n\n\n.tooltip\n{\n}\n.tooltip:before\n{\n  display:none;\n  font-size:15px;\n  font-weight: normal;\n  content: attr(data-tooltip);\n  position: absolute;\n  right: 100%;\n  background: #ffcb66;\n  padding: 5px 15px;\n  color: black;\n  -webkit-border-radius: 10px;\n  -moz-border-radius : 10px;\n  border-radius : 10px;\n  white-space: nowrap;\n  opacity: 1;\n  z-index: 9999;\n  -webkit-transition: all 1.4s ease;\n  -moz-transition : all 0.4s ease;\n  transition : all 0.4s ease;\n}\n.stooltip::before\n{\n  width: 0;\nheight: 0;\nborder-style: solid;\nborder-width: 100px 0 100px 200px;\nborder-color: #007bff;\n}\n\n.dtooltip:before\n{\n  content: "";\n  position: absolute;\n  width: 0;\n  height: 0;\n  border-top: 20px solid #ffcb66;\n  border-left: 20px solid transparent;\n  border-right: 20px solid transparent;\n  -webkit-transition: all 0.4s ease;\n  -moz-transition : all 0.4s ease;\n  transition : all 0.4s ease;\n  opacity: 0; left: 30%;\n  bottom: 90%;\n}\n.tooltip:hover:after  { bottom: 100%; }\n.tooltip:hover:before { display:block  }\n.tooltip:hover:after { opacity: 1; }\n\n.markerrectangle\n{\n  background:none;\n  border:1px solid;\n  position:absolute;\n  z-index:5;\n  height:0px;\n  width:90px;\n  _border:none !important;\n}\n\n.rect_term\n{\n  background:aliceblue;\n  width:15px !important;\n  height:15px !important;\n  _opacity:0.3;\n  border:none !important;\n\n\n}\n\n.markerrectangle_rectborder\n{\n  position:absolute;\n  height:20px;\n  width:40px;\n  background:none;\n  opacity:0.8;\n  box-sizing:border-box;\n  border:3px solid;\n}\n\n.markerruler\n{\n  background:none;\n  border:1px solid !important;\n  border-color: red;\n  position:absolute;\n  \n  z-index:99;\n  height:0px;\n  width:90px;\n  transform: translate(-50%, -50%) rotate(50deg);\n}\n\n.markerruler:hover\n{\n  border:2px solid orange !important;\n}\n\n\n.markerruler_text\n{\n  position:relative;\n  left:10%;\n  width:80%;\n  top:2px;\n  cursor:pointer;\n}\n\n.markerruler_text span\n{\n  spointer-events:none;\n  position:absolute;\n  background: rgba(0,0,0,0.2);\n}\n.markerruler_text i\n{\n  float:right;\n  padding-top:2px;\n  color:rgba(255,255,255,1);\n  text-shadow: 0 2px 5px rgba(0, 0, 0, .9);\n\n  font-size:15px;\n    \n}\n.markerruler_text .fa:hover\n{\n  color:red;\n}\n\n\n.markerruler_terminal:hover\n{\n  border:2px solid orange !important;\n}\n\n.markerruler_terminal\n{\n  background:yellow;\n  position:absolute;\n  z-index:99;\n  height:15px;\n  width:15px;\n  border-radius:15px;\n  transform: translate(-50%, -50%);\n}\n\n.markerruler_terminal_a\n{\n  left:100%;\n}\n\n.markerruler_terminal_b\n{\n  left:-2px;\n}\n\n\n\n\n.markerpoint\n{\n  cursor:default;\n  background:none;\n  border:2px solid;\n  border-color: red;\n  border-radius: 50%;\n  position:absolute;\n  \n  z-index:5;\n  height:50px;\n  width:50px;\n  transform: translate(-50%, -50%);\n  cursor: move;\n}\n\n\n.markerpoint_hovered\n{\n  box-shadow: 0 0 15px !important;\n  /* border-color: rgba(81, 203, 238,1)!important; */\n}\n\n.markerpoint:hover .markerpoint_haircross\n{\n  box-shadow: 0 0 20px ;\n}\n\n\n.markerpoint .markerpoint_haircross_x\n{\n  sdisplay:none;\n  \n  background:green;\n  border:0px solid;\n  border-color:green;\n  position:relative;\n  height:50%;\n  width: 2px;\n  margin:auto;\n  vertical-align:center;\n  dtransform: translate(0, -150%);\n  top: 25%;\n  left:0px;\n\n\n}\n\n\n.markerpoint .markerpoint_haircross_y\n{\n  sdisplay:none;\n  \n  background:green;\n  border:0px solid;\n  border-color:green;\n  position:relative;\n  height:50%;\n  width: 2px;\n  margin:auto;\n  vertical-align:center;\n  dtransform: translate(0, -150%);\n\n  transform: rotate(90deg); top:-25%;  \n\n}\n\n.markerpoint_resizer_box\n{\n  position:absolute;\n  bottom:2px;\n  right:2px;\n  \n  display: block;\n  width: 25%;\n  height: 25%;\n\n  background:transparent!important;\n  border-bottom: 4px solid;\n  border-right: 4px solid;\n  border-color: inherit;\n  cursor: se-resize;\n  opacity:.7;\n}\n\n\n\n/* the rect shape for a marker point */\n.markerpoint_box\n{\n   border-radius: 0%;\n/*   transform: translate(-50%, -50%);*/\n}\n\n.markerpoint_resizer_box:hover\n{\n  opacity:1;\n  border-width: 6px;\n  border-color: inherit;\n}\n\n\n\n.markerpoint_3Druler\n{\n  border-radius: 0%;\n  border:none;\n  overflow: visible;\n  cursor: default;\n  pointer-events:none!important;\n}\n\n/* switch off box shadow for ruler */\n.annotation_point_hovered.markerpoint_3Druler \n{\n  box-shadow: none !important;\n}\n\n\n.markerpoint_3Druler_resizer:hover\n{\n  _border:2px solid white !important;\n  box-shadow:  0 0 4px 3px rgba(000,100,200,.9);\n}\n\n.markerpoint_3Druler_resizer\n{\n  background:yellow;\n  position:absolute;\n  height:10px;\n  width:10px;\n  border-radius:15px;\n  transform: translate(-50%, -50%);\n  _cursor: se-resize;\n  pointer-events:all;\n}\n.markerpoint_3Druler_resizer_______:after\n{\n  content:"";\n  position:absolute;\n  height:10px;\n  width:10px;\n  top:50%;\n  right:50%;\n  border-radius:15px;\n  transform: translate(50%, -50%);\n  background:inherit;\n  background:blue;\n}\n\n\n.markerpoint_resizer_other\n{\n  right:0px;\n  bottom:0px;\n  transform: translate(50%, 50%);\n}\n\n\n.markerpoint_3Druler svg\n{\n  box-sizing:border-box;\n  width: 100%;\n  height:100%;\n  min-width:2px;\n  min-height:2px;\n}\n\n.markerpoint_3Druler svg line\n{\n  stroke:white;\n  stroke-width:2;\n  stroke-dasharray: 4;\n  vector-effect: non-scaling-stroke;\n}\n\n\n.markerpoint_3Druler_text\n{\n  position:absolute;\n  left:50%;\n  bottom:50%;\n\n  padding:2px 4px;\n  background: rgba(0,0,0,0.1);\n  text-shadow: 0 1px 1px rgba(0, 0, 0, .9);\n  font-size:15px;\n  font-weight:bold;\n  white-space:nowrap;\n  cursor: move;\n}\n.markerpoint i\n{\n}\n\n.markerpoint i\n{\n  color:white;\n  background:black;\n  padding:1px;\n  opacity:0.8;\n  border-radius:5px;\n  border: whitesmoke 2px solid;\n  display:inline;\n  margin-left: 4px;\n  pointer-events:all;\n  cursor:default;\n}\n.markerpoint i:hover\n{\n  color:red;\n  pointer-events:all;\n}\n\n.markerpoint_scribble\n{\n  border:none;\n  _background:green;\n  overflow:visible;\n  pointer-events:none;\n  opacity:1!important;\n  cursor:default!important;\n}\n\n.markerpoint_scribble svg\n{\n  _background:orange;\n  overflow:visible;\n  width:100000px;\n  height:100000px;\n  left:50%;\n  top:50%;\n  position:absolute;\n  border:1px solid transparent;\n}\n.markerpoint_scribble svg g\n{\n  pointer-events:all;\n  _cursor:pointer;\n}\n\n.markerpoint_comment\n{\n  display:none;\n}\n\n.markerpoint_scribble polyline\n{\n  stroke:red;\n  /* blur does not work with straight lines ...!*/\n  _filter: url(#svg_blur); \n  stroke-width:3;\n  vector-effect: non-scaling-stroke;\n  fill:blue;\n  fill:none;\n  _opacity:1!important;\n}\n\n.markerpoint_resizer_sphere\n{\n  position:absolute;\n  bottom:-4px;\n  right:-4px;\n  \n  display: block;\n  width: 25%;\n  height: 25%;\n\n  background:transparent!important;\n  border-bottom: 4px solid;\n  border-color: inherit;\n  cursor: se-resize;\n  opacity:.9;\n  \n  transform: translate(-10%, -10%) rotate(-45deg);\n}\n\n.markerpoint_resizer_sphere:hover\n{\n  opacity:1;\n  border-width: 6px;\n}\n\n\n.markerpoint_thresh_slider\n{\n  position:absolute;\n  top:50%;\n  left:-10px;\n  \n  display: block;\n  min-width: 10px;\n  min-height: 10px;\n  _width: 12%;\n  _height: 12%;\n  background:red;\n  border-radius:20px;\n  cursor:ns-resize;\n  transform: translate(-50%, -50%) rotate(-0deg);\n  opacity:.6;\n}\n\n.markerpoint_thresh_slider:hover\n{\n  opacity:1;\n  border-width: 6px;\n}\n\n\n.markerpoint .markerpoint_props, .markerrectangle .markerpoint_props\n{\n  color:black;\n  font-weight:bold;\n  background:hsla(0,0%,90%,.6);\n  padding:5px;\n  border-radius:5px;\n  position:absolute;\n  top:0px;\n  left:100%;\n  width:auto;\n  display:none;\n}\n\n.markerpoint:hover .markerpoint_props, .markerrectangle:hover .markerpoint_props\n{\n  z-index:100;\n  display:block;\n}\n\n\n.markerROIStats \n{\n\n  width: auto;\n  height: auto;\n  display: inline;\n  text-align: left;\n  vertical-align: top;\n  padding: 3px;\n  color: yellow;\n  z-index:2;\n  position:absolute;\n  background: rgba(0,0,0,0.1);\n\n  line-height:14px;\n  font-size:14px;\n  _pointer-events:none;\n\n  user-select:text;\n  -moz-user-select:text;\n  -webkit-user-select:text;\n}\n\n.markerROIStats td\n{\n  font-weight:bold;\n  height:10px;\n  padding:0px;\n  margin:0px;\n}\n\n.markerROIStats td:first-child\n{\n  text-align:right;\n  font-weight:normal;\n}\n.markerROIStats td:last-child\n{\n  text-align:left;\n  padding-left:5px;\n}\n\n.markerpoint .markerpoint_delete\n{\n  position:absolute;\n  top:-10px;\n  right:-10px;\n  background:darkred;\n  padding:5px;\n  width:20px;\n  height:20px;\n  font-size:20px;\n  border-radius:150px;\n  \n  display:block;\n  text-align:center;\n  vertical-align:middle;\n  color:white;\n}\n.markerpoint:hover .markerpoint_delete:hover\n{\n  background:red;\n}\n\n.markerpoint:hover .markerpoint_delete\n{\n  display:block;\n}\n\n\n\n\n.markerpoint_coords\n{\n}\n\n.markerpoint_coords  div\n{\n  display:inline-block;\n  __width:75px; \n  margin-right:3px;\n}\n\n\n.markerpoint_coords input\n{\n  color:black;\n  width:50px;\n  border-radius:0px;\n}\n\n.markerpoint_coords .pointcomment\n{\n  width:130%!important;\n  box-sizing:border-box;\n  border-radius:0px;\n}\n\n\n/*------------------\n.markerpoint_coords\n{\n  width:auto;\n}\n\n\n.markerpoint_coords > div\n{\n  display:flex;\n  flex-wrap:nowrap;\n  flex-direction:row;\n  width:100%;\n}\n\n.markerpoint_coords > div > div\n{\n flex-grow:1;\n}\n\n.markerpoint_coords input\n{\n  color:black;\n  width:50px;\n  border-radius:0px;\n}\n\n.markerpoint_coords .pointcomment\n{\n  width:100%;\n  box-sizing:border-box;\n  border-radius:0px;\n}\n\n.annotation_tool_listDIV .markerpoint_coords > div > div\n{\n flex-grow:0;\n}\n---------------  */\n\n\n\n/* any generic row for markerpoint representation */\n.markerpointrow\n{\n  display:block;\n  white-space:nowrap;\n  width:auto;\n  \n}\n/* special if in panel itself */\n.markerPanel .markerpointrow\n{\n  border-top: 1px solid hsl(0,0%, 14%);\n  display:block;\n  width:100%;\n}\n\n\n.markerPanel .KViewPort_tool \n{\n  min-width:initial;\n}\n\n.markerpointrow_info\n{\n  display:flex;\n  margin-bottom:2px;\n  color:white;\n}\n.markerpointrow_info .markerpointrow_colorselector\n{\n  padding:3px;\n  height:12px;;\n  width:12px!important;\n  display:flex;\n  align-items:center;\n}\n.markerpointrow_info > div\n{\n margin-right:4px;\n}\n/* the toolbar at the right side, find, delete ... */\n.markerpointrow_info .markerpointrow_tools\n{\n  flex-grow:1;\n  text-align:right;\n}\n\n.markerpointrow_info .markerpointrow_tools > i\n{\n  margin:1px 4px;\n}\n.markerpointrow_info .markerpointrow_tools > i:hover\n{\n  color:hsl(0,0%,50%);\n}\n\n/* the coordinates */\n.markerpointrow .markerpointrow_coords\n{\n  flex-grow:1;\n}\n.markerpointrow .markerpointrow_coords input\n{\n  margin:0px!important;\n}\n\n\n.markerset_colselector\n{\n  float:right;\n  margin:-2px;\n  margin-left:2px;\n}\n\n.markerset_row\n{\n  font-size:15px;\n  _padding:3px;\n  background:gray;\n  margin:3px;\n  margin-top:5px;\n  line-height:1;\n}\n\n.annotation_info\n{\n\n}\n\n.markerset_row >  div:first-child\n{\n  box-sizing:content-box;\n  background:lightgray;\n  color:black;\n  _margin:2px;\n  padding:3px;\n  margin-bottom:5px;\n  border:3px solid;\n  border-color:gray;\n  \n}\n\n.markerset_row .annotation_info\n{\n  padding-bottom:10px;\n  color:white;\n}\n\n.markerset_row > div > i \n{\n  float:right;\n  margin-left:7px;\n  margin-right:3px;\n    \n}\n.markerset_row select\n{\n  float:right;\n  margin-left:7px;\n  margin-right:3px;\n    \n}\n\n.markerset_row i:hover\n{\n  color:red;\n    \n}\n\n.markerset_row input\n{\n  width:70px;    \n}\n\n\n.markerset_row  > div:first-child\n{\n  height:16px;\n}\n\n.markerset_row span\n{\n float:left;\n    \n}\n\n.markerset_row_active\n{\n  _box-shadow:  0 0 5px 2px rgba(82,168,236,.9);\n  border-color: yellow !important;\n  background-color:#FFFFAA !important;\n}\n  \n\n.markerTable \n{\n  border-collapse:collapse;\n  width:100%;\n  line-height:1;\n  box-sizing:content-box;\n}\n\n\n\n.markerTable td\n{\n  border-top: 1px solid black;\n  margin:0px;\n  white-space:nowrap;\n\n}\n.markerTable tr:hover td\n{\n  background:hsla(0,0%,60%,.5);\n}\n\n\n.markerTable td:nth-child(1) /*id*/\n{\n  color:lightgray;\n  padding-right:5px;\n  padding-left:5px!important;\n}\n\n.markerTable td:nth-child(2)/*color*/\n{\n  padding:3px;\n  height:12px;;\n  width:12px!important;\n  display:flex;\n  align-items:center;\n}\n\n.markerTable td:nth-child(3)/*name*/\n{\n  padding-left:5px;\n  font-weight:bold;\n}\n\n.markerTable td:last-child\n{\n  padding-left:15px;\n\n}\n.markerTable td div\n{\n  display:inline-block;\n}\n\n.markerTemplates\n{\n display:flex;\n flex-wrap: wrap;\n width:100%; \n}\n\n.markerTemplates > div\n{\n  margin: 4px;\n  padding:3px 4px;\n  border-radius:6px;\n  min-width:40px;\n  text-align:center;\n  font-weight:bold;\n  min-width:20%;\n  cursor:move;\n\n  _border: 1px solid hsl(0,0%,0%);;\n  background:hsl(0,0%,70%);\n  color:hsl(0,0%,100%);\n  _text-shadow: 0 1px 1px rgba(255, 255, 255, .9);\n\n\n}\n\n.markerTemplates > div:hover\n{\n  _background:hsl(0,0%,90%);\n  _box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/ \n    box-shadow:  0 0 15px 4px rgba(82,168,236,.9);\n\n\n}\n\n/*  end markers */\n\n\n\n\n\n.annotation_point\n{\n  background:none;\n  border:2px solid;\n  border-color: red;\n  border-radius: 50%;\n  position:absolute;\n  z-index:9;\n  height:50px;\n  width:50px;\n  transform: translate(-50%, -50%);\n}\n\n.annotation_point_hovered\n{\n  box-shadow: 0 0 15px !important;\n  /* border-color: rgba(81, 203, 238,1)!important; */\n}\n\n.annotation_point:hover .annotation_point_haircross\n{\n  box-shadow: 0 0 20px ;\n}\n\n\n.annotation_point .annotation_point_haircross\n{\n  background:red;\n  border:0px solid;\n  border-color:green;\n  position:relative;\n  z-index:10;\n  height:200%;\n  width: 2px;\n  margin:auto;\n  vertical-align:center;\n  stransform: translate(0, -125%);\n  top: -50%;\n\n}\n\n\n\n.annotation_tool\n{\n  padding: 0px;\n  z-index:0;\n  box-sizing:border-box;\n  -webkit-box-sizing: border-box;\n  -moz-box-sizing: border-box;\n  border-radius:0px; /*borderradius*/\n  border:1px solid;\n  border-color:#666666; /*bordercolor*/\n  border-collapse:collapse;\n  position:relative;\n  background:hsl(0, 0%, 22%); /*windowbackground*/\n  display:flex;\n  flex-direction:column;\n\n  white-space: normal;\n\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/ \n  font-family: Arial, sans-serif;\n  font-size: 10pt;\n}\n\n.annotation_tool.inactive\n{\n  pointer-events:none;\n  opacity:0.5;\n}\n\n\n/*empty placeholder with zero height*/\n.annotion_tool_resizer\n{\n  height:0px;\n  width:100%;\n  position:relative;\n  background:red;\n  z-index:300000;\n}\n/*the relevant height*/\n.annotion_tool_resizer > div\n{\n  width:100%;\n  height:15px;\n  background:none;\n  position:absolute;\n  transform: translate(0%, -50%);\n  cursor:ns-resize;\n}\n/*the hover effect*/\n.annotion_tool_resizer > div > div\n{\n  width:100%;\n  height:0px;\n  background:none;\n  position:absolute;\n  transform: translate(0%, 8px);\n}\n.annotion_tool_resizer > div:hover > div\n{\n   -webkit-box-shadow:  0 0 5px 5px rgba(82,168,236,.9);\n}\n\n\n.annotation_tool .highlight::before\n{\n  content: "x";\n  z-index:100;\n  height:0px;\n  top:0px;\n  position:absolute;\n  background: yellow;\n  -webkit-box-shadow:  0 0 9px 5px rgba(255,255,102,.9);\n  pointer-events:none;\n  width:100%;\n}\n\n\n.annotation_tool_captionBar\n{\n  position: relative;\n  padding: 0;\n}\n.annotation_tool_caption\n{\n  color:white;\n}\n\n.annotation_tool_droparea > span\n{\n  align-self:center;\n  color:white;\n}\n.annotation_tool_droparea\n{\n  color:gray;\n  height:100px !important;\n  background:inherit !important;\n  border-radius:10px;\n  border:2px dashed gray;   \n  display:flex;\n  flex-wrap:wrap;\n  justify-content:center;\n  overflow:auto;\n}\n\n.annotation_tool_droparea > div\n{\n  color:black;\n  position:relative;\n  border:1px solid;\n  background:aliceblue;\n  opacity:0.9;\n  margin:2px;\n  padding:2px;\n  border-radius:4px !important;\n\n}\n\n.annotation_tool_droparea > div > div\n{\n  min-width:100px;  \n  max-width:180px;  \n  padding-right:4px;  \n  text-overflow:ellipsis;\n  overflow:hidden;\n  cursor:pointer;\n}\n\n.annotation_tool_droparea > div > i\n{\n  position:absolute;\n  top:-2px;\n  right:0px;\n   \n}\n\n\n\n.annotation_tool_listDIV /* inner KTool List element */\n{\n  margin-top:2px;\n  margin-left:4px;  \n  height: -moz-calc(100% - 30px);\n  height: -webkit-calc(100% - 30px);\n  height: calc(100% - 30px);\n  height:100% !important;\n  overflow:auto;\n  white-space:nowrap;\n}\n\n\n.annotation_tool_listDIV \n{\n  \n  position:relative;\n  left:0px;\n  width: calc(100% - 30px);\n  width: -webkit-calc(100% - 30px);\n  width: -moz-calc(100% - 30px);\n  \n  \n}\n\n.annotation_tool_listDIV button\n{\n height:21px;\n line-height:0.5;\n}\n\n\n\n.annotation_tool_elemDIV:first-of-type\n{\n  margin-bottom:0px;\n}\n\n\n.annotation_tool_elemDIV > div /* header div */\n{\n  background-color:gray;\n  border:0 px solid black;\n  padding:0px 0px 0px 2px;\n  font-size: 15px;\n  margin:auto;\n  margin-top:10px;\n  width:98%;\n  height:27px;\n  display:flex;\n  box-sizing:border-box;\n  line-height:20px;\n  \n}\n\n.annotation_tool_elemDIV > div > div\n{\n  vertical-align:middle;\n  margin:auto;\n}\n\n.annotation_tool_elemDIV .annotation_tool_color /* header div color */\n{\n  background:none;\n  width:30px;\n  height:80%;\n}\n\n.annotation_tool_elemDIV .annotation_tool_caption /* name of the annot */\n{\n  padding: 0px 0px 0px 10px;\n}\n\n.annotation_tool_elemDIV.inactive\n{\n  opacity:0.5;\n  pointer-events:none;\n}\n\n.annotation_tool_elemDIV_tools\n{\n  flex-grow:1;\n  text-align:right;\n  vertical-align:middle;\n  border: 0px solid red;\n  height:100%;\n  box-sizing:border-box;\n}\n\n\n.annotation_tool_elemDIV_tool  /* this is the toolbar */\n{\n    font-family: Verdana, Arial, Helvetica, sans-serif; \n\n}\n\n.annotation_tool_elemDIV  i\n{\n  display:inline-block;\n\n\n  font-size: 15px;\n  padding:  2px 4px ;\n  color: black;\n  height:100%;\n  width:auto;\n  font-weight:normal;\n  cursor: pointer;\n  margin-right: 0px;\n  background: linear-gradient(to top left, #FFFFFF, #CFCFCF);\n  box-sizing:border-box;\n  border-radius:3px;\n\n  margin: 1px;\n  border: 0px solid gray;\n  width: auto;\n  height: auto;\n   dbackground: linear-gradient(to top left, #003D7A, #80B2E6);\n  text-align: center;\n  padding: 2px;\n\n  margin-top:4px;\n\n}\n\n.annotation_tool_elemDIV .space\n{\n  width:20px;\n  background:none;\n}\n\n.annotation_tool_elemDIV .space:hover\n{\n  width:20px;\n  background:none;\n}\n\n\n\n.annotation_tool_elemDIV  i:hover\n{\n   background: #CFCFCF;\n }\n\n\n\n\n.annotation_tool_elemDIV table\n{\n  width:98%;\n  font-size:15px;\n  border: 0px solid gray;\n  background-color:lightgray;\n  border-spacing: 0px;\n  box-sizing:border-box;\n  margin:auto;\n}\n\n\n\n.annotation_tool_elemDIV .newPoint\n{\n    background: linear-gradient(to top left, #FFFFFF, #CFCFCF);\n    color:black;\n    display:flex;\n    margin-top:0px;\n    border:0px solid green;\n    padding-left:10px;\n    height:20px;\n    box-sizing:border-box;\n}\n\n\n.annotation_tool_elemDIV table th\n{\n    font-size:15px;\n    margin:5px 5px 0 0;\n    height:22px;\n    background: #cccccc;\n    color:black;\n    border: 0px solid black;\n    text-align:center;\n}\n\n\n.annotation_tool_elemDIV table td\n{\n    border: 0px solid black;\n    margin:5px 5px 0 0;\n    height:22px;\n    padding:0px;\n}\n\n.annotation_tool_elemDIV table td:nth-child(4)\n{\n  margin-left:10px;\n  border-right: 1px solid black;\n  width:0px;\n}\n\n.annotation_tool_elemDIV .tr_hovered input\n{\n    background: linear-gradient(to top left, rgba(81, 203, 238,1), #CFCFCF);\n}\n\n.annotation_tool_elemDIV  input\n{\n    width:100%;\n    height:100%;\n    border:0px;\n    margin:0px;\n    text-align:center;\n    color:#171717;\n    font-weight:normal;\n    -webkit-box-sizing: border-box;\n    -moz-box-sizing: border-box;\n    box-sizing: border-box;\n    font-size: 13px;\n    background: linear-gradient(to top left, #FFFFFF, #CFCFCF);\n}\n\n.annotation_tool_elemDIV table td:last-child\n{\n  text-align:right;\n  width:100px;\n  font-size:15px;\n  text-align:right;\n\n}\n\n.DBSpanel > .panel\n{\n  width:100%;\n}\n\n.panel hr\n{\n  height:0px;\n  margin:5px;\n}\n\n.DBS_simindicator\n{ \n color:yellow;\n padding-left:3px;\n width:67px !important;\n font-size:10px;\n eopacity:0.7;\n cursor:default;\n}\n.DBS_siminfo\n{\n  position:absolute;\n  z-index:9999;\n  background:gray;\n  color:black;\n  padding:5px;\n  border-radius:2px;\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/\n\n\n}\n.DBS_name\n{\n  padding:2px;\n  padding-top:8px;\n  padding-left:4px;\n  margin-left:10px;\n\n}\n\n\n\n.DBS_simparams_head\n{\n  background:gray;\n  padding:2px;\n  margin:2px;\n  margin-top:10px;\n  width:95%;\n  border-radius:2px;\n}\n\n.DBS_simparams_head:hover\n{\n  \n  background:#555;\n}\n.DBS_simparams_head:hover .DBS_simparams\n{\n  visibility:visible;\n\n  transition-delay:0.3s;\n\n}\n.DBS_simparams\n{\n  visibility:hidden;\n  position:absolute;\n  width:100%;\n  background:gray;\n  padding:5px;\n  margin-top:6px;\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/\n  border-radius:2px;\n  z-index:999;\n  transition-delay:0.3s;\n\n}\n\n.DBS_paramname\n{\n  display:inline-block;\n  width:150px !important;\n  margin-left:3px;\n}\n\n.DBS_paraminput\n{\n  height:15px;\n  width:80px;\n}\n\n\n.DBS_result\n{\n  background:#555;\n  margin:5px;\n  padding:1px;\n  border-radius:1px;\n  cursor:pointer;\n}\n\n.DBS_result:hover\n{\n  background:gray;\n}\n\n.DBS_filedivs\n{\n  display:inline-block;\n  width:70%;\n}\n\n.DBS_buttons\n{\n  display:inline-block;\n  width:30%;\n  text-align:center;    \n  transform:translate(0%,-30%)\n}\n\n.DBS_buttons > span\n{\n  width:50px;\n  display:inline-block;\n  text-align:center;    \n  transform:translate(0%,-30%)\n}\n\n\n.KPickerPanelLargeHead\n{\n  position:relative;\n  margin-top:15px;\n  width:300px;\n  margin-left:20px;\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/ \n  padding:30px;  \n    \n}\n\n.KPickerPanelDrop\n{\n  position:absolute;\n  top:20px;\n  right:10px;\n  padding:3px;\n  border-radius:2px;\n}\n\n.KPickerPanelDrop:hover\n{\n   background:red;\n   color:yellow;\n    \n}\n\n.KPickerPanelLargeHead > span:first-child\n{\n  display:inline-block;\n  font-size:20px;\n  font-weight:bold;\n  text-shadow: 0 2px 2px rgba(0, 0, 0, .9);\n  padding-bottom:10px !important;\n}\n\n.KPickingPanelHist\n{\n  margin-right:5px;\n  width:50px;\n  border:1px solid white;\n  text-align:center;\n  display:flex;\n  align-items:flex-end;\n  justify-content:center;  \n  bottom:0px;\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/ \n  text-shadow: 0 2px 2px rgba(0, 0, 0, .9);\n  color:white;\n  font-weight:bold;\n\n\n}\n\n.KPickingPanelHistDense\n{\n  margin-right:0px;\n  border:1px solid black;\n  text-align:center;\n  display:flex;\n  align-items:flex-end;\n  justify-content:center;  \n  bottom:0px;\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/ \n  text-shadow: 0 2px 2px rgba(0, 0, 0, .9);\n  color:white;\n  font-weight:bold;\n\n\n}\n\n.KPickerPanelRow\n{\n  height:60px;\n  bottom:0px;\n  border:2px;\n  display:flex;\n  align-items:flex-end;\n  justify-content:center;\n  margin-bottom:13px;\n  \n\n}\n\n.KPickerPanelRow > span:first-child\n{\n  display:inline-block;\n  width:100px;\n}\n\n.KPickerPanelRow > div:nth-child(2) \n{\n  background:red;\n}\n.KPickerPanelRow > div:nth-child(3) \n{\n  background:green;\n}\n.KPickerPanelRow > div:nth-child(4) \n{\n  background:blue;\n}\n\n.roiTool_pencil\n{\n  background: none;\n  opacity:0.8;\n  width:40px;\n  height:40px;\n  position:  absolute;\n  z-index:9999;\n  display:block;\n  pointer-events:none;\n  border-radius: 50%;\n  __transform: translate(50%, 50%);\n  border: 2px solid yellow;\n\n}\n\n\n.roiTool_pencil.regionGrow \n{\n  border:0px !important;\n  background:green;\n  \n\n}\n\n.roiTool_pencil_haircross\n{\n  opacity:0.8;\n  border:none;\n  background:yellow;\n  position:absolute;\n  width: 20px;\n  height: 20px;\n  transform: translate(-50%, -50%);\n  left:50%;\n  top:50%;\n  pointer-events:none;\n}\n\n.roiTool_pencil.leftright\n{\n   sbackground:yellow;\n   opacity:0.5;\n   sborder-color:transparent;\n}\n\n.roiTool_pencil.leftright .left\n{\n  position:relative;\n  width:0px;\n  height:0px;\n  left:170%;\n  border-top: 30px solid transparent;\n  border-bottom: 30px solid transparent;  \n  border-left: 40px solid yellow;\n  background:transparent;\n}\n.roiTool_pencil.leftright .right\n{\n  aposition:relative;\n  width:0px;\n  height:0px;\n  left:-70%;\n  stop:10%;\n  border-top: 30px solid transparent;\n  border-bottom: 30px solid transparent;  \n  border-right: 40px solid yellow;\n  background:transparent;\n}\n\n.roiTool_pencil_busy\n{\n  display:none;\n  position:absolute;\n  left:50%;\n  top:50%;\n  transform: translate(-50%, -50%);\n  \n  font-size:50px;  \n  color:yellow;\n  background:red;\n  border-radius:50%;\n  padding:5px;\n  opacity:1 !important;\n}\n\n.roiTool_pencil.busy .roiTool_pencil_busy\n{\n  display:block;\n}\n\n\n.roiTool_pencil > div:first-child\n{\n  width:15px;\n  height:2px;\n\n}\n.roiTool_pencil > div:last-child\n{\n  width:2px;\n  height:15px;\n\n}\n\n.scribble_pencil\n{\n  border: 4px solid #ff4bd4;\n  background:rgba(255,75, 212, .2);\n  pointer-events:none;\n}\n\n\n.roiToolContainer \n{\n  margin-top:3px;\n  display:flex;\n  flex-direction:horizontal;\n  overflow-y:auto;\n  overflow-x:hidden;\n  flex-grow:1;\n  box-sizing:border-box;\n  height:calc(100% - 30px)!important;\n\n  /*\n  border:5px solid white;\n  background:red;\n  */\n}\n.roiToolContainer > div \n{\n  height:100%;\n  \n\n}\n.roiToolContainer > div:nth-child(2) /* the file list */\n{\n  padding:0px;\n  overflow:auto;\n}\n\n\n\n/* Roi panel on right side */\n.roiTool_panel\n{\n  padding-left:2px;\n  width:120px;\n  height:100%;\n  background: rgba(99, 99, 99, 0.99);\n  margin-right:6px;\n  padding-right:2px;\n  z-index:2;\n  _border:1px solid red;\n\n  \n}\n\n.roiTool_panel_flex.inactive:not(.persistent)\n{\n  opacity:0.3;  \n  pointer-events:none;  \n}\n\n\n.markerPanel\n{\n\n  background: hsla(0, 0%, 40%, 1);\n  width:210px;\n  min-width:210px;\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/ \n\n  /* old version for pos absolute pos */\n  font-family: Arial, sans-serif;\n  font-size: 12pt;\n  border-radius:0px; /*border-radius*/\n  position:absolute;\n  top:70px;\n  z-index:1;\n}\n\n.markerPanel > div\n{\n  border-radius:0px; /*border-radius*/\n  box-sizing:border-box;\n  padding:1px 1px; \n  width: 100%;\n  color:white;\n  cursor:default;\n}\n.markerPanel > div:first-child\n{\n  background:hsla(0, 0%, 30%, 1);;\n}\n.markerPanel > div:first-child i\n{\n  background:hsla(0, 0%, 30%, 1);;\n}\n\n\n.markerPanel_active\n{\n  box-shadow:  0 0 15px 4px rgba(82,168,236,.9);\n  __box-shadow:  0 0 15px 4px #FFFFAA;\n}\n\n\n.panel\n{\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/\n  padding-left:0px;\n  width:120px;\n  height:100%;\n  background: rgba(99, 99, 99, 0.99);\n  margin-right:6px;\n  padding-right:2px;\n  z-index:109;\n  _border:1px solid red;\n}\n\n.panel.inactive\n{\n  opacity:0.3;  \n  pointer-events:none;  \n}\n\n\n.KViewPort_tool.inactive\n{\n  opacity:0.3;  \n  pointer-events:none;  \n}\n\n.panel_toprow\n{   \n   margin-top:-24px;\n   background:#226699; /*menucolor*/\n   overflow:hidden;\n   height:24px;\n\n}\n.panel_toprow > .fa-close\n{\n  position:absolute;\n  right:0px;\n  top:1px;\n  margin-top:0px;\n}\n.panel_toprow > span\n{\n  white-space:nowrap;\n  margin-left:4px;\n}\n\n.roiTool_panel_flex \n{\n\n  display:flex;\n  flex-directions:column;\n  cdjustify-content: flex-end;\n  align-items:center;\n  cborder:1px solid red;\n  padding-top:2px;\n  position:relative;\n\n}\n\n.anno_panel_tools\n{\n  margin:3px 3px 3px 3px;\n  dborder:1px solid rgb(150,150,150);\n  background:#555;\n  width:calc(100% - 30px) !important;\n  border-radius:3px;\n  padding:2px;\n  position:relative;\n\n}\n\n\n.roiTool_panel > div\n{\n  border-radius:0px; /*border-radius*/\n  dbox-sizing:border-box;\n  padding:1px;\n  swidth: 100%;\n  color:white;\n  cursor:default;\n}\n\n.roiTool_panel > .KViewPort_spinner \n{\n\n  color:yellow;\n  background: rgba(1,1,1,0.4);\n  font-size:20px;\n  width:50%;\n  \n\n}\n.roiTool_panel > .KViewPort_spinner  >span\n{\n  color:yellow;\n  background: rgba(1,1,1,0.4);\n  font-size:20px;\n  width:50%;\n  \n\n}\n\n.roiTool_panel .roiTool_panel_flex_topRow\n{\n  padding:0px 0px 4px;\n  background: rgba(139, 0, 0, 1);\n  vetical-align:middle;\n  font-size:16px;\n\n}\n\n.roiTool_panel > div:first-child i\n{\n  background:none;\n}\n\n.roiTool_panel_caption:not(:first-child)\n{\n  border-top:1px solid rgb(150,150,150);\n  margin-bottom:0px;\n}\n\n.roiTool_panel_flex  .label\n{\n    font-size:13px; \n    padding: 0px 2px;\n}\n\n.roiTool_panel_flex  input\n{\n  width:28px;\n  text-align:right;\n  padding-right:1px;\n}\n\n\n.roiTool_KviewControl  input\n{\n  width:28px;\n  text-align:right;\n  padding-right:1px;\n}\n\n\n.floatingViewporthidetitle > .panel_toprow\n{\n  width:20%;\n  height:24px;\n  left:80%;\n  top:2px;\n  border-radius:4px;\n  border:1px solid black;\n}\n\n.floatingViewporthidetitle\n{\n background:none;\n\n}\n\n\n/**************/\n\n.roiTool_panel .thresPenInput > div\n{\n  display:flex;\n  flex-direction:row;\n  _background:green;\n  align-items:left;\n  justify-content:left;\n  white-space:nowrap;\n}\n\n.roiTool_panel .thresPenInput > div  input\n{\n  width:38px;\n}\n\n.roiTool_panel .thresPenInput > div > div:hover .threspenclimsel\n{\n  display:flex;\n}\n\n.roiTool_panel .threspenclimsel\n{\n  display:none;\n  position:absolute;\n  width:auto;\n  cursor:pointer;\n  z-index:900;\n}\n\n.roiTool_panel .threspenclimsel > div\n{\n  position:relative;\n  padding:1px 4px;\n}\n.roiTool_panel .threspenclimsel > div:first-child\n{\n  background:red;\n}\n.roiTool_panel .threspenclimsel > div:last-child\n{\n  background:darkgreen;\n}\n\n.roiTool_panel .threspenclimsel:hover\n{\n  _border:1px solid black;\n  box-shadow:  0 0 2px 2px rgb(0,0,0) inset;\n}\n\n\n\n#roi_default_names_wrap\n{\n  _position:absolute;\n  width:75px;\n  white-space:nowrap;\n  overflow:hidden;\n  padding:2px;\n  margin-top:2px;\n  margin-left:3px;\n  background-color:white;\n  resize:both;\n  height:100%;\n}\n\n\n#roi_default_names_wrap:hover\n{\n  overflow:visible;\n}\n\n\n\n#roi_default_names\n{\n  \n  background-color:white;\n  color:black;\n  text-align:left;\n  height:auto;\n  //height:20px!important;\n}\n\n/* marker panel */\n.panel_floatable\n{\n  /* old version for pos absolute pos */\n  font-family: Arial, sans-serif; \n  font-size: 12pt;\n  border-radius:0px; /*border-radius*/\n  position:absolute;\n  right:0;\n  top:70px;\n  _background: rgba(199, 199, 199, 0.6);\n  height:auto;\n}\n\n\n\n@-moz-document url-prefix() {\n  .roiTool_panel_flex  input\n  {\n    width:23%;\n    text-align:right;\n\n  }\n  \n\n\n  input[type=number]\n  {\n      -moz-appearance:textfield;\n      box-shadow: none;   \n  }\n  \n  \n}\n\n.roiTool_panel ul\n{\n  list-style:none;\n  margin:0;\n  border:1px solid white;\n  tex-align:left;\n  padding:3px;\n  background:rgb(90,90,90);\n\n\n}\n\n.roiTool_panel ul li\n{\n  display:block;  \n\n}\n.roiTool_panel ul:hover li\n{\n  display:block;  \n}\n\n\n.flexspacer\n{\n  flex-grow:1;\n}\n\n\n/*  */\n\n\n\n\n.roiTool_svg  \n{\n\n   position:absolute; \n   overflow:visible;\n   z-index:99;\n   width:100%;\n   height:100%;\n   top:0px;\n   left:0px;\n}\n\n.roiTool_svg  svg\n{\n   position:absolute; \n   width:100%;\n   height:100%;\n   border:0px solid red;\n  \n}\n.roiTool_svg  polygon\n{\n   stroke: rgb(220,0,0);\n   fill:none; \n   stroke-width:2;\n}\n\n.roiTool_svg circle \n{\n   fill:rgb(230,0,0);\n   stroke: rgb(220,0,0);\n   stroke-width:1;\n}\n\n.roiTool_svg circle:hover \n{\n  color:blue;\n  background:white;\n  border:30px solid green;\n  fill: rgb(220,0,0);;\n  stroke: none;\n  radius:20px;\n  filter: url(#svg_blur);\n}\n.roiTool_svgText\n{\n   position:absolute; \n   overflow:visible;\n   z-index:199;\n   left:50%;\n   top:50%;\n   transform:translate(-50%);\n   font-size:24px;\n   text-align:center;\n   color:red;\n   text-shadow:0px 0px 0px white ;\n\n} \n\n\n\n.KRotate3D\n{\n  opacity:0.5;\n  position:absolute;\n  right:0px;\n  bottom:28px;\n  border-radius:1px;\n}\n\n\n.KTimeRangeSlider\n{\n  opacity:0.7;\n  position:absolute;\n  right:0px;\n  bottom:0px;\n  border-radius:1px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  z-index:10;\n  _background:red;\n  _height:50px;\n  pointer-events:all;\n}\n.KTimeRangeSlider div\n{\n  border-radius:2px;\n  _height:14px;\n  display:flex;\n  align-items:center;\n  justify-content:center;\n  \n}\n.KTimeRangeSlider input\n{\n   position:relative;\n   width:20px;\n   height:14px;\n   font-size:12px;\n   text-align:right;\n}\n.KTimeRangeSlider input[type=range]\n{\n   position:relative;\n   width:70px;\n   top:0px;\n}\n\n.KTimeRangeSlider:hover\n{\n\n background:hsla(0,0%,100%,.35);\n}\n\n#Kcmat_annotation\n{\n  position:absolute;\n  background:white;\n  color:black;\n  z-index:9999;\n  pointer-events:none;\n\n}\n\n\n\n.KFiberQuiver\n{\n  position:absolute;\n  top:0px;\n  left:0px;\n  width:100%;\n  height:100%;\n  z-index:1;\n pointer-events:none;\n \n}\n\n.KFiberQuiver > svg\n{\n  color:red;\n  width:100%;\n  height:100%;\n  pointer-events:none;\n  \n}\n\n.atlaslabeltable\n{\n  height:300px;\n  width:auto;\n}\n\n.atlaslabeltable > table\n{\n  top:-2px;\n}\n\n.atlaslabelhead > tr > td\n{\n  border: 0px solid !important;  \n}\n\n\n.atlaslabeltable tr.selected\n{\n  color:black;   \n  border:2px solid red !important \n}\n\n\n.atlaslabeltable tbody td:hover > span\n{\n  position:relative;\n  overflow: visible; \n  background:lightgreen;\n\n}\n\n.KSearchHTML \n{\n  width:100%;\n}\n\n\n\n\n.KViewPort_curvecontainer\n{\n  width:100%;\n  height:auto;\n  border:0px solid lightblue;\n  padding:0px;\n  background:hsl(0,0%,5%);\n  box-sizing:border-box;\n  _position:absolute;\n  top:0px;\n  left:0px;\n  margin:0px;\n  user-select:none;\n  -moz-user-select:none;\n  -webkit-user-select:none;\n\n}\n.KViewPort_svgcontainer\n{\n  padding:40px 40px 40px 60px;\n}\n\n.KViewPort_svgcontainer svg\n{\n   border:0px solid lightblue;\n\n}\n\n\n\n.KViewPort_curvetool_gridline \n{\n  stroke:hsl(0,0%,60%);\n  stroke-width:.1;\n  stroke-dasharray: 1;\n}\n\n.curveTool_grid_vertlines\n{\n  stroke-dasharray: 1;\n}\n.KViewPort_curvetool_timeline\n{\n  stroke:white;\n  stroke:rgb(240,240,240);\n  stroke-width:.2;\n  stroke-dasharray: 0;\n}\n\n\n.KViewPort_curvecontainer polyline\n{\n  vector-effect: non-scaling-stroke;\n  marker-mid: url(#marker-circle);\n}\n\n.KViewPort_svgcontainer svg .polyline\n{\n}\n\n\n.KViewPort_curvecontainer_list\n{\n  border:0px solid red;\n  background: hsla(0, 0%, 40%, 1);\n  padding:4px;\n  flex-grow:0;\n\n}\n\n.KViewPort_curvecontainer_listTitle\n{\n  background:hsl(0,0%,20%);\n  padding:4px 0px 2px 3px;\n  border-bottom:1px solid gray;\n  display:flex;\n  flex-wrap:wrap;\n  overflow:hidden;\n  width:100%;\n}\n\n.KViewPort_curvecontainer_listTitle > div:nth-child(1)\n{\n  margin-right:10px;\n\n}\n.KViewPort_curvecontainer_listTitle > div:nth-child(3)\n{\n  _flex-grow:1;\n  _text-align:right;\n}\n\n\n.KViewPort_curvecontainer_item\n{\n display:flex;\n overflow:hidden;\n flex-wrap:nowrap;\n cursor:default;\n padding:4px 0px;\n width:100%;\n _border:1px solid;\n}\n.KViewPort_curvecontainer_item:hover\n{\n  background:hsl(0,0%,44%);\n}\n\n\n.KViewPort_curvecontainer_item > div\n{\n  flex-shrink:0;\n}\n.KViewPort_curvecontainer_item i\n{\n  margin:1px 4px;\n}\n.KViewPort_curvecontainer_item i:hover\n{\n  color:hsl(0,0%,50%)!important;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n.menu_context\n{\n  color: black;\n  cfont-size:14px;\n  font-weight:normal;\n  white-space: nowrap;\n  display: block;\n  height: 100%;\n  margin: 0px;\n  padding: 0px;\n  background: #E6E6E6;\n  text-shadow: 0 1px 1px rgba(255, 255, 255, .9);\n  text-align: left;\n  border-radius:0px; /*borderradius*/\n  background:#F0F0FF; /*menucolor_context*/ \n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/\n  position:relative;\n  \n}\n\n.menu_context.small\n{\n  font-size:11px !important;\n}\n\n.menu_context i.leftaligned\n{\n  position:relative;\n  top:0px;\n  width:20px;\n  left:1px;\n\n}\n\n.menu_context i\n{\n  position:absolute;\n  right:5px;\n  top:5px;  \n}\n\n\n.menu_context i.button\n{\n  top:4px;  \n  border: 1px solid gray;\n  border-radius:3px;\n  background:lightgray;\n  padding:2px 4px ;\n\n}\n\n.menu_context.small i.button\n{\n  top:1px;  \n  padding:2px 1px ;\n  margin-right:-20px;\n}\n\n.menu_context i:nth-child(2)\n{\n  right:30px;  \n}\n\n.menu_context i:nth-child(3)\n{\n  right:50px;  \n}\n\n.menu_context .button:hover\n{\n  color:red;\n}\n\n\n.menu_context i.pentool\n{\n   position:inherit;\n  margin: 0px 0px 0px 0px;\n  border: 0px solid gray;\n  width: 20px;\n  height: 20px;\n  font-size:17px;\n   background: gray;\n   color:black;\n  padding: 4px;\n\n}\n.menu_context i.pentool:hover\n{\n  background:#99C2EB;\n}\n\n\n\n\n\n\n\n.menu_context li\n{\n  padding:  5px 85px 5px 8px;\n  margin: 0;\n  float: none;\n  position: relative;\n  list-style: none;\n  border: none;\n  cursor:pointer;\n  background: #E6E6E6;\n  border: none;\n  color: #000;\n  border-radius:0px; /*borderradius*/\n  background:#F0F0FF; /*menucolor_context*/\n\n}\n\n.menu_context.small li\n{\n padding:  0px 45px 1px 8px;\n}\n\n\n.menu_context hr\n{\n  background:#F0F0FF; /*menucolor_context*/  \n}\n.menu_context span\n{\n    white-space: nowrap;\n  background:#F0F0FF; /*menucolor_context*/\n  color:#666;\n\n}\n\n.menu_context  ul\n{\n  position:relative;\n  padding: 0;\n  box-shadow: 15px 15px 25px hsla(0, 0%, 10%, .7); /*boxshadow*/\n}\n.menu_context li ul\n{\n  display: none;\n}\n\n.menu_context li:hover\n{\n  background: #229966;\n  color: #fff !important;\n  text-shadow: 0 1px 1px rgba(0, 0, 0, .1);\n}\n\n.menu_context li.inactive:hover\n{\n  background:none;\n  color: #000!important;\n  text-shadow:none!important; \n}\n\n.menu_context li:hover > ul\n{\n  display:block;\n}\n\n.menu_context  li > ul\n{\n  float:none;\n  position:absolute;\n  top:0;\n  left:100%;\n  bborder:1px solid;\n}\n\n\n.patientTableContextmenu\n{\n  position: absolute;\n  display: none;\n  z-index: 9999;\n  padding: 0 ;\n  margin: 0;\n  height: auto;\n  width:auto;\n  border:0px solid transparent;\n  left:100%;\n  top:0;\n  box-sizing:border-box;\n  font-family: Arial, sans-serif;  \n\n}\n\n\n\n.KRoistats_tablecontainer\n{\n  padding:10px;\n}\n\n.KRoistats_table\n{\n  border-collapse:collapse;\n  font-size:14px;\n}\n\n\n.KRoistats_table thead td\n{\n  background:hsl(0,0%,20%);\n  padding:3px;\n  border:1px solid hsl(0,0%,50%);\n  text-align:center;\n\n}\n\n.KRoistats_table tbody td\n{\n  background:hsl(0,0%,70%);\n  color:hsl(0,0%,0%);\n  border:1px solid hsl(0,0%,50%);\n  padding:1px 5px;\n  text-align:right;\n  __font-family: "Courier New", Courier, "Lucida Sans Typewriter", "Lucida Typewriter", monospace;\n\n}\n\n.KRoistats_table tbody td:nth-child(2)\n{\n  _width:0px;\n  _padding:0px;\n}\n\n.KRoistats_table tbody td:nth-child(1), .KRoistats_table tbody td:nth-child(3) \n{\n  text-align:left;\n  font-weight:bold;\n}\n\n.KRoistats_table tbody .noupperborder\n{\n\n}\n\n\n.text_selectable\n{\n     -webkit-touch-callout: text;\n    -webkit-user-select: text;\n    -khtml-user-select: text;\n    -moz-user-select: text;\n    -ms-user-select: text;\n    user-select: text;\n\n}\n\n.maintck\n{\n  background: linear-gradient(to top left, #FEA, #FEA) !important;\n}\n\n\n\n.tckNotVisible\n{\n  opacity:0.4 !important;\n  xbackground:#A88 !important;\n  \n}\n\n\n\n.Kinfo3D\n{\n  position:absolute;\n  background:black;\n  width:auto;\n  height:auto;\n  float: left;\n  font-size: 8pt;\n  line-height:9pt;\n  padding: 3px;\n  color: yellow;\n  z-index:2;\n  background-color: rgba(0,0,0,0.2);\n  pointer-events:none;\n   \n}\n\n\n.mosaiclabels\n{\n  sddisplay:none;\nposition:absolute;\ncolor:yellow;\nbackground:rgba(0,0,0,1);\nz-index:2;\nwidth:0px;\npointer-events:none;\nfont-size:25px;\n  text-shadow: 2px 2px 2px #000;\n\n}\n\n.KViewPort_curvetoolinput\n{\n  white-space: nowrap;\n  \n}\n\n\n.KViewPort_curvetoolinput > span \n{\n  width:50px;\n  \n}\n\n.KViewPort_curvetoolinput > input\n{\n  width:50px;\n  margin-right:10px;\n}\n\n.Kcurveinfo\n{\n  position:absolute;\n  z-index:2 !important;\n  right:2px;\n  height:18px;\n  font-size:10px;\n  border:4px solid black;\n  padding-left:3px;\n  padding-right:3px;\n  opacity:0.6;\n  user-select: text;\n \n\n}\n\n.markerhover3d\n{\n  position:absolute;\n  background:black;;\n  margin:2px;\n  margin-left:10px;\n  opacity:0.6;\n  border:1px solid white;  \n  border-radius:3px;\n  padding:3px;\n  z-index:999;\n}\n\n.color_selector\n{\n  width:90px;\n  display:flex;\n  flex-wrap:wrap;\n  flex-direction:row;\n  padding:0px;\n  background: hsl(0,0%,35%);\n  padding:1px;\n}\n\n.color_selector  input\n{\n  display:block;\n  width:50px;\n  margin-left:5px;\n}\n\n.color_selector > li\n{\n  box-sizing:border-box;\n  margin:0px;\n  flex-grow: 0;\n  width: 33%; \n  border-collapse:collapse;\n}\n.color_selector > div\n{\n  box-sizing:border-box;\n  cursor:default;\n  height:30px;\n  margin:0px;\n  border:3px solid hsl(0,0%,35%);\n  flex-grow: 0;\n  width: 33%; \n  border-collapse:collapse;\n}\n\n.color_selector div:hover\n{\n  border:3px solid hsl(0,0%,25%);\n  opacity:.6;\n}\n\n\n.color_selector_virtual\n{\n  height:10px;\n  width:10px;\n  display:inline-block;\n  border:1px solid gray;\n  margin-right: 4px;\n  margin-bottom:-2px;\n}\n\n\n.ironsight_title\n{\n  font-size:17px;\n  font-weight:700;\n  margin:20px;\n}\n\n.ironSight_ea > span\n{\n  color:lightblue !important;\n}\n\n.ironSight_ep > span\n{\n  color:lightgreen !important;\n}\n\n#brainpicto\n{\n  position:relative;\n  left:10%;\n}\n\n.current_input \n{\n  background:gray;\n}\n\n.ironsight_done\n{\n  border-radius:3px;\n  box-shadow: 1px 1px 1px 1px rgba(0, 0, 0, 1);\n  height:10px;\n  \n}\n\n.Kchart\n{\n  background:white;\nposition:absolute;\n\n}\n\n.KChartCanvas\n{\n  position:relative;\n  height:20px;\n}\n',""]),t.exports=n},function(t,n){t.exports='\n\n\n/**\n* @module MiscFunctions\n*/\n\nvar resources = {\n    lang: "en",\n    tooltips: {\n        en: {\n            roitool_open: "open roitool",\n            masterviewport: "use gridding of content as interpolation master",\n            changeslicing: "change slicing",\n            centerview: "center view at current location",\n            resetclims: "reset colormap limits",\n            changecolormap: "select a different colormap",\n            switchto3d: "Switch to 3D mode",\n            zoomviewport: "Zoom viewport",\n            closeviewport: "close viewport",\n            dragdropviewport: "drag and drop content",\n\n            closetool: "close the tool",\n            resizetoolvertically: "resize the tool vertically",\n            dragdroptool: "drag and drop the tool",\n            patienttrash: "delete selected items or drop an elemet to delete",\n            refreshtable: "refresh the patient table",\n            anonymmode: "(un)switch table anonymization",\n            levelswitcher: "switch table mode",\n            singlesel: "switch to single patient mode",\n            tabletoggler: "resize/toggle table",\n            closeOVL: "close overlay view",\n\n            closefiberview: "close fiber viewer",\n            createvisitmap: "create a visitmap of current selection",\n            showallfibers: "show all fibers",\n            fiberpick: "control fiber picker (use annotations to select fibers)",\n            fibercut: "cut fibers to imaging planes",\n            cropfibers: "create fiber subset by cropping current selection",\n            currentpicker: "enable fiberset for picking",\n\n            batchtestmode: "send jobs to your matlab console",\n\n\n            isosurfROI: "enable 3D isosurface view of ROI",\n            jumptoROI: "jump to center of ROI",\n            selectcolor: "select a different color",\n            saveuploadROI: "upload/save ROI",\n            closeROI: "close view of ROI",\n            createroi: "create ROI",\n            createemptyroi: "create empty ROI",\n            makecurrent: "enable ROI for drawing",\n\n            playstoptimeseries: "play or stop timeseries movie",\n            showhide: "show/hide content",\n            drawonlyonsimilarcolors: "draw on colors similar to center voxel (use colormap limits to control sensitivity)",\n            regionfillsimilarcolors: "unrestricted region filling (use colormap limits and mouse left/right to control sensitivity)",\n            regionfillwithinpen: "region filling within pen",\n            misctools: "miscellaneous tools",\n\n            mcpsys: "create mcp reorientation system from two/three markers",\n            addnewanno: "add new marker to annotation",\n            closeanno: "remove this annotation",\n            showhideanno: "show/hide annotation",\n            jumptopoint: "jump to this point",\n            delannopoint: "delete this point",\n\n        }\n    }\n};\n\n\n\n\n\nif (typeof jQuery != "undefined")\n{\n\n    $.prototype.appendTooltip = function(id)\n    {\n        var tout;\n\n        var fadeOuttimer = {\n            clear: function() {\n                clearInterval(this.id)\n            },\n            callback: function()\n            {\n                inhibit();\n            }\n        };\n\n\n        this.on(\'mouseenter\', function(event) {\n            fadeOuttimer.id = setInterval(function() {\n                fadeOuttimer.callback()\n            }, 8000);\n            clearInterval(tout)\n            tout = setTimeout(function() {\n\n                $("#KJobinfoTooltip").remove();\n                var ttips = resources.tooltips[resources.lang];\n                var text = ttips[id];\n                if (text == undefined)\n                    text = id;\n                var $div = $("<div id=\'standardTooltip\'> " + text + " </div>");\n                $div.css("top", event.clientY);\n                $div.css("left", event.clientX + 15);\n                $div.appendTo($(document.body));\n\n                if ($div.position().left + $div.width() > $(document.body).width())\n                {\n                    $div.css(\'left\', $(document.body).width() - $div.width() - 10);\n                    $div.css(\'top\', $div.position().top + 15);\n                }\n                if ($div.position().top + $div.height() > $(document.body).height())\n                    $div.css(\'top\', $(document.body).height() - $div.height() - 10);\n\n                $div.hide();\n                $div.fadeIn(200);\n\n\n            }, 800);\n\n\n\n        });\n\n\n\n\n\n\n\n\n\n        var inhibit = function()\n        {\n            fadeOuttimer.clear();\n            clearInterval(tout);\n            $("#standardTooltip").remove();\n        }\n\n        this.on(\'mouseleave mouseclick mousedown\', inhibit);\n\n        return this;\n\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n}\n\n\nfunction zeroPad(num, places) {\n    var zero = places - num.toString().length + 1;\n    return Array(+(zero > 0 && zero)).join("0") + num;\n}\n\nif (typeof alertify != "undefined")\n    alertify.lazy_error = function(errstr,type,delay)\n    {\n        if (delay == undefined)\n            delay = 5000;\n\n        if (!alertify[type])\n        {\n            alertify.error(errstr);\n            alertify[type] = true;\n            setTimeout(function() { alertify[type] = false;},delay);\n        }    \t\n    }\n\n\nArray.prototype.chunk = \nObject.defineProperty(Array.prototype, \'chunk\', {\n    value:  \n    function(fn, chunksize, delay, aggregate, onready)\n    {\n        var forchunk = function(_this, fn, chunksize, delay)\n        {\n            if (delay == undefined)\n                delay = 0;\n            _this.interval_id = setInterval(function(_this) {\n                return function()\n                {\n                    if (_this.cnt == undefined)\n                        _this.cnt = 0;\n                    for (var k = 0; k < chunksize & k + _this.cnt < _this.length; k++)\n                    {\n                        fn(_this[k + _this.cnt], k + _this.cnt, _this);\n                    }\n                    if (aggregate)\n                    {\n                        aggregate(_this.cnt);\n                    }\n\n                    _this.cnt += chunksize;\n                    if (_this.cnt >= _this.length)\n                    {\n                        clearInterval(_this.interval_id);\n                        delete _this.cnt;\n                        delete _this.interval_id;\n                        if (onready != undefined)\n                            onready();\n                    }\n\n                }\n            }(_this), delay);\n\n\n        }\n        ;\n\n        forchunk(this, fn, chunksize, delay);\n    }\n});\n\n//Float32Array.prototype.chunk =\nObject.defineProperty(Float32Array.prototype, \'chunk\', {\n    value:  \n    function(fn, chunksize, delay, aggregate, onready)\n    {\n        var forchunk = function(_this, fn, chunksize, delay)\n        {\n            if (delay == undefined)\n                delay = 0;\n            _this.interval_id = setInterval(function(_this) {\n                return function()\n                {\n                    if (_this.cnt == undefined)\n                        _this.cnt = 0;\n                    for (var k = 0; k < chunksize & k + _this.cnt < _this.length; k++)\n                    {\n                        fn(_this[k + _this.cnt], k + _this.cnt, _this);\n                    }\n                    if (aggregate)\n                    {\n                        aggregate(_this.cnt);\n                    }\n\n                    _this.cnt += chunksize;\n                    if (_this.cnt >= _this.length)\n                    {\n                        clearInterval(_this.interval_id);\n                        delete _this.cnt;\n                        delete _this.interval_id;\n                        if (onready != undefined)\n                            onready();\n                    }\n\n                }\n            }(_this), delay);\n\n\n        }\n        ;\n\n        forchunk(this, fn, chunksize, delay);\n    }\n}\n);\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// Octree\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n/** The octree used for fast position lookup of fibers\n * @class\n */\n\nfunction Octree(position, size, accuracy) {\n    this.maxDistance = Math.max(size[0], Math.max(size[1], size[2]));\n    this.accuracy = 0;\n    this.root = new Octree.Cell(this,position,size,0);\n    this.numPoints = 0;\n}\n\n\nOctree.fromBoundingBox = function(bbox) {\n    return new Octree(bbox.min.clone(),bbox.getSize().clone());\n}\n;\n\nOctree.MaxLevel = 4;\n\n\nOctree.prototype.add = function(p, data) {\n    this.numPoints++;\n    this.root.add(p, data);\n}\n;\n\n\nOctree.prototype.has = function(p) {\n    return this.root.has(p);\n}\n;\n\n\nOctree.prototype.findNearestPoint = function(p, options) {\n    options.includeData = options.includeData ? options.includeData : false;\n    options.bestDist = options.maxDist ? options.maxDist : Infinity;\n    options.notSelf = options.notSelf ? options.notSelf : false;\n\n    var result = this.root.findNearestPoint(p, options);\n    if (result) {\n        if (options.includeData)\n            return result;\n        else\n            return result.point;\n    }\n    else\n        return null ;\n}\n;\n\nOctree.prototype.findNearbyPoints = function(p, r, options) {\n    options = options || {};\n    var result = {\n        points: [],\n        data: []\n    };\n    this.root.findNearbyPoints(p, r, result, options);\n    return result;\n}\n;\n\n\nOctree.prototype.getAllCellsAtLevel = function(cell, level, result) {\n    if (typeof level == \'undefined\') {\n        level = cell;\n        cell = this.root;\n    }\n    result = result || [];\n    if (cell.level == level) {\n        if (cell.points.length > 0) {\n            result.push(cell);\n        }\n        return result;\n    } else {\n        cell.children.forEach(function(child) {\n            this.getAllCellsAtLevel(child, level, result);\n        }\n        .bind(this));\n        return result;\n    }\n}\n;\n\n\nOctree.Cell = function(tree, position, size, level) {\n    this.tree = tree;\n    this.position = position;\n    this.size = size;\n    this.level = level;\n    this.points = [];\n    this.data = [];\n    this.children = [];\n}\n;\n\nOctree.Cell.prototype.has = function(p) {\n    if (!this.contains(p))\n        return null ;\n    if (this.children.length > 0) {\n        for (var i = 0; i < this.children.length; i++) {\n            var duplicate = this.children[i].has(p);\n            if (duplicate) {\n                return duplicate;\n            }\n        }\n        return null ;\n    } else {\n        var minDistSqrt = this.tree.accuracy * this.tree.accuracy;\n        for (var i = 0; i < this.points.length; i++) {\n            var o = this.points[i];\n            var distSq = (p[0] - o[0]) * (p[0] - o[0]) + (p[1] - o[1]) * (p[1] - o[1]) + (p[2] - o[2]) * (p[2] - o[2]);\n            if (distSq <= minDistSqrt) {\n                return o;\n            }\n        }\n        return null ;\n    }\n}\n;\n\nOctree.Cell.prototype.add = function(p, data) {\n\n    if (this.children.length > 0) {\n        this.addToChildren(p, data);\n    } else {\n        this.points.push(p);\n        this.data.push(data);\n        if (this.points.length > 10 && this.level < Octree.MaxLevel) {\n            this.split();\n        }\n    }\n}\n;\n\nOctree.Cell.prototype.addToChildren = function(p, data) {\n    for (var i = 0; i < this.children.length; i++) {\n        if (this.children[i].contains(p)) {\n            this.children[i].add(p, data);\n            break;\n        }\n    }\n}\n;\n\nOctree.Cell.prototype.contains = function(p) {\n    return p[0] >= this.position[0] - this.tree.accuracy\n    && p[1] >= this.position[1] - this.tree.accuracy\n    && p[2] >= this.position[2] - this.tree.accuracy\n    && p[0] < this.position[0] + this.size[0] + this.tree.accuracy\n    && p[1] < this.position[1] + this.size[1] + this.tree.accuracy\n    && p[2] < this.position[2] + this.size[2] + this.tree.accuracy;\n}\n;\n\n\nOctree.Cell.prototype.split = function() {\n    var x = this.position[0];\n    var y = this.position[1];\n    var z = this.position[2];\n    var w2 = this.size[0] / 2;\n    var h2 = this.size[1] / 2;\n    var d2 = this.size[2] / 2;\n    var whd = [w2, h2, d2];\n    this.children.push(new Octree.Cell(this.tree,[x, y, z],whd,this.level + 1));\n    this.children.push(new Octree.Cell(this.tree,[x + w2, y, z],whd,this.level + 1));\n    this.children.push(new Octree.Cell(this.tree,[x, y, z + d2],whd,this.level + 1));\n    this.children.push(new Octree.Cell(this.tree,[x + w2, y, z + d2],whd,this.level + 1));\n    this.children.push(new Octree.Cell(this.tree,[x, y + h2, z],whd,this.level + 1));\n    this.children.push(new Octree.Cell(this.tree,[x + w2, y + h2, z],whd,this.level + 1));\n    this.children.push(new Octree.Cell(this.tree,[x, y + h2, z + d2],whd,this.level + 1));\n    this.children.push(new Octree.Cell(this.tree,[x + w2, y + h2, z + d2],whd,this.level + 1));\n    for (var i = 0; i < this.points.length; i++) {\n        this.addToChildren(this.points[i], this.data[i]);\n    }\n    this.points = [];\n    this.data = [];\n\n}\n;\n\nOctree.Cell.prototype.squareDistanceToCenter = function(p) {\n    var dx = p[0] - (this.position[0] + this.size[0] / 2);\n    var dy = p[1] - (this.position[1] + this.size[1] / 2);\n    var dz = p[2] - (this.position[2] + this.size[2] / 2);\n    return dx * dx + dy * dy + dz * dz;\n}\n\nOctree.Cell.prototype.findNearestPoint = function(p, options) {\n    var nearest = null ;\n    var nearestData = null ;\n    var bestDist = options.bestDist;\n\n    if (this.points.length > 0 && this.children.length == 0) {\n        for (var i = 0; i < this.points.length; i++) {\n            var dist = this.points[i].distance(p);\n            if (dist <= bestDist) {\n                if (dist == 0 && options.notSelf)\n                    continue;\n                bestDist = dist;\n                nearest = this.points[i];\n                nearestData = this.data[i];\n            }\n        }\n    }\n\n    var children = this.children;\n\n    var children = this.children\n    .map(function(child) {\n        return {\n            child: child,\n            dist: child.squareDistanceToCenter(p)\n        }\n    })\n    .sort(function(a, b) {\n        return a.dist - b.dist;\n    })\n    .map(function(c) {\n        return c.child;\n    });\n\n    if (children.length > 0) {\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            if (child.points.length > 0) {\n                if (p[0] < child.position[0] - bestDist || p[0] > child.position[0] + child.size[0] + bestDist ||\n                p[1] < child.position[1] - bestDist || p[1] > child.position[1] + child.size[1] + bestDist ||\n                p[2] < child.position[2] - bestDist || p[2] > child.position[2] + child.size[2] + bestDist\n                ) {\n                    continue;\n                }\n                var childNearest = child.findNearestPoint(p, options);\n                if (!childNearest || !childNearest.point) {\n                    continue;\n                }\n                var childNearestDist = childNearest.point.distance(p);\n                if (childNearestDist < bestDist) {\n                    nearest = childNearest.point;\n                    bestDist = childNearestDist;\n                    nearestData = childNearest.data;\n                }\n            }\n        }\n    }\n    return {\n        point: nearest,\n        data: nearestData\n    }\n}\n;\n\nOctree.Cell.prototype.findNearbyPoints = function(p, r, result, options) {\n    for (var i = 0; i < this.points.length; i++) {\n        var dx = this.points[i][0] - p[0];\n        var dy = this.points[i][1] - p[1];\n        var dz = this.points[i][2] - p[2];\n        var dist = (dx * dx + dy * dy + dz * dz);\n        if (dist <= r * r) {\n            if (dist == 0 && options.notSelf)\n                continue;\n            result.points.push(this.points[i]);\n            if (options.includeData)\n                result.data.push(this.data[i]);\n        }\n    }\n\n\n    var children = this.children\n\n    if (children.length > 0) {\n        for (var i = 0; i < children.length; i++) {\n            var child = children[i];\n            //if (child.points.length > 0)\n            {\n                if (p[0] < child.position[0] - r || p[0] > child.position[0] + child.size[0] + r ||\n                p[1] < child.position[1] - r || p[1] > child.position[1] + child.size[1] + r ||\n                p[2] < child.position[2] - r || p[2] > child.position[2] + child.size[2] + r\n                ) {\n                    continue;\n                }\n                child.findNearbyPoints(p, r, result, options);\n            }\n        }\n    }\n}\n;\n\n\n\n\n\n\n\n\nfunction executeImageWorker(execObj,Buffers,progress,onready,worker)\n{\n\n        if (worker == undefined)\n        {\n            var scriptname = \'KImageProcWorker.js\' + \'?\' +  static_info.softwareversion;\n            if (typeof url_pref != "undefined")\n               scriptname = url_pref + scriptname;\n           \n            worker = new Worker(scriptname);\n            worker.postMessage = worker.webkitPostMessage || worker.postMessage;\n            worker.addEventListener(\'message\', function(e) {\n                e = e.data;\n                if (e.msg == \'done\')\n                {\n                    if (progress != undefined)\n                        progress();\n                    onready(e);\n                }\n                else\n                    if (progress != undefined)\n                        progress(e.msg);\n            }, false);\n\n            worker.kill = function()\n            {\n                worker.postMessage({\'msg\':\'kill\'},[]);\n            }\n        }\n\n\n\t\tworker.postMessage(execObj,Buffers); // Send data to our worker.\n\n\t\treturn worker;\t\t\n}\n\n\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// generic context menu\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/** A generic contextmenu\n* @param {function} themenu - A function returning an "ul" containing the menu\n* @param {function} theselfun - called on menu selection with signature theselfun(onchoice,mouseupevent,mousedownevent). First argument contains onchoice attribute of menu "li"\n* @param {logical} loose - ??\n* @param {logical} keepOpenAfterClick - menu disappears only on mouse leave\n* @param {logical} selectonrelease    - allow item selection on moushold- mouseup, can be dangerous for unexperienced users\n* @return {function} - a menu creater function that should be called upon click/mousedown etc.\n*/\n\n\n\n\n\n\nfunction KContextMenu(themenu, theselfun, loose, keepOpenAfterClick, eventonmenu, selectonmouseup)\n{\n    var last_ev;\n    var createFun = function(ev)\n    {\n        if (ev != undefined)\n        {\n            ev.preventDefault();\n            ev.stopPropagation();\n        }\n        last_ev = ev;\n        var target = ev.target;\n        var $cmdiv = $("<div class=\'patientTableContextmenu\'>");\n        \n        var mymenu = themenu(ev);\n        if (mymenu == undefined)\n            return;\n        // this was always called twice, with (ev)...?\n        //var $menu = themenu(ev).appendTo($cmdiv);\n        var $menu = mymenu.appendTo($cmdiv);\n\n\n        // correct for chrome bug, where a hover is not triggered during mousedown\n        $menu.find("li").each(function(i, a) {\n            $(a).mouseenter(function() {\n                $(this).addClass(\'jsHover\');\n            })\n            .mouseleave(function() {\n                $(this).removeClass(\'jsHover\');\n            })\n        });\n        \n        if(keepOpenAfterClick)\n        {\n            var offs_top  = -10;\n            var offs_left = -5;\n        }\n        else\n        {\n            var offs_top  = 5;\n            var offs_left = 5;\n        }\n\n\n\n        $cmdiv.css("display", "block");\n        $cmdiv.css({\n            left: ev.pageX + offs_left,\n            top: ev.pageY + offs_top\n        });\n        $cmdiv.show();\n        var selFun = function(ev2)\n        {\n            var str;\n            var $target = $(ev2.target)\n            for (var k = 0; k < 3; k++)\n            {\n                str = $target.attr("onchoice")\n                if (str != undefined)\n                    break;\n                else\n                    $target = $target.parent();\n            }\n\n            if (str != \'preventSelection\')\n            {\n                ev2.preventDefault();\n                ev2.stopPropagation();\n                if (str != undefined | !loose) // (keepOpenAfterClick | !loose )  // | ev2.type == "mousedown"  | ev2.type == "mouseup") )\n                {\n                    $cmdiv.remove();\n                    fadeOuttimer.clear();\n                    $(document.body).off("mouseup mousedown");\n                }\n\n                if (theselfun(str, ev2, ev) == "close")\n                    return;\n\n                if (keepOpenAfterClick)\n                    createFun(last_ev);\n\n            }\n        }\n        ;\n\n\n        $(document.body).append($cmdiv);\n\n\n        var uls = $cmdiv.find("ul,div");\n        var left = 0;\n        for (var k = 0; k < uls.length;k++)\n        {\n            var $ul = $(uls[k]);\n            var disp = $ul.css(\'display\');\n            if ($ul.offset().left +left + $ul.width() > $(document.body).width())\n                $ul.css(\'left\',-($ul.offset().left +left + $ul.width() - $(document.body).width())- offs_left-20);\n            if ($(document.body).height() != 0 && $ul.offset().top + $ul.height() > $(document.body).height())\n                $ul.css(\'top\', -($ul.offset().top + $ul.height() - $(document.body).height())- offs_top-10);\n\n            if (k==0)\n                left = $ul.offset().left + $ul.width()-20 ;\n        }\n\n\n        var $which = $(document.body);\n        if (eventonmenu)\n        {\n             $which = $cmdiv;\n             $(document.body).on("mousedown",function()\n             {\n                   $(document.body).off("mousedown");\n                   $cmdiv.off("mouseup mousedown");            \n                   $cmdiv.remove();\n             })\n\n        }\n\n        if (keepOpenAfterClick || selectonmouseup === false )\n            $which.on("mousedown", selFun);\n        else\n            $which.on("mouseup mousedown", selFun);\n\n        $which.on("contextmenu",function(e)\n        {\n            e.preventDefault();\n        });\n\n        $cmdiv.on("mouseleave", function(ev) {\n\n            $which.off("mouseup mousedown");\n            fadeOuttimer.clear();\n            $cmdiv.remove();\n        });\n\n        var fadeOuttimer = {\n            clear: function() {\n                clearInterval(this.id)\n            },\n            callback: function()\n            {\n                this.clear();\n                $which.off("mouseup mousedown");\n                $cmdiv.fadeOut(1000);\n            }\n        };\n        fadeOuttimer.id = setInterval(function() {\n            fadeOuttimer.callback()\n        }, 10000000);\n\n    }\n\n    return createFun;\n\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// shared links\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n/** open a shared link. Information comes from php within "sharedLink" variable \n * @param {function} onready - called after establishment of shared viewing state\n*/\nfunction openSharedLink(sharedLink,onready)\n{\n\n    // extend the state with the shared link. Can be done now safely, as the presets are not overwritten\n    // dangerous. can destroy project state and everything ...\n    //$.extend(state, share dLink, true);\n\n   \n    // etabslish tree state\n    if (userinfo.username != guestuser && sharedLink.project != undefined)\n    {\n        selectProject(sharedLink.project, function() {\n\n\n            // set settings\n            if (sharedLink.ViewerSettings !== undefined)\n            {\n                state.viewer = sharedLink.ViewerSettings;\n                stateManager.applyState(state);\n            }\n\n            switchto(state.viewer.selectionMode,undefined,function()\n            {\n\n\n                patientTableMirror.nodesExpanded = sharedLink.expandedNodes || [];\n                patientTableMirror.selectedItems = sharedLink.selectedItems || [];\n                patientTableMirror.mirrorState();\n\n\n\n\n\n                currentPSID = sharedLink.currentPSID || {};\n                if (currentPSID.patients_id)\n                {\n                    if (state.viewer.selectionMode[1] == \'s\')\n                    {\n                        setEditModeText(currentPSID.patients_id + riddelim + currentPSID.studies_id);\n                    }\n                    if (state.viewer.selectionMode[1] == \'p\')\n                    {\n                        setEditModeText(currentPSID.patients_id);\n                    }\n                }\n                loadSharedContent();\n            });\n        });\n    }\n    else\n    {\n\n            // set settings\n        if (sharedLink.ViewerSettings !== undefined)\n        {\n            state.viewer = sharedLink.ViewerSettings;\n            stateManager.applyState(state);\n        }\n\n        loadSharedContent();\n\n    }\n\n    function loadSharedContent()\n    {\n\n        $(document.body).addClass("wait");\t\t\n\n        if (sharedLink.toolstate)\n             KToolWindow.reestablishToolState(sharedLink.toolstate);\n\n  \n        if (sharedLink.naviMode != undefined)\n        {\n            KViewer.navigationTool.switchToNavimode( sharedLink.naviMode);\n            if (sharedLink.navi_reorientationMatrix!= undefined && sharedLink.navi_reorientationMatrix.notID)\n            {\n                KViewer.reorientationMatrix.notID = true;\n                var transform = sharedLink.navi_reorientationMatrix;\n                KViewer.reorientationMatrix.name = transform.name;\n                KViewer.reorientationMatrix.matrix = math.matrix(transform.matrix);\n                KViewer.navigationTool.transform.update();\n            }\n\n            //KViewer.reorientationMatrix = sharedLink.navi_reorientationMatrix;\n        }\n        \n        // load annos\n        if (sharedLink.annotations != undefined)\n        {\n            if (markerProxy != undefined)\n            {\n                markerProxy.delAll();\n                markerProxy.import(sharedLink.annotations.content);\n                if (sharedLink.annotations.panelenabled)\n                {\n                    for(var p in markerProxy.markersets)\n                         markerProxy.markersets[p].showPanel();\n                }\n            }\n        }\n        // load atlas deffield\n        if (sharedLink.atlas_defField != undefined)\n            KViewer.dataManager.loadData({\n                URLType: \'serverfile\',\n                fileID: sharedLink.atlas_defField,\n                json: {\n                    project: sharedLink.project\n                },\n                callback: KViewer.atlasTool.addAtlas\n            });\n\n\n        // load viewport content\n        var params = sharedLink.viewports || [];\n        var q = [];\n        var derived_q = [];\n\n\n\n\n        if (sharedLink.atlases != undefined & !electron)\n            for (var k = 0; k < sharedLink.atlases.length; k++)\n            {            \n               var param = ({ URLType: \'serverfile\', fileID:sharedLink.atlases[k].fileID,json:{project:sharedLink.atlases[k].project},intent:{atlas:true,project:sharedLink.atlases[k].project}});\n               if (param.json.project == undefined)\n                  param.json.project =    sharedLink.project    \n               q.push(param);     \n            }\n\n        for (var k = 0; k < params.length; k++)\n        {\n            if (params[k])\n            {\n                if (params[k].fileID.refvisit_tck)\n                {\n                    derived_q.push(params[k])\n                    continue;\n                }\n                else if (params[k].id.search("atlas") > -1)\n                {\n                    if (params[k].project != undefined)\n                        params[k].json = {\n                            project: params[k].project\n                        };\n                    else\n                        params[k].json = {\n                            project: sharedLink.project\n                            //static_info.atlas.project\n                        };\n                    params[k].fileID = params[k].fileID.replace("atlas_", "");\n                }\n                else\n                    params[k].json = {\n                        project: sharedLink.project\n                    }\n\n\n                q.push(params[k]);\n            }\n        }\n       \n\n        if (electron)\n        {\n            for (var k = 0; k < q.length;k++)\n            {\n                var filepath = q[k].fileID; \n\n                if (sharedLink.absolutePath)\n                    filepath = path.join(sharedLink.absolutePath,filepath);\n\n                filepath = filepath.replace(/\\\\/g,"/"); // for windows\n\n                q[k].URLType = "localfile";\n                q[k].file =  {name:filepath,local:true};\n                q[k].filename = filepath;\n                q[k].fileID = "localfile:"+filepath;\n            }\n        }\n        setTimeout(function(){\n            $(document.body).addClass("wait");\t\t\n            loadingQueue.execQueue(q, function() {\n                if (sharedLink.navi_movingObjs && sharedLink.navi_movingObjs.length > 0)\n                {\n                    for (var k = 0; k < sharedLink.navi_movingObjs.length; k++)\n                        KViewer.navigationTool.movingObjs[sharedLink.navi_movingObjs[k]] =\n                        KViewer.dataManager.getFile(sharedLink.navi_movingObjs[k]);\n                    KViewer.navigationTool.updateMoving();\n                }\n                if (sharedLink.mainviewport != undefined)\n                    KViewer.toggleMainViewport(sharedLink.mainviewport, true);\n\n                //\tKViewer.resetCrossHair();\n                if (sharedLink.position)\n                    KViewer.currentPoint = math.matrix(sharedLink.position);\n\n\n                if (sharedLink.ironSight)\n                {\n                    ironSight.toggle();\n                }\n\n                if (sharedLink.WMQLpanels != undefined)\n                {\n                    for (var k = 0; k < sharedLink.WMQLpanels.length;k++)\n                    {\n                        KWMQLPanel.openPanel(KViewer.obj3dTool.objs[sharedLink.WMQLpanels[k].tract_id],\n                                             KViewer.atlasTool.objs[sharedLink.WMQLpanels[k].atlas_id],\n                                             sharedLink.WMQLpanels[k]);\n\n                    }\n                }\n\n\n\n                signalhandler.send("reslice positionChange");\n\n\n                for (var k=0;k < derived_q.length;k++)\n                {\n                    if (derived_q[k].fileID.refvisit_tck != undefined)                    \n                    {\n                        var vport_id = derived_q[k].fileID.viewport_id;\n                        var vmap_params = derived_q[k].fileID.refvisit_params;\n                        var fibid = derived_q[k].fileID.refvisit_tck;                      \n                        var objs = KViewer.viewports[vport_id].medViewer.objects3D;\n                        for (var j = 0; j < objs.length;j++)\n                            if (KViewer.viewports[vport_id].medViewer.objects3D[j].fibers && \n                                KViewer.viewports[vport_id].medViewer.objects3D[j].fibers.fileID == fibid)\n                            {\n                                var tck = KViewer.viewports[vport_id].medViewer.objects3D[j];\n                                var fobj;\n                                if (vmap_params.terminal)\n                                {\n        \t\t\t\t  \t  \t    tck.visitworker_terms = tck.createVisitMap(vmap_params.undersamp,vmap_params.terminal,true,true);\n        \t\t\t\t  \t  \t    fobj = tck.visitworker_terms.fobj;\n                                }\n                                else\n                                {\n        \t\t\t\t  \t  \t    tck.visitworker = tck.createVisitMap(vmap_params.undersamp,undefined,true,true);        \n        \t\t\t\t  \t  \t    fobj = tck.visitworker.fobj;\n                                }\n                                var target_vid = derived_q[k].intent.viewportID\n                                KViewer.viewports[target_vid].setContent(fobj,{intent:derived_q[k].intent});                                       \n\n                                fobj;\n                            }\n\t\t\t\t  \t  }\n                }\n\n\n      /*\n                setTimeout(function()\n                {\n                    for (var r = 0;r < markerProxy.markersets.length;r++)\n                    {\n                         for (var x in  markerProxy.markersets[r].onupdate)            \n                             markerProxy.markersets[r].onupdate[x]();\n                    }   \n                },1000);\n        */    \n\n                if (sharedLink.TableHidden)\n                    KViewer.toggleTableHide();\n\n\n                if (markerProxy != undefined && sharedLink.currentAnnot != undefined)\n                   markerProxy.setCurrentSet(sharedLink.currentAnnot,true);\n\n                if (sharedLink.zoomedViewport != -1 &&  KViewer.viewports[sharedLink.zoomedViewport] != undefined )\n                    KViewer.viewports[sharedLink.zoomedViewport].zoomViewPort();\n\n\n                $(document.body).removeClass("wait");\t\t\n                $("#KLoadingFrame").css(\'display\',\'none\')\n\n\n                if (onready)\n                    onready();\n\n            });\n        },0);\n    }\n}\n\n\n\n\n\n\nfunction saveWorkstate(that)\n{\n    var s = gatherState(\'savestate\');\n    if (electron)\n    {\n        uploadJSON("workstate.json",s,{subfolder:\'workstates\',tag:\'workstate\'},function(){});\t\t\t\t\t\n    }\n    else\n        alertify.prompt("Enter a name for of state", function(e,name)\n        {\n            if (e)\n            {\n                that.lastProjectStatename = name;\n                uploadJSON(name,s,{subfolder:\'workstates\',tag:\'workstate\'},function(){});\t\t\t\t\t\n            }\n        } ,that.lastProjectStatename);\n\n}\n\n\n\n/** objectifies viewing state including all currently loaded files etc.\n * @return {object} - an object containg all state information\n */\nfunction gatherState(issuer)\n{\n\n    function mapID(obj)\n    {\n        var id ;\n\n        if (obj.content && obj.content.refvisit_params)\n        {\n            id = {refvisit_tck:obj.content.refvisit_tck.fibers.fileID,\n                  viewport_id:obj.content.refvisit_tck.viewer.viewport.viewPortID,\n                  refvisit_params:obj.content.refvisit_params}\n            return id;\n\n\n        }\n        if (obj.fileID)\n            id = obj.fileID;\n        if (obj.currentFileID)\n            id = obj.currentFileID;\n        if (obj.trackingVolID)\n            id = obj.trackingVolID;\n        if (id == undefined)\n            return undefined;\n        if (electron)\n        {\n            var file = KViewer.dataManager.getFile(id);\n            return file.fileinfo.SubFolder + "/" + file.fileinfo.filename;\n\n        }\n        else        \n        {\n            return id;\n        }\n    }\n\n\n    // gather viewport content and overlays\n    var imgs = [];\n    for (var k = 0; k < KViewer.viewports.length; k++)\n    {\n        if (KViewer.viewports[k] == undefined)\n            continue;\n        if(KViewer.viewports[k].getCurrentViewer)\n            var viewer = KViewer.viewports[k].getCurrentViewer();\n        else\n            viewer = undefined;   \n        if (viewer != undefined \n            && ( ( viewer.currentFileID != undefined & viewer.currentFileID != "") || (viewer.nii != undefined && viewer.nii.dummy != undefined) ) )\n        {\n            var myid = "ID" + viewer.currentFileID;\n            if (viewer.viewerType == "medViewer")\n            {\n\n                /*  that.zoomFac = zl[0];\n                that.zoomOriginY = zl[1];// / hei_cm * $canvas.height();\n                that.zoomOriginX =\n\t*/\n\n\n                var gl_props;\n                if (viewer.isGLenabled())\n                    gl_props = {alpha:viewer.gl.camera.alpha,\n                                  beta:viewer.gl.camera.beta,\n                                  radius:viewer.gl.camera.radius,\n                                  planesVisibility:viewer.gl.getPlanesVisibility()};\n\n\n                if (viewer.currentFileID != undefined)\n                {\n\n                    var main_img = {\n                        id: myid,\n                        fileID: mapID(viewer), //viewer.currentFileID,\n                        URLType: \'serverfile\',\n                        name:viewer.currentFilename,\n                        intent:\n                        {\n                            viewportID: k,\n                            zooms: viewer.getRelativeZoomLims(),\n                            cmap: viewer.histoManager.cmapindex,\n                            clim: viewer.histoManager.getManuallyEnteredClim(issuer == \'savestate\'),\n                            gl: viewer.isGLenabled(),\n                            gl_props:gl_props,\n                            isosurf: (viewer.refSurfView!=undefined)?viewer.refSurfView.getViewProperties():undefined,\n                            slicing: viewer.getSlicingDimOfWorld(),\n                            showcolored_type:viewer.showcolored_type,\n                            showcolored:viewer.showcolored,\n                            transfactor:viewer.transfactor\n                        }\n                    };\n\n                    if (viewer.mosaicview && viewer.mosaicview.active)\n                    {\n                        main_img.mosaic = {border:viewer.mosaicview.border,\n                          nx: viewer.mosaicview.nx,\n                          nx_cont: viewer.mosaicview.nx_cont,\n                          zoom: viewer.mosaicview.zoom,\n                          start:viewer.mosaicview.start,\n                          end:viewer.mosaicview.end};\n                    }\n        \n                    if (viewer.nii && viewer.nii.quiver_params)\n                    {\n                        main_img.intent.quiver_params = viewer.nii.quiver_params;\n                    }\n\n\n                    imgs.push(main_img);\n                }\n                if (viewer.overlays != undefined)\n                    for (var j = 0; j < viewer.overlays.length; j++)\n                    {\n                        var myid = "ID" + viewer.overlays[j].currentFileID;\n\n                        imgs.push({\n                            id: myid + "ovl",\n                            fileID: mapID(viewer.overlays[j]),\n                            name:viewer.overlays[j].currentFilename,\n                            URLType: \'serverfile\',\n                            intent:\n                            {\n                                overlay: true,\n                                viewportID: k,\n                                isosurf: (viewer.overlays[j].refSurfView!=undefined)?viewer.overlays[j].refSurfView.getViewProperties():undefined,\n                                cmap: viewer.overlays[j].histoManager.cmapindex,\n                                transparent: viewer.overlays[j].histoManager.blending,\n                                clim: viewer.overlays[j].histoManager.getManuallyEnteredClim(issuer==\'savestate\'),\n                                showcolored:viewer.overlays[j].showcolored,\n                                showcolored_type:viewer.overlays[j].showcolored_type,\n                                posnegsym:viewer.overlays[j].histoManager.posnegsym,\n                                blocky:viewer.overlays[j].histoManager.blocky,\n                                visible:viewer.overlays[j].visible,\n                                hideview:viewer.overlays[j].hideview,\n                                quiver_params:viewer.overlays[j].nii.quiver_params,\n                                outlines: (viewer.overlays[j].outlines != undefined)?((viewer.overlays[j].color != undefined)?viewer.overlays[j].color:0):undefined\n                            }\n                        });\n\n                 \n\n\n                    }\n                if (viewer.ROIs != undefined)\n                    for (var j = 0; j < viewer.ROIs.length; j++)\n                    {\n                        var myid = "ID" + viewer.ROIs[j].roi.fileID;\n                        var roi = viewer.ROIs[j].roi;\n                        var isosurf;\n                       // if (viewer.ROIs[j].refSurfView != undefined)\n                         //   isosurf = true;\n                        imgs.push({\n                            id: myid + "roi",\n                            fileID: mapID(roi),\n                            name:roi.filename,\n                            URLType: \'serverfile\',\n                            intent:\n                            {\n                                roi: true,\n                                isosurf: (viewer.ROIs[j].refSurfView!=undefined)?viewer.ROIs[j].refSurfView.getViewProperties():undefined,\n                                color: viewer.ROIs[j].color,\n                                viewportID: k,\n                                visible:viewer.ROIs[j].visible\n                            }\n                        });\n                    }\n                if (viewer.objects3D != undefined)\n                    for (var j = 0; j < viewer.objects3D.length; j++)\n                    {\n                        var obj = viewer.objects3D[j];\n                        var fid, assoc_annot;\n                        var clim;\n                        var more_intent;\n                        if (obj.getViewProperties)\n                            more_intent = obj.getViewProperties()\n                        else\n                            more_intent = {};\n                        if (viewer.currentFileID == undefined)\n                            more_intent.gl_props = gl_props\n                        if (obj.fibers != undefined | obj.contour != undefined)\n                        {\n\n                            if (obj.fibers)\n                            {\n                                fid = mapID(obj.fibers);     \n                                if (obj.fibers.tckjsonref)                       \n                                    fid = mapID(obj.fibers.tckjsonref);\n                                else\n                                {\n                                    if (obj.children && obj.children.length > 0)\n                                    {\n                                        var json = KViewer.obj3dTool.save(obj.fibers,undefined,true)\n                                        more_intent.jsonsubsets = json;\n                                    }\n                                }\n                                if (obj.Selection && obj.parent)\n                                    more_intent.select = obj.Selection.name;\n                                else\n                                    more_intent.select = \'all\';\n\n                                if ((obj.subsetToDisplay != undefined && obj.subsetToDisplay.length > 0) | \n                                      (obj.isParentView && obj.subsetToDisplay == undefined))\n\n                                {\n                                    more_intent.visible = true; // not yet\n                                    more_intent.donotmakecurrent = true; // not yet\n                                }\n                                else\n                                {\n                                    more_intent.visible = false; // not yet\n                                    more_intent.donotmakecurrent = true; // not yet\n\n                                }\n                                if (obj.isCurrent)\n                                  more_intent.donotmakecurrent = false;\n                                    \n\n                                if (obj.trackingVol)\n                                {\n                                    fid = mapID(obj);\n                                    more_intent.createFiberTracking = obj.getViewProperties();\n                                }                                    \n\n                                                                  \n                                var annots = markerProxy.getSets();\n                                for (var r = 0;r < annots.length;r++)\n                                    if (annots[r].uuid == obj.associated_annotation)\n                                    {\n                                        more_intent.assoc = r;\n                                        break;\n                                    }\n                            }\n                            else\n                            {\n                                fid = mapID(obj.contour);     \n                                more_intent.select = obj.select;\n                \n                            }\n                            more_intent.fibcut = obj.fibcut;\n                            more_intent.fibcut_proj = obj.fibcut_proj;\n                            more_intent.fibcut_thres = obj.fibcut_thres;\n                            more_intent.color = obj.color;\n                            \n                        }\n\n\n                        var atlasiso = undefined\n                        var project = undefined;\n                        if (obj.surf != undefined)\n                        {                            \n                            fid = mapID(obj.surf);\n                            for (var jj=0;jj <obj.overlays.length; jj++)\n                            {\n                                var ovl = obj.overlays[jj];\n                                imgs.push({\n                                    id: myid + "roi",\n                                    fileID: mapID(ovl),\n                                    URLType: \'serverfile\',\n                                    name:ovl.filename,\n                                    intent:\n                                    {\n                                        surfcol: fid,\n                                        cmap: ovl.histoManager.cmapindex,\n                                        clim:ovl.histoManager.clim,\n                                        viewportID: k,\n\n                                    }})\n                            }                            \n                            if (obj.surf.atlasref)\n                            {\n                                fid = mapID(obj.surf.atlasref.atlas),\n                                project =  obj.surf.atlasref.atlas.project,\n                                atlasiso = obj.surf.atlasref.label;\n                            }\n                            else if (obj.refRoiView != undefined)\n                                continue;\n                        }\n                     \n                        if (obj.cmat != undefined)\n                        {\n                            fid = mapID(obj.cmat);\n                            clim = obj.histoManager.getManuallyEnteredClim(issuer == \'savestate\');\n                        }\n                        imgs.push({\n                            id: fid + (atlasiso?"atlas":"") + "3D",\n                            fileID: fid,\n                            project: project,\n                            name:obj.filename,\n                            URLType: \'serverfile\',\n                            intent: $.extend(\n                            {\n                                GL: true,\n                                gl: true,\n                                atlasiso:atlasiso,\n                                viewportID: k,\n                                cuts: obj.cuts,\n                                assoc_annot: assoc_annot,\n                                clim: clim\n                            },more_intent)\n                        });\n\n                        if (obj.surf != undefined)\n                        {\n                           \n\n                        }\n                    }\n                if (viewer.atlas != undefined)\n                    for (var j = 0; j < viewer.atlas.length; j++)\n                    {\n                        var obj = viewer.atlas[j];\n                        imgs.push({\n                            id: myid + "atlas",\n                            fileID: mapID(obj.atlas),\n                            project: obj.atlas.project,\n                            URLType: \'serverfile\',\n                            intent:\n                            {\n                                viewportID: k,\n                                hasPanel :   ( obj.atlas.panel != undefined)? obj.atlas.panel.getState() : undefined,\n                            }\n                        });\n                    }\n\n\n            }\n            else if (viewer.viewerType == "formViewer")\n            {\n                if (viewer.currentFileID == \'NA\')\n                {\n                    var fid = KViewer.formManager.getFormByID(viewer.currentFormID).name;\n                    imgs.push({\n                        id: "ID" + fid + \'formNA\',\n                        fileID: fid,\n                        URLType: \'form\',\n                        intent: {\n                            viewportID: k\n                        }\n                    });\n                }\n                else\n                {\n                    var fid = mapID(viewer);\n                    imgs.push({\n                        id: "ID" + fid + "form",\n                        fileID: fid,\n                        URLType: \'serverfile\',\n                        intent: {\n                            viewportID: k\n                        }\n                    });\n                }\n            }\n            else\n            {\n                var fid = mapID(viewer);\n                imgs.push({\n                    id: "ID" + fid,\n                    fileID: mapID(viewer),\n                    filename: viewer.currentFilename,\n                    URLType: \'serverfile\',\n                    intent: {\n                        viewportID: k\n                    }\n                });\n            }\n\n        }\n    }\n\n\n    var atlas_defField;\n    if (KViewer.atlasTool.defField != undefined)\n        atlas_defField = KViewer.atlasTool.defField.fileID;\n\n    var atlases = [];\n    for (a in KViewer.atlasTool.objs)\n        atlases.push({fileID:KViewer.atlasTool.objs[a].fileID,\n                       project:KViewer.atlasTool.objs[a].project});\n\n    var WMQLpanels = [];\n    if (typeof KWMQLpanel != "undefined")\n    for (var k in KWMQLPanel.panels)\n    {\n        if (KWMQLPanel.panels[k].visible)\n        {\n            WMQLpanels.push(KWMQLPanel.panels[k].getState());\n        }\n            \n    }\n\n\n    // gather settings\n    var vset = $.extend(true, {}, ViewerSettings);\n   // delete vset.SearchText;\n   // delete vset.SearchText_a;\n    vset.crosshairModeDefault = KViewer.crosshairMode;\n    vset.histoModeDefault = KViewer.histoMode;\n\n    var position;\n    if (KViewer.currentPoint)\n        position = KViewer.currentPoint._data;\n    // and pack everything\n\n    var annotations = {content:markerProxy.objectify()};\n\n    var currentAnnot = -1;\n    var keys = Object.keys(markerProxy.markersets);\n\tfor (var k=0;k < keys.length;k++)\t\n\t{\n\t   if (markerProxy.currentSet == markerProxy.markersets[keys[k]])\n            currentAnnot = k;\n     }\n     \n    var iron_visible = false;\n    if (typeof ironSight != "undefined" && ironSight.visible)\n        iron_visible = true;\n   \n\n\n    var shareinfo = {\n        project: project,\n        viewports: imgs,\n        position: position,\n        annotations: annotations,\n        currentAnnot:currentAnnot,\n        SearchText:state.SearchText,\n        SearchText_a:state.SearchText_a,\n        WMQLpanels:WMQLpanels,\n        ironSight:iron_visible,\n        naviMode:KViewer.navigationMode,\n        navi_movingObjs: Object.keys(KViewer.navigationTool.movingObjs),\n        navi_reorientationMatrix: KViewer.reorientationMatrix,\n        mainviewport: KViewer.mainViewport,\n        ViewerSettings: vset,\n        atlas_defField: atlas_defField,\n        atlases:atlases,\n        TableHidden: TableHidden,\n        enabledTool: KTool_enabled(),\n        toolstate: KToolWindow.getToolsState(),\n        styletheme:userinfo.styletheme,\n        zoomedViewport:KViewer.zoomedViewport,\n        electron:electron\n    };\n\n    if (typeof projectInfo != "undefined")\n        shareinfo.project = projectInfo.name;\n\n    if (typeof patientTableMirror != "undefined")\n    {\n        var expanded = {}\n        for (var k in patientTableMirror.nodesExpanded )\n            if (patientTableMirror.nodesExpanded[k] == true)\n            {\n                v = true;\n                for (var j in patientTableMirror.nodesExpanded )\n                {\n                   if (k!=j)\n                   {\n                      if (k.substring(0,j.length) == j)\n                      {\n                          v = v & patientTableMirror.nodesExpanded[j];\n                      }\n\n                   }\n                }\n                if (v)\n                  expanded[k] = true;\n            }\n\n        shareinfo.expandedNodes= expanded;\n        shareinfo.selectedItems= patientTableMirror.selectedItems;\n        shareinfo.currentPSID= currentPSID;\n        shareinfo.ProjectSettings= ProjectSettings;\n\n    }\n\n    if (typeof shareTour != "undefined")\n        shareinfo.tour = shareTour;\n\n\n\n    return shareinfo;\n}\n\n/** called to creae shared link\n */\nfunction shareLink()\n{\n    var shareinfo = gatherState(\'savestate\');\n    var sharedID = "";\n    if (sharedLink && sharedLink.shareID)\n        sharedID = "&shareID=" + sharedLink.shareID + "&ID=" + sharedLink.ID;\n\n    // store all this as a shared link\n    ajaxRequest(\'command=share&json=\' + encodeURIComponent(JSON.stringify(shareinfo)) + sharedID, function(result) {\n        var url = myownurl() + "?sharelink=" + result.id;\n        if (sharedID != "")\n            alertify.prompt("Copy the link below to clipboard (old shared link was overwritten): Ctrl+C, Enter", function() {}, url);\n        else\n            alertify.prompt("Copy the link below to clipboard: Ctrl+C, Enter", function() {}, url);\n    });\n\n\n}\n\n\n\n\nfunction startImageLoader(loaders,callback)\n{\n\n\n   var loaders_ = []\n   for (var k = 0; k < loaders.length;k++)\n   {\n       var l = loaders[k];\n       if (l.url != undefined)\n          l.pattern = l.url;\n       l.enabled = true;\n       if (l.viewportID == undefined)\n       {\n            l.viewportID = "0,1,2";\n            l.intent.slicing = [1,0,2];\n       }\n       loaders_[k] = l;\n   }\n\n\n   startAutoloader(loaders_,undefined , undefined, callback);\n\n\n}\n\n\n\n\n\n\n\n\n\n\nfunction startAutoloader(loader, psid, onerror, callback)\n{\n\t// rows can be a file list from patient table or similar.\n\t// if rows is undefined, the search will performed with an ajax over the whole patient table.\n\n   // close all is already applied further down\n   //signalhandler.send("close");\n\n\n   if (state.viewer.selectionMode[1] == \'a\' | loader == undefined)\n   \t  return;\n\n   var queue = [];\n   var queue_ovlsrois = [];\n\n\n   // iterate over all loaders\n   for (var i=0;i<loader.length;i++)\n   {\n        var currentLoader = loader[i];\n        if (currentLoader.intent.auto_tag == undefined)\n        \tcurrentLoader.intent.auto_tag = i;\n\n        \n\t\tif(currentLoader.enabled !== undefined) // pattern must be set!!!\n\t\t\tif(currentLoader.enabled === false) // pattern must be set!!!\n\t\t\t\tcontinue;\n\t\tif(currentLoader.pattern === undefined | currentLoader.pattern.trim() === \'\') // pattern must be set!!!\n\t\t{\n\t\t\tconsole.log(\'error in autolader. no pattern set.\')\n\t\t\tcontinue;\n\t\t}\n\n\n\t\tvar pat = currentLoader.pattern.replace("$USER",userinfo.username);\n\t\tif(psid != undefined) \n\t\t{\n\t\t\t// check if the pattern contains a specific piz (with this, an image from the same set can be loaded for all patients, e.g. for atlases)\n          \tif(pat.search(\'PIZ\') == -1)   \n              {\n\t\t\t\t\t\n\t\t\t\tpat = pat.split(" OR ").map(function (x) { return x+ \' PPIZ:\'+ psid.piz }).join(" OR ");\n\n\t\t\t  }\n\n            // No, you also want to be able to select studies in patient mode --\x3e> append the study ID only in study mode. IN patient mode, will select ANY study from this patient            \n            //if( psid.sid != undefined && ViewerSettings.selectionMode[1] == "s")\n\t\t// 0 = patient or study, 1=patient, 2=study\n\n\n            if( psid.sid != undefined && ViewerSettings.autoloaderLevel != 1 )\n            {\n            \t\n           \t\tif(pat.search(\'StudyID\') == -1)\n\t\t\t\t\tpat = pat.split(" OR ").map(function (x) { return x+ \' SStudyID:\'+ psid.sid }).join(" OR ");\n            }\n\t\t}\n\t\t\n\t\t// extend with varpattern, e.g for autoloaders\n\t\tpat = (pat + (currentLoader.varpattern!==undefined?currentLoader.varpattern:\'\'));\n\t\t// abuse the pattern as fileID, so that datamanger can store already loaded files\t\n  \t\tvar fi = {ID: pat};\n\t\t\n\n        var shared = {};\n\n\t    if (fi != -1)\n\t\t\t{\n\t\t\t// extract the numeric values from the loader def if not already in numeric strcuture. To be implemented elsewhere\n\t\t\t\n\t\t\tvar slicing =[];\n\t\t\tvar cmaps = [];\n\t\t\tvar select = [];\n\t\t\tvar color = [];\n\t\t\tvar ids = [undefined];\n\t\t\tif (currentLoader.viewportID != undefined)\n\t\t\t{\n\t\t\t\tids  = currentLoader.viewportID.toString().split(",");\n\t\t\t\tids.forEach(function(part,index,array) { array[index] = parseInt(part); });\n\t\t\t}\n\t\t\tif(currentLoader.intent !== undefined)\n\t\t\t{\n\t\t\t\tif (currentLoader.intent.color != undefined && Array.isArray(currentLoader.intent.color))\n\t\t\t\t\tcolor = currentLoader.intent.color.slice(0);\n\t\t\t\tif (currentLoader.intent.select != undefined)\n\t\t\t\t\tselect = currentLoader.intent.select.slice(0);\n\t\t\t\tif (currentLoader.intent.slicing != undefined)\n\t\t\t\t{\n\t\t\t\t\tslicing   = currentLoader.intent.slicing.toString().split(",");  \n\t\t\t\t\tslicing.forEach(function(part,index,array) { if ($.isNumeric(part)) array[index] = parseInt(part); else array[index] = part; });\n\t\t\t\t}\n\t\t\t\tif (currentLoader.intent.cmap != undefined)\n\t\t\t\t{\n\t\t\t\t\tcmaps   = currentLoader.intent.cmap.toString().split(",");  \n\t\t\t\t\tcmaps.forEach(function(part,index,array) { if ($.isNumeric(part)) array[index] = parseInt(part); else array[index] = part; });\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t for (var j=0;j< ids.length; j++)\n\t\t\t\t {\n\t\t\t\t\t\t// auto loader defaults\n\t\t\t\t\t\tvar finalLoader =  new Object();\n\t\t\t\t\t\tfinalLoader.clim = undefined;\n\t\t\t\t\t\tfinalLoader.cmap = undefined;\n\t\t\t\t\t\tfinalLoader.transparent = undefined;\n\t\t\t\t\t\tfinalLoader.overlay = false;\n\t\t\t\t\t\tfinalLoader.gl = false;\n\t\t\t\t\t\t\n\t\t\t\t\t\t// extend with current loader first\n\t\t\t\t\t\t$.extend(true, finalLoader, currentLoader); \n\n\t\t\t\t\t\t// extend with intent, intent wins !!!\n\t\t\t\t\t\t$.extend(finalLoader, currentLoader.intent); \n\n\t\t\t\t\t\tfinalLoader.viewportID = ids[j];   // overwrite id with single number\n\t\t\t\t\t\tif(color[j] != undefined)\n\t\t\t\t\t\t   finalLoader.color = color[j];   \n\t\t\t\t\t\tif(select[j] != undefined)\n\t\t\t\t\t\t   finalLoader.select = select[j];   \n\t\t\t\t\t\tif(slicing[j] != undefined)\n\t\t\t\t\t\t   finalLoader.slicing = slicing[j]; \n\t\t\t\t\t\tif(cmaps[j] != undefined)\n\t\t\t\t\t\t   finalLoader.cmap = cmaps[j];   \n\n\n                        // additional information could be stored in clims. not so nice, add field for that in future. and ideally as object\n                        if( finalLoader.clim !== undefined)\n                            $.extend(true, finalLoader, extractDetailsFromClimString(currentLoader.clim) )\n\n                        finalLoader = $.extend(true,{viewportID:ids[j], slicing:slicing[j]},finalLoader)\n\t\t\t\t\t\tfinalLoader.shared =shared;\n\n                        // set the file params\n                        \n                        var item = {fileID: fi.ID, URLType: \'serverfile\',intent: finalLoader  };\n                        item.intendedName = finalLoader.intendedName;\n                        item.filetype = finalLoader.filetype;\n\n                        //finalLoader.fileparams = {fileID: fi.ID, URLType: \'serverfile\'  }\n                        // queue.push( $.extend(true, { viewportID:ids[j], slicing:slicing[j] },   finalLoader   ) ); //make a deep copy and add j\n                        if (onerror != undefined)\n                            item.onerror = onerror;\n                        if (item.intent.roi || item.intent.overlay || item.intent.createFiberTracking) // these are loader after all the others\n                            queue_ovlsrois.push(item);\n                        else\n                            queue.push(item);\n\t\t\t\t }\n\t\t\t }\n\t\t  else\n\t\t  {\n\t\t  \t if (onerror == undefined)\n\t\t\t   $.notify("no file found with pattern " + currentLoader.pattern );\n\t\t\t else \n\t\t\t     onerror("no file found with pattern " + currentLoader.pattern );\n\t\t  }\n\t\t} // END iterate over all loaders\n   \n\n\t   queue = queue.concat(queue_ovlsrois);\n\n\t   var fileQuerys = [];\n       for (var k = 0;k < queue.length;k++)\n\t\t  fileQuerys[k] = queue[k].fileID;\n\n\t\tif (KViewer.dataManager.getFileList().length >0)\n\t\t{\n\t\t   KViewer.closeAll(undefined, loader.whattoclose );\t\n\t\t}\n\n  \t   $(document.body).addClass(\'wait\');\n\t\t  \n\t   if (typeof ajaxRequest != "undefined")\n  \t       ajaxRequest(\'command=resolve_file_query&json=\' + JSON.stringify({fileQuerys:fileQuerys}) , onresolution);\n  \t   else\n  \t   {\n  \t       var resolved_files = [];\n           for (var k = 0; k < queue.length;k++)\n           {\n            \tqueue[k].URLType = \'foreignurl\';   \n            \tresolved_files[k]  = queue[k].fileID;\n           }\n\n           onresolution({resolved_files:resolved_files});\n\n  \t   }\n  \t    \n\t   function onresolution (result){\n\t\t\t \tvar resolved = [];\n\t\t\t \tfor (var k = 0; k < result.resolved_files.length;k++)\n\t\t\t \t{\n\t\t\t \t\tif ( result.resolved_files[k] == "")  // file not present, create file in case\n\t\t\t \t\t{\n\t\t\t \t\t\tif (queue[k].intent && queue[k].intent.defaultform)\n\t\t\t \t\t\t{\n\t\t\t\t\t\t\t var m = queue[k].fileID.match(/FFilename:\\w+/);\n\t\t\t\t\t\t\t if (m.length>0)\n\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t \tqueue[k].URLType = \'form\';\n\t\t\t\t\t\t\t \tqueue[k].fileID = m[0].substring(10);\n\t\t\t\t\t\t\t \tresolved.push(queue[k]);\n\t\t\t\t\t\t\t }\n\n\t\t\t \t\t\t}\n\t\t\t \t\t\tif (queue[k].intent && queue[k].intent.autocreateroi)\n\t\t\t \t\t\t{\n\t\t\t\t\t\t\t \tqueue[k].URLType = \'createROI\';\n\t\t\t\t\t\t\t \tqueue[k].intendedName = translatepatterntoname(queue[k].fileID)\n\t\t\t\t\t\t\t \tqueue[k].fileID =  queue[queue[k].intent.autocreateroi].fileID;\n\t\t\t\t\t\t\t \tresolved.push(queue[k]);\n\t\t\t \t\t\t}\n\t\t\t \t\t\tif (queue[k].intent && queue[k].intent.autocreate_ano)\n\t\t\t \t\t\t{\n\t\t\t\t\t\t\t \tqueue[k].URLType = \'createANO\';\n\t\t\t\t\t\t\t \tvar pattern = queue[k].fileID;\n\t\t\t\t\t\t\t \tqueue[k].fileID =  queue[k].intent.autocreate_ano;\n\t\t\t\t\t\t\t \tqueue[k].fileID.name = translatepatterntoname(pattern);\n\t\t\t\t\t\t\t \tresolved.push(queue[k]);\n\n\t\t\t \t\t\t}\n\n\t\t\t \t\t\tfunction translatepatterntoname(pattern)\n\t\t\t \t\t\t{\n\t\t\t \t\t\t\tvar subf,name;\n\t\t\t\t\t\t\tvar m = pattern.match(/FFilename:\\w+/);\n\t\t\t\t\t\t\tif (m) // old style\n \t\t\t\t\t\t\t{\n  \t\t\t \t\t\t\t    name = m[0].substring(10);\n                                var m = pattern.match(/FSubFolder:\\w+/);\n                                if (m)\n                                  subf = m[0].substring(11);\n\n                                if (subf == undefined)\n                                    return name;\n                                else\n                                    return subf +"/"+name;\n \t\t\t\t\t\t\t}\n \t\t\t\t\t\t\telse // simple spattern style\n \t\t\t\t\t\t\t{\n                                return pattern.split(" ")[0];\n\n \t\t\t\t\t\t\t}\n\n\n\t\t\t \t\t\t}\n\t\t\t \t\t\t\n\t\t\t \t\t}\n\t\t\t \t\telse\n\t\t\t \t\t{\n\t\t\t \t\t    if (queue[k].URLType == \'foreignurl\')\n                        {\n                        \tvar ttfile = result.resolved_files[k]; // might return multi matches\n                            queue[k].url = ttfile;\n                            queue[k].fileID = ttfile;\n                            if (queue[k].intent && queue[k].intent.intendedID)\n                                 queue[k].fileID = queue[k].intent.intendedID;\n\n\t                        resolved.push(queue[k]);\n                        }\n                        else\n                        {\n                           \tqueue[k].fileID = result.resolved_files[k][0];\n\t                        resolved.push(queue[k]);\n\n                        \tif(queue[k].intent.onmultimatches == \'loadall\')\n                        \t{\n                        \t\tvar flist = result.resolved_files[k];\n                        \t\tfor(var j=1; j<flist.length; j++)\n                        \t\t{\n                        \t\t\tvar newqitem = $.extend(true, {}, queue[k])\n\t\t\t\t\t\t\t\t\tnewqitem.fileID = result.resolved_files[k][j];\n\t\t\t\t\t\t\t\t\tnewqitem.intent.viewportID = queue[k].intent.viewportID + j;\n\t\t\t\t\t\t\t\t\tresolved.push(newqitem);\n                        \t\t}\n                        \t}\n                        }\n\t\t\t \t\t}\n\t\t\t \t}\n\t\t\t \n\t\t\t    if (ViewerSettings.calcpanel && ViewerSettings.calcpanel.enabled)\n\t\t\t         resolved.push({fileID:"meta_"+currentPSID.patients_id + currentPSID.studies_id,\n\t\t\t   \t\t\t\tURLType:"serverfile", intent:{auto_tag:"pinfo"}})\n\t\t\t    \n\t\t        $(document.body).removeClass(\'wait\');\n\n\t\t        KViewer.setViewPortLayout();\n\n\t\t\t    if (resolved.length > 0)\n\t\t\t    {\n\t\t\t\t   loadingQueue.execQueue(resolved,function() \n\t\t\t\t   {\n\t\t\t\t\t\tif(ViewerSettings.autoloaders) // new version of settings\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tKViewer.toggleMainViewport(ViewerSettings.mainViewport,true);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tKViewer.toggleMainViewport(ViewerSettings.viewPortAutoDefaults.mainViewPort,true);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (ViewerSettings.calcpanel && ViewerSettings.calcpanel.enabled)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar autoinput = [];\n\t\t\t\t\t\t\tvar pinfo;\n\t\t\t\t\t\t\tfor (var k = 0;k < queue.length;k++)\n\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tif (queue[k].obj)\n\t\t\t\t\t\t\t\t\tautoinput[queue[k].intent.auto_tag] = queue[k].obj;\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tautoinput[queue[k].intent.auto_tag] = KViewer.dataManager.getFile(queue[k].fileID);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tfor (var k = 0;k < loadingQueue.fobjs.length;k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif ( loadingQueue.fobjs[k].filename && loadingQueue.fobjs[k].filename.search("study meta") > -1)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tpinfo = JSON.parse(loadingQueue.fobjs[k].content);\n\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tKCalcPanel(ViewerSettings.calcpanel,autoinput,pinfo);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (callback)\n\t\t\t\t\t\t\tcallback();\n\t\t\t\t   });\n\t\t\t    }\n               else\n               {\n                    if (callback)\n                        callback();\n\n               }\n\n\t\t\t }\n\t\t\t\t\t  \n\n\n\n\n      function extractDetailsFromClimString(lstr)\n      {\n            var out = {clim:""};\n           \tif($.type(lstr) !== "string")\n            {\n           \t\tout.clim = lstr;\n           \t\treturn;\n           \t}\n            if (lstr.length > 0)\n      \t\t\t{\n      \t\t\t   if (lstr.search("overlay") != -1)\n      \t\t\t   {\n      \t\t\t   \t\tout.overlay = true;\n      \t\t\t   \t\tlstr = lstr.replace("ovl","").trim();\n      \t\t\t   }\n      \t\t\t   if (lstr.search("GL") != -1)\n      \t\t\t   {\n      \t\t\t   \t\tout.gl = true;\n      \t\t\t   \t\tlstr = lstr.replace("GL","").trim();\n      \t\t\t   }\n      \t\t\t   if (lstr.search("transparent") != -1)\n      \t\t\t   {\n      \t\t\t   \t\tout.transparent = true;\n      \t\t\t   \t\tlstr = lstr.replace("transparent","").trim();\n      \t\t\t   }\n      \t\t\t   for (var k = 0; k < colormap.names.length;k++)\n      \t\t\t   {\n      \t\t\t   \t\tif (lstr.search(colormap.names[k]) != -1)\n      \t\t\t   \t\t{\n      \t\t\t   \t\t lstr = lstr.replace(colormap.names[k],"").trim();\n      \t\t\t\t\t\t out.cmap = colormap.names[k];\n      \t\t\t   \t\t}\n      \t\t\t   }\n      \t\t\t   if (lstr.length > 0)  // this is what remains from the clims\n      \t\t\t   {\n      \t\t\t\t   out.clim = lstr.split(",");\n      \t\t\t\t   out.clim.forEach(function(part,index,array) { array[index] = parseFloat(part); });\n      \t\t\t\t   if(out.clim.length != 2 )\n      \t\t\t\t     \tout.clim = "";\n      \t\t\t   }\n      \t\t\t}\n            return out;\n        }\n\n\n}\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// Misc stuff\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nDataView.prototype.getUTF8String = function(offset, length) {\n    var utf16 = new ArrayBuffer(length * 2);\n    var utf16View = new Uint16Array(utf16);\n    for (var i = 0; i < length; ++i) {\n        utf16View[i] = this.getUint8(offset + i);\n    }\n    return String.fromCharCode.apply(null , utf16View);\n}\n;\n\n\n\n\nfunction webgl_detect()\n{\n    if (webgl_detect.is != undefined)\n        return webgl_detect.is;\n\n    var context;\n\n    if (!!window.WebGLRenderingContext) {\n        var canvas = document.createElement("canvas")\n          ,\n        names = ["webgl", "experimental-webgl", "moz-webgl", "webkit-3d"]\n          ,\n        context = false;\n\n        for (var i = 0; i < 4; i++) {\n            try {\n                context = canvas.getContext(names[i]);\n                if (context && typeof context.getParameter == "function") {\n                    webgl_detect.is = true;\n                    return true;\n                }\n            } catch (e) {}\n        }\n\n        // WebGL is supported, but disabled\n        webgl_detect.is = false;\n        return false;\n    }\n\n    // WebGL not supported\n    webgl_detect.is = false;\n    return false;\n}\n\n\n\n\n/***************************************************************************************\n*  loading Queue - loads a series of files from server\n***************************************************************************************/\n\n/** for loading a series of files from server synchronously \n * @class */\nvar loadingQueue =\n{\n    queue: [],\n\t/** @function */\n    execQueue: function(queue, onready)\n    {\n        if (queue != undefined)\n        {\n            loadingQueue.queue = queue.reverse();\n            loadingQueue.fobjs = [];\n        }\n\n        if (loadingQueue.queue.length == 0)\n        {\n            if (onready)\n                onready(loadingQueue.fobjs);\n            return;\n        }\n\n        var item = loadingQueue.queue.pop();\n        var targetViewer;\n        if (item.intent.viewportID != undefined)\n            targetViewer = KViewer.viewports[item.intent.viewportID];\n\n\n\n        if (item.intent.clim == "")\n            item.intent.clim = undefined;\n\n\n        if (targetViewer == undefined)\n        {\n            item.callback = function(fobj) {\n                loadingQueue.fobjs.push(fobj);\n                this.obj = fobj;\n                loadingQueue.execQueue(undefined, onready);\n            }            \n            KViewer.dataManager.loadData(item);\n        }\n        else\n        {\n            if (targetViewer.getCurrentViewer() != undefined && targetViewer.getCurrentViewer().viewerType == \'Manager\')\n                loadingQueue.execQueue(undefined, onready);\n            else\n                targetViewer.openFile(item, function() {\n                    loadingQueue.execQueue(undefined, onready);\n                });\n        }\n    }\n};\n\n\n/***************************************************************************************\n*  Full screen related functions\n***************************************************************************************/\n\nfunction isFullScreen()\n{\n    return (document.fullScreenElement && document.fullScreenElement !== null )\n    || document.mozFullScreen\n    || document.webkitIsFullScreen;\n}\n\nfunction requestFullScreen(element)\n{\n    if (element.requestFullscreen)\n        element.requestFullscreen();\n    else if (element.msRequestFullscreen)\n        element.msRequestFullscreen();\n    else if (element.mozRequestFullScreen)\n        element.mozRequestFullScreen();\n    else if (element.webkitRequestFullscreen)\n        element.webkitRequestFullscreen();\n}\n\nfunction exitFullScreen()\n{\n    if (document.exitFullscreen)\n        document.exitFullscreen();\n    else if (document.msExitFullscreen)\n        document.msExitFullscreen();\n    else if (document.mozCancelFullScreen)\n        document.mozCancelFullScreen();\n    else if (document.webkitExitFullscreen)\n        document.webkitExitFullscreen();\n}\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// Misc\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\nfunction invertObject(obj)\n{\n\n    var inv = {};\n    var keys = Object.keys(obj);\n    for (var k = 0; k < keys.length; k++)\n    {\n        inv[obj[keys[k]]] = keys[k];\n    }\n\n    return inv;\n\n\n}\n\n\nfunction patientTableScrollLock($thediv)\n{\n\n    // turn off horizontal autoscroll behaviour\n    var scleft = $thediv.scrollLeft();\n    var scrollock = function(e) {\n        $thediv.scrollLeft(scleft);\n    }\n    var clear = function() {\n        $thediv.off(\'scroll\', scrollock);\n        $(document.body).off(\'mouseup\', clear);\n    }\n    ;\n    $thediv.on(\'scroll\', scrollock);\n    $(document.body).on("mouseup", clear);\n\n}\n\n\n\nfunction permMat(nii)\n{\n    var P = math.matrix([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]]);\n    for (var i = 0; i < 3; i++)\n        P._data[i][nii.permutationOrder[i]] = nii.arrayReadDirection[i] / nii.voxSize[i];\n    \n    return P;\n}\n\npermutationMat = permMat;\n\n\nfunction permMat_noscale(nii)\n{\n    var P = math.matrix([[0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 0], [0, 0, 0, 1]]);\n    for (var i = 0; i < 3; i++)\n        P._data[i][nii.permutationOrder[i]] = nii.arrayReadDirection[i];\n    \n    return P;\n}\n\n\n\nfunction isIdentity(R)\n{\n    var eps = 0.001;\n    var identity = true;\n    for (var k = 0; k < R.length;k++)\n    {\n        if (Math.abs(R[k][k] - 1) > eps)\n        {\n            identity = false;\n            break;\n        }\n        for (var j = k+1; j < R.length;j++)\n            {\n                if (Math.abs(R[j][k]) > eps | Math.abs(R[k][j]) > eps)\n                {\n                    identity = false;\n                    break;\n                }\n            }\n        if (!identity)\n            break;\n    }\n\n    return identity;\n}\n\n\nfunction transMat(t)\n{\n    if (t._data != undefined)\n        t = t._data;\n    var T = math.matrix(math.diag([1, 1, 1, 1]))._data;\n    T[0][3] = t[0];\n    T[1][3] = t[1];\n    T[2][3] = t[2];\n    return T;\n}\n\nfunction applyInvPerm(p,s)\n{\n    for (var k = 0; k < p.length;k++)\n        if (s == p[k])\n        {\n            return k;            \n        }\n}\n\n\nfunction invert(arr, len)\n{\n    var r = new Array();\n    for (var k = 0; k < len; k++)\n    {\n        r[k] = k;\n    }\n    return $(r).not(arr).get();\n}\n\n\n\nfunction componentToHex(c) {\n    var hex = c.toString(16);\n    return hex.length == 1 ? "0" + hex : hex;\n}\nfunction RGB2HTML(r, g, b,a) {\n    if (a == undefined)\n        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n    else\n        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b) + componentToHex(a);\n}\n\n\n\nfunction hexToRgb(hex) {\n    var result = /^#?([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})([a-f\\d]{2})*$/i.exec(hex);\n    if (result == null)\n        return {\n        r: 0,\n        g: 0,\n        b: 0,\n        a: 1\n    } ;\n    var alpha = 255;\n    if (result[4] != undefined)\n        alpha = parseInt(result[4], 16);\n\n    return result ? {\n        r: parseInt(result[1], 16),\n        g: parseInt(result[2], 16),\n        b: parseInt(result[3], 16),\n        a: alpha\n    } : null ;\n}\n\nfunction KColorSelector(colorlist, colencode, onchange, obj)\n{\n    var colors = colorlist;\n\n    function robustcolencode(colidx)\n    {\n        if (colidx == undefined)\n            return colencode([0,0,0])\n        if (colidx.length == 3)\n            return colencode(colidx)\n        else\n            return colencode(colors[colidx]);\n    }\n\n    var $colselector = $("<div  class=\'KViewPort_tool KViewPort_tool_cmap fibers\' style=\'" + robustcolencode(obj.color) + ";\'>  <i class=\'fa fa-empty fa-1x\'>&nbsp&nbsp&nbsp&nbsp</i></div>");\n    var color_response = function(str, ev) \n    {\n        if (str!=undefined) \n        {\n            obj.color = parseInt(str);\n            $colselector.attr(\'style\', colencode(colors[obj.color]));\n            var col = colors[obj.color];\n            onchange(col,obj.color);\n        }\n    }\n    $colselector.color_response = color_response;\n\n    $colselector.updateColor = function()\n    {\n        $colselector.attr(\'style\', colencode(colors[obj.color]));\n    }\n\n    var color_contextmenu = new KContextMenu(\n    function() {\n        {\n            var $menu = $("<div class=\'menu_context color_selector\'></div>");\n            for (var k = 0; k < colors.length; k++)\n            {\n                var c = colors[k];\n                $menu.append($("<div style=\' " + colencode(c) + "\' onchoice=\'" + k + "\' ><div> </div>  </div>"));\n            }\n            if (obj.alpha != undefined)\n            {\n                var $alpha = $("<input onchoice=\'preventSelection\' type=\'number\' step=\'0.05\' min=\'0\' max=\'1\'>").val(obj.alpha).\n                on(\'change\', function(ev) {\n                    var $input = $(ev.target);\n                    obj.alpha = $input.val();\n                    onchange();\n                });\n                $menu.append($("<li  onchoice=\'preventSelection\'> Alpha: </li>").append($alpha));\n            }\n            if (obj.gamma != undefined)\n            {\n                var $gamma = $("<input onchoice=\'preventSelection\' type=\'number\' step=\'0.05\' min=\'0\' max=\'2\'>").val(obj.gamma).\n                on(\'change\', function(ev) {\n                    var $input = $(ev.target);\n                    obj.gamma = $input.val();\n                    onchange();\n                });\n                $menu.append($("<li  onchoice=\'preventSelection\'> Gamma: </li>").append($gamma));\n            }\n            if (obj.exposure != undefined)\n            {\n                var $exposure = $("<input onchoice=\'preventSelection\' type=\'number\' step=\'0.05\' min=\'0\' max=\'4\'>").val(obj.exposure).\n                on(\'change\', function(ev) {\n                    var $input = $(ev.target);\n                    obj.exposure = parseFloat($input.val());\n                    onchange();\n                });\n                $menu.append($("<li  onchoice=\'preventSelection\'> Exposure: </li>").append($exposure));\n            }\n\n            return $menu;\n        }\n    }\n    ,color_response,false,true);\n    $colselector.click(color_contextmenu);\n    $colselector.themenu = color_contextmenu;\n\n    return $colselector;\n}\n\n\nfunction KColor(c)\n{\n    if (Array.isArray(c))\n        this.color = c.slice(0);\n    else if (typeof c == \'string\')\n    {\n        var tmp = hexToRgb(c);\n        if (tmp.a != undefined)\n            this.color = [tmp.r,tmp.g,tmp.b,tmp.a];\n        else\n            this.color = [tmp.r,tmp.g,tmp.b];\n    }\n    else // and some more, which are not yet implemented\n        this.color = c.slice(0);\n}\n\nKColor.prototype.getAlpha = function()\n{\n    if (this.color[3] != undefined)\n        return this.color[3]/255;\n    else\n        return 1;\n}\n\n\nKColor.prototype.getRGBarr = function()\n{\n    return this.color;\n}\nKColor.prototype.getHEX = function ()\n{\n    if (this.color[3] != undefined && this.color[3] != 255)\n        return RGB2HTML(this.color[0],this.color[1],this.color[2],this.color[3]);\n    else\n        return RGB2HTML(this.color[0],this.color[1],this.color[2]);\n}\nKColor.prototype.getCSS = function()\n{\n    if (this.color.length == 4)\n        return \'rgba(\' + this.color.toString() + \')\'\n    else\n        return \'rgb(\' + this.color.toString() + \')\'\n}\nKColor.prototype.getOpacity = function()\n{\n    if (this.color.length == 4)\n        return this.color[3]/255;\n    else\n        return 1;\n}\nKColor.prototype.getBabylon = function()\n{\n    return new BABYLON.Color3(this.color[0]/255,this.color[1]/255,this.color[2]/255);\n}\nKColor.prototype.darken = function(a)\n{\n\n        this.color[0] *= a;\n        this.color[1] *= a;\n        this.color[2] *= a;\n        return this;\n}\nKColor.findColorIndex = function(color)\n{\n    var retcolor = 0;\n    for(var k=0; k< KViewer.roiTool.colors.length; k++)\n    {\n        var cc = KViewer.roiTool.colors[k];\n        var found = true;\n        for(var j=0; j< cc.length; j++)\n            if(cc[j] != color[j])\n                found = false;\n\n        if(found)\t\n        {\n            retcolor = k;\n            break;\n        }    \t\t\t\n    }\n    return retcolor;\n}\n\n \nKColor.list =[[255,0,0],[0,255,0],[0,0,255],[255,255,0],[255,0,255],[0,255,255],[255,128,0],[255,0,128],[128,255,128],[0,128,255],[128,128,128],[185,170,155]];\n\nfunction KColorSelectorSimple($selectordiv, onchange, obj)\n{\n    var clist = KColor.list;\n    var colors = [];\n    for (var k = 0; k < clist.length; k++)\n        colors[k] = new KColor(clist[k]);\n\n    // return the color list only on request\n    if ($selectordiv === \'getcolors\')\n        return colors;\n\n    if(obj.color instanceof KColor)\n        $selectordiv.css(\'background\', obj.color.getCSS());\n    else\n        $selectordiv.css(\'background\', (new KColor(KColor.list[obj.color])).getCSS() );\n      \n    \n\n    var color_response = function(k)\n    {\n        if (k == undefined)\n            return;\n        var color = colors[parseInt(k)];\n        \n        $selectordiv.css(\'background\', color.getCSS() );\n        //$selectordiv.css(\'background\', (new KColor(color)).getCSS());\n        \n        onchange(color)\n    }\n    $selectordiv.color_response = color_response;\n\n    var color_contextmenu = new KContextMenu(\n    function() {\n        {\n            var $menu = $("<div class=\'menu_context color_selector\'></div>");\n            for (var k = 0; k < colors.length; k++)\n            {\n                $menu.append($("<div style=\'background:" + colors[k].getCSS() + "\' onchoice=\'" + k + "\' ><div></div>  </div>"));\n            }\n            return $menu;\n        }\n    }\n    ,color_response);\n\n    $selectordiv.click(color_contextmenu);\n\n    return $selectordiv;\n}\n\n\n\n\n\n\n\n\n/***************************************************************************************\n*  logout\n****************************************************************************************/\nfunction logout()\n{\n    clearTimeout(updatePatientTimerID);\n    // beforeunload is called automatically -> save state;\n    var url = myownurl();\n    if (url[url.length - 1] == \'#\')\n        url = url.substring(0, url.length - 1);\n    window.location.link_was_clicked = true;\n\n    if(projectInfo != undefined && projectInfo.name != undefined)\n        window.location.href = url + "?logout&project="+projectInfo.name;\n    else\n        window.location.href = url + "?logout";\n\n}\n\nfunction login()\n{\n    logout();\n}\n\n\n/***************************************************************************************\n*  dicom upload\n***************************************************************************************/\n\nvar dicomupload = function(e) {\n    for (var k = 0; k < this.files.length; k++)\n    {\n        var file = this.files[k];\n        var parts = file.name.split(\'.\');\n        var ext = parts[parts.length - 1];\n        var recognized = false;\n        switch (ext.toLowerCase()) {\n        case \'gz\':\n        case \'tgz\':\n        case \'zip\':\n        case \'tar\':\n            recognized = true;\n        }\n\n        if (!recognized)\n            $.notify("file type not accepted: " + file.name + ". Accepted types are gz,tgz,zip,tar! ", "error")\n        else\n        {\n            var xhr = new XMLHttpRequest();\n            var formData = new FormData();\n            formData.append("thefile", file);\n            var notiid = "x" + Math.floor((Math.random() * 1000000000000));\n            $.notify(file.name + " upload started", {\n                autoHide: false,\n                className: "info " + notiid\n            })\n\n            xhr.upload.addEventListener(\'progress\', function(name, id) {\n                return function(e) {\n                    //console.log("progress" + Math.ceil(e.loaded/e.total * 100 )+ \'%\');\n                    $("." + id).text(name + " upload in progress " + +Math.ceil(e.loaded / e.total * 100) + \'%\');\n                }\n            }(file.name, notiid), false);\n\n\n            xhr.open(\'post\', myownurl() + \'?asuser=\' + userinfo.username + "&project=" + projectInfo.name);\n            xhr.send(formData);\n            xhr.onload = function(name, id) {\n                return function(e)\n                {\n                    $("." + id).remove();\n                    try {\n                        var response = JSON.parse(this.response);\n                        if (response.success != 1)\n                            $.notify("error during upload: " + response.msg, "error");\n                        else\n                            $.notify(name + " successfully uploaded, import started!", "success");\n                    }\n                    catch (err)\n                    {\n                        $.notify("error during upload, file above 1GB limit?!", "error");\n\n                    }\n\n                }\n            }(file.name, notiid);\n        }\n\n    }\n    this.value = null ;\n    // otherwise onchange is only triggered if file really changes\n}\n;\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// Signal Handler\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\nfunction SignalHandler()\n{\n    var that = new Object()\n    var signal = new Object();\n    var sigmap = new Object();\n\n    that.signal = signal;\n    that.rid = 0;\n    function send(sigs, event, preferredID)\n    {\n        sigs = sigs.split(" ");\n        \n        for (var k = 0; k < sigs.length; k++)\n        {\n            var s = signal[sigs[k]];\n            if (s != undefined)\n            {\n                if (preferredID != undefined)\n                {\n                    for (var i = 0; i < s.length; i++)\n                        if (s[i].id == preferredID)\n                        {\n                           var ev = $.extend({preferred:true},event);\n                           s[i].handler(ev);\n                           break;\n                        }\n                    for (var i = 0; i < s.length; i++)\n                        if (s[i].id != preferredID)\n                        {\n                           var ev = $.extend({preferred:false},event);\n                           s[i].handler(ev);\n                        }\n\n                }\n                else\n                {\n                    for (var i = 0; i < s.length; i++)\n                        s[i].handler(event);\n                }\n            }\n        }\n\n    }\n    function attach(sig, handler)\n    {\n        if (signal[sig] == undefined)\n            signal[sig] = new Array();\n        signal[sig].push({\n            id: that.rid,\n            handler: handler\n        });\n        that.rid++;\n        return that.rid - 1;\n    }\n\n    function detach(sig, id)\n    {\n        var s = signal[sig];\n        for (var i = 0; i < s.length; i++)\n            if (s[i].id == id | id == "all")\n            {\n                s.splice(i, 1);\n                break;\n            }\n    }\n\n    function detachByIdList(idlist)\n    {\n        for (var k = 0; k < idlist.length; k++)\n        {\n            // stupid, must try and run over all signals if only id is known...\n            for (var tsig in signal)\n            {\n                detach(tsig, idlist[k])\n            }\n        }\n    }\n\n\n    that.send = send;\n    that.attach = attach;\n    that.detach = detach;\n    that.detachByIdList = detachByIdList;\n\n    return that;\n}\n\n\nfunction buildDragImg(ev)\n{\n    var dragtxt = "";\n\n    if (ev.toolDragDrop)\n        dragtxt = ev.toolDragDrop;\n    else\n    {\n        for (var k = 0; k < tempObjectInfo.length; k++)\n        {\n            if (tempObjectInfo[k].type == \'file\' | tempObjectInfo[k].type == \'subfolder\')\n                dragtxt += tempObjectInfo[k].filename + "<br>";\n            else if (tempObjectInfo[k].type == \'patient\')\n                dragtxt += tempObjectInfo[k].piz + "<br>";\n            else if (tempObjectInfo[k].type == \'study\')\n                dragtxt += tempObjectInfo[k].filename + "<br>";\n            else if (tempObjectInfo[k].type == \'markertemplate\')\n                return false;\n            else if (tempObjectInfo[k].type == \'tagpaneltag\')\n                return false;\n        }\n        if (dragtxt == "")\n            dragtxt = "?????";\n        else\n            dragtxt = dragtxt.substring(0, dragtxt.length - 4);\n    }\n\n    if (ev.originalEvent)\n        ev = ev.originalEvent;\n    \n    var crt = $("<div id=\'dragimg\' >" + dragtxt + " </div>").get(0);\n    document.body.appendChild(crt);\n    if (ev.dataTransfer != undefined)\n    {\n        ev.dataTransfer.setDragImage(crt, 0, 0);\n        setTimeout(function() {\n            $("#dragimg").remove() },10 )\n    }\n  //  $("#dragimg").hide();\n\n}\n\n\nfunction buildDragBox(ev, $source, $dragger)\n{\n    var $frame = $("<div class=\'dragbox\'></div>");\n    $frame.width($source.width());\n    $frame.height($source.height());\n    $frame.offset($source.offset());\n    var startoffs = $source.offset();\n    var startpos = [ev.originalEvent.clientX, ev.originalEvent.clientY];\n\n    function mmove(ev2)\n    {\n        $frame.offset({\n            left: startoffs.left + (ev2.originalEvent.clientX - startpos[0]),\n            top: startoffs.top + (ev2.originalEvent.clientY - startpos[1])\n        });\n    }\n\n    $dragger.on("drag", mmove);\n    $dragger.on("dragend", function(ev)\n    {\n        $frame.remove();\n        $dragger.off(\'drag\');\n    })\n\n    $frame.appendTo(document.body);\n}\n\n\nfunction dragstarter(info)\n{\n    return function(ev)\n    {\n        tempObjectInfo = {\n            type: \'\',\n            sid: \'\',\n            piz: \'\',\n            subfolder: \'\',\n            tag: \'\',\n            mime: \'\',\n            filename: \'\',\n            fileID: \'\'\n        };\n        var the_info;\n        if (typeof (info) == \'function\')\n            the_info = info();\n        else\n            the_info = info;\n        tempObjectInfo = [$.extend(tempObjectInfo, the_info)];\n        if (ev.originalEvent != undefined)\n            ev = ev.originalEvent;\n\n        if (ev.dataTransfer != undefined)\n            ev.dataTransfer.setData("fromfiletable", "yea");\n        tempObjectInfo.shiftKey = ev.shiftKey;\n\n        buildDragImg(ev);\n    }\n    ;\n}\n\n\n\nfunction detectmob() {\n    if (navigator.userAgent.match(/Android/i)\n    || navigator.userAgent.match(/webOS/i)\n    || navigator.userAgent.match(/iPhone/i)\n    || navigator.userAgent.match(/iPad/i)\n    || navigator.userAgent.match(/iPod/i)\n    || navigator.userAgent.match(/BlackBerry/i)\n    || navigator.userAgent.match(/Windows Phone/i)\n    ) {\n        return true;\n    }\n    else {\n        return false;\n    }\n}\n\n\nfunction allocateLocalstorage(done)\n{\n\n    // Specify desired capacity in bytes\n    var desiredCapacity = 1024 * 1024 * state.project_user.localstoragesizeMB;\n\n    try {\n        if (desiredCapacity > 0)\n        {\n\n            storage = new LargeLocalStorage({\n                size: desiredCapacity,\n                name: \'myDb\'\n            });\n\n            // Await initialization of the storage area\n            storage.initialized.then(function(grantedCapacity) {\n                // Some browsers don\'t indicate how much space was granted in which case\n                // grantedCapacity will be 1.\n                if (grantedCapacity.getCapacity() == -1)\n                {\n                    console.log("no local storage available!!");\n                    storage = undefined;\n                }\n\n                if (done != undefined)\n                    done();\n            }).catch(function()\n            {\n                console.log("no local storage available!!");\n                storage = undefined;\n                if (done != undefined)\n                    done();\n            });\n\n            storage.rmOld = function(cb, sz)\n            {\n                function findOldest(objs)\n                {\n                    var time = Object.keys(objs);\n                    time.sort();\n                    var sum = 0;\n                    var todel = [];\n                    for (var k = 0; k < time.length; k++)\n                    {\n                        sum += objs[time[k]].filesize;\n                        todel.push(objs[time[k]].docid);\n                        if (sum > sz)\n                            break;\n                    }\n\n                    var fun = function() {\n                        storage.rm(todel[0]).then(function() {\n                            if (todel.length > 0)\n                            {\n                                todel.splice(0, 1);\n                                fun();\n                            }\n                            else\n                            {\n                                cb();\n                            }\n                        })\n                    }\n                    ;\n                    fun();\n\n\n                }\n\n                storage.ls().then(function(docKeys) {\n                    var objs = {};\n                    var fun = function() {\n                        storage.getContents(docKeys[0]).then(\n                        function(content)\n                        {\n                            if (docKeys.length > 0)\n                            {\n                                if (content != "")\n                                {\n                                    var finfo = JSON.parse(content);\n                                    finfo.docid = docKeys[0];\n                                    objs[finfo.timeOfInsertion] = finfo;\n                                }\n                                docKeys.splice(0, 1);\n                                fun();\n                            }\n                            else\n                            {\n                                findOldest(objs);\n                            }\n                        })\n                    }\n                    ;\n                    fun();\n                })\n            }\n\n\n\n\n        }\n        else\n        {\n            storage = undefined;\n            if (done != undefined)\n                done();\n        }\n    }\n    catch (e)\n    {\n        storage = undefined;\n        if (done != undefined)\n            done();\n\n    }\n}\n\n\nfunction toArray(list) {\n    return Array.prototype.slice.call(list || [], 0);\n}\n\n\nfunction readBufferFromFile(reader, ev)\n{\n    // the file is already loaded (e.g converted from dicoms)\n    // workaround: continue the pipeline and give the file reader the corresponding buffer\n\n\n    if (ev.constructor && ev.constructor.name == \'Blob\') // if you give a blob\n    {\n        reader.readAsArrayBuffer(ev);\n    }\n    else if (ev.file === undefined && ev.buffer != undefined) // this bypasses loading for already loaded buffers\n    {\n        reader.customBuffer = ev.buffer;\n        if (reader.onload)\n            reader.onload(ev);\n        if (reader.onloadend)\n            reader.onloadend(ev);\n    }\n    // firefox behaves very differently here. Observed [object FileEntry], [object FilySystemFileEntry], [object File]\n    // maybe ev.file.isFile is more universal\n    //else if (ev.file.toString() == "[object FileEntry]")\n    else if (ev.file.isFile)\n    {\n        ev.file.file(function(f) {\n            ev.file = f;\n            reader.readAsArrayBuffer(ev.file);\n        });\n    }\n    else if (ev.file.local)\n    {\n        //if (reader.onprogress)  // unfortunately no onprogress in fs.readFiles\n        //    reader.onprogress({total:1,loaded:0.5});\n        \n        fs.readFile(ev.file.name,function(err,data){\n            if (data == undefined)\n            {\n                reader.onerror();\n            }\n            else\n            {\n                reader.customBuffer = data;\n\n                if (reader.onload)\n                    reader.onload(ev);\n                if (reader.onloadend)\n                    reader.onloadend(ev);\n            }\n        });\n        \n    }\n    else if (ev.file.compressionMethod != undefined)\n    {\n        ev.file.getData(new zip.BlobWriter(), function(blob)\n        {\n            // text contains the entry data as a String\n            var old = reader.onload;\n            reader.onload = function(e) {\n                ev.progressSpinner();\n                if (old)\n                    old(e)\n            }\n            ;\n            reader.readAsArrayBuffer(blob);\n\n        }, function(current, total)\n        {\n            ev.progressSpinner("unzipping " + math.round(current / total * 100) + "%");\n        });\n    }\n    else\n        reader.readAsArrayBuffer(ev.file);\n\n}\n\n\n\n\n\n\n\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= upload functions\n// ======================================================================================\n// ======================================================================================\n\n\n\nfunction extendWithUniquePSID(finfo)\n{\n\n    // if no psid ist set ...\n    if (finfo.patients_id == "undefined" | finfo.studies_id == "undefined" | finfo.patients_id == undefined | finfo.studies_id == undefined)\n    {\n\n        cPSID = patientTableMirror.getCurrentUniquePSID();\n        if (cPSID === false && userinfo.username != guestuser)\n        {\n            $.notify("Error: You have to select/expand a unique study for upload!", "error");\n            return false;\n        }\n        else\n        {\n            finfo = $.extend(finfo, cPSID);\n        }\n    }\n    return finfo;\n}\n\n\n\n\nuploadJSON.askonOverwrite = true;\nuploadJSON.quiet = false;\nfunction uploadJSON(name, content, finfoextension, onsuccess)\n{\n\n    var out = new Object();\n    out.name = name;\n\n    // create a fileinfo to add to db\n    out = $.extend(out, finfoextension);\n\n    var tag = "";\n    if (out.tag)\n        tag = out.tag;\n    if (tag[0] != \'/\')\n        tag = "/" + tag;\n    if (tag[tag.length - 1] != \'/\')\n        tag = tag + "/";\n\n\n    function appendExtension(stag, ext)\n    {\n        if (tag.search("/" + stag + "/") != -1)\n        {\n            if (out.name.search("\\\\." + ext) == -1)\n            {\n                out.name = out.name.replace(\'.json\', \'\');\n                out.name = out.name + "." + ext + ".json";\n            }\n        }\n    }\n\n    appendExtension("FORM", "form");\n    appendExtension("ANO", "ano");\n    appendExtension("RO", "transform");\n    appendExtension("TCKSEL", "tck");\n\n\n    if (!electron)\n    {\n        out = extendWithUniquePSID(out);\n            \n        if (out.piz == undefined || out.study == undefined)\n        {\n\n            if (out == false)\n                return;\n\n            out.piz = out.patients_id;\n            out.study = out.studies_id;\n        }\n\n        if (out.study == undefined && userinfo.username != guestuser)\n        {\n            alertify.error("please select a unique study to upload!")\n            return;\n        }\n    }\n\n\n    out.content = content\n\n    if (uploadJSON.askonOverwrite && $(\'#patientTable\').find("tr[data-piz=\'" + out.piz + "\'][data-sid=\'" + out.study + "\'][data-subfolder=\'" + out.subfolder + "\'][data-filename=\'" + out.name + "\']").length > 0)\n    {\n        alertify.prompt(\'The file `\' + out.subfolder + \'/\' + out.name + \'` already exists for this study. Overwrite?\', function(e, str)\n        {\n            out.name = str;\n            if (e)\n                saveit()\n        }, out.name);\n        return;\n    }\n    else\n        saveit();\n\n    function saveit()\n    {\n\n\n\n        var json = JSON.stringify(out);\n\n        var public_save_allowed = (static_info && static_info.public_projects);\n        \n        if ( (userinfo.username == guestuser || electron) && !public_save_allowed)\n        {\n            var blob = new Blob([json],{\n                type: "octet/stream"\n            });\n            saveBlob(blob, {filename:out.name} );\n            if (onsuccess)\n                onsuccess();\n\n        }\n        else\n            ajaxRequest(\'command=save_json&json=\' + encodeURIComponent(json), function(e)\n            {\n                if (!uploadJSON.quiet)\n                    $.notify(out.piz + out.study + " " + out.name + " saved.", "success");\n                if (e.fileID == undefined)\n                {\n                    patientTableMirror.mirrorState();     \n                    if (onsuccess)           \n                        onsuccess(undefined,out)\n                    return;\n                }\n                var fobj = KViewer.dataManager.getFile(e.fileID);\n                if (fobj == undefined)\n                {\n                    fobj = {\n                        contentType: \'json\',\n                        fileID: e.fileID,\n                        filename: out.name,\n                        fileinfo: out,\n                        content: {\n                            content: out.content\n                        }\n                    };\n                    if (out.tag != undefined && out.tag.search("TCKSEL") == -1)\n                        KViewer.dataManager.setFile(e.fileID, fobj);\n                }\n\n                patientTableMirror.mirrorState();\n                signalhandler.send("updateInfoBar");\n                if (onsuccess)\n                    onsuccess(fobj,out);\n            });\n    }\n\n\n}\n\n\nfunction str2ab(str) {\n    var buf = new ArrayBuffer(str.length);\n    // 2 bytes for each char\n    var bufView = new Uint8Array(buf);\n    for (var i = 0, strLen = str.length; i < strLen; i++) {\n        bufView[i] = str.charCodeAt(i);\n    }\n    return buf;\n}\n\nfunction uploadBinary(fobj, finfoextension, onsaved, progress, zip, usenativePID)\n{\n\n    // create a fileinfo to add to db\n    var finfo = $.extend(true, fobj.fileinfo, finfoextension);\n    delete finfo.ID;\n\n\n    if (usenativePID)\n    {\n        if (finfo.patients_id == undefined || finfo.studies_id == undefined)\n        {\n            alertify.error("No PID/SID assigned to " + fobj.filename + ", cannot upload!");\n            return;\n        }\n        finfo.usenativePID = true;\n    }\n    else\n    {\n        var backup_pid = finfo.patients_id;\n        var backup_sid = finfo.studies_id;\n        delete finfo.patients_id;\n        delete finfo.studies_id;\n        if (extendWithUniquePSID(finfo) == false)\n        {\n            finfo.patients_id = backup_pid;\n            finfo.studies_id = backup_sid;\n            return;\n        }\n    }\n\n\n    finfo.Filename = fobj.filename;\n    if (fobj.contentType == \'nii\')\n    {\n        if (fobj.filename.search("\\\\.nii") == -1)\n        {\n            if (fobj.notzipped == undefined | !fobj.notzipped)\n                finfo.Filename = fobj.filename + ".nii.gz";\n            else\n                finfo.Filename = fobj.filename + ".nii";\n        }      \n    }\n\n\n    if (zip == undefined)\n        zip = true;\n\n    var exts = [\'json\', \'txt\', \'jpeg\', \'jpg\', \'png\', \'bmp\', \'txt\', \'bvec\', \'bval\',\'bmat\', \'mgh\'];\n    for (var j = 0; j < exts.length; j++)\n        zip = zip & finfo.Filename.search("\\\\." + exts[j]) == -1;\n\n    var alreadyZipped = finfo.Filename.search("\\\\.gz") != -1 || finfo.Filename.search("\\\\.mgz") != -1\n\n    if (fobj.modified)\n        // if this upload originates from local changes, keep the zip state\n        zip = alreadyZipped;\n\n\n\n    if (zip & !alreadyZipped)\n        finfo.Filename += ".gz";\n\n\n    if (!zip & alreadyZipped)\n        finfo.Filename = finfo.Filename.replace(\'.gz\', \'\');\n\n    if (finfo.FilePath)\n        finfo.FilePath = finfo.FilePath.substring(0, finfo.FilePath.lastIndexOf("/")) + "/" + finfo.Filename;\n    else\n        finfo.FilePath = "";\n    //build filepath on php side\n\n    if (progress)\n        progress(\'packing \' + fobj.filename);\n\n\n    finfo.Filename = finfo.Filename.trim();\n\n    if (finfo.SubFolder == undefined)\n        finfo.SubFolder = "";\n\n    if (0)\n        setTimeout(function() {\n            executeUpload({\n                fobj: fobj,\n                zip: zip,\n                alreadyZipped: alreadyZipped,\n                finfo: finfo,\n                progress: progress,\n                onsaved: onsaved\n            });\n        }, 10);\n    else\n    {\n        var obj = {\n            fileID: fobj.fileID,\n            userinfo: userinfo,\n            projectInfo: projectInfo,\n            myownurl: myownurl(),\n            zip: zip,\n            alreadyZipped: alreadyZipped,\n            finfo: finfo\n        };\n\n        if (fobj.fileID.substring(0, 5) != \'proxy\')\n        {\n            obj.buffer = fobj.content.buffer;\n            if (fobj.content.buffer != undefined)\n                obj.buffer = fobj.content.buffer;\n            else            \n            {\n                if (typeof fobj.content == "object")\n                   obj.buffer = str2ab(JSON.stringify(fobj.content));\n                else\n                   obj.buffer = str2ab(fobj.content);\n            }\n\n            obj.deflate = zip;\n            obj.inflate = false;\n            executeUploadWorker(obj, progress, onsaved);\n        }\n        else\n        {\n            var reader = new FileReader();\n            reader.onload = function(e) {\n                obj.buffer = reader.result;\n                obj.deflate = zip & !alreadyZipped;\n                obj.inflate = !zip & alreadyZipped;\n                executeUploadWorker(obj, progress, onsaved);\n            }\n            readBufferFromFile(reader, fobj.proxyev)\n        }\n\n        return true;\n    }\n\n\n}\n\nfunction executeUploadWorker(obj, progress, onsaved)\n{\n\n\n    var scriptname = \'KuploadWorker.js\' + \'?\' +  static_info.softwareversion;;\n    if (typeof url_pref != "undefined")\n       scriptname = url_pref + scriptname;\n    \n    var worker = new Worker(scriptname);\n\n    worker.addEventListener(\'message\', function(e) {\n        e = e.data;\n        if (e.msg == \'done\')\n        {\n            progress();\n\n            try\n            {\n                var response = JSON.parse(e.response);\n            }\n            catch (err)\n            {\n                alertify.alert("ERROR: The returned data was not in JSON format\\n\\n " + err + "\\n" + "<textarea style=\'width:400px;height:500px\'>" + e.response + "</textarea>");\n                return false;\n            }\n\n            if (response.success != 1)\n                alertify.error("error during upload: " + response.msg, "error");\n            else\n                onsaved(obj.fileID, response);\n        }\n        else if (e.msg == \'warning\')\n        {\n            progress();\n            alertify.error("error during upload: " + e.err);\n        }\n        else\n            progress(e.msg);\n    }, false);\n\n    // we need to clean the obj for cloning\n    var savegl;\n    if (obj.finfo.surfreference)\n    {\n        savegl = obj.surfreference;\n        obj.finfo.surfreference = undefined;\n    }\n    var saveupdate;\n    if (obj.userinfo.update)\n    {\n        saveupdate = obj.userinfo.update;\n        obj.userinfo.update = undefined;\n    }\n\n    worker.postMessage(obj);\n    // Send data to our worker.\n\n    // reestablish cleaned props\n    if (savegl)\n        obj.finfo.surfreference = savegl;\n    if (saveupdate)\n        obj.userinfo.update = saveupdate;\n}\n\nfunction saveNiftilocal(fobj)\n{\n    var zipped = false;\n\n\n    if (fobj.contentType == \'nii\')\n    {\n        if (fobj.filename.search("\\\\.nii") == -1)\n            fobj.filename = fobj.filename + ".nii";\n    }\n\n    // pack the file as blob\n    var x = new Uint8Array(fobj.content.buffer);\n    if (zipped)\n    {\n        x = pako.gzip(x);\n        if (fobj.filename.search("\\\\.gz") == -1)\n            fobj.filename += ".gz";\n    }\n    else\n    {\n        fobj.filename = fobj.filename.replace(".gz", "");\n    }\n    var blob = new Blob([x],{\n        type: \'application/octet-binary\'\n    });\n\n    \n    saveBlob(blob, fobj);\n    KViewer.cacheManager.update();\n\n}\n\n\n\n\nfunction saveBlob_electron(blob, fobj)\n{\n        if (fobj.fileinfo == undefined)\n            fobj.fileinfo = {};\n        \n\n        if (fobj.fileinfo.SubFolder == undefined)\n            fobj.fileinfo.SubFolder = defaultOpenPath;\n\n        var res = dialog.showSaveDialog({ title: \'save file\',\n\t\t\t\t\t\t\tproperties: [],\n\t\t\t\t\t\t\tdefaultPath: fobj.fileinfo.SubFolder + "/" + fobj.filename\n\t\t\t\t\t\t})\n        if (res.then)\n            res.then(saveit)\n        else\n            saveit(res);\n\n\n\t\tfunction saveit(savename)\n\t\t\t\t\t\t{\n                          if (savename.filePath)\n                             savename =savename.filePath;\n\n\t\t\t\t\t\t  if (savename == undefined)\n\t\t\t\t\t\t      return;\n\n\t\t\t\t\t\t  savename = savename.replace(/\\\\/g,"/");\n\t\t\t\t\t\t  if (path.extname(savename) == "")\n\t\t\t\t\t\t      savename = savename + path.extname(fobj.filename);\n\n\n                          var fileReader = new FileReader()\n\n                          fileReader.onload = function(event) {\n\n                            var buffer = Buffer.from(event.target.result);\n                            try {\n                                if (fobj.contentType != "nii")\n                                {\n                                    var obj = JSON.parse(Buffer.from(event.target.result).toString(\'utf8\'));\n                                    if (obj.tag == \'workstate\')\n                                    {\n                                        var content = obj.content;\n                                        var wspath = path.dirname(savename);\n                                        for (var k = 0; k < content.viewports.length;k++)\n                                            content.viewports[k].fileID  = path.relative(wspath, content.viewports[k].fileID);\n                                        buffer = JSON.stringify(obj);\n\n                                    }\n                                }\n\n                            } catch(err) {}\n\n\n\n\t\t\t\t\t\t     fs.writeFile( savename, buffer,undefined,function(err)\n\t\t\t\t\t\t     { \n                                    alertify.success(\'successfully saved \' + savename);\n                                    defaultOpenPath = fobj.fileinfo.SubFolder;\n\t\t\t\t\t\t     });\n                          };\n                          fileReader.readAsArrayBuffer(blob);\n\t\t\t\t\t\t}\n     \n}\n\n\n\n\n\n\nfunction saveBlob(blob, fobj)\n{\n    if (electron)\n    {\n        saveBlob_electron(blob,fobj);\n    }\n    else\n    {\n        var filename = fobj.filename;\n        // initiate download\n        var url = window.URL.createObjectURL(blob);\n        var link = document.createElement(\'a\');\n        link.setAttribute(\'href\', url);\n        link.setAttribute(\'download\', filename);\n        var event = document.createEvent(\'MouseEvents\');\n        event.initMouseEvent(\'click\', true, true, window, 1, 0, 0, 0, 0, false, false, false, false, 0, null );\n        link.dispatchEvent(event);\n    }\n}\n\n\nfunction saveScreenShot(blob, finfo, type, download)\n{\n    var defname = this.defaultname;\n\n    alertify.prompt("Please enter a name", function(e, name) {\n        if (e)\n        {\n            this.defaultname = name;\n            // create a nice file name with increasing numbers, so we have at least some unique id\n            var filename = name == "" ? "screenshot" : name;\n            var list = $(\'#patientTable\').find("tbody").find(".fileRow[data-subfolder=screenshots]");\n            seriesnumber = 1;\n            if (list.length > 0)\n            {\n                list.each(function(k, e) {\n                    var a = $(e).attr(\'data-filename\').match(/(\\d+)\\..*/);\n                    list[k] = a === null ? null : a[1];\n                });\n                seriesnumber = Math.max.apply(null , list) + 1;\n            }\n            // pad with 3 zeros\n            seriesnumber = ("0000" + seriesnumber);\n            seriesnumber = seriesnumber.substr(seriesnumber.length - 3);\n            if (type == undefined)\n                type = \'.png\';\n            filename += ("_" + seriesnumber + type);\n\n            var fobj = {\n                fileID: \'proxy\',\n                buffer: 0,\n                filename: filename,\n                fileinfo: {\n                    patients_id: finfo.patients_id,\n                    studies_id: finfo.studies_id,\n                    SubFolder: \'screenshots\'\n                },\n                proxyev: blob\n            };\n\n            if (userinfo.username == guestuser || download)\n            {\n                saveBlob(fobj.proxyev, fobj);\n            }\n            else\n                uploadBinary(fobj, {}, function(e) {\n                    KViewer.progressSpinner();\n                    patientTableMirror.mirrorState();\n                    // updates study contents and keeps tree state\n                }, KViewer.progressSpinner, false)\n        }\n    },defname);\n\n}\n\n\n  \n\n\nKPanel.currentPanels = {};\nfunction KPanel($target, id, title)\n{\n    var panel = {visible:true};\n\n    KPanel.currentPanels[id] = panel;\n\n    $(\'div[id="\'+id+\'"]\').remove();\n    var $container = $("<div id=\'" + id + "\' class=\'panel_floatable roiTool_panel panel\' ></div>");\n    $container.appendTo($target);\n\n    panel.$container = $container\n    panel.show = function()\n    {\n        panel.visible = true;\n        $container.show();\n\n    }\n\n\n\n    panel.close =function()\n    {\n        if (panel.visible)\n        {\n            panel.hide();\n            if (panel.customClose)\n                panel.customClose(panel);\n        }\n    }\n\n    panel.hide = function()\n    {\n        panel.visible = false;\n        $container.hide();\n    }\n\n    panel.toggle = function()\n    {\n        if (!panel.visible)\n            panel.show();\n        else\n            panel.hide();\n    }\n\n    panel.$spinner = $("<div class=\'KViewPort_spinner\' ><i class=\'fa fa-spinner fa-spin\'></i> <span >Loading</span></div>").appendTo(panel.$container);\n    /** spinner callback for this tool (see {@link module:MiscFunctions~theSpinner}) */\n    panel.progressSpinner = theSpinner(panel.$spinner);\n    panel.hideSpinner = function() {  panel.$spinner.hide(); }\n\n   \n    // ----------- the top Row\n\n    var $topRow = $("<div class=\'panel_toprow roiTool_panel_flex persistent \'></div>").appendTo($container);\n    panel.$topRow = $topRow;\n    $mover = $("<i class=\'KViewPort_tool fa fa-hand-paper-o \'></i>");\n    var $caption = $("<span>" + title + "</span>");\n    var $close = $("<i class=\'KViewPort_tool panel_toprow fa fa-close\'></i>").click(\n      function() { if (panel.closeOnHide)\n                        panel.close()\n                   else\n                        panel.hide() } );\n    $topRow.append($caption).append($("<i class=\'flexspacer\'></i>")).append($close);\n\n\n    $container.css(\'left\',100);\n    $topRow.mousedown(function(ev) {\n        var starDiffX = -ev.clientX + parseInt($container.css(\'left\'));\n        var starDiffY = ev.clientY - parseInt($container.css(\'top\'));\n        $(document.body).mousemove(function(ev)\n        {\n            var dx = starDiffX + ev.clientX;\n            //if (dx > 0)\n            {\n              //  dx = dx < 10 ? 0 : dx;\n                $container.css(\'left\', dx);\n            }\n            var dy = -starDiffY + ev.clientY;\n            if (dy > 0)\n                $container.css(\'top\', dy);\n        });\n        $(document.body).on(\'mouseup mouseleave\', function(ev) {\n            $(this).off(\'mousemove\');\n        });\n\n    });\n\n    return panel;\n\n\n}\n\n\nvar ironSight = {\n\n    visible:false,\n\n    isVisible:function() {\n            return (ironSight.panel && ironSight.panel.visible) ;\n        },\n\n    toggle: function()\n    {\n        if (ironSight.panel)\n        {\n            ironSight.visible = !ironSight.visible;\n            ironSight.panel.toggle();\n        }\n        else\n        {\n            ironSight.createPanel();\n            ironSight.visible = true;\n        }\n    },\n\n\n\n\n    save: function()\n    {\n\n        alertify.prompt("Enter a name:", function(e,name)\n        {\n            if (e)\n            {\n                 var s = {\n                   elec_La: ironSight.input.elec_La.getVal(),\n                   elec_Ra: ironSight.input.elec_Ra.getVal(),\n                   elec_Lp: ironSight.input.elec_Lp.getVal(),\n                   elec_Rp: ironSight.input.elec_Rp.getVal(),\n                   ear_R:ironSight.input.ear_R.getVal(),\n                   ear_L:ironSight.input.ear_L.getVal() };\n                uploadJSON(name,s,{subfolder:\'ironsight\',tag:\'ironsight\'},function(){});\t\t\t\t\t\n            }\n        } ,"ironsight_state");\n\n    },\n\n    import: function(s)\n    {\n        ironSight.input.ear_L.setVal(s.ear_L);\n        ironSight.input.ear_R.setVal(s.ear_R);\n        ironSight.input.elec_La.setVal(s.elec_La);\n        ironSight.input.elec_Ra.setVal(s.elec_Ra);\n        ironSight.input.elec_Lp.setVal(s.elec_Lp);\n        ironSight.input.elec_Rp.setVal(s.elec_Rp);\n    },\n   \n\n\n    createPanel: function()\n    {\n\n        var panel = KPanel($(document.body), "ironSight", "ironSight");\n        ironSight.panel = panel;\n\n        panel.$container.width(400)\n        var $fileRow = $("<div class=\'roiTool_panel_flex_persistent\'></div>").appendTo(panel.$container);\n        var $start = $("<div class=\'ironsight_title\'><span>3D x-ray based visualization of directional deep brain stimulation lead orientation. </span></div>")\n\n        $fileRow.append($start).append($("<i class=\'flexspacer\'></i>"));\n        ironSight.$progress = $(" <span>  </span>").appendTo($fileRow);\n\n        $("<div class=\'roiTool_panel_caption\'></div>").appendTo(panel.$container);\n        $(\'<object  id="brainpicto" type="image/svg+xml" data="ironsight.svg"></object>\').appendTo(panel.$container);\n\n\n        var current_input;\n        signalhandler.attach("positionChange",function()\n        {\n\n            if (current_input != undefined)\n            {\n                current_input.trigger_get_click();\n            }\n        });\n\n     \n        var picto = document.getElementById(\'brainpicto\').contentDocument        \n\n\n\n        var left_ear = 0;\n        var right_ear = 0;\n\n        function sliceToAngle(a)\n        {\n            return (parseFloat(a)-left_ear)/(right_ear-left_ear)*180 -90;\n        }\n\n        function angleToSlice(a)\n        {\n            return a/delta  + offset;\n        }\n\n        function takeVal($input,fun)\n        {\n           return function() {\n            var p = 0;\n            var vp = KViewer.viewports[p];\n            var mv = vp.getCurrentViewer()\n            if (mv == undefined)\n                {\n                    //alertify.error(\'load the MIP into viewport\')\n                    return;\n                }\n            var v = mv.getCurrenVoxel()._data\n            var val = (v[2]);\n            $input.val(val); \n            if (fun)\n                fun(val);\n            update();\n             }\n        }\n\n        function setVal($input,fun)\n        {\n           return function() {\n            if ($input.val() == "")\n                return;\n            var p = 0;\n            var vp = KViewer.viewports[p];\n            var mv = vp.getCurrentViewer()\n            if (mv == undefined)\n                {\n                  //  alertify.error(\'load the MIP into viewport\')\n                    return;\n                }\n            mv.setSlicePos(2,parseFloat($input.val()));\n            \n             }\n        }\n\n        function helpertext(type)\n        {\n            if (type == "leftear")\n            {\n                return "define the angle system by finding the direction where the ear canals overlap while looking from the <b>left</b> side of the head."\n            }\n            if (type == "rightear")\n            {\n                return "define the angle system by finding the direction where the ear canals overlap while looking from the <b>right</b> side of the head."\n            }\n            if (type == "eal")\n            {\n                return "find the direction where the ironsight sign is visible for the left elctrode while looking from the left";\n            }\n            if (type == "epl")\n            {\n                return "find the direction where the ironsight sign is visible for the left elctrode while looking from the right (depending on coverage this is most of the times not possible)";\n            }\n            else\n                return "helper " + type;\n        }\n\n\n\n        function update()\n        {\n\n            var eal =  $elec_La.update();\n            var ear =  $elec_Ra.update();\n            var epl = $elec_Lp.update();\n            var epr = $elec_Rp.update();\n            return;\n\n        }\n\n        function updateAngle()\n        {\n            var p = 0;\n            var vp = KViewer.viewports[p];\n            var mv = vp.getCurrentViewer()\n            if (mv == undefined)\n                {\n                    return;\n                }\n            var v = mv.getCurrenVoxel()._data\n            var val = sliceToAngle(v[2]).toFixed(1);\n            $(panel.$angle0[1]).text(val );\n        }\n\n        var widinput = 50;\n        var widspan = 200;\n\n        function setSVGtext(id,txt)\n        {\n            var x = document.getElementById(\'brainpicto\').contentDocument\n            if (x == undefined)\n                return\n            x = x.getElementById(id)\n            if (x == undefined)\n                return\n            x = x.children[0];\n            x.textContent = txt;\n            \n\n        }\n\n        function setArrowDir(id,angle)        \n        {\n            if (isNaN(angle))\n                return;\n\n            var x = document.getElementById(\'brainpicto\').contentDocument\n        \n            x = x.getElementById(id)\n            $(x).css(\'opacity\',1)\n            var dir = x.getAttribute("d").split(" ");\n            var r = 30;\n            x.setAttribute("d","m " + dir[1] + " " + Math.cos(angle/180*Math.PI)*r + "," + Math.sin(angle/180*Math.PI)*r);\n\n        }\n\n\n        function setAMarker(angle)        \n        {\n            if (isNaN(angle))\n                return;\n\n            var x = document.getElementById(\'brainpicto\').contentDocument\n        \n            x = x.getElementById("AMARKER")\n            if (x==null)\n                return;\n            $(x).css(\'opacity\',1)\n            var dir = x.getAttribute("d").split(" ");\n            var r = 125;\n            x.setAttribute("d","m " + dir[1] + " " + Math.cos(angle/180*Math.PI)*r + "," + Math.sin(angle/180*Math.PI)*r);\n\n        }\n\n\n        function input_field(txt,onchange,type)\n        {\n\n\n            var $div0 = $("<div class=\'inputrow roiTool_panel_flex\'></div>").appendTo(panel.$container);\n            var $input = $(" <span  style=\'width:"+widspan+"px;\' > "+txt+" </span><input  style=\'width:"+widinput+"px;\' type = \'number\'/> ").appendTo($div0);\n\n            $div0.click(function(e)\n            {   \n                e.preventDefault();\n                panel.$container.find(".current_input").removeClass("current_input");\n                panel.$container.find(".ironsight_done").hide();\n                $(this).addClass("current_input");\n                $(this).find(".ironsight_done").show();\n                current_input = $div0;\n                $div0.trigger_set_click();\n                $div0.update();\n                $helper.find("span").html(helpertext(type));\n\n            }\n            );\n\n            $div0.update = function()\n            {\n               var angle = sliceToAngle($($input[1]).val());\n\n               if (type == \'eal\')\n               {\n                  angle = angle+90;\n                  setSVGtext("texteal",angle.toFixed(0) + "");\n                  setArrowDir("patheal",angle);\n               }\n               if (type == \'ear\')\n               {\n                  angle = angle-90;\n                  setSVGtext("textear",angle.toFixed(0) + "");\n                  setArrowDir("pathear",angle);\n               }\n\n               if (type == \'epl\')\n               {\n                  angle = angle-90;\n                  setSVGtext("textepl",angle.toFixed(0) + "");\n                  setArrowDir("pathepl",angle);\n               }\n               if (type == \'epr\')\n               {\n                  angle = angle+90;\n                  setArrowDir("pathepr",angle);\n                  setSVGtext("textepr",angle.toFixed(0) + "");\n               }\n\n\n               var str = angle.toFixed() + "";\n               $angle.text(str);     \n\n               return angle + "/ slice=" + $($input[1]).val();\n            }\n\n            $div0.onchange = function() {\n\n               if (onchange)\n                onchange($($input[1]).val())\n\n               $div0.update();\n\n               update()\n\n            }\n               \n            $div0.getVal = function()\n            {\n                return {slice: $($input[1]).val(), angle:$angle.text()};\n            }\n\n            $div0.setVal = function(s)\n            {\n                 if (s == undefined)\n                 {\n                     $($input[1]).val("");\n                     $div0.onchange();\n                     update();\n\n                 }\n                 else\n                 {\n                     $($input[1]).val(s.slice);\n                     $div0.onchange((s.slice));\n                     update();\n                 }\n            }\n\n            var fetchfun =takeVal($($input[1]),function(v) {\n                             if (onchange) \n                                onchange(v); \n\n                             setAMarker(sliceToAngle(v));\n                             $div0.update() \n\n                             });\n            var setfun = setVal($($input[1]))\n\n            var $getclick = $("<a style=\'margin-left:10px;\' class=\'KViewPort_tool\'><i class=\'fa fa-circle\'> get</i></a>").\n            click(fetchfun).appendTo($div0).hide();\n            var $setclick = $("<a style=\'margin-left:10px;\' class=\'KViewPort_tool\'><i class=\'fa fa-circle\'> set </i></a>").\n            click(setVal($($input[1]))).appendTo($div0).hide();\n\n            var $angle = $("<span style=\'color:lightgray;margin-left:10px;\'>NaN</span>").appendTo($div0);\n\n            $div0.trigger_get_click = fetchfun;\n            $div0.trigger_set_click = setfun;\n\n            var $done = $("<a class=\'KViewPort_tool ironsight_done\' style=\'margin-left:10px;\' ><i class=\'fa fa-check\'> done </i></a>").\n            click(function(e) {\n                e.preventDefault();\n                e.stopPropagation();\n                var n = $div0.nextAll(".inputrow").first()\n                n.trigger("click");\n            }).appendTo($div0);\n\n\n\n            $($input[1]).on(\'change\', $div0.onchange );\n\n            return $div0;\n        }\n\n        $("<div class=\'roiTool_panel_caption\'>Ear canal overlap</div>").appendTo(panel.$container);\n\n\n       var $ear_L = input_field("from left",function(v) {\n                        left_ear = parseFloat(v);\n                        setSVGtext("textupperEar",  "-90 = slice "+ left_ear.toFixed(0));\n\n                        },"leftear")\n       var $ear_R = input_field("from right",function(v) {\n\n                        right_ear = parseFloat(v);\n                        setSVGtext("textlowerEar",  "90 = slice "+ right_ear.toFixed(0));\n\n                },"rightear")\n\n        $("<div class=\'roiTool_panel_caption\'></div>").appendTo(panel.$container);\n\n       $("<div><span> Left electrode </span></div>").appendTo(panel.$container);\n       var $elec_La = input_field("from left",undefined,"eal")\n       var $elec_Lp = input_field("from right",undefined,"epl")\n\n\n        $("<div class=\'roiTool_panel_caption\'></div>").appendTo(panel.$container);\n       $("<div><span> Right electrode </span></div>").appendTo(panel.$container);\n       var $elec_Ra = input_field("from right",undefined,"ear")\n       var $elec_Rp = input_field("from left",undefined,"epr")\n\n       $elec_La.addClass("ironSight_ea")\n       $elec_Ra.addClass("ironSight_ea")\n       $elec_Lp.addClass("ironSight_ep")\n       $elec_Rp.addClass("ironSight_ep")\n\n       $("<div class=\'roiTool_panel_caption\'></div>").appendTo(panel.$container);\n       var $helper = $("<div><span> helptext</span></div>").appendTo(panel.$container);\n       $("<div class=\'roiTool_panel_caption\'></div>").appendTo(panel.$container);\n\n\n\t   var $tools = $("<div class=\'modernbuttongroup\'></div>").appendTo(panel.$container);\n\t   var $save = $("<div class=\'modernbutton small green\'><i class=\'fa fa-save\'></i>Save</div>").appendTo($tools).click( function() {\n            ironSight.save();\n\t        } );\n\t   var $reset = $("<div class=\'modernbutton small green\'><i class=\'fa fa-close\'></i>Reset</div>").appendTo($tools).click( function() {\n        ironSight.input.ear_L.setVal();\n        ironSight.input.ear_R.setVal();\n        ironSight.input.elec_La.setVal();\n        ironSight.input.elec_Ra.setVal();\n        ironSight.input.elec_Lp.setVal();\n        ironSight.input.elec_Rp.setVal();\n\t        } );\n\n\n\n\n\n\n       $ear_L.trigger("click");\n\n       this.input = { \n       elec_La: $elec_La,\n       elec_Ra: $elec_Ra,\n       elec_Lp: $elec_Lp,\n       elec_Rp: $elec_Rp,\n       ear_R:$ear_R,\n       ear_L:$ear_L\n\n       }\n\n        \n    }\n\n\n}\n\n\n\n\n\n\n\nvar createGif = {\n    cnt: 0,\n    mode: "",\n    startRecord: function()\n    {\n        if (createGif.$viewportContainer == undefined)\n            createGif.$viewportContainer = KViewer.$viewportContainer;\n\n        if (createGif.animate) \n            createGif.animate.cnt = undefined;\n\n\n\n        if (createGif.recording)\n        {\n            console.warn("gif recorder stopped");\n            createGif.mode = "";\n            return;\n        }\n        var delay = parseInt(createGif.panel.$delay[1].value);\n        var maxframe = parseInt(createGif.panel.$max[1].value);\n\n        if (KViewer.hasControlsOn())\n            KViewer.toggleElementsForScreenShot();\n\n        createGif.panel.$container.find(".roiTool_panel_flex").addClass("inactive");\n        createGif.$start.addClass(\'KViewPort_tool_enabled\');\n        createGif.$start.find("i").removeClass("fa-circle").addClass("fa-stop");\n        createGif.$start.find("span").text(" Stop ");\n        createGif.cnt = 0;\n        createGif.mode = "recording";\n        var gif = new GIF({\n            workers: 5,\n            quality: 3\n        });\n        var addframe = function()\n        {\n\n\n            html2canvas(createGif.$viewportContainer).then(function(canvas)\n            {\n                gif.addFrame(canvas, {\n                    delay: delay\n                });\n                createGif.cnt++;\n                createGif.$progress.text(" " + createGif.cnt);\n                if (createGif.mode != "recording" || createGif.cnt > maxframe)\n                {\n                    createGif.$start.find("i").removeClass("fa-stop").addClass("fa-spinner fa-spin");\n                    createGif.$start.find("span").text(" rendering ");\n                    if (!KViewer.hasControlsOn())\n                        KViewer.toggleElementsForScreenShot();\n                    gif.on(\'finished\', function(blob) {\n                        saveScreenShot(blob, {}, \'.gif\', true);\n                        createGif.mode = "";\n                        createGif.$start.find("i").removeClass("fa-spinner fa-spin").addClass("fa-circle");\n                        createGif.$start.find("span").text(" Record ");\n                        createGif.panel.$container.find(".roiTool_panel_flex").removeClass("inactive");\n                        createGif.$start.removeClass(\'KViewPort_tool_enabled\');\n                        createGif.$progress.text("");\n                       \n\n                    });\n\n                    gif.render();\n\n                }\n                else\n                {\n                    if (createGif.animate)\n                        createGif.animate();\n                    setTimeout(addframe, 0);\n                }\n\n            });\n        }\n        addframe();\n    },\n\n\n    createPanel: function()\n    {\n\n        var panel = KPanel($(document.body), "GIFrecorder", "GIFrecorder");\n        createGif.panel = panel;\n\n        var $fileRow = $("<div class=\'roiTool_panel_flex_persistent\'></div>").appendTo(panel.$container);\n        var $start = $("<a class=\'KViewPort_tool\'><i class=\'fa fa-circle\'></i><span> Record </span></a>").appendTooltip("startstoprecord").click(\n        function() {\n            if (createGif.mode == "")\n                createGif.startRecord();\n            else if (createGif.mode == \'recording\')\n                createGif.mode = "rendering";\n        });\n        createGif.$start = $start;\n\n        $fileRow.append($start).append($("<i class=\'flexspacer\'></i>"));\n        createGif.$progress = $(" <span>  </span>").appendTo($fileRow);\n\n        $("<div class=\'roiTool_panel_caption\'></div>").appendTo(panel.$container);\n\n        var $delayRow = $("<div class=\'roiTool_panel_flex\'></div>").appendTo(panel.$container);\n        panel.$delay = $(" <span> delay:  </span><input type = \'number\' min=\'0\' max=\'100\' value=\'20\'/> ").appendTo($delayRow);\n        var $maxFrames = $("<div class=\'roiTool_panel_flex\'></div>").appendTo(panel.$container);\n        panel.$max = $(" <span> max #:  </span><input type = \'number\' min=\'0\' max=\'100\' value=\'360\'/> ").appendTo($maxFrames);\n\n    }\n\n\n}\n/*\ncreateGif.animate = function()\n{\n   var mv = KViewer.viewports[0].getCurrentViewer();\n\nif (0)\n{\n   if (createGif.animate.cnt == undefined) // transversal\n     createGif.animate.cnt = 85;\n   mv.setSlicePos(2,createGif.animate.cnt++);\n\n   if (createGif.animate.cnt == undefined) // coronal\n     createGif.animate.cnt = 130;\n   mv.setSlicePos(1,createGif.animate.cnt++);\n}\n   if (createGif.animate.cnt == undefined) // saggital\n     createGif.animate.cnt = 125;\n   mv.setSlicePos(0,createGif.animate.cnt++);\n\n\n\n}\n\n*/\n\nfunction executeUnpackWorker(abuf, progress, onready)\n{\n\n    var scriptname = \'KunpackWorker.js\' + \'?\' +  static_info.softwareversion;;\n    if (typeof url_pref != "undefined")\n       scriptname = url_pref + scriptname;\n\n    var worker = new Worker(scriptname);\n\n\n    worker.postMessage = worker.webkitPostMessage || worker.postMessage;\n\n    worker.addEventListener(\'message\', function(e) {\n        e = e.data;\n        if (e.msg == \'done\')\n        {\n            if (progress != undefined)\n                progress();\n            logProcess("unzip done");\n            onready(e);\n        }\n        else if (e.msg == \'error\')\n        {\n            if (progress != undefined)\n            {\n                progress("unzip error:" + e.error.message);\n                logProcess("unzip error:" + e.error.message);\n                setTimeout(progress,2000);\n            }\n            else\n            {\n                console.error("unzip error:" + e.error.message)\n                logProcess("unzip error:" + e.error.message);\n                progress();\n            }\n            onready(e);\n        }\n        else\n            if (progress != undefined)\n            {\n                progress(e.msg);\n                logProcess(e.msg);\n            }\n    }, false);\n\n    logProcess("unzip started");\n    worker.postMessage(abuf.buffer, [abuf.buffer]);\n    // Send data to our worker.\n\n}\n\n\n\n\nfunction autoExpandOneColumn(selector, columnid,minwidth)\n{\n    var $table = $(selector);\n    var cols = $table.find("thead tr:first").children(\':visible\');\n\n    var twid = 0;\n    for (var k = 0; k < cols.length; k++)\n    {\n        var col = cols[k];\n        twid += $(col).width()+1;\n    }\n    var targetwid = $table.parent().width()\n\n    var diff = targetwid - twid;\n    var c = $(cols[columnid]);\n    var newwid = c.width() + diff - 11\n    if (minwidth != undefined)\n    {\n        if (newwid < minwidth)\n            newwid = minwidth;\n    }\n    if (1) // diff > 0)\n    {\n        c.attr(\'data-lastwidth\', c.attr(\'data-lastwidth\') || c.width());\n        c.width(newwid);\n    }\n    else\n    {\n        if (newwid > c.attr(\'data-lastwidth\'))\n            c.width(newwid);\n        else\n        {\n            c.width(c.attr(\'data-lastwidth\'));\n            c.removeAttr(\'data-lastwidth\');\n        }\n    }\n}\n\n\n\n\n\nfunction showProgressFrameAboveDiv($div)\n{\n    var cumulativeOffset = function(element) {\n        var top = 0\n          , left = 0;\n        do {\n            top += element.offsetTop || 0;\n            left += element.offsetLeft || 0;\n            element = element.offsetParent;\n        } while (element);\n\n        return {\n            top: top,\n            left: left\n        };\n    }\n    ;\n\n    var pos = cumulativeOffset($div[0]);\n    $(\'#KProgressFrame\').remove();\n    $progressframe = $("<div id=\'KProgressFrame\'>" +\n    " <div><i class=\'fa-5x fa fa-spinner fa-spin\'></i></div>  </div>");\n    $progressframe.css(\'left\', pos.left)\n    $progressframe.css(\'top\', pos.top)\n    $progressframe.css(\'height\', $div.height());\n    $progressframe.css(\'width\', $div.width())\n    var $close = $("<div> <i class=\'fa-close fa fa-3x\'> </i> </div>");\n    $progressframe.append($close)\n    $progressframe.appendTo($(document.body));\n    $close.click(function() { \n        ptablexhr.abort(); \n        hideProgressFrame();\n    })\n\n}\n\nfunction hideProgressFrame()\n{\n\n    $(\'#KProgressFrame\').remove();\n}\n\n\n\n\nfunction JSONparse_lazy(str)\n{\n    var tmp;\n    try\n    {\n        tmp = JSON.parse(str);\n        return tmp;\n    }\n    catch (e)\n    {\n        try\n        {\n            eval(\'tmp = \' + str);\n            return tmp;\n        }\n        catch (e)\n        {\n            console.log(\'error during parsing json\')\n            console.error(e);\n            return;\n        }\n    }\n}\n\n\n/** computes a lazy histogram \n * @param {number} min lower bound of histogram\n * @param {number} max higher bound of histogram\n * @param {number} nbins number of bins\n * @param {array} the data to be binned\n * @param {number} length of data array\n * @param {number} number of samples\n */\nfunction comphisto(min, max, nbins, data, n, numsamples,nonormalization)\n{\n    var EPSILON = 0.01;\n\n    var cnt = 0;\n    var histogram = {\n        min: min,\n        max: max\n    };\n\n    if (numsamples > n)\n        numsamples = n;\n\n    histogram.accus = new Array();\n\n    for (var i = 0; i < nbins; i++)\n        histogram.accus.push(0);\n    var step = Math.floor(n / numsamples)\n    for (var i = 0; i < n; i += step )\n    {\n        var val = math.floor(nbins * (data[i] - min) / (max - min));\n        if (!isNaN(val) & val >= 0 & val < nbins & data[i] != 0)\n        {\n            histogram.accus[val]++;\n            cnt++;\n        }\n    }\n    if (nonormalization)\n    {\n\n    }\n    else\n        for (var i = 0; i < nbins; i++)\n        {\n            histogram.accus[i] = 100 * histogram.accus[i] / (cnt + EPSILON);\n        }\n\n    var maxfreq = 0;\n    for (var k = 0; k < histogram.accus.length;k++)\n    {\n        if (histogram.accus[k] > maxfreq)\n            maxfreq = histogram.accus[k];\n    }\n    histogram.accus.maxfreq = maxfreq;\n\n\n    return histogram;\n}\n\n\nfunction getMinMax(data, n, numsamples)\n{\n    var max = data[0] + Number.EPSILON;\n    var min = data[0];\n    var isMask = true;\n    for (var i = 0; i < n; i += Math.round(n / numsamples) * 2 + 1)\n    {\n        if (!isNaN(data[i]) & (isFinite(data[i])))\n        {\n            if (data[i] > max | isNaN(max))\n                max = data[i];\n            if (data[i] < min | isNaN(min))\n                min = data[i];\n        }\n        ;\n        if (data[i] != 0 & data[i] != 1)\n            isMask = false;\n        // treat isMask as special case later\n    }\n\n\n    return {\n        max: max,\n        min: min,\n        isMask: isMask\n    }\n}\n\n\n\n\nfunction KSetContentEditable($element, callback,defaultname,ondblclick,bluronenter)\n{\n    if (ondblclick)\n        $element.on("dblclick",function(ev)\n        {\n            ev.preventDefault();\n            ev.stopPropagation();\n            $element.attr(\'contenteditable\', \'true\')    \n            $element.focus();\n        });\n    else    \n        $element.attr(\'contenteditable\', \'true\')\n    $element.on(\'blur\', function(ev) {\n        callback($element,ev);\n        var tmp = document.createElement("input");\n         document.body.appendChild(tmp);\n         tmp.focus();\n         document.body.removeChild(tmp);\n         if (ondblclick)\n            $element.attr(\'contenteditable\', \'false\')\n    })\n    .on(\'keydown\', function(ev) \n        {\n            if (ev.keyCode == 13) { return false;            } \n    })\n    .on(\'keyup\', function(ev) \n    {\n        if((ev.keyCode == 13) && bluronenter)\n        {\n            $(this).trigger(\'blur\'); \n            return false;\n        }\n\t    if($element.html().replace(/\\s*[<br\\s*/>]/g, \'\') == "")\n            $element.html(defaultname);\n        callback($element,ev);\n    });\n\n\n}\n\n/** Format a number into string. Number of digits is adapted to number range\n * @param {number} x - the number\n * @function */\nfunction niceFormatNumber(x)\n{\n    var absx = math.abs(x)\n    if (absx > 100)\n        return x.toFixed(0);\n    else if (absx > 1)\n        return x.toFixed(1);\n    else\n    {\n        var ndig = 2 + Math.round(-Math.log(absx) / Math.log(10));\n        if (!(ndig >= 0 && ndig < 20))\n            return x;\n        else\n            return x.toFixed(2 + Math.round(-Math.log(absx) / Math.log(10)));\n    }\n\n}\n\n\n/** Format a numeric filesize nicely\n * @param {number} sz - the number\n * @function */\nfunction toFileSize(sz)\n{\n    if (sz == undefined)\n        return "NA";\n    if (sz > 1024 * 1024 * 1024)\n        return (sz / 1024 / 1024 / 1024).toFixed(1) + "G";\n    else if (sz > 1024 * 1024)\n        return (sz / 1024 / 1024).toFixed(1) + "M";\n    else if (sz > 1024)\n        return (sz / 1024).toFixed(1) + "K";\n    else\n        return sz + "B";\n}\n\n\n\n\n\n/** The progress spinner\n * @param {div} $spinner - the div where the spinner lives\n * @function */\nfunction theSpinner($spinner)\n{\n    var $abort = $("<div class=\'KSpinner_abortloading\'> <i class=\'fa fa-close\'> </i> </div>");\n    $spinner.append($abort);\n    var abortfun = undefined;\n\n\n    var progressfun = function(perc, aborter)\n    {\n        if (aborter)\n        {\n            abortfun = aborter\n            $abort.show();\n        }\n        else\n        {\n            abortfun = undefined;\n            $abort.hide();\n        }\n\n\n        if (perc == undefined)\n        {\n            $spinner.css("display", "none");\n            abortfun = undefined;\n            return;\n        }\n\n        var txt;\n        if ($.isNumeric(perc))\n            txt = "<div class=\'spinnerbar\'> <div class=\'innerbar\' style=\'width:" + math.round(perc * 100) + "%\'> </div> </div> ";\n        else\n            txt = perc;\n        if ($("#KLoadingFrame").css("display") != "block")\n        {\n            if (perc == undefined)\n            {\n                that.$spinner.css("display", "none");\n                return;\n            }\n            $spinner.css("display", "inline-block");\n            $spinner.css("top", "60%");\n            $spinner.css("left", "50%");\n            $spinner.children()[1].innerHTML = txt;\n        }\n        else\n        {\n            //$("#KLoadingFrameText").text( txt );  \t\n            $("#KLoadingFrameTypeString").text("Loading Image Resources")\n            $("#KLoadingFrameText")[0].innerHTML = txt;\n        }\n\n    }\n\n\n    $abort.click(function()\n    {\n        if (abortfun != undefined)\n        {\n            var theaborter = abortfun;\n            progressfun("aborting");\n            setTimeout(function() {\n                theaborter();\n                progressfun();\n            }, 0);\n        }\n\n    });\n\n    return progressfun;\n\n}\n\nfunction dataURItoBlob(dataURI) {\n    // convert base64 to raw binary data held in a string\n    // doesn\'t handle URLEncoded DataURIs - see SO answer #6850276 for code that does this\n    var byteString = atob(dataURI.split(\',\')[1]);\n\n    // separate out the mime component\n    var mimeString = dataURI.split(\',\')[0].split(\':\')[1].split(\';\')[0]\n\n    // write the bytes of the string to an ArrayBuffer\n    var ab = new ArrayBuffer(byteString.length);\n    var ia = new Uint8Array(ab);\n    for (var i = 0; i < byteString.length; i++) {\n        ia[i] = byteString.charCodeAt(i);\n    }\n\n    // write the ArrayBuffer to a blob, and you\'re done\n    var blob = new Blob([ab],{\n        type: mimeString\n    });\n    return blob;\n\n    // Old code\n    // var bb = new BlobBuilder();\n    // bb.append(ab);\n    // return bb.getBlob(mimeString);\n}\n\n\n\n/** print nice matrix representations for console log */\nfunction print_matrix(m)\n{\n    m = m._data || m;\n    if (Array.isArray(m))\n    {\n        if (!Array.isArray(m[0]))\n            m = [m];\n    }\n    else\n    {\n        m = [[m]];\n    }\n\n    var s = "\\n";\n\n    var rows = m.length;\n    var cols = m[0].length;\n    for (var k = 0; k < rows; k++)\n    {\n        for (var r = 0; r < cols; r++)\n        {\n            var x = ("             " + Math.round(m[k][r] * 100) / 100);\n            x = x.substr(x.length - 10);\n            s += (" " + x);\n        }\n        //if( k < rows-1)\n        s += "\\n";\n    }\n    return s;\n}\n\n\nfunction randperm(maxValue) {\n    // first generate number sequence\n    var permArray = new Array(maxValue);\n    for (var i = 0; i < maxValue; i++) {\n        permArray[i] = i;\n    }\n    // draw out of the number sequence\n    for (var i = (maxValue - 1); i >= 0; --i) {\n        var randPos = Math.floor(i * Math.random());\n        var tmpStore = permArray[i];\n        permArray[i] = permArray[randPos];\n        permArray[randPos] = tmpStore;\n    }\n    return permArray;\n}\n\n/** uploads a freshly created binary which has not yet been assigned to a subject\n * @param {object} fobj - the fileObject\n * @param {object} finfo - addtional fileinfo used for upload\n * @param {callback} progress - called during upload\n * @param {callback} callback - called after upload\n */\nfunction uploadUnregisteredBinary(fobj, finfo, progress, callback,zipped)\n{\n    uploadBinary(fobj, finfo,\n    function(id, response)\n    {\n        var newid = response.fileID;\n        var roi = KViewer.dataManager.getFile(id);\n        if (roi != undefined)\n        {\n            roi.modified = false;\n            if (newid != id)\n            {\n                roi.fileID = newid;\n                roi.fileinfo = $.extend(roi.fileinfo, finfo);\n                KViewer.dataManager.setFile(newid, roi);\n                KViewer.dataManager.delFile(id);\n                callback(newid, id);\n\n                patientTableMirror.mirrorState();\n                KViewer.cacheManager.update();\n            }\n            alertify.success(\'successfully saved \' + roi.filename);\n        }\n        else\n            alertify.success(\'successfully saved \' + fobj.filename);\n\n    }, progress, zipped, "usenativePID");\n}\n\n\nfunction attachMouseSlider($target, callbacks, options)\n{\n    // a generalized handler for mouse down and move, calculating the relative dx and dy\n    /*\n        callbacks:\n            mousedown(ev)\n            mousemove(ev, dx, dy)\n            mouseup(ev)\n            mousedownvar: remember vars when sliding starts and pass to mousemove\n\n            options:\n                showMinMaxRange:  whow the max range\n    */\n    \n    // this will be overwritten when mousedown returns a relative start value\n    var showMinMaxRange = false;\n\n    var $slider;\n    var baseheight = 40;\n    var basemargin = 10;\n    \n    // this defines the reference range\n    var refrange = 200;\n\n    var speed = 1;\n    var allowSpeedChange = false;\n\n    $target.mousedown( mousedown )\n    function mousedown(ev)\n    {\n        ev.stopPropagation();\n        ev.preventDefault();\n        \n        var starDiffX = -ev.clientX; \n        var starDiffY = -ev.clientY;\n\n        var lastX = starDiffX;\n        var lastY = starDiffY;\n\n        if(callbacks.mousedown)\n            var mousedownvar =  callbacks.mousedown(ev);\n        else\n            var mousedownvar = undefined;\n\n        \n        if(1) // always who the slider bar\n        {\n           var $indicator = $("<div class=\'KMouseSliderIndicator\'></div>");\n           \n           var $upper = $("<div class=\'KMouseSliderIndicator_bg\' style=\'bottom:0px\'></div>").appendTo($indicator);\n           var $lower = $("<div class=\'KMouseSliderIndicator_bg\' style=\'top:0px\'></div>").appendTo($indicator);\n\n           var $plus   = $("<i style=\'top:2px;\' class=\'fa fa-plus\'>").appendTo($upper);\n           var $minus = $("<i style=\'bottom:2px;\' class=\'fa fa-minus\'>").appendTo($lower);\n\n           //var $center = $("<div class=\'KMouseSliderIndicator_center\'></div>").appendTo($indicator);\n           var $ball = $("<div class=\'KMouseSliderIndicator_ball\'></div>").appendTo($indicator);\n           var $currentVal = $("<div class=\'KMouseSliderIndicator_currentval\'></div>").appendTo( $ball );\n\n           var pp = getPixelPosition($target);\n           var center = [ pp[0] + pp[2]/2, pp[1] + pp[3]/2 ];\n\n           setPixelPosition($indicator, [center[0] + 2 , center[1] - 2, 8, 8]);\n           \n\n           var ww = getPixelPosition($(document.body));\n           if(ww[2] - center[0] > 50)\n               $currentVal.css(\'left\', \'150%\'); \n            else\n               $currentVal.css(\'right\',\'150%\'); \n\n            // initialise\n            if( mousedownvar != undefined && mousedownvar.startval !=undefined )\n                $currentVal.text( mousedownvar.startval.toFixed(0) )\n\n            // right click: slide faster\n            \n            setReferenceRange( ev.button + 1);\n\n            if(options && options.hideCurrentval)\n                $currentVal.hide();\n                \n            $indicator.appendTo( $(document.body ) );\n        }\n\n        function setReferenceRange(speed_new)\n        {\n            speed = speed_new;\n            baseheight = 40 / speed + 10;\n            refrange   = 200 / speed\n            if( mousedownvar.startval_percent != undefined )\n            {\n                $upper.height( refrange * (1-mousedownvar.startval_percent)    + 10); \n                $lower.height( refrange * (mousedownvar.startval_percent)+ 10);\n                showMinMaxRange = true;\n            }\n            else\n            {\n               $upper.height(baseheight);\n               $lower.height(baseheight);\n            }\n        }\n\n\n        $(document.body).mousemove(function(ev)\n        {\n            var dx = starDiffX + ev.clientX;\n            var dy = starDiffY + ev.clientY;\n            \n            var wasinrange = true;\n            \n            //  allow to change speed\n            if(allowSpeedChange)// math.abs(dy) < 10)\n            {\n                var scale = 20;\n                var step = 15;\n                // allow step wise\n                var temp = 1 /math.exp( math.round(dx/step)*step/scale );\n\n                if(temp > .1 & temp < 10)\n                    setReferenceRange( temp );\n                    \n            }\n\n            if(callbacks.mousemove)\n            {\n                // give also increment to last move motion\n                var lastdx = speed*(lastX + ev.clientX); lastX = -ev.clientX;\n                var lastdy = speed*(lastY + ev.clientY); lastY = -ev.clientY;\n\n                var ret = callbacks.mousemove(ev, dx/refrange, dy/refrange, mousedownvar, lastdx, lastdy);\n                if(ret != undefined && ret.wasinrange !== undefined && ret.value !=undefined )\n                {\n                    wasinrange = ret.wasinrange;\n                    if(wasinrange)\n                        $currentVal.text( ret.value.toFixed(0) )\n                }\n\n            }\n            \n            if(wasinrange)\n            {\n                if(!showMinMaxRange)\n                {\n                    if(dy*dy > baseheight*baseheight - basemargin*basemargin)\n                    {\n                        if(dy < baseheight -basemargin )\n                        {\n                            $upper.height(-dy + basemargin);\n                        }\n                        else if(dy > baseheight -basemargin)\n                        {\n                            $lower.height(+dy +basemargin)\n                        }\n                    }\n                }\n                $ball.css(\'top\', dy + \'px\');\n            }\n        });\n\n        $(document.body).on(\'mouseup mouseleave\', function(ev)\n        {\n            $indicator.remove();\n            $currentVal.remove();\n            $(document.body).off(\'mousemove mouseup mouseleave\');\n            if (callbacks.mouseup)\n                callbacks.mouseup(ev);\n            return false\n        });\n\n\n    }\n    return $target\n}\n\n\n// slider for quick adjustment of input fields (similar to the arrows but faster)\nfunction KMouseSlider($targetinput, options_in)\n{\n\n    $targetinput.css(\'position\', \'relative\'); \n    \n    var options = \n    {\n        incrementPerPixel: 1,\n        logScaling:0,\n        min:0,\n        max:Infinity,\n        direction: \'ud\',\n        updateonmove:1,\n        updateonrelease: 0,\n        hideCurrentval:1,\n        callback: undefined\n    }\n    $.extend(true, options, options_in)\n\n    var $slider = $("<div class=\'KMouseSliderBtn\'><i class=\'fa fa-unsorted\'></i></div>");\n    \n    attachMouseSlider($slider, {\n        mousedown: function(ev, dx, dy, mousedownvar)\n        {\n            //if(options.updateonstart) not implemented, since it would only make sense to pass a special function...\n            return {startval: parseFloat($targetinput.val()) }\n        },\n        mousemove: function(ev, dx, dy, mousedownvar)\n        {\n           var newval = (mousedownvar.startval + options.incrementPerPixel * -dy *200);\n           if(options.logScaling > 0 && newval < 1 &&  newval > -1) // allow float values between 0 and 1\n                newval = math.round(newval*options.logScaling)/options.logScaling;\n           else\n                newval = math.round(newval)\n                \n           wasinrange = false;\n           if(newval >= options.min && newval <= options.max)\n           {\n                $targetinput.val( newval  );\n                if(options.updateonmove)\n                    $targetinput.trigger("change");\n                wasinrange = true;\n           }\n           return {wasinrange:wasinrange, value: newval }\n        },\n        mouseup: function()\n        {\n            if(options.updateonrelease)\n                $targetinput.trigger("change");\n        }\n    }\n    ,\n    {\n        hideCurrentval:options.hideCurrentval\n    }\n    )\n\n\n    $slider.insertAfter($targetinput);\n\n    return $slider;\n    \n}\n\n\nfunction movableWindowMousedownFn(ev, $container, callbackAfterMove, ignoreClass)\n{\n    if (!$container.hasClass("movableWindows"))\n        $container.addClass("movableWindows");\n\n    if ($(ev.originalEvent.target).hasClass(ignoreClass))\n        return false;\n\n    var starDiffX = -ev.clientX + $container.offset().left;\n    var starDiffY = -ev.clientY + $container.offset().top\n    $(document.body).mousemove(function(ev)\n    {\n        var dx = starDiffX + ev.clientX;\n        var dy = starDiffY + ev.clientY;\n        if(dy < 32) // min top distance\n            dy = 32; \n        $container.offset({\n            top: dy,\n            left: dx\n        });\n\n    });\n    $(document.body).on(\'mouseup mouseleave\', function(ev)\n    {\n        //$(this).off(\'mousemove\'); // "this" is the body ...? so why?\n        $(document.body).off(\'mousemove mouseup mouseleave\');\n        // must remove the mouseup handler again!!\n        if (callbackAfterMove != undefined)\n            callbackAfterMove();\n        return false\n\n    });\n\n    bringToFront($container);\n}\n\nfunction maximizerButton($menu, $target)\n{\n   var $max = $("<li  style=\'float:right\'><a> <i class=\'fa fa-window-restore\' ></i></a></li>").appendTooltip("maximize")\n   .on("click", function(ev) \n   {\n       if($max.oldsize == undefined)\n       {\n           $max.maxstate = true;\n           $max.oldsize = getPixelPosition($target);\n           maximizeWindow($target);\n       }\n       else\n       {\n           setPixelPosition($target, $max.oldsize, 1);\n           delete $max.oldsize;\n       }\n   });\n   $max.appendTo($menu);\n}\n\nfunction maximizeWindow($target, animate)\n{\n   if(animate== undefined)\n        animate = 1;\n        \n   var topmargin = 38;\n   var w = $body.width();\n   var h = $body.height();\n   setPixelPosition($target, [ 0, topmargin, w-2, h-topmargin-5 ], animate);\n}\n\n\nfunction resizeSplitter($attachTo, $resizeTarget)\n{\n    if($resizeTarget==undefined)\n        $resizeTarget = $attachTo;\n    var $leftresizer = $("<div class=\'resizer_vertical\'><div><div></div></div></div>").appendTo($attachTo).mousedown(resizeSplitterInternal);\n\tfunction resizeSplitterInternal(ev)\n\t{\n\t\tev.preventDefault();\n    \tvar x = ev.clientX;\n\n    \tvar $target  = $resizeTarget;\n\t\tvar w = $target.width();\n        var h = $target.height();\n\t    $body.on("mouseup mouseleave",   mymouseup);\n  \t\t$body.on("mousemove", moveUnlagger(mymousemove)) ;\n\t\tfunction mymousemove(ev)\n\t\t{\n\t\t\t   var nx =  ev.clientX;\n\t\t\t   var neww = w-(x - nx)\n\t\t\t   if (neww > 100)\n\t\t\t   \t$target.width(w- (x - nx));\n\t\t}\n\n\t\tfunction mymouseup(ev)\n\t\t{\n\t\t\t$body.off("mousemove mouseup mouseleave");\n\t\t\tev.preventDefault();\n\t\t}\n\t}\n\treturn $leftresizer;\n}\n\n\n\n\n\n// helpers, similar to matlab conventions\nfunction getPixelPosition($target)\n{\n    var offs = $target.offset();\n    var sizes = [ offs.left, offs.top,$target.width(), $target.height(),];\n    return sizes;\n\n}\n\nfunction setPixelPosition($target, sizes, animate)\n{\n    if(animate)\n        $target.animate({\'left\': sizes[0], \'top\': sizes[1], width: sizes[2], height:  sizes[3] } , 180 );\n    else\n        $target.css({\'left\': sizes[0], \'top\': sizes[1], width: sizes[2], height:  sizes[3] } );\n}\n\nfunction isMouseEventOverDiv(e, $div)\n{\n    var pp = getPixelPosition( $div);\n    return ( e.clientX > pp[0] && e.clientX < pp[0]+pp[2] && e.client> pp[1] && e.client < pp[1]+pp[3]   )\n}\n\n\n// pops a div out from a certain point or element\nfunction popShow($div, $popoutTo)\n{\n    var targetpos = getPixelPosition($popoutTo);\n    $div.attr(\'savedposition\', getPixelPosition($div).join(\',\'));\n    setPixelPosition($div, targetpos, 1);\n    $div.fadeOut(250);\n}\n\n// hides a div by moving it into a certain element or point\nfunction popHide($div, $popoutFrom)\n{\n    var frompos = getPixelPosition($popoutFrom);\n    var targetpos = $div.attr(\'savedposition\');\n    if(targetpos!=undefined)\n        targetpos = targetpos.split(\',\')\n    else    \n        targetpos =  getPixelPosition($div);// [ 400, 400, 400, 400];\n    \n    bringToFront($div);\n    $div.fadeIn(250);\n    setPixelPosition($div, frompos, 0);\n    setPixelPosition($div, targetpos, 1);\n}\n\n\n// brings a container to front and reorders the group\nfunction bringToFront($div, theclass)\n{\n    if (theclass == undefined)\n        theclass = "movableWindows";\n\n    var elems = $("." + theclass);\n\n    var zinds = [];\n    var index_highest = parseInt(elems.eq(0).css("z-index"), 10);\n    \n    elems.each(function() \n    {\n        zinds.push([$(this), parseInt($(this).css("z-index"), 10)]);;\n    });\n\n    zinds.sort(function(a, b) {\n        return a[1] - b[1];});\n        \n    var off =0;\n    var basez = 10;\n    for(var k=0;k<zinds.length; k++)\n    {\n        if( zinds[k][0].is($div) )\n        {\n            var ind = zinds.length;\n            off = 1;\n        }\n        else\n        {\n            var ind = k -off;\n        }\n        zinds[k][0].css(\'z-index\',  (basez + ind).toString());\n    }\n    \n\n}\n\n\n\n\nfunction getHighestZIndexOfSameClass(theclass)\n{\n    if (theclass != undefined)\n        var elems = $("." + theclass);\n    else\n        var elems = $("div");\n\n    var $div\n    var indlist = [];\n    var index_highest = parseInt(elems.eq(0).css("z-index"), 10);\n    elems.each(function() \n    {\n        var index_current = parseInt($(this).css("z-index"), 10);\n        indlist.push(index_current);\n        if (index_current > index_highest && index_current < 100000) // only go up to 1000 or so, loading frame will have max\n        {\n            index_highest = index_current;\n            $div = $(this);\n        }\n    });\n    \n\n    return {\n        div: $div,\n        index: index_highest\n    };\n\n}\n\n\n\nfunction squeeze(arr)\n{\n    var tmp = [];\n    for (var k = 0 ; k < arr.length;k++)\n        if (arr[k] != undefined)\n            tmp.push(arr[k]);\n    arr.splice(0,arr.length);\n    for (var k = 0; k < tmp.length;k++)\n        arr.push(tmp[k]);\n    return arr;\n}\n\n\nif (typeof jQuery != "undefined")\n{\n    // used to make a input/text editable on sinle click\n    // the callback is given with "keyup", optionally, a final callback can be passed\n    function makeEditableOnDoubleClick($elem, callback)\n    {\n        $elem.on(\'blur\', function(ev)\n        {\n            this.contentEditable = false;\n            $(this).removeAttr("contentEditable")\n            var val = $(this).text().trim().replace("\\n", "");\n            $(this).text(val);\n            if (val == "")\n            {\n                $(this).text("enter_text");\n                $(this).trigger("keyup");\n                $(this).trigger("dblclick");\n            }\n            if(callback)\n                callback();\n        })\n        .on("dblclick", function(e) {\n            this.contentEditable = true;\n            // must click again, otherwise might be deselected (if some click mechanism involved)\n            //$(this).trigger("click"); \n            $(this).focus().select();\n            document.execCommand(\'selectAll\', false, null );\n            e.preventDefault();\n            e.stopPropagation();\n            return false;\n            ;\n        })\n        .on(\'keydown\', function(e){\n            if(e.keyCode == 13)\n            {\n                $(this).trigger("blur");\n                return false;\n            }\n        }\n        )\n\n    }\n\n}\n\n\n\n\n/** converts utf-16 encoded ArrayBuffer to String \n * @function */\nfunction ab2str(buf) {\n    var chars = new Uint16Array(buf);\n    var s = "";\n    var l = chars.length;\n    for (var i = 0; i < l; i++)\n    {\n        if (chars[i] == 0)\n            break;\n        s += String.fromCharCode(chars[i]);\n    }\n    return s;\n    //return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n\n\n\n/** converts utf8 encoded ArrayBuffer to String \n * @function */\nfunction utf8ab2str(array) {\n    var out, i, len, c;\n    var char2, char3;\n\n    out = "";\n    len = array.length;\n    i = 0;\n    while (i < len) {\n        c = array[i++];\n        switch (c >> 4)\n        {\n        case 0:\n        case 1:\n        case 2:\n        case 3:\n        case 4:\n        case 5:\n        case 6:\n        case 7:\n            // 0xxxxxxx\n            out += String.fromCharCode(c);\n            break;\n        case 12:\n        case 13:\n            // 110x xxxx   10xx xxxx\n            char2 = array[i++];\n            out += String.fromCharCode(((c & 0x1F) << 6) | (char2 & 0x3F));\n            break;\n        case 14:\n            // 1110 xxxx  10xx xxxx  10xx xxxx\n            char2 = array[i++];\n            char3 = array[i++];\n            out += String.fromCharCode(((c & 0x0F) << 12) |\n            ((char2 & 0x3F) << 6) |\n            ((char3 & 0x3F) << 0));\n            break;\n        }\n    }\n    return out;\n}\n\n\n\n\n\n\n/** create a  nifti object and adds it the worspace\n * @param {object} nii - a Object containng edges,voxSize,sizes\n * @param {string} name - the new name\n * @param {string} type - either uint8,float,uint16\n * @param {integer} tdim - size of the fourth dimension\n */\nfunction createNifti(nii,name,type,tdim)\n{\n     nii.pixdim = [1,nii.voxSize[0],nii.voxSize[1],nii.voxSize[2]];\n     var fobj = cloneNifti({content:nii}, name + ".nii", type, tdim);\n     fobj.fileID = name; \n     KViewer.dataManager.setFile(fobj.fileID,fobj);\n     KViewer.cacheManager.update();     \n     return fobj.content;\n \n}\n\n\n/** clones a nifti object\n * @param {object} fobj - a fileObject \n * @param {string} name - the new name\n * @param {string} type - either uint8,float,uint16\n * @param {integer} tdim - size of the fourth dimension\n * @param {float} fac - undersampling factor\n */\nfunction cloneNifti(fobj, name, type, tdim,fac)\n{\n    var fileObject = {};\n\n    var nii = fobj.content;\n    var littleEndian = nii.endian == \'little\' || true;\n\n    if (tdim == undefined)\n        tdim = 1;\n    else if (tdim == "sametdim")\n        tdim = nii.sizes[3];\n\n    if (fac == undefined)\n        fac = 1;\n\n\n\n    // set the bruker header to nifti header\n    var niihdr = [92, 1, 0, 0, 117, 105, 110, 116, 49, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114, 0, 1, 0, 16, 0, 16, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 16, 0, 0, 0, 0, 0, 128, 191, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 111, 110, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 105, 49, 0, 0, 0, 0, 0];\n    var hdrbuffer = (new Uint8Array(niihdr)).buffer;\n\n    if (type == undefined)\n        type = \'uint8\';\n\n\n    var types = {\n        "uint8": {\n            type: 2,\n            bitpix: 8\n        },\n        "float": {\n            type: 16,\n            bitpix: 32\n        },\n        "int16": {\n            type: 4,\n            bitpix: 16\n        },\n        "uint16": {\n            type: 512,\n            bitpix: 16\n        }\n    }\n    var t = types[type];\n\n    var sizes = [math.floor(nii.sizes[0]/fac),math.floor(nii.sizes[1]/fac),math.floor(nii.sizes[2]/fac) ];\n\n\n    var buffer = new Uint8Array(hdrbuffer.byteLength + t.bitpix / 8 * sizes[0] * sizes[1] * sizes[2] * tdim);\n    buffer = buffer.buffer;\n\n    var view = new DataView(buffer);\n\n    // sizes\n    view.setInt32(0, 348, littleEndian)\n    if (tdim > 1)\n        view.setInt16(40, 4, littleEndian)\n    else\n        view.setInt16(40, 3, littleEndian)\n    view.setInt16(42, sizes[0], littleEndian)\n    view.setInt16(44, sizes[1], littleEndian)\n    view.setInt16(46, sizes[2], littleEndian)\n    view.setInt16(48, tdim, littleEndian)\n\n    // edges\n    // spaceDirections are stored column wise (column index first)\n    // multiplication in javascript is row-wise defined, therefore transpose at the end\n    var edges;\n    if (nii.spaceDirections == undefined)\n        edges = nii.edges\n    else\n    {\n        edges =  math.eye(4);\n        edges._data[0][0] = nii.spaceDirections[0][0];\n        edges._data[0][1] = nii.spaceDirections[0][1];\n        edges._data[0][2] = nii.spaceDirections[0][2];\n        edges._data[1][0] = nii.spaceDirections[1][0];\n        edges._data[1][1] = nii.spaceDirections[1][1];\n        edges._data[1][2] = nii.spaceDirections[1][2];\n        edges._data[2][0] = nii.spaceDirections[2][0];\n        edges._data[2][1] = nii.spaceDirections[2][1];\n        edges._data[2][2] = nii.spaceDirections[2][2];\n        edges._data[3][0] = nii.spaceOrigin[0];\n        edges._data[3][1] = nii.spaceOrigin[1];\n        edges._data[3][2] = nii.spaceOrigin[2];\n        edges = math.transpose(edges);\n    }\n\n    view.setFloat32(280 + 0 * 4, edges._data[0][0]*fac, littleEndian);\n    view.setFloat32(280 + 1 * 4, edges._data[0][1]*fac, littleEndian);\n    view.setFloat32(280 + 2 * 4, edges._data[0][2]*fac, littleEndian);\n    view.setFloat32(280 + 3 * 4, edges._data[0][3], littleEndian);\n\n    view.setFloat32(280 + 4 * 4, edges._data[1][0]*fac, littleEndian);\n    view.setFloat32(280 + 5 * 4, edges._data[1][1]*fac, littleEndian);\n    view.setFloat32(280 + 6 * 4, edges._data[1][2]*fac, littleEndian);\n    view.setFloat32(280 + 7 * 4, edges._data[1][3], littleEndian);\n\n    view.setFloat32(280 + 8 * 4, edges._data[2][0]*fac, littleEndian);\n    view.setFloat32(280 + 9 * 4, edges._data[2][1]*fac, littleEndian);\n    view.setFloat32(280 + 10* 4, edges._data[2][2]*fac, littleEndian);\n    view.setFloat32(280 + 11* 4, edges._data[2][3], littleEndian);\n\n    if (nii.pixdim == undefined)\n    {\n        nii.pixdim = [nii.sizes.length];\n        nii.pixdim = nii.pixdim.concat(nii.sizes);\n    }\n\n\n    for(var i=0; i<nii.pixdim.length; i++) {\n       if (i > 0 &&  i <= 3)\n        view.setFloat32(76+4*i, nii.pixdim[i]*fac, littleEndian)\n    }\n\n\n    view.setInt16(252, 0, littleEndian)\n    //qform\n    view.setInt16(254, 1, littleEndian)\n    //sform\n\n\n    // ====== apply some other important stuff\n    // set the magic number to n+1\n    view.setInt32(344, 1848324352, !littleEndian)\n    // set vox offset to 352\n    view.setFloat32(108, 352, littleEndian)\n\n\n    view.setFloat32(112, 1, littleEndian)\n    view.setFloat32(116, 0, littleEndian)\n\n\n    view.setInt32(348, 0, littleEndian);\n\n\n\n    view.setInt16(70, t.type, littleEndian);\n    view.setInt16(72, t.bitpix, littleEndian);\n\n\n\n\n    fileObject.buffer = buffer;\n\n    // parse nifti\n    fileObject.content = prepareMedicalImageData(parse(fileObject.buffer), fileObject);\n    fileObject.contentType = "nii";\n\n    var subfolder;    \n    if (name && name.split("/").length > 1)\n    {\n        var split = name.split("/");\n        name = split[split.length-1];\n        if (split.length > 1)\n        {\n            split.pop();\n            subfolder = split.join("/");\n        }\n\n    }\n\n\n    fileObject.filename = name;\n    fileObject.editable = true;\n    fileObject.fileinfo = {};\n    if (fobj.fileinfo)\n    {\n        fileObject.fileinfo.patients_id = fobj.fileinfo.patients_id;\n        fileObject.fileinfo.studies_id = fobj.fileinfo.studies_id;\n        fileObject.fileinfo.SubFolder = subfolder;\n    }\n\n\n\n    return fileObject;\n}\n\n/** resizes a Nifti object (space origin and sizes only. Object must have been already created and prepared)\n * @param {object} fobj - a fileObject \n * @param {array} spaceorigin - the new corner of the edges\n * @param {array} sizes - the new size of the array\n * @param {bool}  keepconten - keep (copy) the old image, or create a  new empty array\n */\nfunction resizeNifti(fobj, edges, sizes)\n{\n    var nii = fobj.content;\n    var littleEndian = nii.endian == \'little\' || true;\n    var buffer = nii.buffer;\n    var view = new DataView(buffer);\n\n    // ----------------- space origin only\n    /*\n    if( spaceorigin != undefined)\n    {\n        nii.spaceOrigin = spaceorigin._data;\n        nii.edges._data[0][3] = nii.spaceOrigin[0];\n        nii.edges._data[1][3] = nii.spaceOrigin[1];\n        nii.edges._data[2][3] = nii.spaceOrigin[2];\n        // update header\n        view.setFloat32(280 + 3 * 4, nii.edges._data[0][3], littleEndian);\n        view.setFloat32(280 + 7 * 4, nii.edges._data[1][3], littleEndian);\n        view.setFloat32(280 + 11 * 4, nii.edges._data[2][3], littleEndian);\n    }\n    */\n\n    if(  edges != undefined)\n    {\n        nii.edges = edges;\n        nii.spaceOrigin[0] = edges._data[0][3]; \n        nii.spaceOrigin[1] = edges._data[1][3];\n        nii.spaceOrigin[2] = edges._data[2][3];\n        \n        nii.spaceDirections = math.transpose(nii.edges)._data;\n\n        var permutationOrder = [findIndexOfGreatest(nii.spaceDirections[0]), findIndexOfGreatest(nii.spaceDirections[1]), findIndexOfGreatest(nii.spaceDirections[2])];\n        nii.arrayReadDirection = [nii.spaceDirections[0][permutationOrder[0]] < 0 ? -1 : 1, nii.spaceDirections[1][permutationOrder[1]] < 0 ? -1 : 1, nii.spaceDirections[2][permutationOrder[2]] < 0 ? -1 : 1, ];\n        nii.permutationOrder = permutationOrder;\n        var Order = KMedViewer.getPermutationOrder();\n        var perm = Order.perm;\n        var flips = Order.flips;\n\n        nii.permutationOrder = [perm[nii.permutationOrder[0]], perm[nii.permutationOrder[1]], perm[nii.permutationOrder[2]]];\n        nii.arrayReadDirection = [flips[nii.permutationOrder[0]] * nii.arrayReadDirection[0], flips[nii.permutationOrder[1]] * nii.arrayReadDirection[1], flips[nii.permutationOrder[2]] * nii.arrayReadDirection[2]];\n\n        nii.invPermOrder = [];\n        nii.invPermOrder[nii.permutationOrder[0]] = 0;\n        nii.invPermOrder[nii.permutationOrder[1]] = 1;\n        nii.invPermOrder[nii.permutationOrder[2]] = 2;\n\n        nii.voxSize[0] = math.sqrt(nii.spaceDirections[0][0] * nii.spaceDirections[0][0] + nii.spaceDirections[0][1] * nii.spaceDirections[0][1] + nii.spaceDirections[0][2] * nii.spaceDirections[0][2]);\n        nii.voxSize[1] = math.sqrt(nii.spaceDirections[1][0] * nii.spaceDirections[1][0] + nii.spaceDirections[1][1] * nii.spaceDirections[1][1] + nii.spaceDirections[1][2] * nii.spaceDirections[1][2]);\n        nii.voxSize[2] = math.sqrt(nii.spaceDirections[2][0] * nii.spaceDirections[2][0] + nii.spaceDirections[2][1] * nii.spaceDirections[2][1] + nii.spaceDirections[2][2] * nii.spaceDirections[2][2]);\n\n\n\n        // update header\n        view.setFloat32(280 + 0 * 4, nii.edges._data[0][0], littleEndian);\n        view.setFloat32(280 + 1 * 4, nii.edges._data[0][1], littleEndian);\n        view.setFloat32(280 + 2 * 4, nii.edges._data[0][2], littleEndian);\n        view.setFloat32(280 + 3 * 4, nii.edges._data[0][3], littleEndian);\n\n        view.setFloat32(280 + 4 * 4, nii.edges._data[1][0], littleEndian);\n        view.setFloat32(280 + 5 * 4, nii.edges._data[1][1], littleEndian);\n        view.setFloat32(280 + 6 * 4, nii.edges._data[1][2], littleEndian);\n        view.setFloat32(280 + 7 * 4, nii.edges._data[1][3], littleEndian);\n\n        view.setFloat32(280 + 8 * 4, nii.edges._data[2][0], littleEndian);\n        view.setFloat32(280 + 9 * 4, nii.edges._data[2][1], littleEndian);\n        view.setFloat32(280 + 10 * 4, nii.edges._data[2][2], littleEndian);\n        view.setFloat32(280 + 11 * 4, nii.edges._data[2][3], littleEndian);\n    }\n\n\n    // ------------------ sizes\n    if( sizes != undefined)\n    {\n        if(sizes[0] > nii.sizes[0] | sizes[1] > nii.sizes[1] | sizes[2] > nii.sizes[2])\n        {\n            nii.sizes = sizes;\n            nii.widheidep = nii.sizes[0] * nii.sizes[1] * nii.sizes[2];\n            nii.widhei = nii.sizes[0] * nii.sizes[1];\n            nii.wid = nii.sizes[0];\n\n             \n            var tdim = sizes[3];\n            var hdroffset = nii.hdroffset;\n\n            var bitpix = view.getInt16(72, littleEndian)\n            var tmp = new Uint8Array(hdroffset + bitpix / 8 * sizes[0] * sizes[1] * sizes[2] * tdim);\n\n            // copy the header\n            tmp.set(new Uint8Array(nii.buffer, 0, hdroffset) );\n            \n            nii.buffer = tmp.buffer;\n            nii.data = new Uint8Array(nii.buffer, hdroffset);\n\n            // update header\n            if (tdim > 1)\n                view.setInt16(40, 4, littleEndian)\n            else\n                view.setInt16(40, 3, littleEndian)\n\n            view.setInt16(42, nii.sizes[0], littleEndian)\n            view.setInt16(44, nii.sizes[1], littleEndian)\n            view.setInt16(46, nii.sizes[2], littleEndian)\n            view.setInt16(48, tdim, littleEndian)\n\n        }\n\n    }\n\n\n}\n\n\n/** used to unlag mouse move events in firefox \n * @function */\nfunction moveUnlagger(fun, cloneEvent)\n{\n    var lastMove = false;\n    if (!(/Firefox/i.test(navigator.userAgent)))\n        return fun;\n    else\n    {\n        var movefun = function(ev, s)\n        {\n            if (!lastMove)\n            {\n                if (cloneEvent)\n                {\n                    var event = $.extend({}, ev);\n                    setTimeout(function() {\n                        fun(event, s)\n                    }, 0);\n                }\n                else\n                    setTimeout(function() {\n                        fun(ev, s)\n                    }, 0);\n            }\n            lastMove = true;\n            setTimeout(function() {\n                lastMove = false;\n            }, 10);\n            ev.preventDefault();\n            // return false;\n\n        }\n        return movefun;\n    }\n}\n\n\nfunction getloadParamsFromDrop(ev,intent, progress)\n{\n\n\n\n  var params_arr  = [];\n  if(ev.dataTransfer != undefined && ev.dataTransfer.files.length > 0)\n  {\n\tfor (var l = 0;l <ev.dataTransfer.files.length;l++)\n\t   params_arr.push(createParamsLocalFile( ev.dataTransfer.files[l],intent, progress ) );\n\treturn params_arr;\n  }\n  \n  // dataTransfer might be reordered during drag ... not really good but must live with it\n  if (ev.dataTransfer != undefined &&  (ev.dataTransfer.types[0] == \'form\' | ev.dataTransfer.types[1] == \'form\' ))\n  {\n      var params = {};\n      params.URLType  = \'form\';\n      if (ev.dataTransfer.types[0] == \'form\')\n         params.fileID = ev.dataTransfer.types[1];\n      else\n         params.fileID = ev.dataTransfer.types[0];\n      params_arr.push(params);\n     return params_arr;\n  }\n\n  if (tempObjectInfo != undefined)\n  {\n\t    function objinfo2loadParams(objinfo)\n\t    {\n\t\t\t  var params = {};\n\t\t\t  params.URLType  = \'serverfile\';\n\t\t\t  params.fileID    = objinfo.fileID; \n\t\t\t  params.close = objinfo.close;\n\t\t\t  var ev_intent = {};\n\t\t\t  if (objinfo.intent != undefined)\n\t\t\t  {\n\t\t\t\tif (typeof objinfo.intent == "string")\n\t\t\t\t\teval(\'ev_intent={\'+objinfo.intent +\'};\');\n\t\t\t\telse\n\t\t\t\t    ev_intent = objinfo.intent;\n\t\t\t  }\n\t\t\t  params.intent = $.extend(true,ev_intent,intent);\n\t\t\t  return params;    \t\n\t    }\n\n\t\tfor (var l=0;l <tempObjectInfo.length;l++)\n\t\t{\n\t\t  var params = {};\n\t\t  if (tempObjectInfo[l].type == \'file\')\n\t\t  {\n\t\t\t  params_arr.push(objinfo2loadParams(tempObjectInfo[l]));\n\t\t  }\n\t\t  else if (tempObjectInfo[l].type == \'subfolder\')\n\t\t  {\n\t\t  \tvar elem = $("tr[rowid_parent=\'" + tempObjectInfo[l].piz + riddelim + tempObjectInfo[l].sid + riddelim + tempObjectInfo[l].subfolder + "\'][data-type=\'file\']:first");\t\t  \t\n\t\t  \tif (elem.length>0)\n\t\t  \t\t params_arr.push(objinfo2loadParams(packObjectInfo(elem[0])));\n\t\t  } \n\t\t  else if (tempObjectInfo[l].type == \'study\')\n\t\t  {\n\t\t\treturn {patient_study_drop: tempObjectInfo[l].piz + riddelim + tempObjectInfo[l].sid };\n\t\t  }\n\t\t  else if (tempObjectInfo[l].type == \'patient\')\n\t\t  {\n\t\t  \t  return {patient_study_drop: tempObjectInfo[l].piz };\n\t\t  }\n\t\t  else if (tempObjectInfo[l].type == \'markertemplate\')\n\t\t  {\n\t\t  \t  return  tempObjectInfo[l] ;\n\t\t  }\n\t\t  else if (tempObjectInfo[l].type == \'tagpaneltag\')\n\t\t  {\n\t\t  \t  return  tempObjectInfo[l] ;\n\t\t  }\n\n\t\t}\n        return params_arr;\n  }\n  \n  return params_arr;\n  \n}\n\nfunction cleanAllDropIndicators()\n{\n    $(\'.KView_viewportdropIndicator\').fadeOut(220, function(){});\n    $(\'.KView_autoloader_dropIndicator\').fadeOut(220, function() { $(this).remove() } );\n    $(\'.body_dropindicator\').fadeOut(220, function() { $(this).remove() } );\n    //tempObjectInfo = undefined;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// USER settings\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfunction UserSettingsDialog()\n{\n   \n   var that = new dialog_generic();\n   that.$frame.width("500px").height("800px");\n\n\t\n   var form = \n   { \n\tname \t\t: "usersettings",\n\tlastchange  : "",\n\tlayout: \n\t[\n \t  {\ttype: \'title\', val: userinfo.username}\n\t ,{ type: \'separator\', css: ["height","1px"] }\n\t \t,{name:"fullname"\t\t\t\t, type: \'input\',     defaultval:""  }\n\t \t,{name:"email"\t\t\t\t\t, type: \'input\',     defaultval:""  }\n\t \t,{name:"institution"\t\t\t\t, type: \'input\',     defaultval:""  }\n\t \t,{name:"street"\t\t\t\t, type: \'input\',     defaultval:""  }\n\t \t,{name:"city"\t\t\t\t, type: \'input\',     defaultval:""  }\n\t \t,{name:"forceanonymize"\t\t\t\t, type: \'check\',     defaultval:false  }\n\t \t ,{type:"separator"}\n\t \t,{name:"passwd"\t\t\t\t    , type: \'input\', val:\'3434\',    defaultval:""  }\n\t \t ,{type:"separator"}\n\t\t,{name:"styletheme"\t\t        , type: \'option\',  style:"",  title:" Styling theme",\n  \t    \tchoices: ["classic blue","greenish","redish"],\n  \t    \tids:     ["classic", "green", "red"] ,defaultval:\'classic\' }\n\n\t] }\n\n\tuserinfo.id = userinfo.ID;\n    var content= userinfo;\n\n    KForm.getFormContent(form, content);\n\n\n\n\n    var $div = $("<div class=\'usersettings\'></div>").appendTo(that.$container);\n    KForm.createForm(form, content, $div, onchange);\n\n\n    var $style = $div.find("div[name=\'styletheme\']").find("select");\n    $style.on("change",function()\n    {\n        that.saveChanges();\n        alertify.success("Reload/press F5 to let changes to become active");\n\n    });\n\n    var $pwd = $div.find("input[name=\'passwd\']");\n    $pwd.attr(\'placeholder\',\'click to change\').attr(\'readonly\',true).on("click",changepwd);\n\t\n\tfunction changepwd()\n\t{\n\t\t$pwd.parent().nextAll().remove();\n\t\tvar $div = $("<div><br></div>").insertAfter($pwd.parent())\t\n\t\tvar $errmsg = $("<div style=\'color:red; text-align:center\'></div>").appendTo($div);\n\t\tvar $pw0 = $("<label class=\'KFormItem_label\' >old password:</label><input type=\'password\' name=\'newpwd0\' />").appendTo( $("<div class=\'KFormItem\'><br></div>").appendTo($div)  );\n\t\t\n        var $dummy = $("<div style=\'text-align:left;padding:10px 40px;\'>Use your LDAP password or choose another one.<br>Using LDAP is save, it will not be stored in our database.  </div>").appendTo($div);\n\n\t\tvar $pw1 = $("<label class=\'KFormItem_label\' >new password:</label><input type=\'password\' name=\'newpwd1\' />").appendTo( $("<div class=\'KFormItem\'><br></div>").appendTo($div)  );\n\t\tvar $pw2 = $("<label class=\'KFormItem_label\' >repeat new password:</label><input type=\'password\' name=\'newpwd2\' />").appendTo( $("<div class=\'KFormItem\'></div>").appendTo($div) );\n\t\tvar $submit = $("<label class=\'KFormItem_label\' ></label><input type=\'submit\' name=\'submit\' value=\'submit\' />").appendTo( $("<div class=\'KFormItem\'></div>").appendTo($div) )\n\t\t\t\t.click(function(){\n\t\t\t\t\tif($pw1.next().val() !== $pw2.next().val())\n\t\t\t\t\t{\n\t\t\t\t\t\t$errmsg.html("Your must enter the same password twice.");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telse if($pw1.next().val().length < 4)\n\t\t\t\t\t{\n\t\t\t\t\t\t$errmsg.html("New password is too simple");\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthat.passwdChange($pw0.next().val(), $pw1.next().val(), function(result) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t    if(result.custom_success !== undefined && result.custom_success == 0)\n\t\t\t\t\t\t    {\n        \t\t\t\t\t\t$errmsg.html(result.custom_msg).hide().slideDown();\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t    else if(result.custom_success !== undefined && result.custom_success == 1)\n\t\t\t\t\t\t    {\n                                alertify.alert(result.custom_msg);\n                                $div.remove();\n\t\t\t\t\t\t    }\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\n\t\tvar $cancel = $("<input type=\'reset\' name=\'cancel\' value=\'cancel\' style=\'margin-left:50px;\' />").appendTo($submit.parent()).click(function(){$div.remove()});\n\n\t\treturn\n\t}\n\n\tthat.ontoggle = function()\n\t{\n\t\tif(content.modified)\n\t\t{\n\t\t\tdelete content.modified;\n\t\t\tthat.saveChanges();\n\n\t\t}\n\t}\n\t\n\tthat.passwdChange = function(oldpasswd, newpwd, whendone)\n\t{\n\t\tajaxRequest(\'command=passwordChange&json=\' + encodeURIComponent(JSON.stringify([{id:userinfo.ID, oldpasswd:oldpasswd, passwd:newpwd}])) , whendone);\n\t}\n\n\n\tthat.saveChanges = function(onsave)\n\t{\n\t\tfunction whendone(result)\n\t\t{\n\t\t\tif (onsave)\n\t\t\t onsave();\n\t\t}\n// \t\tvar userinfo_tmp = $.extend(true,{},userinfo);\n// \t\tdelete userinfo_tmp.passwd;\n\t\t// do NOT save all fields\n\t\tvar userinfo_tmp = \n\t\t{\n\t\t    id:userinfo.id,\n\t\t    forceanonymize: userinfo.forceanonymize,\n\t\t    email: userinfo.email,\n\t\t    city: userinfo.city,\n\t\t    fullname: userinfo.fullname,\n\t\t    street: userinfo.street,\n\t\t    styletheme: userinfo.styletheme,\n\t\t}\n\n\t\tajaxRequest(\'command=userTable_save&json=\' + encodeURIComponent(JSON.stringify([userinfo_tmp])) , whendone);\n\t}\n\n    return that;\n}\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n// resizer, for example for the codemirror\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfunction addCustomResizer($target, opts_in)\n{\n    var opts = \n    {\n        x:true,\n        y:true,\n        min_x:20,\n        max_x:10000000,\n        min_y:20,\n        max_y:10000000,\n    };\n    opts = $.extend(true, opts,opts_in)\n    var $resizer = $("<div class=\'dialog_generic_resizeTriangle\'></div>").appendTo($target).mousedown( \n    function()\n    {\n        $resizer.addClass(\'dialog_generic_resizeTriangle_hovered\');\n        $(document.body).on(\'mousemove\', function(ev)\n        {\n            var newwidth = ev.clientX - $target.offset().left ;\n            var newheight = ev.clientY - $target.offset().top ;\n            if(newwidth < opts.min_x | newheight < opts.min_y ) \n                return;\n            if(newwidth > opts.max_x | newheight > opts.max_y ) \n                return;\n            if(opts.x)\n                $target.width( newwidth  );\n            if(opts.y)\n                $target.height( newheight );\n\n        });\n\n        $(document.body).on(\'mouseup mouseleave\', function() \n        {       \n            $resizer.removeClass(\'dialog_generic_resizeTriangle_hovered\');   $(document.body).off(\'mousemove mouseup mouseleave\')\n        });\n        return false;\n    });\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// Generic Dialog\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfunction dialog_generic()\n{\n\n  // that.$menu       :   the ul menubar. just append your menu here\n  // that.$container  :   append your content here\n  // that.ontoggle     : add additional functionality to ontoggle button\n  // that.$frame     : the outer main frame. this is hidden on toggle\n  // that.deleteonclose: delete window on close. default is false;\n\n// ================= resize\n  var that = new Object();\n  that.$frame =  $("<div class=\'dialog_generic_frame movableWindows\'></div>").appendTo( $(document.body) );\n  //that.$frame.click(function(){ that.$frame.appendTo($(document.body))  }) ; //does not work. will steel focus.\n   that.$resizer = $("<div class=\'dialog_generic_resizeTriangle\'></div>").appendTo(that.$frame)\n     .mousedown( function()\n     {\n\n       var $elems = that.$frame.find(".sbox_resizable");\n       var scpos = [];\n\t   for(var k=0; k<$elems.length; k++)\n       {\t\t\t\t\n            var scroll = $elems.eq(k).scrollTop();\n            scpos.push( Math.min($elems[k].scrollHeight-$elems[k].clientHeight,scroll));\n       }\t\t\n       that.$resizer.addClass(\'dialog_generic_resizeTriangle_hovered\');\n       $(document.body).on(\'mousemove\', function(ev)\n       {\n         var newwidth = ev.clientX - that.$frame.offset().left ;\n         var newheight = ev.clientY - that.$frame.offset().top ;\n         if(newwidth < 200 | newheight < 200 ) return;\n         that.$frame.width( newwidth  );\n         that.$frame.height( newheight );\n\n         for(var k=0; k<$elems.length; k++)\n                    $elems.eq(k).scrollTop(scpos[k]);\n\n       });\n       \n       $(document.body).on(\'mouseup mouseleave\', function() \n       {       \n         that.$resizer.removeClass(\'dialog_generic_resizeTriangle_hovered\');   $(document.body).off(\'mousemove mouseup mouseleave\')\n\n       });\n       return false;\n\n   });\n\n   // ============== move\n  that.$menuDIV = $("<div class=\'dialog_generic_menu\'></div>").appendTo(that.$frame).mousedown( function(ev) { movableWindowMousedownFn(ev, that.$frame)})\n\n  // why was this? == because of z-index.\n  // but leads to jumping to top behaviour... this can b\n  /*\n  that.$menuDIV.click( function() \n  { \n    var st = that.$container.scrollTop();\n   \tthat.$frame.appendTo($(document.body))  \n    that.$container.scrollTop(st);\n  } ) ;\n  */\n\n  that.$menu = $("<ul class=\'menu_generic\' style=\'\'>").appendTo( that.$menuDIV );\n  //$("<li class=\'menu_generic_disabled\' ></li>").appendTo($(ul));\n\n  // set this to true to delete the window completey on close instead of just hiding it\n  that.deleteonclose = false;\n\n  // this is the defautl behaviour for click on close button. add additional handles by overwriting ontoggle\n  that.ontoggle = function() {return true;};\n  that.toggle = function(ev)\n  {\n\n   \n    var res = that.ontoggle();\n\n    // if the custom toggle fun returns false, abort here, it probably took care of everything (check for unsaved ...)\n    if(res === false)\n    {\n    \treturn;\n    }\n    else\n    {\n        if( that.deleteonclose)\n        {\n            that.$frame.remove(); \n        }\n        else\n        {\n          //  that.$frame.appendTo($(document.body));\n            if (that.$frame.css(\'display\') != \'none\')\n            {\n               that.toggle.scpos = [];\n               var scpos = that.toggle.scpos;  \n               that.toggle.$elems = that.$frame.find(\'.sbox_resizable\' );\n               var $elems = that.toggle.$elems;\n               for(var k=0; k<$elems.length; k++)\n               {\t\t\t\t\n                    var scroll = $elems.eq(k).scrollTop();\n                    scpos.push( Math.min($elems[k].scrollHeight-$elems[k].clientHeight,scroll));\n                  \n               }\n               that.$frame.hide();        \n               if (that.onPastToggle)\n                  that.onPastToggle(false)\n\n            }\n            else\n            {\n                that.$frame.show(); \n                var $elems = that.toggle.$elems;\n                var scpos = that.toggle.scpos;  \n                if ($elems)\n                    for(var k=0; k<$elems.length; k++)\n                    {\t\t\t\t\n                        $elems.eq(k).scrollTop(scpos[k]);                          \n                    }\n                bringToFront(that.$frame)\n                if (that.onPastToggle)\n                    that.onPastToggle(true)\n                return true;\n            }\n\n           // that.$frame.toggle();\n        }\n    }\n  }\n  that.closebtn = $("<li style=\'float:right;\'> <a><i class=\'close_button fa fa-close\' /></i> </a> </li>").appendTo(that.$menu  ).mousedown( function(ev){  ev.stopPropagation(); that.toggle()} );\n\n  maximizerButton(that.$menu, that.$frame);\n\n  that.$container = $("<div class=\'dialog_generic_container\'></div>").appendTo(that.$frame);\n\n  that.bringToFront = function()\n  {\n      bringToFront(that.$frame);\n  }\n  \n  that.bringToFront();\n  \n  return that;\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// Generic List / Tab Manager\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\nfunction KList(struct)\n{\n    /* Usage:\n    struct.$targetcontainer\n    struct.$menucontainer (optional), otherwise use return.$ul\n    struct.classes : classic, roundish, vert, inverted, \n    struct.ondelete\n    struct.onchange\t\n    struct.activeID\n\n    example:\n    tabber = new KList({classes:["roundish", "classic" ], $targetcontainer: $target})\n    tabber.append = (uid, title, function() return($contentdiv), onclick)\n    tabber.updateOrSelectByID(id)\n    tabber.clear;\n    */\n\n\tvar klm = new Object();\n\tklm.list = new Object();\n\n\tklm.activeID = undefined;\n\n\tvar $target;\n\n\tif(struct.$targetcontainer != undefined)\n\t\tsettarget(struct.$targetcontainer);\n\n\t\n\tvar classes = "KList ";\n\tif(struct.classes !=undefined)\n\t{\n\t\tfor(var k=0; k< struct.classes.length; k++)\n\t\t{\n\t\t\tclasses +=  " KList_" + struct.classes[k] ;\n\t\t}\n\t}\n\n\t// the menu container does already exist, append\n\tif(struct.$menucontainer)\n\t\tklm.$ul = struct.$menucontainer.addClass(classes);\n\telse\n\t\tklm.$ul = $("<ul class=\'" + classes + "\'></ul>");\n\t\n\n    klm.deselect = function()\n    {\n        klm.$ul.children().removeClass(\'active\')  \n    }\n\n\n\t/**********************************\n\tset the target where content shall be updated\n\t**********************************/\t\n\tfunction settarget($t)\n\t{\n\t\t$target = $t;\n\t}\n\tklm.settarget = settarget;\n\n\n\t/**********************************\n\treset, when MList becomes empty after deletion of last element\n\t**********************************/\t\n\tklm.reset = function()\n\t{\n\t\tif( klm.subList  && klm.subList.activeID)\n\t\t\tklm.subList[klm.subList.activeID].trigger(\'click\');\t\t\n\t\t\n\t\tif($target!=undefined)\n\t\t\t$target.empty();\n\t}\n\n\t/**********************************\n\tsetVisibleGroups\n\t**********************************/\t\n\tklm.groupsexpanded = {};\n    klm.setGroupsExpanded = function(groups)\n    {\n        if (groups == undefined)\n        \tklm.groupsexpanded = {};\n        else\n            klm.groupsexpanded = groups;\n    }\n\n\t/**********************************\n\tappend items\n\t**********************************/\t\n\tklm.append = function(uid, title, content, onclick, addons)\n\t{\n\t\t\n\t\t/**********************************\n\t\tsub-tree with groups\n\t\t**********************************/\n\t\tvar temp = title.split(\'/\');\n\t\tif(temp.length>1)\n\t\t{\n\t\t\tvar group= temp[0];\n\t\t\tvar ititle = temp.slice(1).join(\'/\');\n\n\t\t\tvar $li = $("<li class=\'KListItem KListItem_subitem\'><a>"+ititle+"</a></li>").hide();\n\t\t\tvar $parent = klm.$ul.find(\'ul[klist_groupid="\'+group+\'"]\')\n\t\t\tvar selstr = "right"\n\t\t\tif(\tklm.groupsexpanded[group])\n\t\t\t  selstr = "down";\n\t\t\tif($parent.length==0)\n\t\t\t\t$("<ul class=\'KListItem KListItem_subgroup\' klist_groupid=\'"+group+"\'></ul>").appendTo(klm.$ul)\n\t\t\t\t.append( $("<li class=\'KListItem\'><a><i class=\'fa fa-caret-"+selstr+"\' style=\'float:left\'></i><span>"+group+"</span></a></ul>").click(function(){\n\t\t\t\t\t$(this).nextUntil().toggle()\n\t\t\t\t\tvar thestate;\n\t\t\t\t\tvar $i = $(this).find(\'i\');\n\t\t\t\t\tif($i.hasClass(\'fa-caret-right\')){thestate = 1;\n\t\t\t\t\t   $i.removeClass(\'fa-caret-right\').addClass(\'fa-caret-down\')}\n\t\t\t\t\telse{thestate = 0;\n\t\t\t\t\t   $i.removeClass(\'fa-caret-down\').addClass(\'fa-caret-right\')}\n\t\t\t\t\tklm.groupsexpanded[group] = thestate;\n\t\t\t\t\tif(onclick) \n\t\t\t\t\t    onclick({klistgroup_id: group, klistgroup_state:thestate });\n\t\t\t\t\t}\n\t\t\t\t))\n\t\t\t\t.append($li);\n\t\t\telse\n\t\t\t\t$li.appendTo($parent.eq(0));\n\t\t\tif(\tklm.groupsexpanded[group])\n\t\t\t    $li.show();\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar $li = $("<li class=\'KListItem\'><a>"+title+"</a></li>").appendTo(klm.$ul);\n\t\t}\n\n\t\tif(uid == \'spacer\')\n\t\t{\n\t\t\t$li.addClass(\'KListSpacer\');\n\t\t\treturn $li.appendTo(klm.$ul);\n\t\t}\n\n\t\t/**********************************\n\t\tdeleteable items\n\t\t**********************************/\n\t\tif(struct.ondelete)\n\t\t{\n\t\t\t$("<i class=\'fa fa-trash\'></i>").appendTo($li).click(function(ev){struct.ondelete(uid);ev.stopPropagation();});\n\t\t}\n\n\t\t/**********************************\n\t\tarbitrary mods\n\t\t**********************************/\n        if (addons)\n            addons(uid,$li);\n\n\n\t\t$li.uid = uid;\n\t\t\n\t\t// save the li twice, as shortcut and as dedicated list\n\t\tklm[uid] = $li;\n\t\tklm.list[uid] = $li;\n\n\t\t/**********************************\n\t\tfirst: run custom handler, e.g. to set a new variable in background\n\t\t**********************************/\n\n\t\t/**********************************\n\t\tclick handler for marking and setting content\n\t\t**********************************/\n\t\t$li.click( function(uid) { return function()\n\t\t{\n\t\t\t\n    \t\tif(onclick) \n    \t\t{\n\t\t\t    if ( onclick($li,dothechange) == "donotcall" )\n\t\t\t         return;\n\t\t\t    dothechange();\n    \t\t}\n    \t\telse\n    \t\t  dothechange();\n\n\n            function dothechange()\n            {\n\n                klm.$ul.find(\'li\').removeClass(\'active\')  \n                $li.addClass(\'active\');\n                klm.activeID = uid;\n\n                // Before clearing the content: If there was a subList set remember its active list element and re-trigger\n    // \t\t\tvar activeID;\n    // \t\t\tif( klm.subList )\n    // \t\t\t\tactiveID = klm.subList.$ul.children(\'.active\').uid;\n                var newContent = undefined;\n                if(typeof content == \'function\' )\n                    newContent = content(uid);\n                else if(content instanceof jQuery )\n                    newContent =  content;\n                if(newContent != undefined)\n                {\n                    // careful here: empty will destroy click handlers on objects. Only empty if create function is given for new object\n                    if(typeof content == \'function\' )\n                        $target.empty(); \n                    else if(content instanceof jQuery )    \n                        $target.children().detach();\n\n                    $target.append( newContent.hide() );\n                    newContent.fadeIn(200);\n                }\n\n                if( klm.subList  && klm.subList.activeID)\n                     klm.subList[klm.subList.activeID].trigger(\'click\');\n            }\n\n\t\t}}(uid));\n\t\t\n\t\t\n\t\treturn $li;\n\n\t}\n\n\n\tklm.updateOrSelectByID = function(id)\n\t{\n\t\tif (id == undefined)\n\t\t{\n\t\t\t// select the active One\n\t\t\tif(klm.activeID!==undefined && klm.list[klm.activeID]!=undefined)\n\t\t\t{\n\t\t\t\tid = klm.activeID;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar list = Object.getOwnPropertyNames(klm.list);\n\t\t\t\tif(list.length > 0 )\n\t\t\t\t\tklm.list[list[0]].trigger("click");\n\t\t\t}\n\t\t}\n\n\t\tif(id != undefined && klm[id] !=undefined)\n\t\t\t\tklm.list[id].trigger("click");\n\t}\n\n\t// rebuild the list\n\tklm.clear = function()\n\t{\n\t\tklm.$ul.empty();\n\t\tklm.list = new Object();\n\t}\n\n\treturn klm;\n\n}\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// Generic Table Manager (similar to localfiletable)\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\nfunction table_generic(opts_in)\n{\n    /*\n    that.$table  \n    that.$thead  \n    that.$tbody  \n    that.appendToHead( [] )\n    that.appendToBody( [] )\n    */\n    \n    var opts = \n    {\n        selectable: 0,\n        checkable: 0,\n        checkonclick: 0,\n        class_checked: \'selectedGray\',\n        class_active : \'selected\',       \n        resizable: 0,\n        sortable: 0\n    }\n    $.extend(true, opts, opts_in)\n\n    var that = new Object();\n    var $table = that.$table = $("<table cellspacing=0  class=\'localfiletable\' style=\'\'></table>"); \n    var $thead = that.$thead   = $("<thead></thead>").appendTo($table);\n    var $tbody = that.$tbody   = $("<tbody></tbody>").appendTo($table);\n\n\n\t/**********************************\n\tAppend a row to head or body\n\t**********************************/\t\n    that.appendToHead =  function(row)\n    {\n       return that.append($thead, row);\n    }\n    that.appendToBody = function(row)\n    {\n       return that.append($tbody, row);\n    }\n\n\t/**********************************\n\tAppend a row \n\t**********************************/\t\n    that.append = function($where, row)\n    {\n        // ***** row is already created from outside\n        if(row.jquery)\n        {\n            var $row = row;\n        }\n        //******** row is array of values\n        else if (row instanceof Array)\n        {\n            var rowid = "xxx";\n            var $row = $("<tr id="+rowid+"></tr>");\n            for(var k=0; k<row.length; k++)\n            {\n                if(row[k] instanceof jQuery)\n                {\n                    row[k].appendTo( $("<td></td>").appendTo($row) ); \n                }\n                else\n                {\n                    if( row[k]==null || row[k] == undefined)\n                        var val  = "";\n                    else\n                        var val = (row[k]).toString();\n    \n                    $("<span>"+val+"</span>").appendTo( $("<td></td>").appendTo($row) ); \n                }\n\n            }\n\n        }\n        // row is an object --\x3e take the keys\n        else if (row instanceof Object)\n        {\n            var rowid = "xxx";\n            var $row = $("<tr id="+rowid+"></tr>");\n            for(var k in row)\n            {\n                if( !(row[k] instanceof Object) && !(row[k] instanceof Array) )\n                {\n                    if( row[k]==null || row[k] == undefined)\n                        var val  = "";\n                    else\n                        var val = (row[k]).toString();\n\n                    $("<span>"+val+"</span>").appendTo( $("<td></td>").appendTo($row) ); \n                }\n            }\n        }\n        else\n        {\n            return false;\n        }\n\n        if(opts.checkable)\n            $("<td ><i class=\'fa fa-square-o\'></i></td>").prependTo($row).click(  function(ev){toggleChecked(ev, $row); return false;}  );\t\n        \n        if(opts.checkable || opts.selectable )\n            $row.click( clickOnRow  );\n\n        $row.appendTo($where);\n        return $row;\n    }\n\t/**********************************\n\tclean all\n\t**********************************/\t\n    that.clean = function()\n    {\n        $thead.empty();\n        $tbody.empty();\n    }\n\n\n\t/**********************************\n\tclickOnRow\n\t**********************************/\t\n    function clickOnRow(ev, callback)\n    {\n        ev.stopPropagation();\n        ev.preventDefault();\n        return false;\n\n        if( (ev.shiftKey || ev.ctrlKey) && opts.checkonclick )\n        {\n            toggleChecked(ev,  $(this) );\n            return false;\n        }\n        else if( opts.selectable )\n        {\n            setActive( $(this) );\n            if(callback)\n                return callback()\n            else\n                return false;\n        }\n        \n    }\n\n\t/***************************************************************************************\n\t* setActive: set the active row \n\t****************************************************************************************/\n\tvar $currentfocus;\n\tfunction setActive($row)\n    {\n\t    //var $row = $(this);\n        $virtualInput.focus();\n        $currentfocus = $row;\n\t    $tbody.find("tr").removeClass(opts.class_active);\n\t    $row.addClass(opts.class_active);\n\t}\n\n\t/***************************************************************************************\n\t* clickOnCheck: clicked on the check box or with ctrl/shift on row\n\t****************************************************************************************/\n    function toggleChecked(ev, $row)\n    {\n        if(ev.shiftKey)\n        {\n            if($currentfocus == undefined)\n                return false;\n\n            var indlast = $currentfocus.index();\n            var indthis = $row.index();\n            var diff = indthis-indlast;\n            if(diff > 0)\n            {\n                var $cc= $currentfocus;\n            }\n            else if(diff < 0)\n            {\n                var $cc= $row;\n                diff = -diff;\n            }\n            for(var x=0; x<=diff; x++)\n            {\n                //toggleCheckedInternal($cc, indlast.hasClass(opts.class_checked));\n                toggleCheckedInternal($cc, ev.ctrlKey);\n                $cc = $cc.next();\n            }\n        }\n        else// if(ev.ctrlKey)\n        {\n            toggleCheckedInternal($row);\n        }\n        return false;\n    }\n\n\n\t/***************************************************************************************\n\t* toggleChecked: toggle the CHECK Selection\n\t****************************************************************************************/\n\tfunction toggleCheckedInternal($row, force)\n\t{\n\t\tif($row.parent().is(\'thead\'))\n\t\t{\n\t\t\tvar $allrows = $tbody.find("tr");\n\t\t\tif(!$row.hasClass(opts.class_checked) )\n\t\t\t{\n\t\t\t\t$row.find(\'.fa\').eq(0).addClass(\'fa-check-square\');\n\t\t\t\t$row.find(\'.fa\').eq(0).removeClass(\'fa-square-o\');\n\t\t\t\t$row.addClass(opts.class_checked);\n\t\t\t\t$allrows.addClass(opts.class_checked);\n\t\t\t\t$allrows.find(\'.fa\').addClass(\'fa-check-square\');\n\t\t\t\t$allrows.find(\'.fa\').removeClass(\'fa-square-o\');\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\t$row.find(\'.fa\').removeClass(\'fa-check-square\');\n\t\t\t\t$row.find(\'.fa\').addClass(\'fa-square-o\');\n\t\t\t\t$row.removeClass(opts.class_checked);\n\t\t\t\t$allrows.removeClass(opts.class_checked);\n\t\t\t\t$allrows.find(\'.fa\').removeClass(\'fa-check-square\');\n\t\t\t\t$allrows.find(\'.fa\').addClass(\'fa-square-o\');\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(force!==undefined)\n\t\t\t\tvar newstate = force;\n\t\t\telse\n\t\t\t\tvar newstate = $row.hasClass(opts.class_checked);\n\t\t\t\t  \n\t\t\tif(newstate )\n\t\t\t{\n\t\t\t\t$row.removeClass(opts.class_checked);\n\t\t\t\t$row.children().eq(0).find(\'.fa\').removeClass(\'fa-check-square\');\n\t\t\t\t$row.children().eq(0).find(\'.fa\').addClass(\'fa-square-o\');\n\t\t\t}\n\t\t\telse \n\t\t\t{\n\t\t\t\t$row.addClass(opts.class_checked);\n\t\t\t\t$row.children().eq(0).find(\'.fa\').addClass(\'fa-check-square\');\n\t\t\t\t$row.children().eq(0).find(\'.fa\').removeClass(\'fa-check-o\');\n\n\t\t\t}\n\t\t}\n\t}\n\n\n\t/**********************************\n\tKeyboard move functionality: move up and down \n\t**********************************/\t\t\n\t// put an key event handler to som element, It must have tabindex to work.\n\tif(opts.selectable)\n\t{\n        $virtualInput = $table;\n        $virtualInput.attr("tabindex",-1)\n        $virtualInput.on(\'keyup\', keyhandler);\n\t}\n    function keyhandler(ev) \n    {\n    \tif($currentfocus)\n    \t{\n    \t\tif(ev.keyCode==38 && $currentfocus.prev().length > 0)\n    \t\t   \t\t$currentfocus = $currentfocus.prev();\n    \t\telse if(ev.keyCode==40 && $currentfocus.next().length > 0)\n    \t\t   \t\t$currentfocus = $currentfocus.next();\n    \t\t\n    \t\tif($currentfocus)\n    \t\t\t$currentfocus.trigger(\'click\');\n    \t}\n        ev.preventDefault();\n        return false;\n    }\n\n\n    function createTestTable()\n    {\n        that.$tbody.empty();\n        that.$thead.empty();\n\n        var h  = ["h2", "h3" , "h5"];\n        var b1 = ["b2aada", "badada3" , "b5"];\n        var b2 = ["b2",  1 , "b5adaa"];\n        var b3 = ["b3",  1 , "bdaa"];\n        var b4 = ["b524",  1 , "b5adaa"];\n        that.appendToHead(h);\n        that.appendToBody(b1);\n        that.appendToBody(b2);\n        that.appendToBody(b3);\n        that.appendToBody(b4);\n\n        $table.appendTo($body);\n        $table.css(\'position\', \'absolute\');\n        $table.css(\'z-index\', \'1000000000000\');\n        $table.dblclick( function(){$table.remove()} );\n    }\n    \n    //createTestTable();\n\n    return that;\t\n}\n\n\n\n\n\n\n\nvar scriptLoader = new ScriptLoader();\nfunction ScriptLoader() \n{\n\tvar that = new Object();\n\tthat.scripts = new Array();\n\tthat.loadScript = function(scriptName, whendone)\n\t{\n\t\t//var url = myownurl().substr(0, myownurl().lastIndexOf(\'/\')) + "/" + scriptName;\n\t\tvar url = url_pref + "/" + scriptName;\n\n        if (url.substring(0,1) == "/")\n            url = url.substring(1);\n\n\t\tif(that.scripts[scriptName] === undefined)// & $(document.head).find("#"+scriptName).length ==0 )\n\t\t{\n\t\t\t// synchrounus loading  .... no so nice\n\t\t\t//var script = $("  <script type=\'text/javascript\' defer=\'defer\'  id=\'"+ scriptName +"\'><\/script>").attr(\'src\', url).appendTo(document.head);\n\t\t\t//that.scripts[scriptName] = true;\n\t\t\t// async: hard: must wait in 3D viewer\n\t\t\t$.getScript(url, function()\t\t\t\t{ that.scripts[scriptName] = true; if (whendone) whendone();});\n\t\t}\n\t\telse \t\t{if(whendone)whendone();}\n\t}\n\n\treturn that;\n}\n\n\n\nfunction setdragend(ev)\n{\n  cleanAllDropIndicators();\t\n/*\n  $(\'.KView_viewportdropIndicator\').fadeOut(220, function()\n  {\n  \t//$(this).remove()\n  } );\n  \n  $(\'.KView_autoloader_dropIndicator\').fadeOut(220, function()\n  {\n  \t$(this).remove()\n  } );\n*/\n}\n\n\nfunction setdragstart(ev)\n{\n\t/***************************************************************************************\n\tdrop-cancellator\n\t****************************************************************************************/\n\t/*\n  \tvar $cancel = $("<div class=\'dropindicator_general_vert body_dropindicator\' style=\'\'></div>").hide().appendTo($body).fadeIn(150);\n  \tsetPixelPosition($cancel, [1,1, 300,100], 0);\n  \tvar $cancelInner = $("<div style=\'background:rgba(255, 139, 0, 0.9);padding:10px 20px;\'>Dragged by accident? <br><br>Drop here to cancel drop.</div>").appendTo($cancel);\n  \t\t\t$cancelInner.on("dragenter dragover", function(ev)\n\t\t\t{ $(this).css(\'background\', \'rgba(200, 139, 0, 0.9)\'); \t\t\t\tev.preventDefault();ev.stopPropagation();return false; });\n\t\t\t$cancelInner.on("dragleave", function(ev)\n\t\t\t{ $(this).css(\'background\', \'rgba(255, 139, 0, 0.9)\');\t\t\t\tev.preventDefault();ev.stopPropagation();return false; });\n\t\t\t$cancelInner.on("drop", function(ev)\n\t\t\t{ $cancel.remove(); cleanAllDropIndicators();\t\t\t\tev.preventDefault();ev.stopPropagation();return false; });\n\t*/\n\t\n\t/***************************************************************************************\n\tAutoloaders\n\t****************************************************************************************/\n\tif(!ev.ctrlKey && ($(ev.target).hasClass("patient") || $(ev.target).hasClass("study")) )\n\t{ \n\n\t\t/***************************************************************************************\n\t\tthe starter\n\t\t****************************************************************************************/\n\t\tvar $start = $("<div class=\'dropindicator_general_vert body_dropindicator\' style=\'border-radius:5px;\'><div>Drag here to show all autoloaders</div></div>").hide().appendTo($body).fadeIn(150);\n\t\tvar pos = getPixelPosition($("#KView_toolBarLeft").find(\'.fa-car\'));\n\t\tsetPixelPosition($start, [pos[0]-00,pos[1]-100, 180,150], 0);\n\t\t\t\t$start.on("dragenter dragover", function(ev)\n\t\t\t\t{ $start.remove(); showAutoloaderIndicators(); \t\t\tev.preventDefault();ev.stopPropagation();return false; });\n\n\t\tfunction showAutoloaderIndicators()\n\t\t{\n\t\t\tvar $frame = $("<div class=\'KView_autoloader_dropIndicator\' style=\'\'></div>")\n\t\t\t\t.offset(KViewer.$container.offset()).width(KViewer.$container.width()).height(KViewer.$container.height());\n\n\t\t\t$("<div><span style=\'font-size:30px\'>AUTOLOADERS</span><br><br><span>Drop patient or study to start an autoloader<br>You can add / remove / manage autoloaders using the autloader menu</span></div>").appendTo($frame);\n\n\t\t\tvar $list = $("<div></div>").appendTo($frame);\n\t\t\tvar plist = presetManager.getPresetList();\n\t\t\tvar keys = Object.getOwnPropertyNames(plist);\n\t\t\tkeys.unshift("0");\n\t\t\tfor(var z=0; z<keys.length; z++)\n\t\t\t{\t\n\t\t\t\tvar k = keys[z];\n\t\t\t\tif(k=="0")\n\t\t\t\t{\n\t\t\t\t\tvar preset = state.viewer;\n\t\t\t\t\tvar title = "<b>currentSnapshot</b>";\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tvar preset = plist[k].content;\n\t\t\t\t\tvar title = preset.name;\n\t\t\t\t}\n\n\t\t\t\tif(1)//preset.autoloaders.length > 0)\n\t\t\t\t{\n\t\t\t\t\tvar str = "" ;\n\n\t\t\t\t\tstr += "<div>" + title + "</div>";\n\t\t\t\t\tstr += "<div>"; \n\t\t\t\t\t//str += "Viewports: <b>" + preset.nVisibleRows + " x " + preset.nVisibleCols +" | " + preset.nVisibleBarports + "</b><br />";\n\t\t\t\t\tstr += "<b>" + preset.nVisibleRows + " x " + preset.nVisibleCols + "</b><br />";\n\t\t\t\t\tfor(var i=0; i<preset.autoloaders.length;i++)\n\t\t\t\t\t\tstr += "<span style=\'font-size:12px;color:gray\'>"+ preset.autoloaders[i].pattern.slice(0,20) + "...<span> <br />" ;\n\t\t\t\t\tstr += "</div>";\n\n\t\t\t\t\tvar $item = $("<div>"+ str +"</div>").appendTo($list);\n\t\t\t\t\t// this must be set, otherwise drop will not work!!!\n\t\t\t\t\t$item.on("dragenter dragover", function(ev)\n\t\t\t\t\t{ $(this).css(\'background\', \'rgba(190, 0, 0, 0.6)\'); \t\t\t\tev.preventDefault();ev.stopPropagation();return false; });\n\t\t\t\t\t$item.on("dragleave", function(ev)\n\t\t\t\t\t{ $(this).css(\'background\', \'rgba(139, 0, 0, 0.6)\');\t\t\t\tev.preventDefault();ev.stopPropagation();return false; });\n\t\t\t\t\t$item.on("drop", creatDropFunction(preset));\n\t\t\t\t\tfunction creatDropFunction(p)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn function(evd)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tevd.preventDefault(); evd.stopPropagation();\n\t\t\t\t\t\t\tvar psid = {piz:($(ev.target)).attr(\'data-piz\'),sid:($(ev.target)).attr(\'data-sid\')};\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tstate.viewer.nVisibleCols =  p.nVisibleCols;\n\t\t\t\t\t\t\tstate.viewer.nVisibleRows =  p.nVisibleRows;\n\t\t\t\t\t\t\tstate.viewer.nVisibleBarports =  p.nVisibleBarports;\n\t\t\t\t\t\t\tKViewer.applyNewViewportLayout();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tstartAutoloader(p.autoloaders, psid);\n\t\t\t\t\t\t\tcleanAllDropIndicators();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\t\t\t}\n\t\t\t$frame.appendTo(document.body);\n\t\t}\n\t}\n\n\n\n  // comes from the roiPanel\n  if($(ev.target).parents(\'.roiToolContainer\').length > 0 )\n  {\n  \t ev.dataTransfer.setData("fromroitool","yea");\n  }\n\n  if ($(ev.target).hasClass("formtable"))\n  {\n  \t ev.dataTransfer.setData("form","");\n  \t ev.dataTransfer.setData($(ev.target).attr("data-fileid"),"");\n  }\n  else\n  {\n\t  prepObjectInfo(ev.target);\n\n\t  // drag from file cacheManager\n\t  if ($(ev.target).hasClass("filecache"))\n\t  {\n\t\t  if(ev.originalEvent!== undefined)\n\t\t\t   ev.originalEvent.dataTransfer.setData("fromcachetable","yea");\n\t\t  else\n\t\t\t   ev.dataTransfer.setData("fromcachetable","yea");\n\t  }\n\n      if(ev.originalEvent!== undefined)\n           ev.originalEvent.dataTransfer.setData("fromfiletable","yea");\n      else\n      {\n           ev.dataTransfer.setData("fromfiletable","yea");\n//           var fi = myownurl() + \'?asuser=\' + userinfo.username + "&project=" + projectInfo.name + "&fileID=100";\n//           ev.dataTransfer.setData("DownloadURL",fi);\n      }\n\n\t  for (var p in tempObjectInfo[0])\n\t\t  ev.dataTransfer.setData(p,tempObjectInfo[0][p]);// just needed for backward compatability (still have to change drop in Kviewports)\n\t  buildDragImg(ev);\n\n  }\n\n  var fromTool = $(ev.target).parents(\'.annotation_tool_listDIV\');\n  if (fromTool.length>0)\n  {\n     patientTableScrollLock($(fromTool[0]));\n  }\n  else\n  \tpatientTableScrollLock($("#patientTableWrap"));\n\n\n}\n\n\n\n/***************************************************************************************\n*  Interprets/packs selection in patient table\n****************************************************************************************/\n // gathers selection if target coincides with selected target,\n // or if target is undefined it gives just the selected objects\nfunction prepObjectInfo(target)\n{\n\n   var type = \'patientTable\';\n   if (target != undefined)\n   {\n   \tif  ($(target).hasClass(\'filecache\'))\n   \t    type = "filecache";\n   }\n\n  if (type == "filecache")\n  {\n  \t   var selected = $(target).parent().find(".selected")\n  \t   if (selected.length==0)\n  \t   {\n  \t   \t  tempObjectInfo = [packObjectInfo(target)];\n  \t   }\n  \t   else\n  \t   {\n  \t   \t  tempObjectInfo = new Array();\n          for (var k = 0; k < selected.length;k++)\n\t\t\t tempObjectInfo.push(packObjectInfo(selected[k]));\n  \t   }\n\n  }\n  else  // this is putativey the patientable\n  {\n\t  var rowid = $(target).attr("id");\n\t  if (rowid) rowid = rowid.toString();\n \n\t  tempObjectInfo = new Array();\n\t  if (typeof patientTableMirror != "undefined")\n\t  {\n          if (target == undefined | patientTableMirror.filesSelected.objs["x"+rowid] != undefined) // gather files\n              prepObjectInfoFromFileSelection(rowid);\n          if (target == undefined | patientTableMirror.selectedItems.indexOf(rowid) != -1)         // gather patients/   studies??\n              prepObjectInfoFromPatientSelection();\n\t  }\n\t  if (tempObjectInfo.length>0)\n\t\t return;\n\n\n\t  tempObjectInfo = [packObjectInfo(target)];\n  }\n}\n\n\nfunction prepObjectInfoFromFileSelection(pointed_rowid,target)\n{\n\n      if (target == undefined)\n        target = tempObjectInfo;\n      if (target == undefined)\n      {\n        console.warning("target not initizalied!!")\n      }\n\n\t  function addtoTempObjectInfo(rowid)\n\t  {\n\t\t  var therow = $("tr[id=\'" + rowid.substring(1) + "\']");\n\t\t  if (therow.length>0)\n\t\t\ttarget.push(packObjectInfo(therow));\n\t  }\n\n  \t  addtoTempObjectInfo("x"+pointed_rowid);\n\n      for (var rowid in patientTableMirror.filesSelected.objs)\n\t  \t if (patientTableMirror.filesSelected.objs[rowid] != undefined & "x"+pointed_rowid != rowid)\n\t  \t \taddtoTempObjectInfo(rowid)\n}\n\nfunction prepObjectInfoFromPatientSelection(target)\n{\n      if (target == undefined)\n        target = tempObjectInfo;\n      if (target == undefined)\n      {\n        console.warning("target not initizalied!!")\n      }\n\n\n  \t  for(var i=0;i<patientTableMirror.selectedItems.length;i++)\n  \t  {\n  \t  \tvar therow = $("tr[id=\'" + patientTableMirror.selectedItems[i] + "\']");\n  \t  \tif (therow.length>0)\n\t\t \ttarget.push(packObjectInfo(therow));\n\t\telse\n\t\t{\n\t\t\tif (state.viewer.selectionMode[1] == \'p\')\n\t\t\t\ttarget.push({type:\'patient\',piz:patientTableMirror.selectedItems[i]})\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar ids = patientTableMirror.selectedItems[i].split(riddelim);\n\t\t\t\ttarget.push({type:\'study\',piz:ids[0],sid:ids[1]});\t\t\t\t\n\t\t\t}\n\t\t}\n  \t  }\n}\n\nfunction packObjectInfo(target)\n{\n\tvar $target = $(target);\n\tvar fname;\n\tif ($target.attr(\'data-subfolder\') == undefined | $target.attr(\'data-subfolder\')=="" )\n\t\tfname = $target.attr(\'data-filename\');\n\telse if ($target.attr(\'data-filename\') == undefined | $target.attr(\'data-filename\')=="" )\n\t\tfname = $target.attr(\'data-subfolder\');\n\telse\n\t\tfname = $target.attr(\'data-subfolder\') + "/"+ $target.attr(\'data-filename\');\n\n\t// find the patient name\n\tif(state.viewer.selectionMode[1]=="p" && $target.attr(\'rowid_parent\')!="")\n\t\tvar namecat = ($(\'#patientTable\').find(\'[id="\'+$target.attr(\'rowid_parent\')+\'"]\')).eq(0).find(\'.td_NameCat\').text().substr(6).trim();\n\telse\n\t\tvar namecat = $target.find(\'.td_NameCat\').text().substr(6).trim();\n\n\treturn {type: $target.attr(\'data-type\'),\n\t\t sid:  $target.attr(\'data-sid\'),\n\t\t piz:   $target.attr(\'data-piz\'),\n\t\t namecat: namecat,\n\t\t subfolder:   $target.attr(\'data-subfolder\'),\n\t\t tag:   $target.attr(\'data-tag\'),\n\t\t intent:   $target.attr(\'data-intent\'),\n\t\t filename: fname,\n\t\t fileID:  $target.attr(\'data-fileid\'),\n\t\t mime:  $target.attr(\'data-mime\'),\n\t//\t\t fileURL: $target.attr(\'href\'),\n\t\t rowid: $target.attr("id"),\n\t\t date:$target.attr("data-date")\n\t\t } ;\n}\n\n\n\n\n\nfunction loadOrthoview(params,offset,cb)\n   {\n\n       var vp,sl;\n       if (ViewerSettings.nVisibleVertports > 0)\n       {\n            vp = [20,0,2];\n            sl = [2,0,1];\n       }\n       else\n       {\n            vp = [0+offset,1+offset,2+offset];\n            sl = [1,0,2];\n       }\n\n       \n\t   loadingQueue.execQueue([\n\t\t //$.extend(true,{intent: {viewportID:3+offset,slicing:2,gl:true}},params),\n\t\t $.extend(true,{intent: {viewportID:vp[0],slicing:sl[0],gl:false}},params),\n\t\t $.extend(true,{intent: {viewportID:vp[1],slicing:sl[1],gl:false}},params),\n\t\t $.extend(true,{intent: {viewportID:vp[2],slicing:sl[2],gl:false}},params)\n\t\t  ],\n\t\t function () { signalhandler.send(" reslice positionChange"); \n                       if (cb) \n                        cb();\n\t\t } );\n\n   }\n\n\nfunction binsearch(fun,target,lower,upper,tolerance)\n{\n    var current;\n\n    function search(low,up)\n    {\n        current = (low+up)*0.5;\n        var dif = fun(current)-target;\n        if (Math.abs(dif) < tolerance)\n            return;\n        else\n        {\n           if (dif < 0)\n             search(current,up)             \n           else \n             search(low,current)\n        }\n    }\n\n    search(lower,upper);\n\n    return current;\n\n}\n\nfunction createMetaIndex(name,index,type,level, shared)\n{\t\t\t\t\t\n\n    var jsonString = JSON.stringify({name:name,index:index,type:type,level:level, shared: shared});\n    ajaxRequest(\'command=addMetaIndex\'+\'&json=\' + jsonString , function(e) {\n        state.metaindices = e.metaindices; \n        refreshButton();\n    });\n}\n\n\n\nfunction attachWheelHandlerBrowserSafe(target, wheelhandler)\n{\n\n// mousewheel handling depends on browserWheelType\n// since we do not support IE lower than 8, it is best to add  both mousewheel and DOMMouseScroll directly\n// this should also be done, since removal of the handlers doe NOT work using when passing the functio as an argument.\n// Another aspect:\n// removal of handlers does NOT work with this secondary function!\n//  \n/*\n    // jquery object\n    if(target.get)\n        target = target.get(0);\n\n    if (target.addEventListener) \n    {\n        // Firefox\n        if (/Firefox/i.test(navigator.userAgent))\n            browserWheelType = "DOMMouseScroll";\n        // IE9+, Chrome, Safari, Opera\n        else\n            browserWheelType = "mousewheel";\n    }\n    else\n    {\n        // // IE 6/7/8\n        browserWheelType = "onmousewheel";\n    }\n    $(target).on( browserWheelType,  wheelhandler)\n    \n\n    // removal will NOT work\n    //$(target).off(browserWheelType,  wheelhandler)\n*/\n}\n\nfunction getWheelDelta(ev)\n{\n    ev = ev || ev.originalEvent;\n    return (ev.wheelDelta || -ev.detail ) > 0? 1:-1;\n}\n\n\nfunction getOnParentPath(obj,condition,depth)\n{\n    if (depth == undefined)\n        depth = 5;\n\n    var d = 0;\n    while (!condition(obj) &  d < depth)\n    {\n        obj = obj.parent();\n    }\n\n    if (d<depth)\n        return obj;\n}\n\n\nfunction createDummyNifti(sizes,bbox_max,bbox_min,perm,flip)\n{\n\t  var voxsz = [0,0,0,1];\n \t  for (var i=0; i< 3;i++)\n \t  \t voxsz[i] = (bbox_max[i]-bbox_min[i])/sizes[i];\n\n  \n\t  var edges = math.matrix(math.diag(voxsz));\n \t  \n\n      for (var i = 0;i < 3;i++)\n\t\t   edges._data[i][3] = +bbox_min[i];\n\t  \t\n\n\t  var nii = {\n\t\t  edges: edges,\n\t\t  voxSize: voxsz,\n\t\t  sizes: sizes,//  newsizes,\n\t\t  permutationOrder:perm,\n\t\t  arrayReadDirection:flip, \n\t\t  dummy:true,\n\t\t  detsign:math.sign(math.det(edges))\n\t   }\n\treturn nii;\n}\n\n\nfunction ignoreDblClickBeforeClose(ev)\n {\n\t\t\tvar $target = $(ev.target);\n\t\t\tfor (var j = 0; j< 4;j++)\n\t\t\t{\n\t\t\t\tif ($target.is("tr"))\n\t\t\t\t\t$target.attr("ondblclick","");\n\t\t\t\t$target = $target.parent();\n\t\t\t}\n }\n\n function setAutoSelectAllOnFocus($elem)\n {\n     $elem.on(\'focus\', function() {  setTimeout(function() { document.execCommand(\'selectAll\', false, null)  }, 0); })\n }\n\n\n\n/***************************************************************************************\ncreate timestamp in sql date format YYYY-MM-DD hh:mm:ss\n****************************************************************************************/\nfunction createSQLDate()\n{\n    var d = new Date();\n    var YYYY = d.getFullYear().toString();\n    var MM = (d.getMonth()+1).toString();\n    var DD = (d.getDate()).toString();\n    var hh = (d.getHours()).toString();\n    var mm = (d.getMinutes()).toString();\n    var ss = (d.getSeconds()).toString();\n    var out =     YYYY + "-" \n                + (MM.length==2?MM:"0"+MM) + "-" \n                + (DD.length==2?DD:"0"+DD) + " " \n                + (hh.length==2?hh:"0"+hh) + ":" \n                + (mm.length==2?mm:"0"+mm) + ":" \n                + (ss.length==2?ss:"0"+ss) + "" \n    return out;\n}\n\n\nfunction cloneCanvas(canvas,clipbox)\n{\n    var $c = $("<canvas> </canvas>");\n\n    var ctx = $c[0].getContext("2d");\n\n\n    if(clipbox)\n    {\n        var ax = clipbox[0]*canvas[0].width/100;\n        var ay = clipbox[1]*canvas[0].height/100;\n        var bx = (100-clipbox[2])*canvas[0].width/100;\n        var by = (100-clipbox[3])*canvas[0].height/100;\n        ctx.canvas.width = canvas[0].width*(clipbox[2]-clipbox[0])/100\n        ctx.canvas.height = canvas[0].height*(clipbox[3]-clipbox[0])/100\n    }\n    else\n    {\n        var ax=0; var ay=0; var bx=0; var by=0;\n        ctx.canvas.width = canvas[0].width\n        ctx.canvas.height = canvas[0].height\n    }\n\n\n    ctx.drawImage(canvas[0],ax,ay,ctx.canvas.width,ctx.canvas.height,\n    0,0,ctx.canvas.width,ctx.canvas.height)\n    return $c;\n}\n\n\nfunction getTicks(a,b)\n{\n    function fix(x,order)\n    {\n        if (Math.abs(order) > 3)\n            return x.toFixed(1) + "e" + order;\n        else\n        {\n            if (order > 0)\n                return ""+ (x*Math.pow(10,order)).toFixed(0);\n            else\n                return ""+ (x*Math.pow(10,order)).toFixed(-order+1);\n        }\n    }\n\n    if (a > b)\n    {\n        var tmp = a;\n        a = b;\n        b = tmp;\n    }\n\n    var order = Math.floor(Math.log10(b-a));\n    a = a*Math.pow(10,-order)\n    b = b*Math.pow(10,-order)\n    //console.log(b-a);    \n    var ticks = [];\n    var pos = [];\n\n    var thres = [ 8, 6,   3.2, 1.5, 0 ];\n    var fu =    [ 1, 4/3, 2,   5  , 10];\n\n    for (var j = 0; j < thres.length;j++)\n    {\n        if (b-a > thres[j])\n        {\n            var aa = (Math.floor(a*fu[j])/fu[j]);\n            var bb   = (Math.ceil(b*fu[j])/fu[j]);\n            var nsteps = ( (bb-aa) * fu[j]).toFixed(2);\n            for (var k = 0; k <= nsteps;k++)\n            {\n                var zz = Math.floor(a*fu[j]+k)/fu[j];\n                ticks.push(fix(zz,order));\n                pos.push(zz*Math.pow(10,order));\n            }\n\n//             for (var k = 0; k <= (end-start)*fu[j] ;k++)\n//             {\n//                 ticks.push(fix(Math.floor(a*fu[j]+k)/fu[j],order));\n//                 pos.push((a*fu[j]+k)/fu[j]*Math.pow(10,order));\n//             }\n            break;\n        }\n    }\n    return {ticks:ticks,position:pos};\n}\n/*\nfunction test()\n{\n    var t = [];\n    var v = [];\n    for (var k = 1; k < 10;k+=1)\n    {\n        t.push(getTicks(-k/2,k/2).length)\n    }\n    console.log(t)\n}*/\n\n\n\n\n/********************************************************\n  SBOX: box with resizable elements, see above and css.\n********************************************************/\nvar sbox = {};\nsbox.appendResizer = function appendResizer($a, callback)\n\t{\n\t\tif($a.parent().hasClass(\'sbox_vert\'))\n\t\t\tvar type = \'resizer_vert\';\n\t\telse\n\t\t\tvar type = \'resizer_horz\';\n\n\n\t\t//var $v =  $("<div class = \'"+type+"\'></div>").appendTo($a);\n\t\tvar $pc =  $("<div class = \'"+type+"_placeholder\'></div>").insertAfter($a);\n\t\tvar $v =  $("<div class = \'"+type+"\'></div>").appendTo($pc);\n\n\t\n\t\t//********************************************************\n\t\t$v.mousedown(function(ev)\n\t\t{\n\t\t\tvar $elems = $a.parent().children(\'.sbox_resizable\' );\n\t\t\t$v.addClass(\'resizer_hovered\');\n\n            var diff;\n\t\t\t//console.log($elems);\n\t\t\tvar sizes = [];\n\t\t\tvar scpos = [];\n\n\t\t\tvar wtot = 0;\n\t\t\tvar htot = 0;\n\t\t\tvar nelems = $elems.length;\n\t\t\tvar ind = 0;\n\t\t\tfor(var k=0; k<$elems.length; k++)\n\t\t\t{\n\t\t\t\tif(type == \'resizer_horz\')\n\t\t\t\t\tvar siz = $elems.eq(k).width();\n\t\t\t\telse\n\t\t\t\t\tvar siz = $elems.eq(k).height();\n\t\t\t\tsizes.push(siz);\n\t\t\t\twtot += siz;\n\n\t\t\t\tif( $a.get(0) == $elems.get(k) )\n\t\t\t\t\tind = k;\n\n\t\t\t\tvar scroll = $elems.eq(k).scrollTop();\n\t\t\t\tscpos.push( Math.min($elems[k].scrollHeight-$elems[k].clientHeight,scroll));\n\t\t\t\t\t\n\t\t\t}\n\t\t\tif(type == \'resizer_horz\')\n\t\t\t\tvar startDiff = -ev.clientX;\n\t\t\telse\n\t\t\t\tvar startDiff = -ev.clientY;\n\t\t\tif(type == \'resizer_horz\')\n\t\t\t{\n\t\t\t\tvar w1 = $elems.eq(ind).width();\n\t\t\t\tvar w2 = $elems.eq(ind+1).width();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar w1 = $elems.eq(ind).height();\n\t\t\t\tvar w2 = $elems.eq(ind+1).height();\n\t\t\t}\n\n\n\t\t    //********************************************************\n\t\t    $body.mousemove(function(ev)\n\t\t\t{\n\t\t\t\tif(type == \'resizer_horz\')\n\t\t\t\t\tdiff = startDiff + ev.clientX;\n\t\t\t\telse\n\t\t\t\t\tdiff = startDiff + ev.clientY\n\n\t\t\t\tvar wnew1 = w1 + diff;\n\t\t\t\tvar wnew2 = w2 - diff;\n\t\t\t\tif(wnew1<1 || wnew2 <1)\n\t\t\t\t\treturn;\n\n\t\t\t\tsizes[ind] = wnew1;\n\t\t\t\tsizes[ind+1] = wnew2;\n\n\t\n\t\t\t\tfor(var k=0; k<$elems.length; k++)\n\t\t\t\t{\n\t\t\t\t\tif(type == \'resizer_horz\')\n\t\t\t\t\t{\n\t\t\t\t\t\t$elems.eq(k).width( sizes[k] );\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t$elems.eq(k).height( sizes[k] );\n\t\t\t\t\t\t$($elems[k]).find(".sbox_resizable").height(sizes[k])\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tfor(var k=0; k<$elems.length; k++)\n\t\t\t\t{\n\t\t\t\t\tif(type == \'resizer_horz\')\n\t\t\t\t\t{\n\t\t\t\t\t\t$elems.eq(k).scrollTop(scpos[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(callback)\n\t\t\t\t    callback()\n\n\t\t\t});\n\n\t\t\t//********************************************************\n\t\t\t$body.on(\'mouseup mouseleave\', function(ev)\n\t\t\t{\n\t\t\t\t$(document.body).off(\'mousemove mouseup mouseleave\');\n\t\t\t\t$v.removeClass(\'resizer_hovered\');\n\n\t\t\t});\n\t\t});\n\n\t}\n\n\n\nfunction isDragFromFileTable(ev)\n{\n  for(var i=0;i<ev.dataTransfer.types.length;i++)\n      if (ev.dataTransfer.types[i] == "fromfiletable")\n      \t  return true;\n  return false;\n}\n\nfunction isDragFromBatchtool(ev)\n{\n  for(var i=0;i<ev.dataTransfer.types.length;i++)\n      if (ev.dataTransfer.types[i] == "frombatchtool")\n      \t  return true;\n  return false;\n}\n\nfunction isDragFromCacheTable(ev)\n{\n  for(var i=0;i<ev.dataTransfer.types.length;i++)\n      if (ev.dataTransfer.types[i] == "fromcachetable")\n      \t  return true;\n  return false;\n}\n\nfunction isDragFromHostSystem(ev)\n{\n  if (ev.originalEvent)\n  \tev = ev.originalEvent;\n\n  for(var i=0;i<ev.dataTransfer.types.length;i++)\n      if (ev.dataTransfer.types[i] == "Files")\n      \t  return true;\n  return false;\n}\n\nfunction isDragFromRoiTool(ev)\n{\n  for(var i=0;i<ev.dataTransfer.types.length;i++)\n      if (ev.dataTransfer.types[i] == "fromroitool")\n      \t  return true;\n  return false;\n}\n\n\n\n/***************************************************************************************\n*  global key event listener\n***************************************************************************************/\n\nfunction addKeyboardShortcuts()\n{\n    var lastmove,lastmove_sincekey\n    document.addEventListener("mousemove",function(evt) \n    {\n        lastmove = evt;\n    })\n\n    document.addEventListener("keydown",function(evt) \n    {\n\n            lastmove_sincekey = lastmove\n            if(evt.keyCode == 89 || evt.keyCode == 88 )\n            {\n                if(!evt.shiftKey && evt.target == document.body && KViewer)\n                {\n                    var mv = KViewer.findMedViewer(function(mv) { return mv.viewport.hasMouse });\n                    if (mv == undefined)\n                        mv = KViewer.findMedViewer(function(mv) { return true });\n                    if (mv == undefined)\n                    {\n                        return false;\n                    }\n                    else\n                    {\n                        mv.handleSliceChange(mv.getSlicingDimOfArray(),1,(evt.keyCode == 88)?1:-1);                        \n                    }\n                    evt.stopPropagation();\n                    evt.preventDefault();\n                    return false;   \n                }\n            }\n    });\n\n    document.addEventListener("keyup",function(evt) \n    {\n            if (evt.keyCode == 16 && lastmove == lastmove_sincekey && lastmove != undefined)\n            {\n                var $obj = $(lastmove.target)\n                for (var k = 0; k < 4; k++)\n                {\n                    if ($obj.is("td"))\n                        break;\n                    $obj = $obj.parent();\n                }\n\n                if ($obj.hasClass(\'fileCell\') | $obj.hasClass(\'studyCell\') | $obj.hasClass(\'patientCell\')) \n                {\n                    //console.log($obj)\n                    patientTableContextMenu(lastmove,true)\n                }\n            }\n\n\n    });\n\n    document.addEventListener("keyup",function(evt) \n    {\n\n      evt = evt || window.event;\n\n    // a reading is enabled, overwrite this handler\n    if(typeof KViewer.readingTool != "undefined" && KViewer.readingTool.isinstance && KViewer.readingTool.readingIsActive)\n    {\n        var res = KViewer.readingTool.handleKeyEvent(evt);\n        if(!res)\n            return false;\n    }\n\n      if (false & state.viewer.selectionMode[0] == "w")\n      {\n        if (!$(evt.target).is("input"))\n        {\n          if (evt.keyCode == 40) {\n            var nextStudy = $("tr[id="+patientTableMirror.selectedItems[0]+"]").next();\n            while (!nextStudy.hasClass("study") & nextStudy.length != 0) nextStudy = nextStudy.next();\n            if (nextStudy.length==0)\n                return;\n            patientTableMirror.tree_click({},nextStudy.attr("id"));\n          }\n          if (evt.keyCode == 38) {\n            var nextStudy = $("tr[id="+patientTableMirror.selectedItems[0]+"]").prev();\n            while (!nextStudy.hasClass("study") & nextStudy.length != 0) nextStudy = nextStudy.prev();\n            if (nextStudy.length==0)\n                return;\n            patientTableMirror.tree_click({},nextStudy.attr("id"));\n\n          }\n        }\n      }\n\n      // ESC key\n      if (evt.keyCode == 27) {\n\n          if (typeof projectInfo != "undefined" && projectInfo.rights && projectInfo.rights.batchtool == "on")\n          {\n              if (commandDialog && commandDialog.$frame && commandDialog.$frame.css("display") != "none")\n                 commandDialog.toggle();\n              if (gridjobsDialog.$frame.css("display") != "none")\n                 gridjobsDialog.toggle();\n          }\n          if ($(".patientTableContextmenu").css("display") != "none")\n             $(".patientTableContextmenu").remove();\n          if (typeof settingsDialog != "undefined" &&  settingsDialog.dialog != undefined)\n              if (settingsDialog.dialog.$frame.css("display") != "none")\n                settingsDialog.dialog.toggle();\n          if (typeof userSettingsDialog != "undefined"  && userSettingsDialog != undefined)\n              if (userSettingsDialog.$frame.css("display") != "none")\n                userSettingsDialog.toggle();\n\n      }\n\n        /***************************************************\n         key schortcuts:\n        ***************************************************/\n        if(evt.target == document.body && KViewer)\n        {\n            //console.log(evt.keyCode);\n            //numbers 1 to 9: adjust contrast (keycode 48 to 57)\n\n\t\t\tif(typeof ktagpanel != "undefined" && ktagpanel && ktagpanel.enabled)\n\t\t\t{\n\t\t\t\tif( ktagpanel.handleKeyEvent(evt) )\n\t\t\t\t\treturn \n\t\t\t}\n\n            if( evt.keyCode >= 48 && evt.keyCode < 57)\n            {\n                KViewer.iterateMedViewers(function(medviewer)\n                {\n                    if(medviewer.nii)\n                    {\n                        var p = colormap.colorlimpresets;\n                        var num = (evt.keyCode - 48);\n                        if(p[num])\n                        {\n                            medviewer.resetColorMapLims( [p[num].min, p[num].max   ]   );\n                            $("<div class=\'KViewPort_sliceOutsideRange\'>"+ p[num].title +"</div>").appendTo(medviewer.viewport.$container).fadeOut(1450, function(){$(this).remove();}); ;\n                        }\n                    }\n                });\n            }\n            // y / x: change scroll speed\n            else if(evt.shiftKey && (evt.keyCode == 89  || evt.keyCode == 88) )\n            {\n                var incr = evt.keyCode==88?1:-1;\n                KViewer.globalScrollSpeed += incr; \n                if(KViewer.globalScrollSpeed == 0)\n                {\n                    KViewer.globalScrollSpeed = 1;\n                }\n                else\n                {\n\n                }\n                var $stop = $("<div class=\'KViewPort_sliceOutsideRange\' style=\'padding:15px;\'>Scroll Speed: <b>x "+KViewer.globalScrollSpeed  +"</b></div>").appendTo($body).fadeOut(1250, function(){$(this).remove();}); ;\n\n            }\n            //************ space bar: toggle roi tool in roi mode\n            else if(evt.keyCode == 32)\n            {\n                if( KViewer.roiTool.isinstance )\n                    KViewer.roiTool.toggleCurrentROI()\n            } \n            //************ esc: disable roi drawing\n            else if(evt.keyCode == 27)\n            {\n                if( KViewer.roiTool.isinstance &&  KViewer.roiTool.getCurrentGlobal()!=undefined )\n                    KViewer.roiTool.makeCurrentGlobal( undefined );\n            } \n            //************ up / down arrow in single mode: got next case\n            else if(evt.keyCode == 38 || evt.keyCode == 40 )\n            {\n                {\n                    // a reading is enabled\n                    if(0)//typeof KViewer.readingTool != "undefined" && KViewer.readingTool.isinstance && KViewer.readingTool.readingIsActive)\n                    {\n                        KViewer.readingTool.handleKeyEvent(evt.keyCode);\n                    }\n                    //else if( state.viewer.selectionMode[0] == "w")\n                    else if(state.viewer.enableAutoloaders && typeof patientTable_gotoRow != "undefined")\n                    {\n                        var dir = evt.keyCode == 40?1:-1;\n                        patientTable_gotoRow(dir)\t\n                    }\n                    else\n                    {\n\n                    }\n                }\n            }\t\t\n            else if(evt.keyCode == 66)\n            {\n                commandDialog.toggle();\n            }\t\n            else if(evt.keyCode == 83)\n            {\n                settingsDialog.dialog.toggle();\n            }\t\n\n        }\n\n\n    });\n\n\n}\n\n\nfunction waiter(condition,callback,delta,maxtimes)\n{\n    var t = 0;\n    iterate();\n    function iterate()\n    {\n        setTimeout(function() { \n            if (condition())\n                callback()\n            else \n            {\n                t++;\n                if (t>maxtimes)\n                    callback()\n                else\n                    iterate();\n            }\n        },delta);\n    }\n}\n\n\n\nnavigationElementsVisible = true;\nfunction hideNavigationElements()\n{\n\tnavigationElementsVisible = false;\n    $("#patientTableTopTools").hide()\n\t$("#patientTableToolsWrench").hide()\n\t$(".KSearchFields").hide()\n\t$(".KSearchFieldContainer").hide()\n\t$(".Kcaretmenu").hide()\n\t$("#patientTableEditMode").show();\t\n\t$(".patientTable_timeMarker").hide();\n\t$("#patientTableEditModeTextFirst").hide();\n\t$("#patientTableEditMode").hide();\n\t$("#topMenu").remove();\n\t$("#frame").css(\'padding\',\'0px 0px 0px 0px\');\n\n\tKViewer.setViewPortLayout()\n\tsetPatientTableLayout();\n\n}\n\ntoolBarLeftVisible = true;\nfunction hideAllElements()\n{\n\ttoolBarLeftVisible = false;\n\tKViewer.toggleLeftBar() \n\t$("#topMenu").remove();\n\t$("#KView_toolBarLeft").remove();\n\t$("#frame").css(\'padding\',\'0px 0px 0px 0px\');\n\n\tKViewer.setViewPortLayout()\n\tsetPatientTableLayout();\n\n    \n}\n\n\n\n\n\nfunction dryimport_Patient(StudyInstanceUID,whendone)\n{\n     var request = { command:"PACSQuery_dryimport_full_study"  , dryimport:true, StudyInstanceUID:StudyInstanceUID, pacsid:"UKLFR", targetproject:currentModule}\n \t var scripturl  = window.location.href.substr(0, window.location.href.lastIndexOf(\'/\')) + \'/pacsquery.php\';\n     var xhr = ajaxRequest(\'command=PACSQuery_dryimport_full_study&json=\' + encodeURIComponent(JSON.stringify(request))\n        , whendone,  scripturl);\t\t\t\n}\n\n\n\n\n\nfunction executeExternalCall()\n{\n    // if (extern_call.suid == undefined)\n    //    logout();\n         if (extern_call.piz)\n         {\n             openPatient({PatientID:extern_call.piz,SID:""});\n         }\n         else if (extern_call.suid)\n         {\n             var StudyInstanceUID = extern_call.suid;\n             SIUID_call(StudyInstanceUID,openPatient);\n         }\n         else if (extern_call.dcmweb)\n         {\n             loadDICOMwebURL(extern_call.dcmweb)\n             $("#KLoadingFrame").css(\'display\',\'none\')\n         }\n         else\n         {\n             $("#KLoadingFrame").css(\'display\',\'none\')\n         }\n\n\n\n         function SIUID_call(siuid,whendone)\n         {\n\n\n             dryimport_Patient(StudyInstanceUID,function(result)\n             {\n                if (result.log && result.log.err && result.log.err.length > 0)\n                {\n                    alertify.error(result.log.err[0]);\n\n                    return;\n                }\n                if (result.json == undefined)\n                {\n                    alertify.error("no matching reponse for given SUID");           \n                    return;\n                }\n\n                var patinfo = result.json[StudyInstanceUID];\n                if (patinfo == undefined)\n                {\n                    alertify.error("no matching entry for given SUID");           \n                    return;\n                }\n\n                whendone(patinfo)\n             });\n\n         }\n\n\n\n\n         function openPatient(patinfo)\n         {\n                presetManager.applyPresetByName("preset(0)")\n              \n                patientTable_jumpToRow( patinfo.PatientID + patinfo.SID,currentModule ,function()\n                {\n   \n                    waiter(function() {return KViewer.formManager.loadedFromServer},function()\n                    {\n\n\n                        if (all_patients.length == 0)\n                        {\n                            alertify.error("patient not found")\n                            return;\n                        }\n                    \n                      \n                        var autoloader = [{enabled: true, viewportID: 0, \n                                           pattern: "FFilename:recent.jsonFSubFolder:workstates", intent:{}\n                                           } ];\n                        startAutoloader(autoloader, {piz:patinfo.PatientID , sid: patinfo.SID} , undefined, function() {\n                            if (extern_call.hide_nav)\n                            {\n                                hideNavigationElements();\n                                $(".studyRow,.patientRow").css("pointer-events",\'none\');\n                            }\n                            if (extern_call.hide_all)\n                            {\n                               hideAllElements();\n                            }\n                            $("#KLoadingFrame").css(\'display\',\'none\')\n                        });\n                        \n\n                    },50,10);\n\n                });\n         }\n\n\n \n\n\n\n\n\n}\n\n\n\nfunction KProgressBar(txt,fa,onclose,noprogressinformation)\n{\n    var progressBar = {};\n\n    var closebutton = "";\n    if (onclose != undefined)\n        closebutton = "<i class=\'fa fa-close\'>";\n\n    progressBar.$div = $("<div class=\'KSyncBar\'> <i class=\'fa "+fa+" fa-spin\'> </i> <i class=\'fafa-spin\'> </i> " \n                       + " <div class=\'spinnerbar\'> <div class=\'innerbar\'>  </div>  </div> " \n                       + "<span class = \'uploadtext\'> "+txt+" </span> "+closebutton+" </div>").appendTo($(document.body));\n    progressBar.$div.show(); //fadeIn(1000);\n//\t\t\t\t\t\t\t\t  var $download = $div.find(".fa-download");\n//\t\t\t\t\t\t\t\t  var $upload = $div.find(".fa-upload").hide();\n    progressBar.$bar = progressBar.$div.find(".innerbar").width(0);\n    progressBar.$text = progressBar.$div.find(".uploadtext");\n\n\n    progressBar.$div.find(".fa-close").click(function() {\t\n                if (onclose)\n                    onclose();\n\t\t\t\tsetTimeout(function() {\n\t\t\t\t\tprogressBar.done("aborted");\n\t\t\t\t},10)})\n\n\tprogressBar.progress = function(perc,text)\n\t{\n\t    \tprogressBar.$bar.width(perc + "%");\t\t\t\n\t\t\tprogressBar.$text.text(text);\n\t\t\t\t\n\t}\n\tprogressBar.done = function(text)\n\t{\n\t    \tprogressBar.$bar.width("100%");\t\t\t\n\t\t\tprogressBar.$text.text(text);\n\t\t\tprogressBar.$div.fadeOut(1500,progressBar.$div.remove);\n\t\t\tif (progressBar.blinker) \n\t\t\t clearInterval(  progressBar.blinker);\n\t\t\t\t\n\t}\n    \n    if (noprogressinformation)\n    {\n        progressBar.blinker_state = 0;\n        progressBar.blinker = setInterval(function() {\n            progressBar.blinker_state += 2;\n            progressBar.blinker_state = progressBar.blinker_state % 100;\n            progressBar.$bar.width(progressBar.blinker_state+"%");\t\t\t\n        },50);\n    }\n\n\n\n\n    return progressBar;\n}\n\n\n\n\n/// elementary ///////////////////////////////////\n\nfunction union(a,b)\n{\n\tvar r = {};\n\tfor (var k in a)\n\t\tr[k] = true;\n\tfor (var k in b)\n\t\tr[k] = true;\n\treturn r;\n}\n\n\nfunction union_array(A)\n{\n\tvar res = {}\n\tfor (var k = 0;k <A.length;k++)\n\t\tfor (var j in A[k])\n\t\t\tres[j] = true;\n\treturn res;\t\t\t\n}\n\n\nfunction intersect(A,B)\n{\n\t var C = {};\n\tfor (var x in A)\n\t{\n\tif (B[x])\n\t\tC[x] = true;\n\t}\n\treturn C;\n}\n\nfunction diff(A,B)\n{\n\tvar C = {};\n\tfor (var x in A)\n\t{\n\t  if (B[x] == undefined)\n\t\tC[x] = true;\n\t}\n\treturn C;\n}\n\nfunction intersect_array(A)\n{\n\tvar res = {}\n\tfor (var j in A[0])\n\t{\n\t\tvar isin = true;\n\t\tfor (var k = 1;k <A.length;k++)\n\t\t{\n\t\t\tif (A[k][j])\n\t\t\t\tcontinue;\n\t\t\telse\n\t\t\t{\n\t\t\t\tisin = false;\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t\tif (isin)\n\t\t\tres[j] = true;\n\t}\n\treturn res;\n\n}\n\nfunction array_to_setObject(A)\n{\n    var x = {}\n    for (var k in A)\n        x[A[k]] = true;\n    return x;\n}\n\n\nfunction transpose_array(arr)\n{\n    var res = [];\n    for (var k = 0; k<arr[0].length;k++)\n        res[k] = [];\n    for (var k = 0; k<arr.length;k++)\n    {\n        for (var j = 0 ; j < arr[k].length;j++)\n        {\n            res[j][k] = arr[k][j];\n        }\n    }\n    return res;\n}\n\n\nfunction KCalcPanel(calcset,inputfiles,pinfo)\n{\n\n    \n\n\n\n    var panel = KPanel($(document.body), "CalcPanel", "Application panel");\n \n    panel.$container.width(400)\n    panel.closeOnCloseAll = true\n    var $fileRow = $("<div class=\'roiTool_panel_flex_persistent\'></div>").appendTo(panel.$container);\n\n\n    var buts = $("<div class=\'modernbuttongroup\'></div>").appendTo(panel.$container);\n   \n    var $recalc = $("<div class=\'modernbutton small green\'><i class=\'fa fa-refresh\'></i> Calculate</div>").appendTo(buts)\n    var $save = $("<div class=\'modernbutton small green\'><i class=\'fa fa-save\'></i>Save all </div>").appendTo(buts)\n        \n\n\n    var stats = KViewer.roiTool.computeStats;\n\n    try\n    {\n      eval(calcset.code);\n    }\n    catch(err)\n    {\n        alertify.error("problem in calcpanel code: "+ err.message)\n    }\n\n    $("<div class=\'roiTool_panel_caption\'></div>").appendTo(panel.$container);\n    var $div = $("<div class=\'some\'></div>").appendTo(panel.$container);\n\n\n\n     var inputform = \n       { \n        name \t\t: "calcform",\n        lastchange  : "",\n        layout: layout\n        \n       }    \n\n    var content = {}\n    KForm.createForm(inputform, content, $div, function(e) { });\n\n    for (var k in inputfiles)\n    {\n        if (inputfiles[k] != undefined && inputfiles[k].drawAllPoints != undefined)\n        {\n            var mset = inputfiles[k];\n            var msetpanel = mset.showPanel();\n            var $mtable = msetpanel.$container.find(".markerTable")\n            var $mtpm = msetpanel.$container.find(".markerTemplates")\n            msetpanel.$container.detach();\n            $mtpm.appendTo(panel.$container)\n            $mtable.appendTo(panel.$container)\n            //msetpanel.$container.attr(\'class\',\'\')\n        }\n    }\n\n\n    $save.click(function()\n    {\n       uploadJSON.askonOverwrite =false\n       KViewer.roiTool.saveAllROIs();\n       var objs = {};\n       for (var k in inputfiles)\n       {\n            if (inputfiles[k].getPointsByName != undefined)\n            {\n                markerProxy.save(undefined,inputfiles[k]);\n      \n            }\n       }\n       uploadJSON.askonOverwrite =true\n    \n\n\n        if (panel.upstr != undefined)\n        {\n            ajaxRequest(\'command=createfile&json=\' + panel.upstr , function(x)\n              {return function(e) {\n                  patientTableMirror.mirrorState();\n                  alertify.success("json successfully saved")\n              } }());\n        }\n\n\n\n\n    })\n\n\n\n    function doTheCalculation()\n    {\n\n\n       if (panel.$container.css(\'display\') == "none")\n       {\n              clearInterval(panel.calc_cid);\n              return;\n       }\n\n       // gather all the object needed for doing the calculations \n       var objs = {};\n       for (var k in inputfiles)\n       {\n           if (inputfiles[k] != undefined)\n           {\n            if (inputfiles[k].getPointsByName != undefined)\n              objs[k] = inputfiles[k].getPointsByName();\n            else\n            {\n              objs[k] = inputfiles[k].content\n            }\n           }\n       }\n\n\n       try {\n\n\n\n            // this evalates the custom code defined in the pane\n            // set here a breakpoint for development\n            eval(calcset.code);           \n\n\n\n            // this does the actual execution of the exec function;\n            var obj = exec(objs,pinfo);\n            if (obj != undefined)\n            {\n                content.result = obj.text;\n                content.update();\n                \n                // this compses a json, which can be saved via "save ALL"\n                if (obj.json)\n                {\n                \tvar tmp = patientTableMirror.getCurrentUniquePSID();\n\t                var up = {piz:tmp.patients_id,sid:tmp.studies_id};\n                    up.content = JSON.stringify(obj.json);\n                    up.filename = obj.filename;\n                    up.subfolder = "";\n                    if (obj.subfolder != undefined)\n                        up.subfolder = obj.subfolder;\n\n                    panel.upstr = JSON.stringify(up);\n\n\n                }\n\n                panel.lasterr = "";\n            }\n\n\n       } catch(err)\n       {\n\n          if (panel.lasterr != err.message)         \n            alertify.error("problem in calcpanel exec function code: " +err.message)\n          panel.lasterr = err.message;\n\n       }\n       content.update("result");\n    }\n\n\n\n\n    panel.customClose = function()\n    {\n       clearInterval(panel.calc_cid);\n    }\n\n\n    $recalc.click(function() {  panel.lasterr= ""; doTheCalculation() });\n\n    doTheCalculation();\n\n    panel.calc_cid = setInterval(doTheCalculation,2500);\n\n\n\n\n\n}\n\n\n\n/***************************************************************************************\ngeneric box for a json / text editor\n****************************************************************************************/\n//we need the struct, field syntax to keep a true pointer\nfunction KJSONEditor(struct, field,  options_in)\n{\n\tvar jsoneditor = new Object();\n\n\tvar options = \n\t{\n\t\tparseonblur:true,\n\t\tlog: true,\n\t\teditable: 1,\n\t\tcopybutton:0,\n\t\ttype: "json"  // can be json or jscode\n\t}\n\t$.extend(true, options, options_in);\n\n\tvar $container = $("<div class=\'KJSONEditor\'></div>")\n\t//var $codeCheck = $("<div class=\'modernbutton small green\' style=\'position:absolute;top:0;right:0\'><i class=\'fa fa-check\'></i>validate code</div>").click(function(){jsoneditor.JSONparse()}).appendTo($container);\n\n\tjsoneditor.$textarea = $("<textarea autocorrect=\'off\' autocapitalize=\'off\' spellcheck=\'false\'>{a:1}</textarea>").appendTo($container);\n\t\n\tif(!options.editable)\n\t\tjsoneditor.$textarea.attr(\'readonly\', "true")\n\n\tjsoneditor.$log = $("<div class=\'KJSONEditor_log\'></div>").appendTo($container);\n\t//jsoneditor.$applybtn = $("<div class=\'modernbutton green\'>Apply</div>").appendTo($container);\n\n\n\tjsoneditor.$log = $("<div class=\'KJSONEditor_log\'></div>").appendTo($container);\n\n\tif(options.copybutton)\n\t{\n\t\tvar $copy= $("<div class=\'modernbutton small gray\' style=\'position:absolute;top:0;right:10px\'><i class=\'fa fa-copy\'></i>copy top clipboard</div>")\n\t\t\t.appendTo($container).click( function(){jsoneditor.copyText()} );\n\t}\n\n\n\tjsoneditor.copyText = function()\n\t{\n\t\tvar ta = jsoneditor.$textarea.get(0);\n\t\tjsoneditor.$textarea.focus();\n\t\tta.selectionStart = 0;\n\t\tta.selectionEnd = jsoneditor.$textarea.val().length; \n\t\tvar successful = document.execCommand(\'copy\');\n\t\tta.selectionEnd = 0;\n\t\tif(successful)\n  \t    \t$.notify(" Copied to clipboard","success");\n\n\t}\n\n\n\tjsoneditor.pasteText = function(content, selectCopied)\n\t{\n\t\tvar $ta = jsoneditor.$textarea;\n\t\tta = $ta.get(0);\n\t\t$ta.val($ta.val());\n\t\tvar s = ta.selectionEnd || $ta.val().length;\n\t\t//console.log(s);\n\t\t$ta.val($ta.val().substr(0, s) + "" + content + "" + $ta.val().substr(s+1));\n\t\tif(selectCopied)\n\t\t{\n\t\t\tta.selectionStart = s;\n\t\t\tta.selectionEnd = s + content.length;\n\t\t}\n\t\t$ta.focus();\n\t}\n\t\n\tjsoneditor.JSONstringify = function()\n\t{\n\t\tif(options.type !== "jscode")\n\t\t\tvar str = myJSONStringify(struct[field], "", 0);\n\t\telse\n\t\t\tvar str = struct[field];\n\t\t\t\n\t\tjsoneditor.$textarea.val(str);\n\t\treturn str;\n\t}\n\n\tjsoneditor.JSONparse = function(forceEval)\n\t{\n\t  jsoneditor.$log.html("");\n\t  var ret = false;\n\t  try\n\t  { \n\t  \t   // keep comments and linebreaks: to be implemented\n// \t  \t   var txt = jsoneditor.$textarea.val();\n// \t\t\tvar pos = txt.indexOf("//");\n// \t\t\tvar lastline;\n// \t\t\twhile(pos > -1) \n// \t\t\t{\n// \t\t\t\t pos = txt.indexOf("//", pos+1);\n// \t\t\t}\n\t\t\tvar text = jsoneditor.$textarea.val() ;\n\t\t\t// JSON in javascript has the convention that all \\ must be escaped, otherwise they will be removed in eval\n\t\t\t// However, we want to be able to write "lazy" in the code, so escape \\ here manually.\n\t\t\t//text = text.replace(/\\\\/g , "\\\\\\\\");\n\t\t\t// but only single bslahes (not followed by another \\) and NOT \\" (this is an escape seq)\n\t\t\ttext = text.replace(/(\\\\)(?=[^\\\\"])/g , "\\\\\\\\");\n\t\t\t// escaped doble quotes \\" in json need some special treatment ...?\n\t\t\t// text = text.replace(/\\\\"/g , \'\\\\\\\\"\');\n\t\t\tif(options.type !== "jscode")\n\t\t\t{\n\t\t\t\tif( struct[field] instanceof Array)\n\t\t\t\t\ttext = "[" + text + "]";\n\t\t\t\telse //if( struct[field] instanceof Object)\n\t\t\t\t\ttext = "{" + text + "}";\n\n\t\t\t\teval(\'var parsed  = \' + text );\n\t\t\t\tstruct[field] = parsed;\n\t\t\t\tjsoneditor.JSONstringify();\n\t\t\t}\n\t\t\t// this will run the code directly. Difference is, that code is not an object or array, but does return\n\t\t\telse\n\t\t\t{\n\t\t\t\tstruct[field] = text;\n\t\t\t\tif(forceEval)\n\t\t\t\t\teval(text);\n\t\t\t}\n\t\t\tjsoneditor.$log.html("Code seems to be correct").css(\'color\',\'green\');\n\t\t\tret = true;\n\t  }\n\t  catch(err)\n\t  {\n\t\t  jsoneditor.$log.html("Error: " + err).css(\'color\',\'red\');\n\t\t  //jsoneditor.JSONstringify();\n\t  }\n\t  return ret;\n\t}\n\t\n\tjsoneditor.getJSONtxt = function()\n\t{\n\t\treturn jsoneditor.$textarea.val();\n\t}\n\n\t// enable tab stops in textarea\n\tjsoneditor.$textarea.on("keydown", function(e)\n\t{\n        if(e.keyCode==9 || e.which==9){\n            e.preventDefault();\n             \tvar s = this.selectionStart;\n            \tthis.value = this.value.substring(0,this.selectionStart) + "\\t" + this.value.substring(this.selectionEnd);\n            \tthis.selectionEnd = s+1; \n            }\n\n    });\n\n\n\tjsoneditor.JSONstringify();\n\n\tif(options.parseonblur)\n\t\tjsoneditor.$textarea.on("blur", function(){jsoneditor.JSONparse()} );\n\n\tjsoneditor.$container = $container; \n\treturn jsoneditor;\n}\n\n\n\nfunction loadDICOMwebURL(urlstr)\n{\n// small\n//https://server.dcmjs.org/dcm4chee-arc/aets/DCM4CHEE/rs/studies/1.2.840.113619.2.66.2158408118.16050010109105933.20000\n//https://server.dcmjs.org/dcm4chee-arc/aets/DCM4CHEE/rs/studies/1.3.6.1.4.1.25403.345050719074.3824.20170125112931.11/series/1.3.6.1.4.1.25403.345050719074.3824.20170125112931.16\n//https://server.dcmjs.org/dcm4chee-arc/aets/DCM4CHEE/rs/studies/1.2.392.200140.2.1.1.1.2.799008771.2448.1519719572.518\n\n\n   // client.searchForStudies().then(studies => {\n      //console.log(studies)\n   // });\n  //  client.searchForSeries().then(studies => {\n  //    console.log(studies)\n //    });\n\n    try {\n\n        var x = urlstr.split("/studies/");\n        var url = x[0];\n        x = x[1].split("/series/");\n        var serUID = x[1];\n        var stuUID = x[0];\n    }\n    catch(err)\n    {\n        alertify.error("wrong dicomweb url format");\n        return;\n    }\n\n    const client = new DICOMwebClient.api.DICOMwebClient({url});\n    var retrieve;\n    var progress = function(w)  {   KViewer.cacheManager.progressSpinner("dicomweb: "  + Math.round(w.loaded/1000000) + " MB loaded")   }\n\n    var receive = function (studies) {              \n      var params = []\n\n      TheDicomReader = new DicomReader();\n      for (var k = 0;k < studies.length;k++)\n      {\n          var p = {}\n          p.URLType = \'localfile\';\n          p.fileID = "lklk"\n          p.filename = "lklk"\n          p.buffer = new Uint8Array(studies[k]);\n          p.progressSpinner = KViewer.cacheManager.progressSpinner\n          params.push(p);\n      }\n      TheDicomReader.loadDicoms(params,\n                function (loadparams)\n                {\n                    for (var k = 0; k < loadparams.length;k++)\n                    {\n                            if (loadparams[k].buffer != undefined)\n                                KViewer.dataManager.loadData(loadparams[k]);\n                    }\n\n                    KViewer.cacheManager.update();\n\n                },KViewer.cacheManager.progressSpinner);\n\n   }\n\n\n    function onerr(e)\n    {\n        alertify.error("problem during dicom receive: " + e);\n    }\n\n\n    if (serUID == undefined)\n        client.retrieveStudy({studyInstanceUID: stuUID, progressCallback: progress }).then(receive).catch(onerr)\n    else\n        client.retrieveSeries({studyInstanceUID: stuUID, seriesInstanceUID:serUID, progressCallback: progress }).then(receive).catch(onerr)\n\n\n\n}\n\n\n\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= TagPanel\n// ======================================================================================\n// ======================================================================================\nKTagPanel = function()\n{\n\tvar that = new Object();\n\t/* major functions of use:\n\t\t- add tags to patient,study files\n\t\t- hold some custom tags per project\n\t\t\tcopy from all possible, trash can do delete, edit with form\n\t\t- hold full list of possible tags (from database)\n\t\t- in single/autoload mode, \n\t\t\tshow tags of selected item\n\t\t\tallow to toggle tag with one click on tag\n\n\t\t- drag and drop: can dragdrop tag to table or viewer, or can dragdrop item to tag (maybe less nice)\n\t\t\t=> good option for tagging files\n\t\t\n\t\t- keyboard shortcuts: tag with numbers or similar\n\t\t\thow to distinguish patient/files?\n\n\t\t- options for\t\n\t\t\tshortcuts enabled/disabled\n\t\t\tpatient/study/file tag mode (better without, make dependent )\n\t\t\tsizes ( for drag/drop )\n\n\t\t-what to do when item has tags not not in customList\n\t\t\t=> must expand / keep 2 lists\n\t\t- re-render on every selection\t\n\n\t*/\n\tthat.enabled = true;\n\n\n\t/******************************************************************\n\t* build the tool\n\t*******************************************************************/\n\tif(ktagpanel != undefined)\n\t{\n\t\tktagpanel.show();\n\t\treturn;\n\t}\n\tktagpanel = that;\n\tvar $container = $("<div id=\'KTagPanel"+"\' class=\'markerPanel movableWindows\' style=\'width:auto; min-width:150px;\'></div>").appendTo($(document.body));\n\n\n\tvar pp = getPixelPosition($(document.body));\n\t//$container.position({left:"10px", top:"450px"})\n \t$container.css("left", "10px")\n \t$container.css("top", "210px"  );\n\n\t\n\t/******************************************************************\n\t  customize --\x3e these values actually come from the markerset!!\n\t*******************************************************************/\n\tthat.state = \n\t{\n\t\tvisible:true,\n\t\ttaglist:\n\t\t{\n\t\t\tptags:{ptest: 1},\n\t\t\tstags:{stest:1},\n\t\t\tftags:{ftest:1},\n\t\t}\n\t}\n\t\n\t// save the taglist in state\n\tif(state.tagpanel != undefined)\n\t{\n\t\tthat.state = state.tagpanel;\n\t}\n\telse\n\t{\n\t\tstate.tagpanel = that.state;\n\t}\n\t\n\t/******************************************************************\n\t* close\n\t*******************************************************************/\n\tthat.close = function()\n\t{\n\t\t$container.hide();\n\t\tthat.enabled = false;\n\t}\n\n\t\n\t/******************************************************************\n\t* close\n\t*******************************************************************/\n\tthat.show = function()\n\t{\n\t\t$container.show();\n\t\tthat.enabled = true;\n\t\trenderTagList();\n\t}\n\n\n\n\t/******************************************************************************\n\t  tools\n\t*******************************************************************************/\n\tvar $topRow  = that.$topRow = $("<div class=\'roiTool_panel_flex persistent\' style=\'background: hsl(206, 64%, 37%); padding:2px;\' ></div>").appendTo($container);\n\tvar $caption = $("<span> <b> TagPanel </b></span>");\n\tvar $close = that.$close = $("<i class=\'KViewPort_tool fa fa-close\'></i>").click( that.close );\n\t$topRow.append($caption).append($("<i class=\'flexspacer\'></i>")).append($close);\n\t$topRow.mousedown( function(ev) { movableWindowMousedownFn(ev, $container) } );\n\n\n\t/******************************************************************************\n\t  toggle a stat var\n\t*******************************************************************************/\n\tfunction switch_enabled(prop, force, invert)\n\t{\n\t\tthat.state[prop] = typeof(force)!=="boolean"?(that.state[prop]?false:true):force;\n\t\tbtns["$"+prop][that.state[prop]?"addClass":"removeClass"](\'KViewPort_tool_enabled\');\n\t\treturn that.state[prop];\n\t}\n\t\n\n\t/******************************************************************************\n\t build tag colums for patients studies files\n\t*******************************************************************************/\n\t$("<div class=\'roiTool_panel_caption\'></div>").appendTo($container);\n\tvar $tagRow    = $("<div class=\'roiTool_panel_flex\'></div>").appendTo($container);\n\t\n\tvar $tagcontainer = $("<div class=\'KTagPanel_tagcontainer\'></div>").appendTo($container);\n\n\tvar $ptags = $("<div class=\'\'></div>").appendTo($tagcontainer);\n\tvar $stags = $("<div class=\'\'></div>").appendTo($tagcontainer);\n\tvar $ftags = $("<div class=\'\'></div>").appendTo($tagcontainer);\n\n\n\n\tvar tagmap = [];\n\tvar currentrow_tags;\n\n\tvar tcols = {};\n\tvar tagtypes = [\'ptags\',\'stags\',\'ftags\'];\n\n\ttcols.ptags = buildCol(\'PTags\');\n\ttcols.stags = buildCol(\'STags\');\n\ttcols.ftags = buildCol(\'FTags\');\n\n\trenderTagList(\'ftags\')\n\trenderTagList()\n\n\tfunction buildCol(tagtype)\n\t{\n\t\tvar tcol = {};\n\t\ttcol.$div = $("<div class=\'KTagPanel_taglistdiv\'></div>").appendTo($tagcontainer);\n\t\ttcol.$top = $("<div class=\'KTagPanel_taglisttitle\'><span>"+ tagtype +"</span></div>").appendTo(tcol.$div);\n\t\t\t$("<i class=\'fa fa-pencil\'></i>").appendTo(tcol.$top).click(function(){ editTags(tagtype.toLowerCase())});\n\t\ttcol.$tags = $("<div class=\'KTagPanel_taglist\'>"+ "content" +"</div>").appendTo(tcol.$div);\n\t\treturn tcol;\n\t}\n\n\t/******************************************************************************\n\t render taglists for current selection\n\t*******************************************************************************/\n\tfunction editTags(tagtype)\n\t{\n\t\tvar $div = $("<div class=\'KTagPanel_editbox\'></div>").appendTo(tcols[tagtype].$top);\n\t\tvar $dummy = $("<div class=\'\'></div>").appendTo($div);\n\n\t\tvar $textarea  = $("<textarea>" + Object.getOwnPropertyNames(that.state.taglist[tagtype]).join("\\n") +"</textarea>").appendTo($dummy);\n\t\tvar $textarea_alltags  = $("<textarea style=\'background:hsl(0,0%,60%)\'>" + Object.getOwnPropertyNames(taglist[tagtype]).join("\\n") +"</textarea>").appendTo($dummy);\n\t\t\n\n\t\tvar $tools = $("<div></div>").appendTo($div);\n\t\t$("<div class=\'modernbutton small blue\'>ok</div>").appendTo($tools).click(function(){\n\t\t\tvar tobj = {};\n\t\t\tvar tlist = $textarea.val().split("\\n"); for(var k=0; k<tlist.length; k++){var key =tlist[k].trim(); if(key!="")tobj[key] = 1; }\n\t\t\tthat.state.taglist[tagtype] = tobj;\n\t\t\trenderTagList(tagtype)\n\t\t\t$div.remove()\n\t\t});\n\t\t$("<div class=\'modernbutton small red\'>cancel</div>").appendTo($tools).click(function(){$div.remove()});;\n\t\t$textarea.focus();\n\t\t//$textarea.get(0).onpaste = function(ev){pastecontent(ev, whichtable)}\n\t\t\n\n\t}\n\t/******************************************************************************\n\t render taglists for current selection\n\t*******************************************************************************/\n\tfunction renderTagList(tagtype)\n\t{\n\t\tif(tagtype==undefined)\n\t\t{\n\t\t\tif(state.viewer.selectionMode[1] == \'s\')\n\t\t\t{\n\t\t\t\ttcols.stags.$div.show();\n\t\t\t\ttcols.ptags.$div.hide();\n\t\t\t\ttagtype = \'stags\';\n\t\t\t}\n\t\t\telse if(state.viewer.selectionMode[1] == \'p\')\n\t\t\t{\n\t\t\t\ttcols.ptags.$div.show();\n\t\t\t\ttcols.stags.$div.hide();\n\t\t\t\ttagtype = \'ptags\';\n\t\t\t}\n\t\t}\n\n\n\t\tvar $target = tcols[tagtype].$tags;\n\t\tvar xtaglist = that.state.taglist[tagtype];\n\t\t/******************************************************************************\n\t\t  synchronize with current tags from patient / study\n\t\t*******************************************************************************/\n\t\tvar psid = patientTableMirror.getCurrentUniquePSID();\n\t\t// get the list of tags, must \n\t\tvar tagmap_ = []\n\t\tcurrentrow_tags = {};\n\t\tvar ctaglist = {};\n\t\tif(tagtype != \'ftags\')\n\t\t{\n\t\t\tif(psid != undefined)\n\t\t\t{\n\t\t\t\tvar rowid = psid.patients_id ;  \n\t\t\t\tif(state.viewer.selectionMode[1] == \'s\')\n\t\t\t\t\trowid += riddelim + (psid.studies_id==undefined?"":psid.studies_id);\n\t\t\t\tvar $row = $("tr[id=\'" + rowid + "\']");\n\t\t\t\tvar $settags =  $row.find(\'.KTagPatient\')//.join( $row.find(\'.KTagStudy\'));\n\t\t\t\tfor(var z=0; z<$settags.length; z++)\n\t\t\t\t{\n\t\t\t\t\tvar ctag =  $settags.eq(z).text();\n\t\t\t\t\tcurrentrow_tags[ctag] = 1;\n\t\t\t\t\tctaglist[ctag] = 1;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t$target.empty();\n\t\tfunction appendTag(item, count)\n\t\t{\n\t\t\tvar $tcont = $("<div class=\'KTagPanel_tagitem KTagPanel_tagitem_disabled\' data-tag=\'"+item+"\'>" + "" + "</div>").appendTo($target); \n\t\t\tif(count!=undefined && tagtype != \'ftags\')\n\t\t\t\t$("<div class=\'KTagPanel_tagitem_shortcut\'>"+(count++)+"</div>").appendTo($tcont);\n\n\t\t\tvar $dummy = $("<div class=\'KTagPatient \' draggable=true>" + item + "</div>").appendTo($tcont)\n\t\t\tif(tagtype!=\'ftags\')\n\t\t\t\t$dummy.click(function(){that.modifyTag_internal(item)});\n\t\t\t$("<i class=\'fa fa-check\' style=\'display:none\'></i>").appendTo($tcont);\n\t\t\treturn $tcont;\n\t\t}\n\n\n\t\tvar count = 0;\n\t\tfor(var k in xtaglist)\n\t\t{\n\t\t\ttagmap_[count] = k;\n\t\t\tvar $tag = appendTag(k, count++);\n\n\t\t\tif( ctaglist[k] != undefined )\n\t\t\t{\n\t\t\t\t$tag.removeClass(\'KTagPanel_tagitem_disabled\').find(\'i\').show();\n\t\t\t\tdelete ctaglist[k]\n\t\t\t}\n\n\t\t\t$tag.on("dragstart", dragstarter( function(x,name)\n\t\t\t\t\t{ \n\t\t\t\t\t\treturn function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\t\ttype: \'tagpaneltag\',\n\t\t\t\t\t\t\t\tcallback: dropCallback,\n\t\t\t\t\t\t\t\tobj:x,\n\t\t\t\t\t\t\t\ttag: x\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}(k), k) );\n\t\t}\n\n\t\t// render all other tags from current selection\n\t\tfor(var k in ctaglist)\n\t\t{\n\t\t\ttagmap_[count] = k;\n\t\t\tvar $tag = appendTag(k, count++)\n\t\t\t$tag.removeClass(\'KTagPanel_tagitem_disabled\').find(\'i\').show();\n\t\t}\n\t\t\n\t\tif(tagtype != \'ftags\')\n\t\t\ttagmap = tagmap_\n\n\t}\n\tthat.update = renderTagList;\n\n\t/******************************************************************************\n\t handleDrop\n\t*******************************************************************************/\n\tfunction dropCallback(ev, params, ttt)\n\t{\n\t\tif(ttt && ttt.getCurrentViewer() && ttt.getCurrentViewer().currentFileID)\n\t\t{\n\t\t\ttobj = {tag:params.tag,objs:[]};\n\t\t\ttobj.objs.push(ttt.getCurrentViewer().currentFileID);\n\t\t\tvar str = "tag_files";\n\t\t\tvar $filerow = $(\'.fileRow[data-fileid="\' + ttt.getCurrentViewer().currentFileID + \'"]\');\n\n\t\t\t/* allow to remove on drop? makes no sense\n\t\t\tvar filetags = $filerow.find(\'.KTagFile\');\n\t\t\tfor(var k=0; k<filetags.length; k++)\n\t\t\t{\n\t\t\t\tif( filetags.eq(k).text() == params.tag)\n\t\t\t\t\tstr = "tag_files_del";\n\t\t\t}\n\t\t\t*/\n\t\t\tvar jsonString = JSON.stringify(tobj);\n\t\t\tajaxRequest(\'command=\'+str+\'&json=\' + jsonString , function(e)\n\t\t\t{ \n\t\t\t\tpatientTableMirror.mirrorState(); \n\t\t\t\t/*\n\t\t\t\tvar $blinker = $("<div class=\'KReading_ItemBlinker\'>tag added</div>").appendTo(document.body);\n\t\t\t\t$blinker.css(\'border-color\', \'red\');\n\t\t\t\tif(!$filerow.is(\':visible\'))\n\t\t\t\t{\n\t\t\t\t\t$filerow.show();\n\t\t\t\t\tvar pp = $filerow.find(\'.imgTag\').offset();\n\t\t\t\t\t$filerow.hide();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tvar pp = $filerow.find(\'.imgTag\').offset();\n\t\t\t\t//var pp = {top: ev.clientY, left:ev.clientX};\n\t\t\t\t$blinker.offset( $blinker.css({\'top\': pp.top , \'left\': pp.left }) );\n\t\t\t\t$blinker.animate({width: 100, height: 100, opacity:0.2}, 500, function(){$blinker.remove()} )\n\t\t\t\t*/\n\t\t\t\t$.notify($filerow.attr(\'data-subfolder\') +"/"+ $filerow.attr(\'data-filename\') + " tagged with \'" + tobj.tag + "\'", "success");\n\t\t\t});\t\t\t\n\t\t}\n\t\ttempObjectInfo = undefined;\n\t}\n\n\n\t/******************************************************************************\n\t handleKeyEvent\n\t*******************************************************************************/\n\tthat.modifyTag_internal = function(ttag)\n\t{\n\t\tvar psid = patientTableMirror.getCurrentUniquePSID();\n\t\tif(!psid)\n\t\t\treturn false\n\n\t\tvar intent = currentrow_tags[ttag] == undefined ? "":"_del";\n\t\tvar tempObjectInfo_temp = undefined\n\t\tif(state.viewer.selectionMode[1] == \'s\')\n\t\t{\n\t\t\ttempObjectInfo_temp = {type:"study",sid:psid.studies_id, piz:psid.patients_id }\n\t\t}\n\t\telse if(state.viewer.selectionMode[1] == \'p\')\n\t\t{\n\t\t\ttempObjectInfo_temp = {type:"patient",piz:psid.patients_id }\n\t\t}\n\t\tif(tempObjectInfo_temp)\n\t\t{\n\t\t\tmodifyTag(ttag,intent, undefined, [tempObjectInfo_temp])\n\t\t\trenderTagList();\n\n// \t\t\tvar $blinker = $("<div class=\'KReading_ItemBlinker\'></div>").appendTo(document.body);\n// \t\t\tvar pp = tcols.stags.$tags.find("div[data-tag=\'"+ttag+"\']").offset();\n// \t\t\t$blinker.offset( $blinker.css({\'top\': pp.top , \'left\': pp.left }) )\n// \t\t\t\t\t.animate({width: 100, height: 100, opacity:0.2}, 500, function(){$blinker.remove()} )\n\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\n\t}\n\n\t/******************************************************************************\n\t handleKeyEvent\n\t*******************************************************************************/\n\tthat.handleKeyEvent = function(evt)\n\t{\n\t\tvar thecode = evt.keyCode;\n\t\t\n\t\tif( (thecode >= 48 && thecode <= 57) || (thecode>=96 && thecode <= 96+9)  || thecode == 192 ) // any number\n\t\t{\n\t\t\tif(thecode<95)\n\t\t\t\tvar num = thecode - 48 ;\n\t\t\telse\n\t\t\t\tvar num = thecode - 96 ;\n\n\t\t\tif(thecode == 192)\n\t\t\t\tnum=0;\n\t\t\tif(evt.shiftKey || evt.ctrlKey || evt.getModifierState(\'CapsLock\'))\n\t\t\t\tnum+=10;\n\t\t\t\n\n\t\t\tif(tagmap[num] != undefined)\n\t\t\t{\n\t\t\t\t return that.modifyTag_internal(tagmap[num])\n\t\t\t}\n\n\t\t}\n\t\treturn false;\n\t}\n\n\n\t/******************************************************************************\n\t finalize\n\t*******************************************************************************/\n\t//renderTagList();\n\t\n\treturn that;\n}\t\n\n\n\n\n\n\n\n\n\n\n/***************************************************************************************\n* compare and subtract two different lists\n****************************************************************************************/\nfunction KExcelFunctions()\n{\n\tvar that = new Object();\n\n\tfunction TList()\n\t{\n\t\tvar tt = {};\n\t\ttt.doublettes = undefined;\n\t\ttt.obj = {};\n\t\treturn tt; \n\t}\n\n\tvar listA = new TList();\n\tvar listB = new TList();\n\tvar listBoth = new TList();\n\tvar listAnotB = new TList();\n\tvar listBnotA = new TList();\n\t\n\tvar d;\n\n\t/*******************************************************************\n\t* main layout\n\t********************************************************************/\n\tif($(\'#KExcelFunctionsDialog\').length == 0)\n\t{\n\t\td = new dialog_generic();\n\t\td.deleteonclose = false;\n\t\td.$frame.attr(\'id\', \'KExcelFunctionsDialog\').show()\n\t\td.$frame.width($(document.body).width()*.7);\n\n\t}\n\telse\n\t{\n\t\t$(\'#KExcelFunctionsDialog\').show();\n\t\treturn;\n\t}\n\n\n    var $tablecontainer = $("<div class=\'KExcelList_tcontainer\'></div>").appendTo(d.$container);\n\n\tcreate_table(listA, \'List A\');\n\tcreate_table(listB, \'List B\');\n\t//setcontent(listA, "1234 20120101\\n1235 20120505");\n\t//setcontent( listB, "1234 20120101\\n1232 20120505\\n1232 20120508");\n\n\tcreate_table(listBoth,  \'in Both\',    1);\n\tcreate_table(listAnotB, \'A not in B\', 1);\n\tcreate_table(listBnotA, \'B NOT in A\', 1);\n\n\tcompare_tables();\n\n\t/*******************************************************************\n\t* prepare table\n\t********************************************************************/\n\tfunction create_table(whichtable, title, type)\n\t{\n\t\tvar $icontainer   = $("<div class=\'KExcelList_icontainer\'></div>").appendTo($tablecontainer);\n\t\tvar $title        = $("<div class=\'KExcelList_ititle\'>"+title +"</div>").appendTo($icontainer);\n\t\tvar $toolbar      = $("<div class=\'KExcelList_icontainer_toolbar\' ></div>").appendTo($icontainer);\n\t\t\n// \t\tif(type != undefined)\n// \t\t\t$textarea.css(\'visibility\', \'hidden\')\n\n\t\tif(type == undefined)\n\t\t{\n\t\t\tvar $textarea  = $("<textarea onclick=\'this.focus();this.select()\'>paste content here</textarea>").appendTo($toolbar);\n\t\t\t\t$textarea.get(0).onpaste = function(ev){pastecontent(ev, whichtable)}\n\t\t\twhichtable.$textarea = $textarea;\n\n\t\t\tvar $copybutton2  = $("<div class=\'modernbutton orange small\' _style=\'height:15px;\' >from patienttable</div>").appendTo($toolbar)\n\t\t\t\t.click(function(){paste_from_ptable(whichtable)});\n\t\t\tvar $copybutton2  = $("<div class=\'modernbutton blue small\' _style=\'height:15px;\' >copy as psids</div>").appendTo($toolbar)\n\t\t\t\t.click(function(){copy_to_clipboard(whichtable, \'psid\')});\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar $copybutton2  = $("<div class=\'modernbutton red small\' _style=\'height:15px;\' >to patienttable</div>").appendTo($toolbar)\n\t\t\t\t.click(function(){copy_to_clipboard(whichtable, \'psid\', 1)});\n\t\t\tvar $copybutton2  = $("<div class=\'modernbutton yellow small\' _style=\'height:15px;\' >copy as excel</div>").appendTo($toolbar)\n\t\t\t\t.click(function(){copy_to_clipboard(whichtable, \'table\')});\n\t\t\tvar $copybutton2  = $("<div class=\'modernbutton blue small\' _style=\'height:15px;\' >copy as psids</div>").appendTo($toolbar)\n\t\t\t\t.click(function(){copy_to_clipboard(whichtable, \'psid\')});\n\t\t}\n\n\t\t\n\t\n\t\tvar $summary = $("<div class=\'KExcelList_summary\'></div>").appendTo($icontainer);\n\t\tvar $table = $("<table cellspacing=0  \'></table>").appendTo($icontainer);\n\n\t\twhichtable.$container = $icontainer;\n\t\twhichtable.$summary = $summary;\n\t\twhichtable.$table = $table;\n\t\treturn $icontainer;\n\t}\n\n\t/*******************************************************************\n\t* paste content /  convert a csv / string to table object\n\t********************************************************************/\n\tfunction paste_from_ptable(targettable)\n\t{\n\t\tvar str = "";\n\t\tvar selectedItems = patientTableMirror.selectedItems;\n\t\tfor(var k=0; k<selectedItems.length; k++)\n\t\t{\n\t\t\tif(k>0)\n\t\t\t\tstr += "\\n";\n\n\t\t\tif(state.viewer.selectionMode[1]==\'p\')\n\t\t\t{\n\t\t\t\tstr += selectedItems[k];\n\t\t\t}\n\t\t\tif(state.viewer.selectionMode[1]==\'s\')\n\t\t\t{\n\t\t\t\tvar spl = selectedItems[k].split(riddelim);\n\t\t\t\tstr += spl[0] + "\\t" + spl[1].substring(1,9);\n\t\t\t}\n\t\t}\n\t\tsetcontent(targettable, str);\n\t\tcompare_tables();\t\n\t}\n\n\t/*******************************************************************\n\t* paste from clipboard\n\t********************************************************************/\n\tfunction pastecontent(ev, whichtable)\n\t{\n\t\tsetcontent(whichtable, (ev?ev.clipboardData.getData("Text"):"") || "" );\n\t\tcompare_tables();\n\t}\n\n\t/*******************************************************************\n\t* paste content /  convert a csv / string to table object\n\t********************************************************************/\n\tfunction setcontent(whichtable, txt)\n\t{\n\n\t\twhichtable.obj = {};\n\n\t\tvar rows = txt.split("\\n");\n\t\tvar trow, cells, uid, val, xx\n\t\tvar obj = {};\n\t\twhichtable.doublettes = 0;\n\t\tfor(var k=0; k<rows.length; k++)\n\t\t{\n\t\t\ttrow = rows[k];\n\t\t\tif(trow.trim()=="")\n\t\t\t\tcontinue\n\n\t\t\tcells = trow.split(/[\\t\\s]+/);\n\t\t\tfor(var c=0; c<cells.length; c++)\n\t\t\t{\n\t\t\t\t// convert dates?\n\t\t\t\txx = cells[c].trim();\n\t\t\t\tif(xx.search(/\\//) != -1 ) // USA date\n\t\t\t\t{\n\t\t\t\t\txx = xx.split(\'/\');\n\t\t\t\t\tif(xx.length==3)\n\t\t\t\t\t\tval = zeroPad(xx[2],2) + zeroPad(xx[0],2) + zeroPad(xx[1],2);\n\t\t\t\t}\n\t\t\t\telse if(xx.search(/\\./) != -1 ) // german date\n\t\t\t\t{\n\t\t\t\t\txx = xx.split(\'.\');\n\t\t\t\t\tif(xx.length==3)\n\t\t\t\t\t\tval = zeroPad(xx[2],2) + zeroPad(xx[1],2) + zeroPad(xx[0],2);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t  \tval = xx;\n\t\t\t\t}\n\t\t\t\tcells[c] = val;\n\t\t\t}\n\t\t\tuid=cells.join(\'\');\t\n\n\t\t\tif(obj[uid] == undefined)\n\t\t\t\tobj[uid] = cells;\n\t\t\telse\n\t\t\t\twhichtable.doublettes++;\n\t\t}\t\n\t\t\n\t\twhichtable.obj = obj;\n\t\twhichtable.$textarea.val("paste excel cells here");\n\t\trender_table_content(whichtable);\n\t}\n\n\n\t/*******************************************************************\n\t* render table\n\t********************************************************************/\n\tfunction render_table_content(whichtable)\n\t{\n\t\t\tvar html ="";\n\t\t\tvar count = 0;\n\t\t\tfor(var k in whichtable.obj)\n\t\t\t{\n\t\t\t\tvar trow = whichtable.obj[k];\n\t\t\t\thtml += "<tr>";\n\t\t\t\tfor(var c=0; c<trow.length; c++)\n\t\t\t\t{\n\t\t\t\t\thtml += "<td>" + trow[c] + "</td>";\n\t\t\t\t}\n\t\t\t\thtml += "</tr>";\n\t\t\t\tcount++;\n\t\t\t}\n\t\t\t//html = "<div style=\'user-select:text;-webkit-user-select:all;\'>" + html + "</div>" \n\t\t\t//whichtable.$table.append($(html));\n\t\t\n\t\t\twhichtable.$table.empty().append($(html));\n\t\t\t\n\t\t\tvar summary = "<b>" + count + "</b> unique rows";\n\t\t\tif (whichtable.doublettes != undefined)\n\t\t\t\tsummary += ( "<br/><b>" + whichtable.doublettes + "</b> doublettes");\n\t\t\twhichtable.$summary.html(summary)\n\t\t\n\t}\n\n\n\t/*******************************************************************\n\t* compare 2 tables\n\t********************************************************************/\n\tfunction compare_tables()\n\t{\n\t\tvar a = listA.obj;\n\t\tvar b = listB.obj;\n\t\tlistBoth.obj = {};\n\t\tlistAnotB.obj = {};\n\t\tlistBnotA.obj = {};\n\t\tfor(var k in a)\n\t\t{\n\t\t\tif(b[k] != undefined)\n\t\t\t\tlistBoth.obj[k] = a[k];\n\t\t\telse\n\t\t\t\tlistAnotB.obj[k] = a[k];\n\t\t\t//a[k].found = \n\t\t}\n\t\tfor(var k in b)\n\t\t{\n\t\t\tif(a[k] == undefined)\n\t\t\t\tlistBnotA.obj[k] = b[k];\n\t\t\t//b[k].found = (a[k] != undefined)\n\t\t}\n\t\trender_table_content(listBoth)\n\t\trender_table_content(listAnotB)\n\t\trender_table_content(listBnotA)\n\t}\n\n\n\t/*******************************************************************\n\t* copy to clipboard\n\t********************************************************************/\n\tfunction copy_to_clipboard(ttable, mode, maptoptable)\n\t{\n\t\tvar str = "";\n\t\tfor(var k in ttable.obj)\n\t\t{\n\t\t\tvar trow = ttable.obj[k];\n\t\t\tif(mode == \'psid\')\n\t\t\t{\n\t\t\t\t\tstr += trow[0] + "#" + trow[1]; ; \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tfor(var c=0; c<trow.length; c++)\n\t\t\t\t{\n\t\t\t\t\tstr += (c>0?"\\t":"") + trow[c]; \n\t\t\t\t}\n\t\t\t}\n\n\t\t\tstr += maptoptable?" ":"\\n";\n\t\t}\n\n\t\tif(maptoptable)\n\t\t{\n\t\t\t$(".KSearchFields[name=\'PIZ\']").val(str);\n\t\t\tif (state.viewer.levelMode)\n\t\t\t\tpatientTableMirror.levelMode_backToAll();\n\t\t\tpatientSearch({keyCode:13},function() { });\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar $temp = $("<textarea style=\'position:absolute; display:block;z-index:99999;top:0px\'>"+str+"</textarea>").appendTo($body).select();\n\t\t\tvar successful = document.execCommand(\'Copy\');\n\t\t\t$.notify(" Copied to clipboard","success");\n\t\t\t$temp.remove();\n\t\t}\n\t\t\n\t}\n\n\n\n\n\n\treturn that;\n}\n\nfunction setNORAenv(toadd)\n{\n    var p = {}\n    p.application = "webview"\n    p.electron = false;\n    p.debug = false;\n\n    p.url_pref = ""\n\n    p.setPatientTableWidth = function() {}\n    p.setPatientTableLayout = function() {}\n    p.jsonTable_loadFormattedList = function() {}\n    p.unsavedChanges = function() {return false; }\n\n    p.KViewer = undefined;\n    p.commandDialog = undefined;\n    p.tempObjectInfo = undefined;\n    p.hasProxy = false;\n    p.static_info = {};\n    p.standardToolsize = 300;\n    p.userinfo = {username:""};\n    p.guestuser="";\n    p.storage = undefined;\n    p.ViewerSettings = undefined;\n    p.TableHidden = true;\n    p.markerProxy = undefined;\n    p.defaultOpenPath ;\n    p.markerProxy = undefined;\n    p.pakoWorker = true;\n\n    p.$body = $(document.body);\n\n    p.signalhandler = new SignalHandler();\n    p.colormap = new KColormap();\n    p.presetManager\t   \t = new PresetManager();\n    p.stateManager\t   = new StateManager();\n    p.logProcess = console.log;\n\n\n    for (var k in p)\n    {\n        if (window[k] == undefined)\n            window[k] = p[k];\n    }\n    for (var k in toadd)\n    {\n         window[k] = toadd[k]\n    }\n\n}'},function(t,n){t.exports='\n// ======================================================================================\n// ======================================================================================\n// ============= KFormViewer\n// ======================================================================================\n// ======================================================================================\n\n\n\n\nfunction KFormViewer(viewport, master)\n{\n\t/** The form viewer\n\t* @class \n\t* @alias KFormViewer\n\t* @augments KPrototypeViewer\n\t*/\n\tvar that = KPrototypeViewer(viewport, master);\n\tthat.viewerType = \'formViewer\';\n\n\tthat.currentFileID = undefined;\n\tthat.currentform = undefined;\n\n\n\tthat.layoutbar.hide()\n\tvar toolbar = that.toolbar;\n\n\t// hide the dragger, this is hard to get working ... (must keep the current form content when moving! to be implemented)\n\tthat.toolbar.$dragdiv.hide();\n\n\ttoolbar.$save = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-save fa-1x\'></i></div>")\n\t\t.click(function() \n\t\t{ \n\t\t  // be strict here and to not allow form without patien set explicetely\n\t\t  if(that.currentFileinfo.patients_id == undefined || that.currentFileinfo.studies_id == undefined )\n\t\t  {\n\t\t  \t\t$info.css({opacity: .2});\n\t\t  \t\t$info.animate({opacity: 1}, 500);\n\t\t  \t\treturn false;\n\t\t  }\n\n\t\t   var fm = master.formManager;\n\t\t   if(that.formcontent.readonly)\n\t\t   \t{\n\t\t   \t\talertify.error(\'Cannot save, this is a read-only form!\');\n\t\t   \t\treturn false;\n\n\t\t   \t}\n\t\t   fm.save(that.currentform.name, that.formcontent, that.currentFileinfo, function(fobj) { \n\t\t   \t\t\tthat.toolbar.$save.removeClass("notsaved");\n\t\t   });\n\n\t });\n\ttoolbar.attach(toolbar.$save);\n// \ttoolbar.$close.off(\'click\');\n// \ttoolbar.$close.on(\'click\', function(ev)\n// \t{\n// \t\treturn\n// \t});\n\n\n\tvar $inner =  $("<div class=\'KViewPort_formViewer\'></div>").appendTo(that.$container);\n\n\tvar $info = $("<div class=\'KViewPort_formViewer_pinfobar patientSetIndicator\'></div>").appendTo(that.$container);\n \t$info.on(\'dragover dragenter\', function(ev)\n \t{\n \t\t$info.css(\'background\', \'lightblue\');\n \t\tev.preventDefault();\n \t});\n \t$info.on(\'dragleave\', function(ev)\n \t{\n \t\t$info.css(\'background\', \'initial\');\n \t\tev.preventDefault();\n \t});\n \t$info.on(\'drop\', function(ev)\n \t{\n \t\tvar psid = {patients_id: tempObjectInfo[0].piz, studies_id: tempObjectInfo[0].sid};\n \t\tif(tempObjectInfo[0].sid == undefined)\n \t\t{\n \t\t\talertify.error(\'You have to drop a study.\')\n \t\t}\n \t\telse\n \t\t{\n\t\t\tsetPatientStudy(psid);\n \t\t}\n\t\t$info.css(\'background\', \'initial\');\n\t\tcleanAllDropIndicators();\n\t\tev.stopPropagation();\n\t\tev.preventDefault();\n \t\treturn false;\n \t});\n\n\tthat.psid = {patients_id:undefined, studies_id:undefined, patient_name:undefined} \n\tfunction setPatientStudy(psid)\n\t{\n\t\t$info.empty();\n\t\tif(psid == false || psid.studies_id == undefined)\n\t\t{\n\t\t\t//var $p = $("<div class=\'\' style=\'color:yellow\'><span>No patient/study set.<br> Drag this tag to left panel to set.</span></div>").appendTo($info); \n\t\t\t//var $p = $("<div class=\'\' style=\'color:yellow\'><span>No patient/study set.<br> Drop a patient/study here to select.</span></div>").appendTo($info); \n\t\t\t$info.css(\'color\', \'yellow\').html("No unique patient/study set for this form.<br>Hold CTRL and drop a study to select.");\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar name; // = tempObjectInfo[0].namecat.trim();\n\t\t\t$info.css(\'color\', \'white\');\n\t\t\tvar $pline = $("<div></div>").appendTo($info); \n\t\t\tvar finfo = "";\n\t\t\tif (psid.filename != undefined)\n\t\t\t\tfinfo = " (" + psid.filename + ")"; \n\t\t\t$pline.append( $("<span > Form:"+ that.currentform.name +finfo + " <br> </span>") );\n\t\t\t$pline.append( $("<span > Subject: "+ psid.patients_id +" </span>") );\n\t\t\t$pline.append( $("<span > "+ psid.studies_id +" </span>") );\n\t\t\tthat.psid = {patients_id:psid.patients_id, studies_id:psid.studies_id};\n\n\t\t\tthat.currentFileinfo =  $.extend(that.currentFileinfo,that.psid);\n\t\t}\n\t}\n\n\n\n\tvar $main =  $("<div class=\'\'></div>").appendTo($inner);\n\tthat.$main = $main;\n\n\n\t$main.hide()\n\tthat.setContent = setContent;\n\n\tfunction setContent(ev,params)\n\t{\n\n\t\t// forms might not be here when tool has to be created.\n\t\t// so wait until they are there and re-run this function\n\t\tif( !master.formManager.isinstance )\n\t\t{\n\t\t\tmaster.formManager.updateListFromServer( function(){ setContent(ev,params)  } );\n\t\t\treturn false;\n\t\t}\n\n\n\t\tif (typeof(ev.content) == \'string\') // a loaded form content\n\t\t{\n\t\t\tvar x = JSONparse_lazy(ev.content);\n\t\t\tev.content = {name:x.KForm_name,content:x};\t\n\t\t\tif (params.intent.patientedit | params.fileID == \'patientinfo\')\n\t\t\t\tev.content.name = \'patientinfo\';\n\t\t\tif (params.intent.studyedit | params.fileID == \'studyinfo\')\n\t\t\t\t\tev.content.name = \'studyinfo\';\n\t\t}\n\n\n\t\t//console.log(ev.content)\n\t\t// -name\n\t\t// -content (= the variable, undefined if created new)\n\n\n\t\t// workaround for double "content.content"" in uploadJSON\n \t\tif(ev.content.content!=undefined && ev.content.content.hasOwnProperty("content") )\n \t\t\tthat.formcontent = ev.content.content;\n \t\telse\n \t\t\tthat.formcontent = ev.content;\n\n\t\t// workaround for reading form content\n\t\tif(ev.formid != undefined)\n\t\t{\n\t\t\t//ev.content.content.formcontent\n\t\t\tthat.formcontent.name = ev.formid;\n\t\t\tthat.formcontent.readonly = 1;\n\t\t\tif(that.formcontent.content.formcontent)\n\t\t\t\tthat.formcontent.content = that.formcontent.content = that.formcontent.content.formcontent;\n\t\t}\n\n\t\tif(that.formcontent.name == undefined)\n\t\t{\n\t\t\talertify.error(\'The form does not contain a "KForm_name" or a "name" field.\');\n\t\t\treturn false;\n\t\t}\n\n\t\tthat.currentform = master.formManager.getFormByID(that.formcontent.name);\n\t\tif(that.currentform == undefined)\n\t\t{\n\t\t\talertify.error("Could not find the form definition for \'" + that.formcontent.name + "\'");\n\t\t\tthat.close();\n\t\t\treturn false;\n\t\t}\n\t\t\n\t\t// somehow/sometimes, the "name"" itself came in there (from event), delete it\n\t\t// delete that.formcontent.name\n\t\tthat.prepViewer(that);\n\t\tviewport.setCurrentViewer(that);\n\n\n\t\t// recreate the content, in case the form layout hase changed (more fields), and to set the KForm_name field ...\n\t\tthat.formcontent.content = KForm.getFormContent(that.currentform, that.formcontent.content);\n\n\n\n\t\tthat.currentFormID =  that.formcontent.name;\n\t\t// this should be done with TRUE ids!!!!!\n\t\t//that.currentFormID = that.currentform.id;\n\n\t\tthat.currentFileID = ev.fileID;\n\t\tif (that.currentFileID == undefined)\n\t\t   that.currentFileID = "NA";\n\n\t\tthat.currentFileinfo = ev.fileinfo;\n\n\n\t\ttoolbar.$info.html("");\n\t\t$main.children().remove();\n\n\t\tif (params.intent.patientedit | params.fileID == \'patientinfo\')\n\t\t\tthat.formcontent.PatientID = ev.fileinfo.patients_id;\n\t\tif (params.intent.studyedit | params.fileID == \'studyinfo\')\n\t\t\tthat.formcontent.StudyID = ev.fileinfo.studies_id;\n\n\t\tthat.update();\n\t}\n\n\tthat.customClose = function()\n\t{\n\t\tif (that.autosave_cid != -1)\n\t\t{\t\t  \n\t\t  clearTimeout(that.autosave_cid);\n\t\t  that.autosave_cid = -1;\n\t\t  saveCurrentForm();\n\t\t}\n\n\t}\n\n\n\tfunction saveCurrentForm()\n\t{\n\t   var fm = master.formManager;\n\t   uploadJSON.askonOverwrite = false;\n\t   uploadJSON.quiet = true;\n\t   fm.save(that.currentform.name, that.formcontent, that.currentFileinfo, function(fobj) { \n\t\t   uploadJSON.askonOverwrite = true;\n\t\t   uploadJSON.quiet = false;\n\t\t   that.toolbar.$save.removeClass(\'notsaved\');\n\t\t});\n\t}\n\n\tthat.autosave_cid = -1;\n\tfunction onchange(e)\n\t{\t\t\n\t    that.toolbar.$save.addClass(\'notsaved\');\n\t\tif (state.viewer.forms_autosave)\n\t\t{\n\t\t\tif (that.autosave_cid != -1)\n\t\t\t   clearTimeout(that.autosave_cid);\n\t\t\tthat.autosave_cid = setTimeout(function()\n\t\t\t{ \t\t\t\t   \n\t\t\t\tsaveCurrentForm();\n\t\t\t},2000);\n\t\n\n\n\t\t}\n\t}\n\n\n\tfunction update()\n\t{\n\t\tvar obj =  that.formcontent;\n\t\t$main.children().remove();\n\t\tKForm.createForm(that.currentform, that.formcontent.content, $main , onchange)\n\t\t$main.show();\n\t\tif(that.currentFileinfo.studies_id!=undefined & that.currentFileinfo.patients_id!=undefined)\n\t\t\tsetPatientStudy( {patients_id:that.currentFileinfo.patients_id, studies_id:that.currentFileinfo.studies_id, filename:that.currentFileinfo.Filename} );\n\t\telse\n\t\t\tsetPatientStudy( patientTableMirror.getCurrentUniquePSID() );\n\t\tthat.setInnerLayout();\n\t}\n\tthat.update = update;\n\n\tthat.setPatientStudy = setPatientStudy\n\n\treturn that;\n\n}\n\n\n// ======================================================================================\n// ======================================================================================\n// ====== KForm \n// ======================================================================================\n// ======================================================================================\n\n /** The form layouter\n   * @class \n   * @alias KForm\n   */\nvar KForm = {};\nKForm.runningID = 0;;\n\nKForm.createForm = function (form0,content0,$targetdiv0,onchange,isPreview)\n{\n\tif (form0.html)\n\t\t{\n\t\t\tKForm.createFormHTML(form0,content0,$targetdiv0,onchange);\n\t\t\treturn\n\t\t}\n\n\n\tdelete content0.modified ;\n\t\n\n \tfunction createForm_rec(form,content,$targetdiv, count)\n \t{\n\n\t\t// this adds an "update" interface to the target object (=content).\n\t\t// with this, specific fields can receive additional updaters\n\t\t// the "onchange" function is GLOBAL for the object (=content) and will be re-set every time the form is created\n\t\tif(count==undefined)\n\t\t \tcount = 0;\t\t\n\n\t\tif (content == undefined)\n\t\t{\n\t\t\tconsole.warn("bug in form creation");\n\t\t\treturn;\n\t\t}\n\n\t\tattachUpdater(content, onchange );\n\n\t\t// add dynmac stylesheet, but only if not already there (tag with name)\t\n\t\tif(form.classdef !== undefined  & $(document.head).find(\'#KForm_\'+form.name).length == 0 )\n\t\t{\n\t\t\t$("<style id=\'KForm_"+form.name+"\' type=\'text/css\'>" + form.classdef  +  "</style>").appendTo(document.head);\n\t\t}\n\n\n\t\tfor (var r = 0; r < form.layout.length; r++)\n\t\t{\n\t\t\tvar x = form.layout[r];\n\t\t\tif(x.title == undefined)\n\t\t\t\tx.title = x.name;\n\t\t\t\n\t\t\tvar thetitle = x.title;\n\t\t\tvar shortcutid = "";\n\t\t\tif(form0 && form0.tag == "READING" && (x.type==\'option\' || x.type==\'check\') && count < 99)\n\t\t\t{\n\t\t\t\tthetitle = " <span style=\'color:gray;position:relative;top:-0px;font-size:12px; margin-right:2px; background:none;\'>"+count+" </span>" + thetitle ;\n\t\t\t\tshortcutid = "shortcut_" + count;\n\t\t\t\tcount++;\n\t\t\t}\n\n\t\t\t\n\t\t\t var element = "div";\n\t\t\t if (x.element)\n\t\t\t\t element = x.element;\n\n\t\t\t// for the labels, the for property\n\t\t\tvar fortarget = x.name;\n\t\n\t\t\tvar $c; \n\t\t\tif (x.type == \'css\')\n\t\t\t{\n\t\t\t\tsetCSS($targetdiv,x.val);\n\t\t\t}\n\t\t\telse if (x.type == \'div\' | x.type == \'placeholder\') // placeholder div for personal use\n\t\t\t{\n\t\t\t\t$c = $(" <"+element+" placeholderid=\'"+x.id +"\' class=\'KFormItem\'>" + (x.val===undefined?\'\':x.val) +"</"+element+"> ");\t\t\t\t\t\t\n\t\t\t} \n\n\t\t\telse if (x.type == \'title\')\n\t\t\t{\n\t\t\t\t$c = $(" <h2 class=\'KFormTitle\' > " + x.val+" </h2> ");\t\t\t\t\t\t\n\t\t\t} \n\t\t\telse if (x.type == \'text\')\n\t\t\t{\n\t\t\t\t$c = $(" <span class=\'KFormItem\' style=\'word-wrap: break-word;\'> " + x.val+" <br> </span> ");\t\t\t\t\t\t\n\t\t\t} \n\t\t\telse if (x.type == "separator")\n\t\t\t{\n\t\t\t\t$c = $("<"+element+" class=\'KFormSeparator\'></"+element+">");\n\t\t\t}\n\t\t\telse if (x.type == "customelement")\n\t\t\t{\n\t\t\t\t$c = x.val(content);\n\t\t\t\t$c.addClass(\'KFormItem\');\n\t\t\t}\n\t\t\telse if (x.type == "form")\n\t\t\t{\n\t\t\t\t$c = $("<"+element+"></"+element+">");\n\t\t\t    createForm_rec(x,content[x.name],$c);\n\t\t\t}\n\t\t\telse if (x.type == "formarray")\n\t\t\t{\n\t\t\t\t$c = $("<"+element+" class =\'KFormItem_formarray\'></"+element+">");\n\t\t\t\tvar $menu = $("<div class=\'KFormItem_formarray_menu\'></div>");\n\t\t\t\t$menu.append("<label>"+thetitle+"</label>").appendTo($c);\n\t\t\t\tx.createbutton = x.createbutton || \'Add new item\';\n\n\t\t\t\tvar createitm = function(cb) { return function(x,content,$c) {return function(ev)\n\t\t\t\t{ \n\t\t\t\t\tif(content[x.name] == undefined)\n\t\t\t\t\t\tcontent[x.name] = new Array();\n                    var newitm = KForm.getFormContent(x, {} ) \n\t\t\t\t\tcontent[x.name].push( newitm);\n\t\t\t\t\tappendFormArrayItem(x, content, content[x.name].length - 1, $c, true);\n\t\t\t\t\tif(x.linkToMarkerset)\n\t\t\t\t\t{\n\t\t\t\t\t\tmarkerProxy.createMarker();\n\t\t\t\t\t}\n\t\t\t\t\tif (cb)\n\t\t\t\t\t    cb(newitm);\n\t\t\t\t} }(x,content,$c) }\n\t\t\t\t$( "<div class=\'modernbutton KFormItem_formarray_tool\'> "+x.createbutton+"  <i class=\'fa fa-plus\'></i></div>")\n\t\t\t\t\t.click(createitm()).appendTo($menu);\n\n                if (x.altcreatebuttons != undefined )\n                {\n                \tfor (var s = 0; s < x.altcreatebuttons.length;s++)\n                \t{\n\t\t\t\t\t\t$( "<div class=\'modernbutton small KFormItem_formarray_tool\'> "+x.altcreatebuttons[s].text+" <i class=\'fa fa-plus\'></i></div>")\n\t\t\t\t\t\t\t.click(createitm(x.altcreatebuttons[s].fun)).appendTo($menu);\n                \t}\n                }\t\t\t\t\n\t\t\t\tfunction appendFormArrayItem(x, content, index, $c, slide)\n\t\t\t\t{\n\t\t\t\t\t\tvar $innerc = $("<div class=\'KFormItem_formarray_subform\' style=\'display:none\'></div>").appendTo($c);\n\t\t\t\t\t\tif(slide)\n\t\t\t\t\t\t\t$innerc.fadeIn(170);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t$innerc.show();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tcreateForm_rec(x,content[x.name][index],$innerc)\n\t\t\t\t\t\tif (x.autoID)\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (content[x.name][index].id == undefined)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar next_valid = 0;\n\t\t\t\t\t\t\t\tfor (var k=0; k < content[x.name].length;k++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif ( next_valid <= content[x.name][k].id )\n\t\t\t\t\t\t\t\t\t\tnext_valid = content[x.name][k].id+1;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tcontent[x.name][index].id = next_valid;\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t$("<div class=\'KFormItem_formarray_tool KFormItem_formarray_autoid\'>#"+content[x.name][index].id +"</div>").appendTo($innerc);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// create a delete button\n\t\t\t\t\t\tif(!x.linkToMarkerset)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$("<div class=\'KFormItem_formarray_tool\' style=\'right:0px\'><i class=\'fa fa-trash\'></i></div>").appendTo($innerc)\n\t\t\t\t\t\t\t.click(function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar index = $innerc.prevAll().length-1; // must find the index each time from new!!\n\t\t\t\t\t\t\t\t\t$innerc.slideUp(110, function(){$(this).remove()}); \n\t\t\t\t\t\t\t\t\tcontent[x.name].splice(index,1);\n\n\t\t\t\t\t\t\t\t\t//console.log(index);\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(content[x.name]\t!= undefined)\n\t\t\t\t{\n\t\t\t\t\tfor(var z=0; z < content[x.name].length ; z++)\n\t\t\t\t\t{\n\t\t\t\t\t\tappendFormArrayItem(x, content, z, $c, false)\n\t\t\t\t\t}\t\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (x.type == "markerset")\n\t\t\t{\n\t\t\t\t$c = $("<"+element+" class =\'KFormItem_formarray\' style=\'position:relative;\'></"+element+">");\n\t\t\t\tfunction dummy_closure(x, content, $c)\n\t\t\t\t{\n\t\t\t\t\tvar $menu = $("<div class=\'KFormItem_formarray_menu\'></div>");\n\t\t\t\t\t$menu.append("<label>"+thetitle+"</label>").appendTo($c);\n\t\t\t\t\tvar $newbutton = $( "<div class=\'modernbutton small KFormItem_formarray_tool\' style=\'max-width:150px;\'><i class=\'fa fa-plus\'></i> New marker </div>").appendTo($menu)\n\n\t\t\t\t\tvar $itemcontainer = $( "<div class=\'\' style=\'position:relative\'></div>").appendTo($c)\n\t\t\t\t\tvar $itemselector = $( "<div class=\'KFormItem_formarray_selectormenu\'></div>").appendTo($itemcontainer)\n\t\t\t\t\tvar $itemtopline = $( "<div class=\'KFormItem_formarray_highligterline\'></div>").appendTo($itemcontainer)\n\t\t\t\t\tvar mset;\n\t\t\t\t\tvar creation_status = 0;\n\n\t\t\t\t\tfunction appendFormArrayItem(x, content, index, $c, point)\n\t\t\t\t\t{\n\t\t\t\t\t\t\tvar $innerc = $("<div class=\'\' style=\'margin-left:20px;\'></div>").appendTo($c);\n\t\t\t\t\t\t\t// colored item for jump-to-point an selection\n\t\t\t\t\t\t\tvar $selItem = $( "<div class=\'\' style=\'\'></div>").appendTo($itemselector);\n\t\t\t\t\t\t\tvar $selItemColor = $( "<div class=\'KFormItem_formarray_colorbox\' style=\'\'></div>").appendTo($selItem);\n\n\t\t\t\t\t\t\t// form will be appended to point.formcontent\n\t\t\t\t\t\t\t// must work with a timeout, since formcontent is not yet there when first point creation  in KAnnotation Tool\n\t\t\t\t\t\t\tif(creation_status == 0)\n\t\t\t\t\t\t\t\twindow.setTimeout(function() { createForm_rec(x, point.formcontent,$innerc, count) },10);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tcreateForm_rec(x, point.formcontent,$innerc, count)\n\n\t\t\t\t\t\t\tfunction deleteFormArrayItem(point)\n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tvar index = $innerc.prevAll().length-1; // must find the index each time from new!!\n\t\t\t\t\t\t\t\t\t$innerc.slideUp(110, function(){$(this).remove()}); \n\t\t\t\t\t\t\t\t\t$selItem.remove()\n\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t// create a delete button\n\t\t\t\t\t\t\tif(1)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar $delbutton = $("<div class=\'KFormItem_formarray_tool\' style=\'right:0px\'><i class=\'fa fa-trash\'></i></div>").appendTo($innerc)\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfunction makeactive(pp)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t$itemselector.children().removeClass(\'active\')\n\t\t\t\t\t\t\t\t$selItem.addClass(\'active\');\n\t\t\t\t\t\t\t\t$itemcontainer.children().hide();\n\t\t\t\t\t\t\t\t$itemselector.show();\n\t\t\t\t\t\t\t\t$itemtopline.show();\n\t\t\t\t\t\t\t\t$innerc.show();\n\t\t\t\t\t\t\t\t$itemtopline.css(\'background-color\', $selItemColor.css(\'background-color\' ) ) \n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tpoint.callbacks.delete.form = deleteFormArrayItem;\n\t\t\t\t\t\t\tpoint.callbacks.changeProps.form = function(pp) \n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t$selItemColor.css(\'background\', pp.p.color.getCSS()) \n\t\t\t\t\t\t\t\tif($selItem.hasClass(\'active\'))\n\t\t\t\t\t\t\t\t\t$itemtopline.css(\'background-color\', $selItemColor.css(\'background-color\' ) ) \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tpoint.callbacks.mousedown.form = makeactive\n\t\t\t\t\t\t\tpoint.callbacks.jumptopoint.form = makeactive\n\n\t\t\t\t\t\t\t$delbutton.click(point.deletepoint);\n\t\t\t\t\t\t\t$selItem.click(point.jumpToPoint)\n\n\t\t\t\t\t\t\tmakeactive();\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar appendNewFormArrayItem = function(x, content, $c)\n\t\t\t\t\t{\treturn function(newpoint)\n\t\t\t\t\t\t{ \n\t\t\t\t\t\t\tif(content[x.name] == undefined)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//Object.defineProperty(content[x.name], \'markerset\', { get: function() { return mset.objectify()} } ) ;\n\t\t\t\t\t\t\t\t// must define getter in an objection creation, and not defineProperty, otherwise stringify will not extract the valuies\n\t\t\t\t\t\t\t\tcontent[x.name] = { get markerset(){ return mset.objectify()  }   }\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// formcontent is not yet set at first import\n\t\t\t\t\t\t\tif(creation_status && newpoint.formcontent == undefined)\n\t\t\t\t\t\t\t\tnewpoint.formcontent = KForm.getFormContent(x, {} ) ;\n\t\t\t\t\t\t\tappendFormArrayItem(x, content, content[x.name].length - 1, $c, newpoint);\n\t\t\t\t\t\t};\n\t\t\t\t\t}(x,content,$itemcontainer)\n\n\t\t\t\t\tif(isPreview)\n\t\t\t\t\t\tmarkerProxy.delSet(x.name);\n\t\t\t\t\t\t\n\t\t\t\t\t// create the markerset if not existing\n\t\t\t\t\tif( markerProxy.markersets[x.name] == undefined )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar state = {ignoremodified:true, keepalive: true};\n\t\t\t\t\t\tif(isPreview)\n\t\t\t\t\t\t\tstate.delSetOnPanelClose = 1;\n\n\t\t\t\t\t\t$.extend(true, state, x.state);\n\t\t\t\t\t\tmset = markerProxy.newSet({name:x.name, uuid: x.name, type: x.markersettype || "circles", showPanel:1 ,templates:x.templates,  state:state});\n\t\t\t\t\t\t\n\t\t\t\t\t\tif(mset.markerPanel && !isPreview) // hide some buttons, save functionality only via form.\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmset.markerPanel.$close.hide();\n\t\t\t\t\t\t\tmset.markerPanel.$saveMarkers.hide();\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmset = markerProxy.markersets[x.name];\t\n\t\t\t\t\t}\n\t\t\t\t\tmset.deleteAllPoints();\n\t\t\t\t\tmset.callbacks.addpoint.form = appendNewFormArrayItem; // append new item via callback of point creation\n\t\t\t\t\t$newbutton.click( function(){markerProxy.createMarker(undefined, mset )} );\n\t\t\t\t\t\n\t\t\t\t\t// if content already exists (for example, after loading existing json => import the points \n\t\t\t\t\tif(content[x.name]\t!= undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tmarkerProxy.import([content[x.name].markerset], mset)\n\t\t\t\t\t\tcontent[x.name] = { get markerset(){ return mset.objectify()  }   }\n\t\t\t\t\t}\n\t\t\t\t\tcreation_status = 1;\n\t\t\t\t\tif(isPreview) // on preview, directly create an element\n\t\t\t\t\t{\n\t\t\t\t\t\tmarkerProxy.createMarker(undefined, mset )\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tdummy_closure(x, content, $c);\n\t\t\t}\n\t\t\telse if (x.type == "markerpoint")\n\t\t\t{\n\t\t\t\t$c = $("<"+element+" class=\'KFormItem\'></"+element+">");\n\t\t\t\tif(x.title !== undefined & x.title != "" )\n\t\t\t\t\t$("<label class=\'KFormItem_label\'>"+x.title+": </label>").appendTo($c);\n\t\t\t\n\t\t\t\t// point was already created on demand in KForm.getFormContent\n\t\t\t\tvar point = content[x.name];\n\t\t\t\t// create a point row without possibility to delete it\n\t\t\t\tvar $row = point.createMarkerRepresentation(form.name, {delete:0, coords:0}).addClass(\'KForm_markerpointrow\');\n\n\t\t\t\t// if the defintion for the point has a property "form", create this form  and forward to the point createRepresentation callback list\n\t\t\t\t// only this way, all representations in all viewports for this point will have the corresponding form\n\t\t\t\tif(x.form !=undefined)\n\t\t\t\t{\n\t\t\t\t\tpoint.formcontent  = KForm.getFormContent(x.form, {} );\n\t\t\t\t\tif(0)//x.formAtPoint) // create the form also at the point in eacht viewport\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.callbacks.createinfobox.form = function(dummy, $target){ \n\t\t\t\t\t\t\t createForm_rec(x.form, point.formcontent, $target)\n\t\t\t\t\t\t };\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\t createForm_rec(x.form, point.formcontent, $row);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$row.appendTo($c);\n\t\t\t\tpoint.callbacks.delete.KForm = function()\n\t\t\t\t{\n\t\t\t\t\tif($c.parent().hasClass(\'KFormItem_formarray_subform\'))\n\t\t\t\t\t\t$c.parent().remove();\n\t\t\t\t\telse\n\t\t\t\t\t\t$c.remove();\n\t\t\t\t};\n\t\t\t}\n\n\n\t\t\telse if (x.type == \'json\')\n\t\t\t{\n\t\t\t\t// make a lazy json\n\t\t\t\tfunction myonfocus(ev, x)\n\t\t\t\t{\n\t\t\t\t\tif (document.activeElement != ev.target)\n\t\t\t\t\t{\n\n\t\t\t\t\t\tvar jsonstring = myJSONStringify(content[x.name],"")\n\t\t\t\t\t\t$(ev.currentTarget).val(jsonstring);\n\t\t\t\t\t\tsetTimeout(function(ev){ return function() \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar target = ev.currentTarget;\n\t\t\t\t\t\t\tif (target[0] != undefined)\n\t\t\t\t\t\t\t\ttarget = target[0];\n\t\t\t\t\t\t\t$(target).height( target.scrollHeight-4);\n\t\t\t\t\t\t} }(ev),0);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tfunction myofffocus(ev, x)\n\t\t\t\t{\n  \t\t\t\t\tvar jsonstring =$(ev.currentTarget).val();\n  \t\t\t\t\ttry\n  \t\t\t\t\t{\n\t\t\t\t\t\teval(\'var parsed = \' +  jsonstring);\n\t\t\t\t\t\tcontent[x.name] = parsed;\n\t\t\t\t\t\tcontent.modified = true;\n\t\t\t\t\t\tcontent.update(x.name);       \n  \t\t\t\t\t}\n\t\t\t\t\tcatch(err)\n\t\t\t\t\t{ \n\t\t\t\t\t\t$.notify(\'Sorry, the JSON intent json\\n\'+jsonstring+\' \\ncould not be parsed. Content was not updated.\', \'error\');\n\t\t\t\t\t}\n  \t\t\t\t\tif (onchange) onchange(x, ev.currentTarget);\n  \t\t\t\t\tif (x.onchange) x.onchange(content[x.name], ev.currentTarget);\n\t\t\t\t}\n\n\t\t\t\t$c = $("<"+element+" class=\'KFormItem\'><label class=\'KFormItem_label\' for=\'"+x.name+"\' > "+x.title+": </label></"+element+">")\n\t\t\t\tvar $textarea = \t$("<textarea name=\'"+x.name+"\' "+attr+"></textarea>").appendTo($c).on("click",  function(x){ return function(ev){ myonfocus(ev, x); } }(x)   )\n\t\t\t\t\t.on("mouseleave",  function(x){ return function(ev){ myofffocus(ev, x); } }(x)   )\n\t\t\t\t\t.on("keyup",  function(ev){ ev.stopPropagation(); }  )\n\t\t\t\t\t.on("keydown",  function(ev){ ev.stopPropagation(); }  )\n\t\t\t\t myonfocus({currentTarget: $textarea}, x);\n\n\t\t\t\t\tvar valchanged = function($div) {return function(val)\n\t\t\t\t\t{\n\t\t\t\t\t\t$div.val( myJSONStringify( val) );\n\t\t\t\t\t}}($textarea)\n\t\t\t\t\tcontent.update.add(x, valchanged, $textarea);\n\t\t\t\n\t\t\t}\n\n\t\t\telse if (x.type == \'textarea\')\n\t\t\t{\n\n\n\t\t\t\tif (x.mode == undefined)\n\t\t\t\t{\n\n\t\t\t\t\t$c = $("<"+element+" class=\'KFormItem\'><label class=\'KFormItem_label\' for=\'"+x.name+"\' > "+x.title+": </label></"+element+">")\n\t\t\t\t\tvar $textarea  = $("<textarea name=\'"+x.name+"\' "+attr+"></textarea>").appendTo($c)\n\t\t\t\t\t$textarea.html(content[x.name])\n\t\t\t\t\t.on("keydown",  function(ev){ ev.stopPropagation(); }  )\n\t\t\t\t\t.on(\'keyup\',function(i,x) { return function(e){\n\t\t\t\t\t\te.preventDefault();\n\t\t\t\t\t\te.stopPropagation();\n\t\t\t\t\t\t content[i] = $(e.currentTarget).val();\n\t\t\t\t\t\t content.modified = true;\n\t\t\t\t\t\t content.update(x.name);        \t\t\t\t\t \n\t\t\t\t\t\t } }(x.name,x));     \n\n\t\t\t\t\tsetTimeout(function(){\n\t\t\t\t\t\t$textarea.height( $textarea[0].scrollHeight-4);\n\t\t\t\t\t},0);\n\n\t\t\t\t\tvar valchanged = function($div) {return function(val)\n\t\t\t\t\t{\n\t\t\t\t\t\t$div.val(val);\n\t\t\t\t\t}}($textarea)\n\t\t\t\t\tcontent.update.add(x, valchanged, $textarea);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$c = $("<"+element+" class=\'KFormItem\'><label class=\'KFormItem_label\' for=\'"+x.name+"\' > "+x.title+": </label></"+element+">")\n\t\t\t\t\tvar $textarea  = $("<textarea name=\'"+x.name+"\' "+attr+"></textarea>").appendTo($c).html(content[x.name])\n\t\t\t\t\t\tvar editor = CodeMirror.fromTextArea($textarea.get(0), {\n\t\t\t\t\t\t\t  lineNumbers: true,\n\t\t\t\t\t\t\t  lineWrapping: true,\n\t\t\t\t\t\t\t  mode:\'javascript\',\n\t\t\t\t\t\t\t  matchBrackets: true\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\teditor.setValue(content[x.name]);\t\n\t\t\t\t\t\teditor.clearHistory();    \n\t\t\t\t\t\tsetTimeout(function() {\n\t\t\t\t\t\t\teditor.refresh();\n\t\t\t\t\t\t},1);\n\n\t\t\t\t\t\t$c.bind(\'keyup\',function(editor,i,x) { return function(e)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t content[i] = editor.getValue();\n\t\t\t\t\t\t\t content.modified = true;\n\t\t\t\t\t\t\t content.update(x.name);  \n\t\t\t\t\t\t}}(editor,x.name,x));\n\n\n\t\t\t\t}\n\n\n\n\n\t\t\t\t\t\t        \n\t\t\t}\n\t\t\telse if (x.type == "input" )\n\t\t\t{ \n\t\t\n\t\t\t\t$c = $("<"+element+" class=\'KFormItem\'><label class=\'KFormItem_label\' for=\'"+x.name+"\' > "+thetitle+": </label></"+element+">")\n\t\t\t\t\n\t\t\t\tif (typeof(x.defaultval) === \'number\') \n\t\t\t\t\tx.data = [\'number\'];\n\t\t\t\tif (x.data == undefined) \n\t\t\t\t\tx.data = [\'text\'];\n\t\t\t    var attr = "";\n\t\t\t    \n\t\t\t    if (x.attribute != undefined)\n\t\t\t    \tattr = x.attribute;\n\t\t\t\t\n\t\t\t\tvar $input ;\n\t\t\t\n\t\t\t\tif (x.data[0] == \'text\')\n\t\t\t\t{\n\t\t\t\t\tvar style = "text"\n\t\t\t\t\tif (x.style == \'password\')\n\t\t\t\t\t style = "password";\n\t\t\t\t\t$input =$("<input type=\'"+style+"\'  name=\'"+x.name+"\' "+attr+">").appendTo($c).val(content[x.name])\n\t\t\t\t\t.on(\'keyup\',function(i,x) { return function(e){\n\t\t\t\t\t\t content[i] = $(e.currentTarget).val();\n\t\t\t\t\t\t content.modified = true;\n\t\t\t\t\t\t content.update(x.name);        \t\t\t\t\t \n\t\t\t\t\t\t } }(x.name,x));\n\t\t\t\t}\n\t\t\t\telse if ( x.data[0] == \'integer\' | x.data[0] == \'number\' )\n\t\t\t\t{\n\t\t\t\t\tif (x.style == \'slider\')\n\t\t\t\t\t{\n\t\t\t\t\t\t$input =\t$("<input name=\'"+x.name+"\' "+attr+" type=\'range\' min=\'"+x.data[1]+"\' max=\'"+x.data[2]+"\' /><span style=\'position:relative;top:-5px;padding:4px\'>"+content[x.name]+"</span>").appendTo($c).val(content[x.name])\n\t\t\t\t\t\t.on(\'input\',function(x) { return function(e){\n\t\t\t\t\t\t\t content[x.name] = $(e.currentTarget).val();\n\t\t\t\t\t\t\t $(e.currentTarget).next().text( content[x.name]);\n\t\t\t\t\t\t\t content.modified = true;\n\t\t\t\t\t\t\t content.update(x.name);        \t\t\t\t\t \n\t\t\t\t\t\t\t } }(x));      \n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\t\t$input =$("<input "+attr+" type=\'number\'  name=\'"+x.name+"\' min=\'"+x.data[1]+"\' max=\'"+x.data[2]+"\'>").appendTo($c).val(content[x.name])\n\t\t\t\t\t\t.on(\'change\',function(x) { return function(e){\n\t\t\t\t\t\t\t content[x.name] = $(e.currentTarget).val();\n\t\t\t\t\t\t\t content.modified = true;\n\t\t\t\t\t\t\t content.update(x.name);        \t\t\t\t\t \n\t\t\t\t\t\t\t } }(x));      \n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tvar valchanged = function($div) {return function(val)\n\t\t\t\t{\n\t\t\t\t\tif (document.activeElement != $div.get(0))\n\t\t\t\t\t{\n\t\t\t\t\t\t$div.val(val);\n\t\t\t\t\t// this is for the slider\n\t\t\t\t\t\t$div.next().text(content[x.name]);\n\t\t\t\t\t}\n\t\t\t\t}}($input)\n\t\t\t\tcontent.update.add(x, valchanged, $input);\n\n// \t\t\t\t$input.valchange = function(val)\n// \t\t\t\t{\n// \t\t\t\t\tthis.val(val);\n// \t\t\t\t\t// this is for the slider\n// \t\t\t\t\tthis.next().text(content[x.name]);\n// \t\t\t\t}\n// \t\t\t\tcontent.update.add(x, valchanged, $input);\n\t\t\t\t\n\n\n\t\t\t}\n\t\t\telse if (x.type == "option")\n\t\t\t{\n\t\t\t\tif(x.ids === undefined) \n\t\t\t\t\tx.ids = x.choices;\n\n \t   \t\t    if (content[x.name]==undefined )\n \t   \t\t    \tcontent[x.name] = x.ids[0];\n\n\t\t\t\t\t\n\t\t\t\tvar tempname = \'KFormID\' + (KForm.runningID++) + x.name;\t\n\t\t\t\tif (x.style == undefined) x.style = "";\n\t\t\t\tif (x.style.search("radio")>=0)\n\t\t\t\t{\n\t\t\t\t\t$c = $("<"+element+" class=\'KFormItem\'><label class=\'KFormItem_label\' for=\'"+x.name+"\' > "+thetitle+": </label></"+element+">")\n\n\t\t\t\t\tvar optlist = "";\n\t\t\t\t\tfor (var i = 0; i < x.choices.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar selected = "";\n\t\t\t\t\t\tif (x.ids[i] == content[x.name] ||  (content[x.name]==undefined && i==0))\n\t\t\t\t\t\t\tselected = "checked";\n\n\t\t\t\t\t\t// for radio choices in form arrays, this does not work. must have unique names !!!\n\t\t\t\t\t\toptlist += "<label><input type=\'radio\' name=\'"+tempname+"\' value=\'"+ x.ids[i] +"\' "+ selected +" />" + x.choices[i]  +"</label>"\n\t\t\t\t\t\tif (x.style.search("vert")>=0) optlist += "<br>";\n\t\t\t\t\t}\n\n\t\t\t\t\tvar $sel = $("  <div style=\'display:inline-block\'> "+ optlist +" </div> " ).appendTo($c).click(function(i,x) { return function(e)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\tvar opts = $(e.currentTarget).find("input");\n\t\t\t\t\t\t\t\tfor (var j = 0;j < opts.length;j++)\n\t\t\t\t\t\t\t\t\tif (opts[j].checked)\n\t\t\t\t\t\t\t\t\t\tcontent[i] = opts[j].value;\n\t\t\t\t\t\t\t\t content.modified = true;\n\t\t\t\t\t\t\t\t content.update(x.name);        \t\t\t\t\t \n\t\t\t\t\t\t\t  } }(x.name,x) );\t\t\t\t\n\t\t\t\t\t\n\t\t\t\t\tvar valchanged = function($div) {return function(val)\n\t\t\t\t\t{\n\t\t\t\t\t\t// uncheck all, and then set the one with val\n\t\t\t\t\t\t$div.find("input").prop(\'checked\', false);\n\t\t\t\t\t\t$div.find("input[value=\'"+val+"\']").prop(\'checked\', true);\n\t\t\t\t\t}}($sel)\n\t\t\t\t\tcontent.update.add(x, valchanged, $sel);\n\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\telse // combobox\n\t\t\t\t{\n\t\t\t\t\t$c = $("<"+element+" class=\'KFormItem\'><label class=\'KFormItem_label\' for=\'"+x.name+"\' > "+thetitle+": </label></"+element+">")\n\t\t\t\t\t//$c = $("<div class=\'KFormItem\'> "+ thetitle + " </div>");\n\t\t\t\t\t\n\n\t\t\t\t\tvar optlist = "";\n\t\t\t\t\tfor (var i = 0; i < x.choices.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar selected = "";\n\t\t\t\t\t\tif (x.ids[i] == content[x.name])\n\t\t\t\t\t\t\tselected = "selected";\n\t\t\t\t\t\toptlist += "<option value=\'"+ x.ids[i] +"\' "+ selected +">"+x.choices[i]+"</option>";\n\t\t\t\t\t}\n\t\t\t\t\tvar $sel = $("  <select f> "+ optlist +" </select>" ).appendTo($c).click(function(i,x) { return function(e)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\tcontent[i] =  $(e.currentTarget).find(\'option:selected\').val() ;\n\t\t\t\t\t\t\t\t content.modified = true;\n\t\t\t\t\t\t\t\t content.update(x.name); \n\t\t\t\t\t\t\t  } }(x.name,x) );\n\t\t\t\t\t\n\t\t\t\t\tvar valchanged = function($div) {return function(val)\n\t\t\t\t\t{\n\t\t\t\t\t\t// uncheck all, and then set the one with val\n\t\t\t\t\t\t$div.find("option").prop(\'selected\', false);\n\t\t\t\t\t\t$div.find("option[value=\'"+val+"\']").prop(\'selected\', true);\n\t\t\t\t\t}}($sel)\n\t\t\t\t\tcontent.update.add(x, valchanged, $sel);\n\n\n\t\t\t\t}\n\t\t\t}\n\n\t\t\telse if (x.type == \'rating\')\n\t\t\t{\n\t\t\t\t$c = $("<"+element+" class=\'KFormItem\' ssstyle=\'display:flex;\'><label class=\'KFormItem_label\' for=\'"+x.name+"\' > "+thetitle+": </label></"+element+">")\n\n\t\t\t\tvar $form = $("<div class=\'KFormItem_rating\'></div>").appendTo($c);\n\n\t\t\t\tvar $arr = $("<table></table>").appendTo($form);\n\t\t\t\tvar $head = $("<tr></tr>").appendTo($arr);\n\t\t\t\t$head.append($("<td><span></span></td"));\t\t\t\t\t\n\t\t\t\tfor (var t=0; t < x.ratings.length;t++)\n\t\t\t\t\t$head.append($("<td><span>"+x.ratings[t]+"</span></td"));\t\t\t\t\t\n\t\t\t\tvar rows = {};\n\t\t\t\tfor (var t=0; t < x.items.length;t++)\n\t\t\t\t{\n\t\t\t\t\tvar item =  x.items[t];\n\t\t\t\t\tvar tempname = \'KFormID\' + (KForm.runningID++) + x.name;\t\n\t\t\t\t\tvar $row = $("<tr></tr>").appendTo($arr)\n\t\t\t\t\t.click(function(n,t,x) { return function(e)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\tvar opts = $(e.currentTarget).find("input");\n\t\t\t\t\t\t\tfor (var j = 0;j < opts.length;j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (opts[j].checked)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t//content[n][t] = opts[j].value;\n\t\t\t\t\t\t\t\t\t// save by key, not as array!\n\t\t\t\t\t\t\t\t\tcontent[n][x.items[t]] = opts[j].value;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tcontent.modified = true;\t\n\t\t\t\t\t\t\t//content.update(x.name, t); \t\t\t\t    \t\t\t\t\t\n\t\t\t\t\t\t\tcontent.update(x.name,item); \t\t\t\t    \t\t\t\t\t\n\t\t\t\t\t\t  } }(x.name,t,x) );\n\t\t\t\t\t$row.append($("<td><span>"+x.items[t]+"</span></td"));\t\t\t\t\t\n\t\t\t\t\tfor (var i = 0; i < x.ratings.length;i++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar selected = "";\n\t\t\t\t\t\t//if (x.ratings[i] == content[x.name][t])\n\t\t\t\t\t\tif (x.ratings[i] == content[x.name][item])\n\t\t\t\t\t\t\tselected = "checked";\n\t\n\t\t\t\t\t\t$row.append("<td> <input type=\'radio\' name=\'"+tempname+"\' value=\'"+ x.ratings[i] +"\' "+ selected +"></td>")\n\t\t\t\t\t}\n\t\t\t\t\trows[item] = ($row);\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tvar valchanged = function($div) {return function(val, t)\n\t\t\t\t{\n\t\t\t\t// uncheck all, and then set the one with val\n\t\t\t\t\t$div[t].find(\'input\').prop(\'checked\', false);\n\t\t\t\t\t$div[t].find("input[value=\'"+val[t]+"\']").prop(\'checked\', true);\n\t\t\t\t}}(rows)\n\n\t\t\t\tcontent.update.add(x, valchanged, $arr );\n\t\t\t\t\n\n\t\t\t}\n\n\t\t\telse if (x.type == "check")\n\t\t\t{\t\n\t\t\t\tvar cid = Math.random() + x.name;\n\t\t\t\t$c = $("<"+element+" class=\'KFormItem\'><label class=\'KFormItem_label\' for=\'"+cid+"\' > "+thetitle+": </label></"+element+">")\n\t\t\t\tvar $check= $("<input type=\'checkbox\' name =\'"+x.name+"\' id=\'"+cid+"\'>").appendTo($c).prop(\'checked\', content[x.name]).on(\'change\',function(i,x) {return function(e)\n\t\t\t\t\t{ \n\t\t\t\t\tcontent[i] = $(e.currentTarget).prop("checked"); \n\t\t\t\t\tcontent.modified = true;\t\n\t\t\t\t\tcontent.update(x.name);     \t\t\t\n\t\t\t\t\t} }(x.name,x));\n\t\t\t\n\t\t\t\t\tvar valchanged  = function($div) {return function(val)\n\t\t\t\t\t{\n\t\t\t\t\t\t$div.prop(\'checked\', val);\n\t\t\t\t\t}}($check)\n\t\t\t\t\tcontent.update.add(x, valchanged, $check);\n\n\t\t\t}\n\n\t\t\tif ($c != undefined)\n\t\t\t{\n\t\t\t\tsetCSS($c,x.css);\t\n\t\t\t\t\n\t\t\t\tif (x.css_spec)\n\t\t\t\t{\n\t\t\t\t\tfor (var k in x.css_spec)\n\t\t\t\t\t{\n\t\t\t\t\t\tsetCSS($c.find(k),x.css_spec[k]);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t\t\t\t\n\t\t\t\tif (x.class)\n\t\t\t\t{\n\t\t\t\t\t$c.addClass(x.class);\n\t\t\t\t\t$c.children().addClass(x.class);\n\t\t\t\t}\n\n\t\t\t\tif (form.items)\n\t\t\t\t{\n\t\t\t\t\tsetCSS($c,form.items.css);\n\t\t\t\t\tif (form.items.class)\n\t\t\t\t\t{\n\t\t\t\t\t\t$c.addClass(form.items.class);\n\t\t\t\t\t\t$c.children().addClass(form.items.class);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\n\t\t\t\tif (x.tooltip)\n\t\t\t\t{\n\t\t\t\t\t$c.attr(\'data-toggle\',\'tooltip\');\n\t\t\t\t\t$c.attr(\'title\',x.tooltip);\n\t\t\t\t}\n\t\t\t\tif (x.name)\n\t\t\t\t\t$c.attr(\'name\',x.name);\n\t\t\t\tif(shortcutid !="")\t\n\t\t\t\t\t$c.attr(\'shortcutid\', shortcutid )\n\n\t\t\t\t$c.appendTo($targetdiv);\n\t\t\t}\n\t\t}\n \t}\n\n\n\tfunction setCSS($c,css)\n\t{\t\n\t\tif ($c == undefined)\n\t\t\treturn\n\t    if (css)\n\t\t{\n\t\t\tfor (var i = 0; i < css.length;i+=2)\n\t\t\t\t$c.css(css[i],css[i+1]);\n\t\t}\n\t}\n\n\n\t\t/***************************************************************************************\n\t\t*  Updater\n\t\t****************************************************************************************/\n\n\t\tfunction attachUpdater(obj, onchange)\n\t\t{\n\t\t  // the object already has an updater. Reset to the "onchange" function and return\n\t\t  if (obj.update != undefined)\n\t\t  {\n\t\t\t if(onchange != undefined)\n\t\t\t\tobj.update.onchange = onchange;\n\t\t  \t return;\n\t\t  }\n\n\n\t\t  function Update(field, varargin)\n\t\t  {\n\t\t\t this.update.broadcast(field,this[field], varargin);\n\t\t  }\n\n\t\t  // varargin is needed for example for rating to define a row\n\t\t  Update.broadcast = function(field,val, varargin)\n\t\t  {\n\t\t  \t if (val == undefined) // undefinded value might cause error in jquery value=\n\t\t  \t\tval = "";\n\t\t\t for (var k = 0;k < Update.funlist.length; k++ )\n\t\t\t\tif (Update.funlist[k].field == field)\n\t\t\t\t  Update.funlist[k].fun(val, varargin);\n\t\t\t  \n\t\t\t  if(Update.onchange)\n\t\t\t  \t\tUpdate.onchange(obj, field, val);\n\t\t  }\n\n\t\t  Update.add = function(x,fun, $element)\n\t\t  {\n\t\t\tUpdate.funlist.push({field:x.name,fun:fun});\n\t\t\t\n\t\t\t// set the remover already here when adding an updater.\n\t\t\tif($element != undefined)\n\t\t\t{\n\t\t\t\t$element.bind(\'destroyed\', function() { \n\t\t\t\tobj.update.remove(fun); \n\t\t\t\t//console.log( obj );  \n\t\t\t\t//console.log( $element.val() );  \n\t\t\t\t});\n\t\t\t}\n\n\t\t  }\n\t\t  \n\t\t  Update.remove = function(fun)\n\t\t  {\n\t\t\t for (var k = 0;k < Update.funlist.length; k++)\n\t\t\t\tif (Update.funlist[k].fun == fun)\n\t\t\t\t{\n\t\t\t\t\tUpdate.funlist.splice(k,1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t  }\n\n\t\t  Update.funlist = [];\n\t      obj.update = Update;\n\n\t\t  if(onchange != undefined)\n\t\t  \tobj.update.onchange = onchange;\n\n\n\n\t\t  return obj;\n\n\t\t}\n\n\n\n\n\tcreateForm_rec(form0,content0,$targetdiv0)\n\n\n}\n\n\nKForm.createFormHTML = function (form0,content0,$targetdiv0,onchange)\n{\n\n\tfunction setContent(element)\n\t{\n\t\tvar e = $(element.target);\n\t\tvar id = e.attr("id");\n\t\tvar value = e.val();\n\t\tcontent0[id] = value;\n\t\t\n\t\tonchange();\n\t}\n\n\n\tvar $page = $(form0.html);\n\t$page.appendTo($targetdiv0);\n\tvar inputs = $page.find("input,textarea,select");\n\tfor (var k = 0; k < inputs.length;k++)\n\t{\n\t\t$(inputs[k]).val(content0[$(inputs[k]).attr("id")]);\n\t\t$(inputs[k]).on("input",setContent);\n\n\t}\n}\n\n\n\nKForm.getFormContentHTML = function(form,obj)\n{\n\tif (obj == undefined)\n\t   obj = {KForm_name:form.name, html:true};\n\t\n\tvar $page = $(form.html);\n\tvar inputs = $page.find("input,textarea,select");\n\tfor (var k = 0; k < inputs.length;k++)\n\t\tif (obj[$(inputs[k]).attr("id")] == undefined)\n\t\t\tobj[$(inputs[k]).attr("id")] = $(inputs[k]).val();\n\n\n\treturn obj;\n}\n\n/***************************************************************************************\n*  find by type, name or ...\n****************************************************************************************/\nKForm.findFormItem = function(form, how, search)\n{\n\tvar out = [];\n\n\tfunction find_rec(layout)\n\t{\n\t\tfor (var k =0;k < layout.length;k++)\n\t\t{\n\t\t\tif(layout[k][how] == search)\n\t\t\t\tout.push(layout[k].name)\n\t\t\t\n\t\t\tif(layout[k].layout !== undefined)\n\t\t\t\tfind_rec(layout[k].layout);\n\t\t\telse if(layout[k].form !== undefined)\n\t\t\t\tfind_rec(layout[k].form.layout);\n\t\t}\n\n\t}\n\tfind_rec(form.layout)\n\treturn out;\n\n}\n\n\n/***************************************************************************************\n*  Get form content \n****************************************************************************************/\nKForm.getFormContent = function(form,obj)\n{\n\tif (form.html)\n\t\treturn KForm.getFormContentHTML(form,obj);\n\n\tif (obj == undefined)\n\t   obj = {KForm_name:form.name};\n\tfor (var k =0;k < form.layout.length;k++)\n\t{\n\t\tif ( form.layout[k] != undefined && obj[form.layout[k].name] == undefined )\n\t\t{\n\t\t\tif( form.layout[k].type== \'markerpoint\')\n\t\t\t{\n\t\t\t\tif( markerProxy.currentSet )// form.layout[k].forReading)\n\t\t\t\t{\n\t\t\t\t\t// re-use the same markerset form this form\n\t\t\t\t\tif(markerProxy.currentSet)\n\t\t\t\t\t{\n\t\t\t\t\t\t//var mset = markerProxy.currentSet;\n\t\t\t\t\t\tvar point = markerProxy.createMarker()\n\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t// create a new markerset\n\t\t\t\t\tvar mset = new KMarkerset(\'M0\');\n\t\t\t\t\tvar point = mset.addpoint();\n\t\t\t\t}\n\t\t\t\t// this is the pointer to the "full" point, i.e. all point properties\n\t\t\t\t// must be deep copied and entschlacked before saving\n\t\t\t\tobj[form.layout[k].name]  = point;\n\t\t\t}\n\t\t\telse // a native type\n\t\t\t{\n\t\t\t\tvar dval = form.layout[k].defaultval;\n\t\t\t\tif( dval != undefined )\n\t\t\t\t{\n\t\t\t\t\t// rating, convert to struct\n\t\t\t\t\tif(form.layout[k].type == "rating")\n\t\t\t\t\t{\n\t\t\t\t\t\tobj[form.layout[k].name] = {};\n\t\t\t\t\t\tfor(var u=0; u<dval.length; u++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tobj[form.layout[k].name][form.layout[k].items[u]] = dval[u];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tobj[form.layout[k].name] = dval;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// conditional default val (mostly for readings etc )\n\t\t\t\tif( form.layout[k].defaultvalif != undefined )\n\t\t\t\t{\n\t\t\t\t\tfor(var z=0; z<form.layout[k].defaultvalif.length-1 ; z+=2)\n\t\t\t\t\t{\n\t\t\t\t\t\ttry\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar expr = "KViewer.readingTool.ccase." + form.layout[k].defaultvalif[z] ;\n\t\t\t\t\t\t\tif( eval(expr) )\n\t\t\t\t\t\t\t\tobj[form.layout[k].name] =  form.layout[k].defaultvalif[z+1];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcatch(err)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tconsole.log(err);\n\t\t\t\t\t\t\talertify.alert(\'An error occured in the forms `defaultvalif:`   \' + expr + err)\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t}\n\n\t\tif (form.layout[k] != undefined && form.layout[k].type == \'form\' )\n\t\t{\n\t\t\tif (obj[form.layout[k].name] == undefined)\n\t\t\t\tobj[form.layout[k].name] = {};\n\t\t\tKForm.getFormContent(form.layout[k],obj[form.layout[k].name]);\n\n\t\t}\n\t}\n\treturn obj;\n}\n\n\n/***************************************************************************************\n*  Get a random form content (mostly for testing reading, teaching)\n****************************************************************************************/\nKForm.getFormContentRandom = function(form,obj)\n{\n\tif (form.html)\n\t\treturn KForm.getFormContentHTML(form,obj);\n\n\tif (obj == undefined)\n\t   obj = {KForm_name:form.name};\n\tfor (var k =0;k < form.layout.length;k++)\n\t{\n\t\tif ( obj[form.layout[k].name] == undefined )\n\t\t{\n\t\t\t// only radio type implemented so far\n\t\t\tif(form.layout[k].ids)\n\t\t\t{\n\t\t\t\tvar numanswers = form.layout[k].ids.length;\n\t\t\t\tvar ind = Math.floor( Math.random()*(numanswers-.0001) );\n\t\t\t\tobj[form.layout[k].name] = form.layout[k].ids[ind];\n\t\t\t}\n\t\t\telse if( form.layout[k].defaultval != undefined )\n\t\t\t\tobj[form.layout[k].name] = form.layout[k].defaultval\n\t\t}\n\n\t\tif (form.layout[k].type == \'form\' )\n\t\t{\n\t\t\tif (obj[form.layout[k].name] == undefined)\n\t\t\t\tobj[form.layout[k].name] = {};\n\t\t\tKForm.getFormContentRandom(form.layout[k],obj[form.layout[k].name]);\n\n\t\t}\n\t}\n\treturn obj;\n}\n\n\n\n\n/***************************************************************************************\n*  check empty fields\n****************************************************************************************/\nKForm.checkEmptyFields = function($form, highlight)\n{\n    var names = new Array();\n    var nonFilled = new Array();\n\tvar highlighcolor = \'rgba(180,0,0,1)\';\n\t// unset highlight first\n\n    $form.find("input[type=\'radio\']").each( function(k, e)\n    {\n      if($(e).css(\'display\') == \'none\') return; // return for hidden elements\n      var tname = $(e).attr(\'name\');\n      if(names.indexOf(tname) == -1)\n      {\n        if(highlight)   $form.find("label[for=\'"+tname+"\']").css( \'background\', \'\');\n        names.push(  $(e).attr(\'name\') );\n        var row = $form.find("input[type=\'radio\'][name=\'"+tname+"\']:checked");\n        if(row.length == 0 )\n        {\n          nonFilled.push(tname);\n          if(highlight)   $form.find("label[for=\'"+tname+"\']").css( \'background\', highlighcolor);\n        }\n      }\n    });\n\t\n    $form.find("input[type=\'text\']").each( function(k, e)  \n    { \n\t    var tname = $(e).attr(\'name\');\n        if(highlight)  $form.find("label[for=\'"+tname+"\']").css( \'background\', \'none\');\n    \tif( $.trim(this.value) === "" )\n    \t{\n           nonFilled.push(tname);\n           if(highlight)  $form.find("label[for=\'"+tname+"\']").css( \'background\', highlighcolor);\n    \t}\n\n    });\n\n\n\tif(nonFilled.length > 0)\n\t\treturn false;\n\telse\n\t\treturn true;\n\n}\n\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= KFormManager\n// ======================================================================================\n// ======================================================================================\n\n\nfunction KFormManager(master)\n{\n\t/** Managing forms\n\t* @class \n\t* @alias KFormManager\n\t* @augments KToolWindow\n\t*/\n\tvar that = new KToolWindow(master,\n\t$("<div class=\'KView_tool \'><i class=\'fa fa-file-text fa-1x\'></i></div>")\n\t.append( $("<ul class=\'KView_tool_menu\'></ul>").append($("<li>Forms</li>")) ) );\n\n\tthat.name = \'Forms\';\n\n    that.$topRow.addClass("FormTool_topmenu");\n\n\tvar formman = master.formManager;\n\n\tvar $menu = $("<ul></ul>");\n\tvar sel = state.viewer.forms_autosave?"-dot":"";\n\tvar $autosave = $("<li> <a> Autosave</a>  <i class=\'fa fa"+sel+"-circle-o\'></i></li>").click(function(){\n\t\t$autosave.find(".fa").toggleClass("fa-dot-circle-o").toggleClass("fa-circle-o");\n\t\tstate.viewer.forms_autosave = !state.viewer.forms_autosave\n\t}  ).appendTo($menu);\n\tvar sel = state.viewer.forms_user_specific_naming?"-dot":"";\n\tvar $userspecname = $("<li> <a> User specific naming </a> <i class=\'fa fa"+sel+"-circle-o\'></i></li>").click(function(){\n\t\t$userspecname.find(".fa").toggleClass("fa-dot-circle-o").toggleClass("fa-circle-o");\n\t\tstate.viewer.forms_user_specific_naming = !state.viewer.forms_user_specific_naming\n\n\t}  ).appendTo($menu);\n\n\tthat.$topRow.append($("<li  ><a>Forms</a></li>").append($menu) );\n\t\n\n\n\n  var $innerDIV = $("<div ondragover=\'event.preventDefault();\' class=\'annotation_tool_listDIV\'></div>").appendTo(that.$container);\n  var $table = $("<table  class=\'localfiletable\'></table>").appendTo($innerDIV);\n  var $help = $("<div  class=\'\'>Drag a form into the viewer to fill out.</div>").appendTo($innerDIV);\n  $innerDIV.on("drop",function(e)\n  {\n    e.preventDefault();\n    var params = getloadParamsFromDrop(e.originalEvent,undefined);\n\n  });\n\n  that.resize = function(hei)\n  {\n      that.$container.height(hei);\n      $innerDIV.height(hei-that.$container.find(\'.KToolsTopMenu\').height());\n      \n  }\n\n\t/***************************************************************************************\n\tFind the correct form for dropped file (if form was dropped, new "file" is generated)\n\t****************************************************************************************/\t\t\n\tthat.getFormByID = function(name)\n\t{\t \n\t\tfor (var k=0;k< that.forms.length;k++)\n\t\t{\n\t\t\tvar form = that.forms[k].content;\n\t\t\tif (that.forms[k].id == name || form.name.toLowerCase() == name.toLowerCase()   ) // comparison by name or id\n\t\t\t{\n\t\t\t\tvar tform = $.extend(true, {}, form);\n\t\t\t\treturn form;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\tthat.getForm = function(name,content)\n\t{\t \n\t\tfor (var k=0;k< that.forms.length;k++)\n\t\t{\n\t\t\tvar form = that.forms[k].content;\n\t\t\tif (form.name.toLowerCase() == name.toLowerCase()) // comparison by id\n\t\t\t{\n\t\t\t\tvar newcontent = KForm.getFormContent(form,content);\n\t\t\t\treturn {form: form, content: newcontent, formid: k};\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n\n\tthat.getIndexFromName = function(name)\n\t{\t \n\t\tfor (var k=0;k< that.forms.length;k++)\n\t\t{\n\t\t\tif (that.forms[k].name == name)\n\t\t\t{\n\t\t\t\treturn k;\n\t\t\t}\n\t\t}\n\t\treturn undefined;\n\t}\n\n \n\tvar psidforms = KForm.PSIDForm();\n\n\tfunction setDefaultForms()\n\t{\n\t\tthat.forms = [ \t{id:"X01", iswritable:false, content: psidforms[0]}, \n\t\t\t\t\t\t{id:"X02", iswritable:false, content: psidforms[1]} ,\n\t\t\t\t\t\t{id:"X03", iswritable:false, content: psidforms[2]}  ];\n\n        var cnt = 4;\n\t\tfor (var key in static_info.forms)\n\t\t  {\n\t\t\t\n\t\t\t  if (key.search(\'\\\\.html\')>-1)\n\t\t\t  {\n\t\t\t\t  var x = static_info.forms[key];\n\t\t\t  \t  key = key.replace(\'.html\',\'\');\n\t\t\t\t  var y = {id:"X0"+cnt,iswritable:false,html:true,content:{name:key,html:x},name:key};\n\t\t\t\t  that.forms.push(y);\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t  eval(\'var x = \' + static_info.forms[key].replace(/\\\\\\\\"/g,\'\'));\n\t\t\t\t  var y = {id:"X0"+cnt,iswritable:false,content:x,name:key};\n\t\t\t\t  that.forms.push(y);\n\t\t\t  }\n\t\t\t  cnt = cnt + 1;\n\t\t  }\n\n\t}\n\tsetDefaultForms()\n\n\n\t/***************************************************************************************\n\tLoad form list from server\n\t****************************************************************************************/\n\tvar formsLoadedFirstTime = false;\n\tthat.updateListFromServer = function(callback)\n\t{\n\t\twindow.setTimeout(function(){\n\t\tjsonTable_loadFormattedList(\'form\', function(res)\n\t\t{\n\t\t\tsetDefaultForms();\n\n\t\t\tfor(var id in res)\n\t\t\t\tthat.forms.push(res[id])\n\t\t\tthat.update();\n\t\t\tthat.loadedFromServer = true;\n\t\t\tif(callback)\n\t\t\t{\n\t\t\t\tcallback()\n\t\t\t}\n\t\t});\n\t\t},200);\n\t}\n\t\n\t\n\t/***************************************************************************************\n\tThe form template elements\n\t****************************************************************************************/\n\tvar tttemplate = KForm.templates();\n\tvar genericForm = {\n\t\t\t\t\t\ttype: "form",\n\t\t\t\t\t\tcontent: tttemplate.basis,\n\t\t\t\t\t\tid :"0",\n\t\t\t\t\t\tiswritable:false\n\t\t\t\t\t  };\n\n\n\tthat.$topRow.append(  $("<li style=\'fffffloat:right\'><a><i class=\'fa fa-pencil\' ></i> New Form </a></li>").click(  function() {copyElement(genericForm);} ) );\n\t\n\n\t/***************************************************************************************\n\tcopyElement\n\t****************************************************************************************/\n\tfunction copyElement(fromwhich)\n\t{\n\n\t\tif(fromwhich == undefined)\t\n\t\t\tfromwhich = genericForm;\n\t\t\n\t\tfromwhich.type = \'form\';\t// important for old objects. Type is needed.\n\t\tjsonTable_copyElement(fromwhich, function(newobj)\n\t\t{\n\t\t\tif(newobj instanceof Object)\n\t\t\t{\n\t\t\t\tthat.forms.push(newobj);\n\t\t\t\tthat.update();\n\t\t\t\tnew KFormDesigner(newobj);\n\t\t\t}\n\t\t})\n\t}\n\tthat.createNewForm = copyElement;\n\n\t\n\n\t/***************************************************************************************\n\tthat.update\n\t****************************************************************************************/\n\tthat.update = function()\n\t{\n\t\t$table.children().remove();\n\t\t//    var fields = [\'id\', \'name\', \'iswritable\', \'project\']\n\n\t\tvar $thead = $("<thead>").appendTo($table);\n\t\tvar $row = $("<tr ></tr>").appendTo($thead);\n\t\t$row.append($("<td>id </td>"));\n\t\t$row.append($("<td>name </td>"));\n\t\t//$row.append($("<td>iswritable</td>"));\n\t\t$row.append($("<td>project</td>"));\n\t\t$row.append($("<td class=\'fixedwidth\' data-fixedwidth=\'6\'></td>"));\n\n\t\tvar $tbody = $("<tbody>").appendTo($table);\n\t\tvar forms = that.forms;\n\t\t\n\t\t// start from index 3 (omit patient forms)\n\t\t\n\t\tfor  (var k = 3;k<forms.length;k++)\n\t\t{\n\t\t\tvar dragstuff = "draggable=\'true\' data-type=\'file\' data-piz=\'\' data-sid=\'\' data-tag=\'/FORM/\' data-fileID=\'"+forms[k].content.name+"\' data-subfolder=\'\' data-filename=\'\' data-mime=\'emptyform\'";\n\t\t\t// should work with ids in future: set data-fileID to form id\n\t\t\t\n\t\t\tdragstuff = dragstuff + " ondragstart=\'setdragstart(event);\' ondragend=\'setdragend(event);\' ondblclick=\'loadDataOndblClick(event);\'";\n\t\t\t\n\t\t\tvar $row = $("<tr class=\'formtable\' " + dragstuff + "></tr>").appendTo($tbody);\n\n\t\t\t$row.on("contextmenu", function (ev) { formContextMenu(ev); });\n\t\t\t$row.append($("<td>" + forms[k].id + "</td>"));\n\t\t\t$row.append($("<td>" + forms[k].content.name + "</td>"));\n\t\t\t//$row.append($("<td>" + forms[k].iswritable + "</td>"));\n\t\t\t$row.append($("<td>" + forms[k].content.project + "</td>"));\n\n\t\t\tvar addstyle = (forms[k].iswritable == true)?(""):("style=\'color:hsl(0,0%,80%)\'")\n\t\t\t$row.append($("<td> <i "+addstyle+"class=\'tablebutton fa fa-fw  fa-wrench\'></td>").click(function(k) { return function(e) \n\t\t\t{ \n\t\t\t\tif(forms[k].iswritable != true)\n\t\t\t\t{\n\t\t\t\t\talertify.error(\'You do not have the permission to change this form.\');\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tnew KFormDesigner(forms[k]);\n\t\t\t\t}\n\t\t\t} }(k) ) ).appendTooltip(\'changeFormDesign\');\n\n\t\t}    \n\t\tthat.attachTableOperator($table.parent());\n\t}\n\n  that.save = function(formtype,content,fileinfo,onsuccess)\n  {\n\t  if (formtype == \'patientinfo\' | formtype == \'studyinfo\' | formtype == \'patientstudyinfo\'  )\n\t  {\n\t     var obj = {piz:fileinfo.patients_id, sid:\'%\', content:content.content};\n\t   //  obj = content.content;\n\t     if (formtype == \'studyinfo\' | formtype == \'patientstudyinfo\' )\n\t         obj.sid = fileinfo.studies_id;\n\t     if (formtype == \'patientinfo\')\n\t     {\n\t\t\tdelete obj.content.Series;\n\t\t\tdelete obj.content.StudyID;\n\t\t\tdelete obj.content.StudyDate;\n\t\t\tdelete obj.content.StudyDescription;\n\t\t\tdelete obj.content.StudyInstanceUID;\n\t\t\tdelete obj.content.StudyTime;\n\t     }\n\t           \n         var json = encodeURIComponent(JSON.stringify(obj));\n         ajaxRequest(\'command=save_patientinfo_studyinfo&json=\' + json , function(e)\n           {\n           \t  renderPatientTable();              \n              if (onsuccess)\n                 onsuccess(e);\n           });\n\t  }\n\t  else \n\t  {\t  \n\t\t  delete content.modified;\n\t\t  var finfo = {subfolder:\'\',tag:\'/FORM/\',subfolder:\'forms\'};\n\t\t  if (fileinfo)\n\t\t  \tfinfo = $.extend(finfo,fileinfo);\n\n\t\t  // set this again here, might have gotten lost\n\t\t  content.KForm_name = formtype;\n\t\t  // must work with ids\n\t\t  \n\n\t\t  var name = formtype;\n\t\t  if (state.viewer.forms_user_specific_naming)\n\t\t\t  name += "." + userinfo.username;\n\n\t\t  uploadJSON(name,content,finfo,function(r)\n\t\t  {\n\t\t\tif (onsuccess)\n\t\t\t\tonsuccess(r);\n\t\t\t\n\t\t  });\t\n\t  }\n  }\n\n\n\n  var formContextMenu = KContextMenu(\n  function(ev) {\n\n      var target = ev.target;\n      for (var k = 0;k< 3;k++)\n      {\n        if ($(target).is("tr"))\n           break;\n        target = $(target).parent();\n      }\n      prepObjectInfo(target);\n\n\n      var $menu = $("<ul class=\'menu_context\'>")\n\n      $menu.append($("<li onchoice=\'save\' >save</li>"));\n      $menu.append($("<li onchoice=\'open\' >open</li>"));\n      $menu.append($("<li onchoice=\'edit\' >edit form</li>"));\n\n      return $menu;\n  },\n  function (str,ev)\n  {\n      var k = that.getIndexFromName(tempObjectInfo[0].fileID);\n      if (str=="save")\n      {\n      \tthat.save(that.forms[k].name,that.content[k], function() {\n\t\t\t  delete that.content[k].modified;\n\t\t\t  that.update(); });\n      } else if (str=="open")\n      {\n      \t KViewer.viewports[0].openFile({fileID:that.forms[k].name, URLType: \'form\'});\n      } \n      else if (str=="edit")\n      {\n      \t \n      } \n  });\n\n\n\n\n\n\tthat.updateListFromServer()\n\tsignalhandler.attach(\'projectchanged\', that.updateListFromServer);\n\treturn that;\n}\n\n\n\n\n\n\n\n\n/***************************************************************************************\nmyJSONStringify\n****************************************************************************************/\nfunction myJSONStringify(obj,indent,level)\n{\n\t/*\n\t\tthis is a "lazy" stringify function.\n\t\tit creates a JSON-like string from a javascript object, a:{b:"2"}\n\t\tunlike "true" json\n\t\t\t- variable names are NOT quoted\n\t\t\t- \\ is NOT escaped as doubleslash\n\t*/\n\tindent = indent || "";\n\tif (obj == undefined)\n\t\treturn "undefined";\n\t\t\n\tvar indentOld = indent;\n\tvar str = "";\n\tvar newline = "\\n";\n\tif (obj instanceof Array)\n\t{\n\t\t\n\t\t// line break for arrays of objects\n\t\tif(obj.length > 0 & obj[0] instanceof Object)\n\t\t{\n\t\t\t// leave brackets for first level. but must remember type (object / array ) in caller then.\n\t\t\tif(level !== 0)\n\t\t\t{\n\t\t\t\tindent += "\\t";\n\t\t\t\tstr += newline + indentOld + "[" ;\n\t\t\t}\n\t\t\tfor (var k=0;k <obj.length;k++)\n\t\t\t{\n\t\t\t\tstr += indent + myJSONStringify(obj[k],indent) + ",";\n\t\t\t}\n\t\t\tstr = str.substring(0,str.length-1); // remove last comma\n\t\t\tif(level !== 0)\n\t\t\t\tstr += newline +indentOld +"]";\n\t\t}\n\t\telse \n\t\t{\n\t\t\t// leave brackets for first level. but must remember type (object / array ) in calling function then.\n\t\t\tif(level !== 0)\n\t\t\t\tstr += "" + \'[\' + " ";\n\t\t\tfor (var k=0;k <obj.length;k++) // is actually only one\n\t\t\t{\n\t\t\t\tstr += myJSONStringify(obj[k],indent,1) + ",";\n\t\t\t}\n\t\t\tstr = str.substring(0,str.length-1);\n\t\t\tif(level !== 0)\n\t\t\t\tstr += "" + \']\';\n\n\t\t}\n\t}\n\telse if (obj instanceof Object)\n\t{\n\t    len = Object.getOwnPropertyNames(obj).length;\n\t\t// always line breaks for objects\n\t\tif(len == 0)\n\t\t{\n\t\t\tstr += "{}";\n\t\t\t//str += newline;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(level !== 0)\n\t\t\t{\n\t\t\t\tindent += "\\t";\n\t\t\t\tstr += newline + indentOld + "{" +newline ;\n\t\t\t}\n\n// \t\t\tstr += newline;\n// \t\t\tstr +=  indentOld + "{";\n// \t\t\tindent += "\\t";\n\t\t\tvar nitems = Object.getOwnPropertyNames(obj).length;\n\t\t\tvar count=0;\n\t\t\tfor (var k in obj)\n\t\t\t{\n\t\t\t\tif( typeof obj[k] === "function")\n\t\t\t\t\tcontinue;\n\t\t\t\tcount++;\n\t\t\t\tstr += (count!=1?newline:"") +indent + k + ":" + myJSONStringify(obj[k],indent,1) + ",";\n\t\t\t}\n\t\t\tstr = str.substring(0,str.length-1);\n\t\t\t//str += newline;\n\t\t\tif(level !== 0)\n\t\t\t\tstr += newline +indentOld +"}";\n\t\t}\n\t\t/*\n\t\telse\n\t\t{\n\t\t\tstr += "" + "{" + " ";\n\t\t\tfor (var k in obj) // is actually only one\n\t\t\t{\n\t\t\t\tstr += k + ":" + myJSONStringify(obj[k],indent) + ",";\n\t\t\t}\n\t\t\tstr = str.substring(0,str.length-1);\n\t\t\tstr += " " + \'}\';\n\t\t}\n\t\t*/\n\t}\n\telse if (typeof(obj) == \'string\')\n\t{\n\t\tstr = "\\"" + obj.toString().replace(/\\n/g, " ").replace(/\\"/g, \'\\\\"\')   + "\\"";\n\t}\n\telse if (typeof(obj) == \'number\')\n\t{\n\t\t\tstr = obj.toString();\n\t}\n\telse if (typeof(obj) == \'boolean\')  // make bools numbers\n\t{\n\t\t\tstr = (obj*1).toString();\n\t}\n\n\t\n\t//console.log(obj);\n\treturn str;\n\n}\n\n\nfunction KFormTester()\n{\n\tvar templateform =\n    { \n      tag: "FORM",\n      name : "my first reading form  #666",\n      editor : "mr. X",\n      lastchange : "jan2016",\n      layout:\n      [ \n\t\t  { type: \'formarray\',  name:"otherarray", title:\'mysubform\', createbutton:\'Add new item\',  \n\t\t\t\t\t\t\t layout: \n\t\t\t\t\t\t\t [\n\t\t\t\t\t\t\t   { type: \'markerpoint\',  name:"mypoint", title: "",\n\t\t\t\t\t\t\t     \'form\':{ \n\t\t\t\t\t\t\t       name:"pointreading", title:\'mysubform\',\n\t\t\t\t\t\t\t       layout:[\n                                            {type: \'option\', name:"myoption",  title: "some option", \n                                            style:"radio vert", \n                                            tooltip:"here give some help",\n                                            choices: ["sure","not so sure", "maybe"], \n                                            ids: ["0","1","2"] , \n                                            defaultval:"" \n                                            }\n                                      ]\n\t\t\t\t\t\t\t     }\n\t\t\t\t\t\t\t     \n\t\t\t\t\t\t\t   }\t\t\t\t\t\t\t    \n\t\t\t\t\t\t\t ]\n\t\t  },\n          { type: \'__markerpoint\',  name:"superpoint",   title: "Markerpoint fixed" },\n          { type: \'option\', name:"myoption",  title: "some option", \n                          style:"radio", \n                          tooltip:"here give some help",\n                          choices: ["never","always", "maybe"], \n                          ids: ["0","1","2"] , \n                          defaultval:"1" },\n          { type: \'option\', name:"myoption2", title: "more options", \n                          style:"radio vert",\n                          choices: ["Multiple Sclerosis","Schizophrenia","no idea"], \n                          ids: ["0","1","2"] , \n                          defaultval:"1" },\n\n          { type: \'rating\',  name:"myrate",   title: "tumor grading", \n                          ratings:[\'low\',\'med\',\'high\',\'severe\'],                                 \n                          items:[\'CC\',\'IFO\',\'AF\',\'OR\',\'SLF\'],\n                          defaultval:[\'low\',\'low\',\'med\',\'high\',\'low\']},\n          { type: \'separator\'},\n          { type: \'placeholder\', id: "markers" },\n          { type: \'input\',  name:"myinput",   title: "some text",  \n                          defaultval: "good"},\n          { type: \'input\',  data: [\'integer\',0,10] , name:"myint",   title: "some number",  \n                          defaultval: "410"},\n          { type: \'input\',  data: [\'integer\',0,10] , style:\'slider\', name:"myint2",   title: "some slider",  \n                          defaultval: "0"},\n          { type: \'option\', name:"myoption3", title: "Select some", \n                          choices: ["Cold coffe","Politics","Beach","Pizza"], \n                          ids: ["0","1","2","3"] , \n                          defaultval:"0" },\n          { type: \'check\',  name:"mycheck",   title: "checkbox!", defaultval:true },\n       ]\n    } \n\t\n\t//KFormTester.content = KFormTester.content || KForm.getFormContent(templateform, {});\n\tKFormTester.content =  KForm.getFormContent(templateform, {});\n\n\tvar $p1 = dialog_generic();    $p1.$frame.show().width(300).css(\'left\', 400);\n\tvar $p2 = dialog_generic();    $p2.$frame.show().width(300).css(\'left\', 10);\n    \n\t// first form\n    KForm.createForm(templateform, KFormTester.content, $p2.$container,  function($c){console.log("Onchange function: p1----------");console.log($c)});\n\n\t// second form\n    KForm.createForm(templateform, KFormTester.content, $p1.$container,  function($c){console.log("Onchange function: p2----------");console.log($c)});\n\nvar that = new Object();\nthat.$p1 = $p1;\nthat.$p2 = $p2;\n\n\n\n\n$($p2.$container).bind(\'destroyed\', function() \n{\n  \tconsole.log("afr");\n})\n\nreturn that;\n}\nKFormTester.content = {};\n\n\n/***************************************************************************************\n*  Allow a remove handler to jQuery objects.\nSet with $obj.bind(\'destroyed\', function() {});\n****************************************************************************************/\n/*\n(function($){\n  $.event.special.destroyed = {\n    remove: function(o) {\n      if (o.handler) {\n        o.handler()\n      }\n    }\n  }\n})(jQuery)\n*/\n\n\n/***************************************************************************************\n*  Template example objects for copy and past\n****************************************************************************************/\nKForm.templates = function()\n{\n\ttemplates = new Object();\n\t\n\ttemplates.basis = \n\t{ \n\t  tag: "FORM",\n\t  name : "untitled",\n\t  editor : "nora",\n\t  lastchange : "jan2016",\n\t  layout: [  ]\n\t}\n\n\ttemplates.subbform =\n\t{ \n\t\ttype: \'formarray\',  \n\t\tname:"otherarray", \n\t\ttitle:\'mysubform\', \n\t\tcreatebutton:\'Add new subform\',  \n\t\tlayout: [ ]\n\t }\n\n\ttemplates.markerpoint =\n\t{ \n\t\ttype: \'markerpoint\',  \n\t\tname:"superpoint",   \n\t\ttitle: "Markerpoint fixed" \n\t}\n\n\ttemplates.radio =\n\t{ type: \'option\', name:"myoption",  title: "some option", \n\t\t\t\t\t  style:"radio", \n\t\t\t\t\t  tooltip:"here give some help",\n\t\t\t\t\t  choices: ["never","always", "maybe"], \n\t\t\t\t\t  ids: ["0","1","2"] , \n\t\t\t\t\t  defaultval:"1" \n\t}\n\t\n\ttemplates.radiovert =\n\t{ \n\t\ttype: \'option\', name:"myoption2", title: "more options", \n\t\t\t\t\t  style:"radio vert",\n\t\t\t\t\t  choices: ["Multiple Sclerosis","Schizophrenia","no idea"], \n\t\t\t\t\t  ids: ["0","1","2"] , \n\t\t\t\t\t  defaultval:"1" \n\t}\n\n\ttemplates.rating =\n\t{ \n\t\ttype: \'rating\',  name:"myrate",   title: "tumor grading", \n\t\t\t\t\t  ratings:[\'low\',\'med\',\'high\',\'severe\'],                                 \n\t\t\t\t\t  items:[\'CC\',\'IFO\',\'AF\',\'OR\',\'SLF\'],\n\t\t\t\t\t  defaultval:[\'low\',\'low\',\'med\',\'high\',\'severe\']\n\t}\n\n\ttemplates.combo =\n    {\n    \ttype: \'option\', name:"myoption3", title: "Select some", \n                          choices: ["Cold coffe","Politics","Beach","Pizza"], \n                          ids: ["0","1","2","3"] , \n                          defaultval:"0" \n\t}\n\n\ttemplates.checkbox =\n    { \n    \ttype: \'check\',  name:"mycheck",   title: "checkbox!", \n                          defaultval:true \n    } \n\n\ttemplates.separator =\n\t{ \n\t\ttype: \'separator\'\n\t}\n     \n    templates.text =\n\t{ \n\t\ttype: \'input\',  \n\t\tname:"myinput",   \n\t\ttitle: "some text",  \n\t\tdefaultval: "good"\n\t}\n\n\ttemplates.number =\n    { \n    \ttype: \'input\',  \n    \tdata: [\'integer\',0,10] , \n    \tname:"myint",   \n    \ttitle: "some number",  \n\t\tdefaultval: "410"\n\t}\n\n\ttemplates.slider =\n    { \n    \ttype: \'input\',  \n    \tdata: [\'integer\',0,10] , \n    \tstyle:\'slider\', \n    \tname:"myint2",   \n    \ttitle: "some slider",  \n\t\tdefaultval: "0"\n\t}\n\t\n\n\ttemplates.markerset =\n\t{ \n\t\ttype: \'markerset\',  name:"markerset", title:\'markerset\',\n\t\tmarkersettype:"pointROI",\n\t\tstate:\n\t\t{\n\t\t\tlocked:0,\n\t\t\tcreateonclick:1,\n\t\t\tcyclecolors:1,\n\t\t\tdefaultradius:5,\n\t\t\tdelSetOnPanelClose:0,\n\t\t\tpointROIthresh:300,\n\t\t\tshowThroughSlice:1,\n\t\t\thoverdetails:0,\n\t\t\tshowOnAllImages:1\n\t\t},\n\t\tlayout:  [\t ]\n\t}\n\n\n\treturn templates;\n}\n\n\nKForm.PSIDForm = function()\n{\n  var patientForm  =  \n\n\t         {  name : "patientinfo",\n\t             layout:\n \t               [ { type: \'css\', val : [] },\n\t\t\t\t\t { type: \'title\', val: "Patient information", css: ["font-size","30px",\'display\',\'inline-block\'] },\n\t\t\t\t\t { type: \'title\', element:\'span\', val: "<p class=\'createbutton\'> </p>", css: ["font-size","30px",\'display\',\'inline-block\'] },\n\t\t\t\t\t { type: \'separator\', css: ["height","5px"] },\n\t\t\t\t\t { type: \'form\',  name: "PatientsName",   \n\t\t\t\t\t\t\t layout: [{ type: \'css\', val : [] },\n\t\t\t\t\t\t\t\t\t  { type: \'title\', val: "Patients name", css: ["font-size","20px"] },\n\t\t\t\t\t\t\t\t\t  { type: \'input\',  name:"GivenName",   title: "Given name",  \n\t\t\t\t\t\t\t\t\t\t\t defaultval: ""},\n\t\t\t\t\t\t\t\t\t  { type: \'input\',  name:"FamilyName",   title: "Family name",  \n\t\t\t\t\t\t\t\t\t\t\t defaultval: ""},\n\t\t\t\t\t\t\t ] },\n\t\t\t\t\t { type: \'input\', name:"PatientID",   title: "Patients ID",  \n\t\t\t\t\t\t\t defaultval: "", attribute: "readonly"},\n\t\t\t\t\t { type: \'separator\', css: ["height","5px"] },\n\n\t\t\t\t\t { type: \'option\', name:"PatientsSex",  title: "Sex", \n\t\t\t\t\t\t\t style:"radio vert", \n\t\t\t\t\t\t\t choices: ["Male","Female"], \n\t\t\t\t\t\t\t ids: ["M","F"] , \n\t\t\t\t\t\t\t defaultval:"" },\n\t\t\t\t\t { type: \'input\', name:"PatientsBirthDate", title: "Birthdate",  \n\t\t\t\t\t\t\t defaultval: ""},\n\t\t\t\t\t { type: \'input\', name:"PatientsAge",   title: "Age",  \n\t\t\t\t\t\t\t defaultval: ""},\n\t\t\t\t\t { type: \'input\', name:"PatientsWeight",   title: "Weight",  \n\t\t\t\t\t\t\t defaultval: ""},\n\t\t\t\t\t { type: \'input\', name:"PatientsSize",   title: "Size",  \n\t\t\t\t\t\t\t defaultval: ""}\n\n\t\t\t\t\t ]\n\t         };\n\tvar studyForm = \n\t         { name : "studyinfo",\n\t             layout:\n \t               [ { type: \'css\', val : [] },\n\t\t\t\t\t { type: \'title\', val: "Study information", css: ["font-size","30px"] },\n\t\t\t\t\t { type: \'title\', element:\'span\', val: "<p class=\'createbutton\'> </p>", css: ["font-size","30px",\'display\',\'inline-block\'] },\t\t\t\t\t \n\t\t\t\t\t { type: \'separator\', css: ["height","5px"] },\n\t\t\t\t\t { type: \'input\', name:"StudyID",   title: "Studys ID",  \n\t\t\t\t\t\t\t defaultval: ""},\n\t\t\t\t\t { type: \'input\', name:"StudyDescription", title: "Description",  \n\t\t\t\t\t\t\t defaultval: ""},\n\t\t\t\t\t { type: \'input\', name:"StudyInstanceUID", title: "Instance UID",  \n\t\t\t\t\t\t\t defaultval: ""},\n\t\t\t\t\t { type: \'input\', name:"StudyDate", data: [\'integer\'],  title: "Date",  \n\t\t\t\t\t\t\t defaultval: ""},\n\t\t\t\t\t { type: \'input\', name:"StudyTime",   title: "Time",  \n\t\t\t\t\t\t\t defaultval: ""},\n\n\t\t\t\t\t ]\n\n\t         };\n\t\n\tpsidform = {name:\'patientstudyinfo\',layout: patientForm.layout.concat( [{ type: \'separator\', css: ["height","5px"] }]).concat(studyForm.layout)}\n\tvar out = [patientForm, studyForm, psidform ];\n\treturn out;\n\n}     \n\n\n\n\n\n\n\n\nfunction jsonTable_EditorTest()\n{\n\t\n\tfunction whenloaded(res)\n\t{\n\t\tfor(var k in res)\n\t\t{\n\t\t\tjsonTable_Editor(res[k], {} );\n\t\t}\n\t}\n\t//jsonTable_loadFormattedList(\'form\', whenloaded);\n\t\tvar tabs =\n\t\t[\n\t\t\t{ \n\t\t\t\ttype: "jscode",\n\t\t\t\ttabid: "jscode",\n\t\t\t\tdefaultcontent: "console.log(\'hello nora\')",\n\t\t\t\tevalbutton:\n\t\t\t\t{\n\t\t\t\t\tbuttontitle: "run code",\n\t\t\t\t\tcallback: function(tabid, jsoneditor){ }\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ \n\t\t\t\ttabid: "viewer.autoloaders",\n\t\t\t\tdefaultcontent: [],\n\t\t\t},\n\t\t\t{ \n\t\t\t\ttabid: "layout",\n\t\t\t\ttitle: "form",\n\t\t\t\tdefaultcontent: "console.log(\'hello nora\')",\n\t\t\t\tevalbutton:\n\t\t\t\t{\n\t\t\t\t\tbuttontitle: "run code",\n\t\t\t\t\tcallback: function(tabid, jsoneditor){ console.log(jsoneditor)}\n\t\t\t\t}\n\t\t\t},\n\t\t\t{ \n\t\t\t\ttitle: "reading_template",\n\t\t\t\tdefaultcontent:  KReadingTool_templateDefintion(),\n\t\t\t}\n\t\t]\n\n\tjsonTable_Editor({id: "new", type: \'form\', content:{name: "newad", id:"new"}}, tabs );\n\n}\n\n\n/***************************************************************************************\njsonTable_Editor: A popup window to edit elements from the json table. (forms, readings, settings, macros ...)\n****************************************************************************************/\nfunction jsonTable_Editor(jsonrow, tabs, options )\n{\n\t/***************************************************************************************\n\tjsonrow basis object\n\t****************************************************************************************/\n\tif(jsonrow == undefined)\n\t\tjsonrow = {id:"new" , type: \'none\' };\n\n\tif(jsonrow.content == undefined)\n\t\tjsonrow.content = {name:"noname" , id: jsonrow.id || "new" };\n\n\tif(tabs == undefined)\n\t\ttabs = [];\n\n\tvar options = \n\t{\n\t\t\n\t}\n\t\n\tvar json = jsonrow.content;\n\n\tvar that = new dialog_generic();\n\tthat.$frame.width(1050).offset({left:0, top:0} );\n\n\tthat.$frame.show();\n\n\t/***************************************************************************************\n\tThe editor + preview view\n\t****************************************************************************************/\n\tvar $dummy = $("<div class=\'KListView\'></div>").appendTo(that.$container)\n\t// main container\n\tthat.$container = $("<div style=\'min-width:50%\t;\' class=\'\'></div>").appendTo($dummy);\n\n\t/* other containers here \n\n\n\t*/\n\n  \n\t/***************************************************************************************\n\tThe main dialog\n\t****************************************************************************************/\n \tvar title = "Form Designer";\n\tvar $filemenuli = $("<li class=\'inactive\'><a>"+title+"</a></li>").appendTo(that.$menu);\n\n\t/***************************************************************************************\n\tcustomized tabs in the main view\n\t****************************************************************************************/\n\tvar TList = undefined;  // the inner tabber\n\t\n\t// a pointer to the current json editor\n\tvar jsoneditor;\n\n\t/***************************************************************************************\n\trender central tabs\n\t****************************************************************************************/\n\tfunction render_central_tabs()\n\t{\n\n\t\tvar $innerContainer = $("<div class=\'KListView\'></div>");\n\t\t// the left list div\n\t\tthat.$listDIV = $("<div></div>").appendTo($innerContainer);\n\t\t\n\t\t// the center div with tabs etc\n\t\tvar $rightDIV = $("<div class=\'KFlexVertical\'></div>").appendTo($innerContainer);\n\n\t\t// title and so on\n\t\tvar $tDIV = $("<div style=\'background:hsl(0, 0%,16%);display:flex;flex-wrap:wrap;\'></div>").appendTo($rightDIV);\n\t\t\n\t\t// top bar in center tab div: name, id, delete, save, and other functions\n\t\tvar $tools = $("<div class=\'modernbuttongroup\' style=\'\'></div>").appendTo($tDIV);\n\t\tvar $nametab = $("<div class=\'\' style=\'padding:15px; font-size:18px; font-weight:bold\'></div>").appendTo($tools);\n\t\t\n\t\tvar $name = $("<span>"+ (json.name || "noname" ) +"<span>").appendTo($nametab);\n\t\tvar $modified = $("<span>" + (json.modified===true?"*":"") + "<span>").appendTo($nametab);\n\n\t\tvar $temp = $("<span style=\'font-size:15px\'> ( id " + json.id +")<span>").appendTo($nametab);\n\n\t\tmakeEditableOnDoubleClick($name, function()\n\t\t{ \n\t\t\tjson.name = $name.text().replace("\\n", "");\n\t\t\trenderInnerContent(); \n\t\t});\n\t\tvar $delete = $("<div class=\'modernbutton small red\'><i class=\'fa fa-trash\'></i>delete</div>").appendTo($tools).click( function(){deleteObject()}  );\n\t\tvar $save   = $("<div class=\'modernbutton small green\'><i class=\'fa fa-save\'></i>save</div>").appendTo($tools).click( function(){saveObject()}  );\n\n\t\t// the editor content\n\t\tvar $cDIVupper = $("<div style=\'background:hsl(0, 0%,16%);\' class=\'\'></div>").appendTo($rightDIV);\n\t\tvar $cDIVLower = $("<div class=\'\' style=\'position:relative;\'></div>").appendTo($rightDIV);\n\n\n\n\t\t/////// viewer List and so on\n\t\tTList = TList || KList({ $targetcontainer:$cDIVLower, classes:["horizontal", "roundish"]   });\n\t\tTList.activeID = TList.activeID || "root";\n\t\tTList.settarget($cDIVLower)\n\t\tTList.clear();\n\t\tTList.$ul.appendTo( $cDIVupper );\n\n\t\t/*****************  the general tab *****************/\n\t\tvar tab_general = \n\t\t{ \n\t\t\tlayout: \n\t\t\t[\n\t\t\t { type: \'title\', val: "General Properties of this form"}\n\t\t\t\t,{name:"name"  \t\t\t, type: \'input\',     defaultval:"untitled"  }\n\t\t\t\t,{name:"project"\t\t, type: \'input\',     defaultval:""  }\n\t\t\t\t,{name:"rights"   \t    , type: \'option\',  style:"",  choices: ["private", "readable", "read/writable" ]}\n\t\t\t]\n\t\t}\n\n\t\t/*****************************************************\n\t\tif nothing specified, render only the json itself\n\t\t*****************************************************/\t\t\n\t\tif(tabs.length == 0)\n\t\t{\n\t\t\ttabs.unshift (\n\t\t\t{\n\t\t\t\ttabid: "raw",\n\t\t\t\tdefaultcontent: {},\n\t\t\t});\n\t\t}\n\n\t\t\n\t\t/*****************************************************\n\t\tadditionaly, always add a formatted general tab \n\t\t*****************************************************/\t\t\n\t\ttabs.unshift(\n\t\t{\n\t\t\ttabid: "general",\n\t\t\tform: tab_general,\n\t\t\tparseonblur: true,\n\t\t\tdefaultcontent: {},\n\t\t});\n\n\t\t\n\t\t\t\t\n\t\t//for(var k in tabs)\n\t\tvar tabmap = {};\n\t\tfor(var k=0; k<tabs.length; k++)\n\t\t{\n\t\t\tTList.append( tabs[k].tabid,  tabs[k].title || tabs[k].tabid , \t tabs[k].fun || renderInnerContent);\n\t\t\ttabmap[tabs[k].tabid] = k;\n\t\t}\n\n\t\tTList.updateOrSelectByID(\'general\');\n\t\t\n\t\t \n\t\t/*****************************************************\n\t\trender a sub tab, and return the corresponding div element\n\t\t*****************************************************/\t\t\n\t\tfunction renderInnerContent(tabid)\n\t\t{\n\t\t\tvar $tabDIV = $("<div class=\'\' style=\'position:absolute;width:100%;height:100%;\'></div>");// the 100 percents are important here\n\t\t\tvar tabobj = tabs[tabmap[tabid]];\n\t\t\t\n\n\t\t\tif(tabid == \'general\' || tabid == \'raw\' )\n\t\t\t{\n\t\t\t\tvar subjson = jsonrow;\n\t\t\t\ttabid = "content";\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar subjson = getPropByString(json, tabid )\n\t\t\t\t// create the sub-object, if not exists\n\t\t\t\tif( subjson[tabid] == undefined && tabobj.defaultcontent )\n\t\t\t\t\t\tsubjson[tabid] = tabobj.defaultcontent;\n\t\t\t}\n\n\t\t\t// if a formular is given render as form, otherwise, render as raw jsoneditor\n\t\t\tif(tabobj.form_________)\n\t\t\t{\n\t\t\t\tKForm.createForm(tabobj.form, subjson[tabid], $tabDIV, function(){json.modified=true;}) ;\n\t\t\t\tjsoneditor = undefined;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tjsoneditor = new KJSONEditor(subjson, tabid,  { parseonblur:tabobj.parseonblur, type: tabobj.type });\n\t\t\t\t$tabDIV.append(jsoneditor.$container);\n\t\t\t\tif(tabobj.evalbutton && tabobj.evalbutton.callback)\n\t\t\t\t{\n\t\t\t\t\tvar $preview= $("<div class=\'modernbutton small green\' style=\'position:absolute;top:0;right:10px\'> "+ ( tabobj.evalbutton.buttontitle || "run code") +"<i class=\'fa fa-arrow-right\'></i></div>");\n\t\t\t\t\t\t$preview.click(function(){ jsoneditor.JSONparse(true); if(tabobj.evalbutton.callback){ tabobj.evalbutton.callback(tabid, jsoneditor)} }).appendTo($tabDIV);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $tabDIV;\n\t\t}\n\n  \t   that.$container.empty().append( $innerContainer );\t\t\n\t   renderTemplateList();\n\t}\n\t/***************************************************************************************\n\tEND OF render_central_tabs\n\t****************************************************************************************/\n    \n\n\n\n\tvar PList = undefined;\t// the template list on left side\n\tvar templates = KForm.templates();\n\t/***************************************************************************************\n\trenderTemplateList\n\t****************************************************************************************/\n\tfunction renderTemplateList()\n\t{\t\n\t\tPList = PList || new KList({ classes:["vertical", "classic" ,"inverted"] });\n\t\tPList.clear();\n\t\t$("<div class=\'placeholder small\' style=\'text-align:center;font-size:17px;padding:3px;\'> Template Elements </div>")\n\t\t.click( function(){copyElement()}).appendTo(PList.$ul);\n\n\t\tPList.$ul.appendTo( that.$listDIV );\n\t\tfor(var id in templates)\n\t\t{\n\t\t\tvar $e = PList.append(id, id, undefined, function(id){return function(){template_copyCode(id)}}(id));\n\t\t\t$("<span class=\'flexright\'></span>").appendTo($e)\n\t\t\t\t.append($("<i class=\'fa fa-arrow-right\'></i>").click( function(id){return function(ev){template_pasteCode(id); ev.stopPropagation();}}(id) )) ;\n\t\t\t\n\t\t}\n\t}\n\n\t/***************************************************************************************\n\tInterpret and check the reading Definition locally in preview container\n\t****************************************************************************************/\n\tthat.previewForm = function()\n\t{\n\t  var temp = KForm.getFormContent(form.content);\n\t  that.$previewContainerInner.empty();\n\t  var $formdiv = KForm.createForm(form.content, temp, that.$previewContainerInner);\n\t  form.modified = true;\n\t}\n \n\n\t/***************************************************************************************\n\tsaveObjectOnClick\n\t****************************************************************************************/\n\tfunction saveObjectOnClick(saveas)\n\t{\n\t\tif(saveas)\n\t\t{\n\t\t\tcopyElement(activePreset);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tsaveObject(jsonrow)\n\t\t}\t\n\t}\n\n\t/***************************************************************************************\n\tsaveObject\n\t****************************************************************************************/\n\tfunction saveObject(whendone)\n\t{\n\t\tif(jsonrow.id == "0")\n\t\t\treturn;\n\t// \t\tif(!form.modified)\n\t// \t\t\treturn\t\n\n\t\t// verify json \n\t\tif(jsoneditor)\n\t\t{\n\t\t\tif(!jsoneditor.JSONparse())\n\t\t\t{\n\t\t\t\talertify.error("Json in current tab could not be parsed, it must be valid before saving.")\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t\tfunction whendone(result)\n\t\t{\n\t\t\tif(result.msg==\'\')\n\t\t\t{\n\t\t\t\talertify.success("Saved successfully.");\n\t\t\t\tjsonrow.modified = false;\n\n\t\t\t\t// this should be in manager ...?\n\t\t\t\t// KViewer.formManager.update();\n\n\t\t\t}\n\t\t}\n\t\t// if this is reading, tag as reading\n\t\tif(jsonrow.content.reading !=undefined && Object.getOwnPropertyNames(jsonrow.content.reading).length > 0)\n\t\t{\n\t\t\tjsonrow.content.tag = \'READING\'\n\t\t}\n\t\tjsonTable_save({ type:jsonrow.type, id: jsonrow.id, json:jsonrow.content } , whendone);\n\n\t} \n\n\t/***************************************************************************************\n\tdeleteObject\n\t****************************************************************************************/\n\tfunction deleteObject(id)\n\t{\n\t\tif(id == "0" || id == "new")\n\t\t\treturn;\n\t\tjsonTable_delete( {id:jsonrow.id}, whendone);\n\n\t\tfunction whendone(result) \n\t\t{\n\t\t\tif(result.msg==\'\')\n\t\t\t{\n\t\t\t\talertify.success("Object deleted.");\n\t\t\t\tthat.$frame.remove();\n\n\t\t\t\t// this should be in manager ...?\n\t\t\t\tvar l = KViewer.formManager.forms;\n\t\t\t\tfor(var k=0;k<l.length;k++)\n\t\t\t\t\tif(l[k].id == jsonrow.id)\n\t\t\t\t\t\tl.splice(k,1);\n\t\t\t\tKViewer.formManager.update();\n\t\t\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\talertify.error("Could not delete Object in jsonTable");\n\t\t\t}\n\t\t}\n\t}\n\n\t/***************************************************************************************\n\tTemplates\n\t****************************************************************************************/\n\tfunction template_copyCode(id)\n\t{\n\t\tif(jsoneditor == undefined || jsoneditor.$textarea == undefined)\n\t\t\treturn;\n\t\tvar $ta = jsoneditor.$textarea;\n\t\tvar ta = $ta.get(0);\n\t\tvar s = ta.selectionEnd || 0;\n\n\t\tvar str  = "\\n " + myJSONStringify( templates[id] ) + "\\n";\n\t\t// must copy text with a virtual textarea\n\t\tvar $temp = $("<textarea style=\'position:absolute; display:block;\'>"+str+"</textarea>").appendTo($body).select();\n\t\tvar successful = document.execCommand(\'copy\');\n\t\t$temp.remove();\n\t\tvar $notification = $("<div style=\'position:absolute;color:green\'>code copied to clipboard. Use ctrl+v to paste.</div>").appendTo(jsoneditor.$log.empty());\n\t\twindow.setTimeout(function(){ $notification.fadeOut(900, function(){$notification.remove()})}, 800);\n\n\t\t$ta.focus();\n\t\tta.selectionStart = s;\n\t\tta.selectionEnd = s; \n\n\t\t// could also paste the text directly (see below, but then ctrl+z does not work.\n\t}\n\n\tfunction template_pasteCode(id)\n\t{\n\t\tvar templates = KForm.templates();\n\t\tvar str  = "" + myJSONStringify( templates[id] ) + "";\n\t\tjsoneditor.pasteText(str, 1);\n\n\t}\n\n\t// custom toggler here\n\tthat.ontoggle = function()\n\t{\n\t\tif(json.modified)\n\t\t{\n\t\t\talertify.confirm("There might be unsaved changes in your form. <br> If you want to save them press \'cancel\' and save manually.", function(a)\n\t\t\t{\n\t\t\t\tif(!a) \n\t\t\t\t\treturn false\n\t\t\t\telse \n\t\t\t\t\tthat.$frame.remove();\t\n\t\t\t});\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthat.$frame.remove();\n\t\t}\n\t\treturn false;\n\t}\n\n\t/***************************************************************************************\n\tLoad Items on creation\n\t****************************************************************************************/\n\trender_central_tabs();\n\n\treturn that;\n\n}\n/********************************************************\nEND OF jsonTable_Editor\n*******************************************************/\n\n\n\n/*************************************************************\nget a nested object with a.b.c.d. path\n**************************************************************/\nfunction getPropByString(obj, propString) {\n    if (!propString)\n        return obj;\n\n    var prop, props = propString.split(\'.\');\n\n    for (var i = 0, iLen = props.length - 1; i < iLen; i++) {\n        prop = props[i];\n\n        var candidate = obj[prop];\n        if (candidate !== undefined) {\n            obj = candidate;\n        } else {\n            break;\n        }\n    }\n    return obj[props[i]];\n}\n\n\n'},function(t,n){t.exports="\n\n\nvar kmath = {};\nfunction clone (source) {\n\n    if (typeof source == \"array\" || source.length > 0)\n    {\n        var res = [];\n        for (var k = 0 ; k < source.length; k++)\n        {\n            res[k] = clone(source[k]);\n        }\n        return res;\n\n    }\n    else if (typeof source == 'object')\n    {\n        var res = {};\n        for (var k  in source)\n        {\n            res[k] = clone(source[k]);\n        }\n        return res;\n\n    }\n    return source;\n}\n\n\nkmath.matrix = function(v)\n{\n    var data;\n    var sizes;\n    if (typeof v[0] == 'number')\n    {\n        data = v.slice(0);\n        sizes = [v.length];\n    }\n    else\n    {\n        if (typeof v == 'object' && v._data != undefined)\n        {\n            v = clone(  v);\n            return v;\n        }\n\n        data = [];\n        sizes = [v.length, v[0].length];\n        for (var k = 0; k < v.length; k++)\n            data[k] = v[k].slice(0);\n    }\n    return {\n        _data: data,\n        _size: sizes\n    };\n}\n\nkmath.Transpose = function(v)\n{\n    if (v._data == undefined)\n        v = kmath.matrix(v);\n    else\n        v = clone(v);\n\n    if (v._size.length == 1)\n    {\n        v._size = [1, v._size[0]];\n        v._data = [v._data];\n    }\n\n    var n = {\n        _data: [],\n        _size: [v._size[1], v._size[0]]\n    }\n    for (var k = 0; k < n._size[0]; k++)\n    {\n        n._data[k] = [];\n        for (var j = 0; j < n._size[1]; j++)\n        {\n            n._data[k][j] = v._data[j][k];\n        }\n    }\n    return n;\n\n}\nkmath.transpose = kmath.Transpose;\n\n\nkmath.diag = function(v)\n{\n\n    var n = v.length;\n    var data = [];\n    for (var i = 0; i < n; i++)\n    {\n        data[i] = [];\n        for (var j = 0; j < n; j++)\n            data[i][j] = 0;\n    }\n    for (var i = 0; i < n; i++)\n        data[i][i] = v[i];\n\n    return kmath.matrix(data);\n}\n\n\nkmath.setTranslation = function(m,t)\n{\n\n    var data = [];\n    var n = m._data.length;\n    for (var i = 0; i < n; i++)\n    {\n        data[i] = [];\n        for (var j = 0; j < n; j++)\n            data[i][j] = m._data[i][j];\n    }\n    for (var i = 0; i < n-1; i++)\n        data[i][n-1] = t[i];\n\n    return kmath.matrix(data);\n}\n\n\n\nkmath.inv = function(M)\n{\n    M = kmath.matrix(M);\n    var E = kmath.eye(M._size[0]);\n    for (var k = 0; k < E._size[0]; k++)\n    {\n        E._data[k] = kmath.mdiv(M, kmath.matrix(E._data[k]))._data;\n    }\n\n    return kmath.Transpose(E);\n}\n\n\nkmath.eye = function(n)\n{\n    var data = [];\n    for (var i = 0; i < n; i++)\n        data[i] = 1;\n    return kmath.diag(data)\n}\n\nkmath.pow = Math.pow;\nkmath.abs = Math.abs;\nkmath.sqrt = Math.sqrt;\nkmath.round = function(x)\n{\n    if (Array.isArray(x))\n    {\n        x = x.slice(0);\n        for (var k = 0; k < x.length; k++)\n        {\n            x[k] = Math.round(x[k]);\n        }\n        return x;\n    }\n    else\n        return Math.round(x);\n\n}\nkmath.floor = Math.floor;\nkmath.ceil = Math.ceil;\nkmath.exp = Math.exp;\n\n\n//kmath.sign = Math.sign;\nkmath.sign = function(x)\n{\n    return x > 0 ? 1 : -1;\n}\n\n\nkmath.sum = function(x)\n{\n    var s = 0;\n    for (var k = 0; k < x.length; k++)\n    {\n        s += x[k];\n    }\n    return s;\n\n}\n\nkmath.cross = function(a, b, donormalize)\n{\n    var x = a;\n    var y = b;\n    if (x._data)\n        x = x._data;\n    if (y._data)\n        y = y._data;\n        \n\n    var z = [x[1] * y[2] - x[2] * y[1],\n    x[2] * y[0] - x[0] * y[2],\n    x[0] * y[1] - x[1] * y[0]];\n\n    if(donormalize==1)\n    {\n        var n = 0;\n        for (var k = 0; k < z.length; k++)\n            n += z[k] * z[k];\n        z = math.multiply(z, 1/kmath.sqrt(n));\n\n    }\n\n    z = kmath.matrix(z);\n    return z;\n\n}\n\nkmath.dot = function(a,b)\n{\n    if(a._data != undefined)\n        a = a._data;\n    if(b._data != undefined)\n        b =b._data;\n    \n    var out = (a[0]*b[0] + a[1]*b[1] + a[2]*b[2]);   \n    return out;\n}\n\nkmath.mdiv = function(M, b)\n{\n    var abs = Math.abs;\n    M  = clone(M);\n\n    var A = M._data;\n    var x = b._data.slice(0);\n\n    var r = clone(b);\n    r._data = gauss(A, x);\n\n    return r;\n\n\n    function array_fill(i, n, v) {\n        var a = [];\n        for (; i < n; i++) {\n            a.push(v);\n        }\n        return a;\n    }\n\n    function gauss(A, x) {\n\n        var i, k, j;\n\n        // Just make a single matrix\n        for (i = 0; i < A.length; i++) {\n            A[i].push(x[i]);\n        }\n        var n = A.length;\n\n        for (i = 0; i < n; i++) {\n            // Search for maximum in this column\n            var maxEl = abs(A[i][i])\n              ,\n            maxRow = i;\n            for (k = i + 1; k < n; k++) {\n                if (abs(A[k][i]) > maxEl) {\n                    maxEl = abs(A[k][i]);\n                    maxRow = k;\n                }\n            }\n\n\n            // Swap maximum row with current row (column by column)\n            for (k = i; k < n + 1; k++) {\n                var tmp = A[maxRow][k];\n                A[maxRow][k] = A[i][k];\n                A[i][k] = tmp;\n            }\n\n            // Make all rows below this one 0 in current column\n            for (k = i + 1; k < n; k++) {\n                var c = -A[k][i] / A[i][i];\n                for (j = i; j < n + 1; j++) {\n                    if (i === j) {\n                        A[k][j] = 0;\n                    } else {\n                        A[k][j] += c * A[i][j];\n                    }\n                }\n            }\n        }\n\n        // Solve equation Ax=b for an upper triangular matrix A\n        x = array_fill(0, n, 0);\n        for (i = n - 1; i > -1; i--) {\n            x[i] = A[i][n] / A[i][i];\n            for (k = i - 1; k > -1; k--) {\n                A[k][n] -= A[k][i] * x[i];\n            }\n        }\n\n        return x;\n    }\n}\n\n\nkmath.halfPixelShift = function(edges,sg)\n{\n    if (sg == undefined)\n        sg=-1;\n    var delta = math.multiply(edges,[sg*0.5,sg*0.5,sg*0.5,0])\n    var e = math.matrix(edges);\n    e._data[0][3] += delta._data[0]\n    e._data[1][3] += delta._data[1]\n    e._data[2][3] += delta._data[2]\n    return e;\n}\n\nkmath.multiply = function(a, b)\n{\n    if (Array.isArray(a))\n        a = kmath.matrix(a);\n    if (Array.isArray(b))\n        b = kmath.matrix(b);\n\n    if (typeof a == 'number')\n    {\n        var r = kmath.matrix(b._data);\n        if (r._size.length == 1)\n            for (var k = 0; k < r._size[0]; k++)\n                r._data[k] = r._data[k] * a;\n        else\n        {\n            for (var k = 0; k < r._size[0]; k++)\n                for (var j = 0; j < r._size[1]; j++)\n                    r._data[k][j] = r._data[k][j] * a;\n        }\n        return r;\n    }\n    else if (typeof b == 'number')\n        return kmath.multiply(b, a);\n    else\n    {\n        var data = [];\n        var trans = false;\n        if (b._size.length == 1)\n        {\n            b = kmath.Transpose(b);\n            trans = true;\n        }\n\n        for (var k = 0; k < a._size[0]; k++)\n        {\n            data[k] = [];\n            for (var j = 0; j < b._size[1]; j++)\n            {\n                var v = 0;\n                for (var i = 0; i < a._size[1]; i++)\n                    v += a._data[k][i] * b._data[i][j];\n                data[k][j] = v;\n            }\n        }\n\n        var r = {\n            _data: data,\n            _size: [a._size[0], b._size[1]]\n        };\n        if (trans)\n        {\n            r = kmath.Transpose(r);\n            r._data = r._data[0];\n            r._size = [r._size[1]];\n            return r;\n        }\n        else\n            return r;\n\n\n    }\n\n\n}\n\nkmath.max = function(a, b)\n{\n    if (b == undefined)\n    {\n        if (a._data != undefined)\n            a = a._data\n\n        var m = a[0]\n        for (var k = 1; k < a.length; k++)\n        {\n            if (m < a[k])\n                m = a[k];\n        }\n        return m;\n    }\n    else\n    {\n        if (a > b)\n            return a;\n        else\n            return b;\n    }\n}\n\n\nkmath.min = function(a, b)\n{\n    if (b == undefined)\n    {\n        if (a._data != undefined)\n            a = a._data\n\n        var m = a[0]\n        for (var k = 1; k < a.length; k++)\n        {\n            if (m > a[k])\n                m = a[k];\n        }\n        return m;\n    }\n    else\n    {\n        if (a < b)\n            return a;\n        else\n            return b;\n    }\n}\n\n\nkmath.argmax = function(array) {\n  return array.map((x, i) => [x, i]).reduce((r, a) => (a[0] > r[0] ? a : r))[1];\n}\n\n\nkmath.add = function(a, b)\n{\n    if (typeof a == 'number')\n        return kmath.add(b, a);\n\n    a = kmath.matrix(a);\n\n    if (typeof b == 'number')\n    {\n        if (a._size.length == 1)\n        {\n            for (var k = 0; k < a._size[0]; k++)\n                a._data[k] += b;\n        }\n        else\n        {\n            for (var k = 0; k < a._size[0]; k++)\n                for (var j = 0; j < a._size[1]; j++)\n                    a._data[k][j] += b;\n        }\n        return a;\n    }\n    else\n    {\n        b = kmath.matrix(b);\n        if (a._size.length == 1)\n        {\n            for (var k = 0; k < a._size[0]; k++)\n                a._data[k] += b._data[k];\n        }\n        else\n        {\n            for (var k = 0; k < a._size[0]; k++)\n                for (var j = 0; j < a._size[1]; j++)\n                    a._data[k][j] += b._data[k][j];\n        }\n\n        return a;\n    }\n\n\n\n}\n\n\nkmath.EV2 = function(M)\n{\n    var a = kmath.maxEV(M);\n    a.v = a.v._data;\n    M._data[0][0] -= a.v[0]*a.v[0]*a.ev;\n    M._data[1][1] -= a.v[1]*a.v[1]*a.ev;\n    M._data[2][2] -= a.v[2]*a.v[2]*a.ev;\n    M._data[1][0] -= a.v[1]*a.v[0]*a.ev;\n    M._data[2][0] -= a.v[2]*a.v[0]*a.ev;\n    M._data[1][2] -= a.v[1]*a.v[2]*a.ev;\n    M._data[0][1] -= a.v[1]*a.v[0]*a.ev;\n    M._data[0][2] -= a.v[2]*a.v[0]*a.ev;\n    M._data[2][1] -= a.v[1]*a.v[2]*a.ev;\n    \n    var b = kmath.maxEV(M);\n    b.v = b.v._data\n\n    return [a,b];\n}\n\nkmath.maxEV3 = function(M)\n{\n    var a = kmath.maxEV(M);\n    a.v = a.v._data;\n    var eps = -0.01;\n    M._data[0][0] -= a.v[0]*a.v[0]*a.ev + eps;\n    M._data[1][1] -= a.v[1]*a.v[1]*a.ev + eps;\n    M._data[2][2] -= a.v[2]*a.v[2]*a.ev + eps;\n    M._data[1][0] -= a.v[1]*a.v[0]*a.ev + eps;\n    M._data[2][0] -= a.v[2]*a.v[0]*a.ev + eps;\n    M._data[1][2] -= a.v[1]*a.v[2]*a.ev + eps;\n    M._data[0][1] -= a.v[1]*a.v[0]*a.ev + eps;\n    M._data[0][2] -= a.v[2]*a.v[0]*a.ev + eps;\n    M._data[2][1] -= a.v[1]*a.v[2]*a.ev + eps;\n    \n    var b = kmath.maxEV(M);\n    b.v = b.v._data\n    M._data[0][0] -= b.v[0]*b.v[0]*b.ev + eps;\n    M._data[1][1] -= b.v[1]*b.v[1]*b.ev + eps;\n    M._data[2][2] -= b.v[2]*b.v[2]*b.ev + eps;\n    M._data[1][0] -= b.v[1]*b.v[0]*b.ev + eps;\n    M._data[2][0] -= b.v[2]*b.v[0]*b.ev + eps;\n    M._data[1][2] -= b.v[1]*b.v[2]*b.ev + eps;\n    M._data[0][1] -= b.v[1]*b.v[0]*b.ev + eps;\n    M._data[0][2] -= b.v[2]*b.v[0]*b.ev + eps;\n    M._data[2][1] -= b.v[1]*b.v[2]*b.ev + eps;\n\n\n    var c = kmath.maxEV(M);\n    c.v = c.v._data\n\n    return [a,b,c];\n}\nkmath.EV3 = kmath.maxEV3 ;\n\n\n\nkmath.maxEV = function(M)\n{\n    var n = M._data.length;\n    var v = new Array(n).fill(0);\n    v[0] = 1;\n    v = kmath.matrix(v);\n    var old = v;\n    var ev;\n    for (var k = 0; k < 20; k++)\n    {\n        v = kmath.multiply(M, v);\n        ev = kmath.normalize(v);\n        var dif = 0;\n        for (var j = 0; j < n; j++)\n            dif += (v._data[j] - old._data[j]) * (v._data[j] - old._data[j]);\n        old = v;\n        if (dif < 0.00000001)\n            break;\n    }\n\n    return {\n        v: v,\n        ev: ev\n    };\n\n}\n\nkmath.normalize = function(v)\n{\n    var n = 0;\n    for (var k = 0; k < v._data.length; k++)\n        n += v._data[k] * v._data[k];\n    n = kmath.sqrt(n);\n    for (var k = 0; k < v._data.length; k++)\n        v._data[k] /= n;\n    return n;\n}\n\nkmath.norm = function(v)\n{\n\n    if (v._data)\n        v = v._data;\n\n    var n = 0;\n    for (var k = 0; k < v.length; k++)\n    {\n        n += v[k] * v[k];\n    }\n    n = kmath.sqrt(n);\n    return n;\n}\n\n\n\nkmath.det = function(M)\n{\n    M = kmath.matrix(M);\n    M = kmath.Transpose(M);\n    var n = M._size[0];\n    var a = M._data.reduce(function(a, b) {\n        return a.concat(b);\n    });\n\n    return Det();\n\n\n    function Det()\n    {\n        if (n == 1)\n            return a[0];\n        if (n == 2)\n            return a[0] * a[3] - a[1] * a[2];\n        if (n == 3)\n            return a[0] * (a[4] * a[8] - a[5] * a[7]) + a[1] * (a[5] * a[6] - a[3] * a[8]) + a[2] * (a[3] * a[7] - a[4] * a[6]);\n        if (n == 4)\n        {\n            d = a[0] * (a[5] * (a[10] * a[15] - a[11] * a[14]) + a[6] * (a[11] * a[13] - a[9] * a[15]) + a[7] * (a[9] * a[14] - a[10] * a[13]));\n            d -= a[1] * (a[4] * (a[10] * a[15] - a[11] * a[14]) + a[6] * (a[11] * a[12] - a[8] * a[15]) + a[7] * (a[8] * a[14] - a[10] * a[12]));\n            d += a[2] * (a[4] * (a[9] * a[15] - a[11] * a[13]) + a[5] * (a[11] * a[12] - a[8] * a[15]) + a[7] * (a[8] * a[13] - a[9] * a[12])) - a[3] * (a[4] * (a[9] * a[14] - a[10] * a[13]) + a[5] * (a[10] * a[12] - a[8] * a[14]) + a[6] * (a[8] * a[13] - a[9] * a[12]));\n            return d;\n        }\n        detGLSL(n);\n        var p = 1.0;\n        for (i = 0; i < n; i++)\n        {\n            p *= a[i * (n + 1)];\n        }\n        return p;\n    }\n\n}\n\nmath = kmath;\n\n\nkmath.median = function(values, iqr)\n{\n\n    values.sort( function(a,b) {return a - b;} );\n\n\tif(iqr == undefined)\n\t{\n\t\tvar half = Math.floor(values.length/2);\n\n\t\tif(values.length % 2)\n\t\t\treturn values[half];\n\t\telse\n\t\t\treturn (values[half-1] + values[half]) / 2.0;\n\t}\n\telse\n\t{\n\t\tvar half = Math.floor(values.length*.5);\n\t\tvar q1   = Math.floor(values.length*.25);\n\t\tvar q2   = Math.floor(values.length*.75);\n\t\treturn {median: values[half], iqr1: values[q1], iqr2:values[q2]};\n\t}\n\n}\n/**********************************\nsome vector functions \n***********************************/\n/*\nkmath.cross2 = function(a,b, normalize)\n{\n    var wasmatrix = 0;\n    if(a._data != undefined)\n    {\n        a._data = a._data;\n        wasmatrix = 1;\n    }\n    if(b._data != undefined)\n    {\n        b._data =b._data;\n        wasmatrix = 1;\n    }\n\n    var v = [ a[1] * b[2] - a[2] * b[1], a[2] * b[0] - a[0] * b[2], a[0] * b[1] - a[1] * b[0] ];\n    if(normalize==1)\n    {\n        var n = 0;\n        for (var k = 0; k < v.length; k++)\n            n += v[k] * v[k];\n        v = math.multiply(v, 1/kmath.sqrt(n));\n\n    }\n    if(wasmatrix)\n        v = math.matrix(v);\n\n    return v;\n}\n*/\n"},function(t,n){t.exports='///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// current state\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nfunction StateManager()\n{\n\tvar that = new Object();\t\n\n\t// create a generic state from the preset and other definitions and send back.\n\tthat.makeGenericState = function()\n\t{\n\t\t\tvar genericpreset    =    KForm.getFormContent(presetForm, {} );\n\t\t\tgenericpreset.autoloaders = [];\n\t\t\tvar generic_project_user    =    KForm.getFormContent(form_project_user, {} );\n\n\t\t\tgeneric_project_user.selectedViewerPreset = -1;\n\t\t\t\n\t\t\tstate = {\n\t\t\t\t\t id: "0"\n\t\t\t\t\t,batchtool: {}\n\t\t\t\t\t,toolstate: []\n\t\t\t\t\t,tools: {}\n\t\t\t\t\t,project: {}\n\t\t\t\t\t,project_user: generic_project_user\n\t\t\t\t\t,viewer: genericpreset,\n\n\t\t\t\t};\n\t\t\t\treturn state;\n\t}\n\n\n\tthat.setDefaultState = function() \n\t{\n\t\tthat.applyState ( that.makeGenericState() );\n\t\t//state =   that.makeGenericState();\n\t}\n\n\t\n\tthat.applyState = function(state_new)\n\t{\t\n\t\t\tif(state_new  === undefined)\n\t\t\t\treturn;\n\t\t\tstate = state_new;\n\t\t\tViewerSettings = state.viewer;\n\t\t\t\n\t\t\tsetPatientTableWidth();\n\t\t\tsetPatientTableLayout();\n\t\t\t$(\'.leveltab\').removeClass(\'current\');\t\t$(\'#modeSelector_\' + state.viewer.selectionMode[1]).addClass(\'current\');\n\t\t\t\n\t\t\tif( typeof KViewer != "undefined" )\n\t\t\t{\n\t\t\t\tKViewer.applyState(); \n\t\t/* // newtoolstate\n\t\t\t\t// reestablish the internal state of the tools (buttons ...)\n\t\t\t\tif(state.tools)\n\t\t\t\t\tfor(var tool in state.tools)\n\t\t\t\t\t\tif(KViewer[tool] !=undefined)\n\t\t\t\t\t\t\tKViewer[tool].setState(state.tools[tool]);\n\t\t\t*/\t\t\t\t\n\t\t\t}\n\t}\n\n\n\tthat.saveCurrentState = function(whendone,force)\n\t{\t\n\n\n\t\tif (typeof sharedLink != "undefined" && sharedLink != undefined)\n\t\t{\n\t\t\tconsole.log("state not saved, it\'s a shared link");\n\t\t\tif(whendone)\n\t\t\t\twhendone();\n\t\t\treturn;\n\n\t\t}\n\n\t\t// do not save for guestuser;\n\t\tif(userinfo.username == guestuser && force == undefined) // | projectInfo.rights.readonly == "on" | projectInfo.rights.readonly === false)\n\t\t{\n\t\t\tif(whendone)\n\t\t\t\twhendone();\n\t\t\treturn;\n\t\t}\n\n\t\tvar req = new Array(new Array, new Array);\n\n\t\t// Save all presets,\n\t\tvar rows = presetManager.getRowsForSaving();\n\t\tif(rows.length > 0)\n\t\t{\n\t\t\treq[0].push( {command:\'jsonTable_insertOrUpdate\', json: rows} );\n\t\t\treq[1].push(  function(){} );\n\t\t}\n\n\t\t// Save state itself\n\t\tif (commandDialog != undefined && commandDialog.getState)\n\t\t\tstate.batchtool = commandDialog.getState();\n\n\t\tstate.toolstate = KToolWindow.getToolsState();\n\t\t\n\t\t// put the internal KViewer state (haircros etc) into the state such that it will be saved\n\t\tKViewer.saveState()\n\n/* //newtoolstate\n\t\t// save the state of individual tools\n\t\tif (state.tools == undefined)\n\t\t\tstate.tools = {};\n\n\t\tvar whichtools = [\'roiTool\' , \'curveTool\' ];\n\n\t\tfor (var k = 0 ; k < whichtools.length;k++)\n\t\t{\n\t\t\tif( KViewer[whichtools[k]].enabled )\n\t\t\t\tstate.tools[whichtools[k]] =  $.extend(true, {}, KViewer[whichtools[k]].getState() ); \n\t\t}\n*/\t\t\n \t\tif( markerProxy != undefined && markerProxy.markersetIDs.length > 0 &&  markerProxy.markersets[markerProxy.markersetIDs[0]] != undefined)\n \t\t\tstate.tools.markerPanel =  $.extend(true, {},  markerProxy.markersets[markerProxy.markersetIDs[0]].state ); \n\n\t\tif (typeof electron != "undefined" && electron)\n\t\t{\n    \t\t dialog.showSaveDialog({ title: \'save settings\',\n\t\t\t\t\t\t\tproperties: [],\n\t\t\t\t\t\t\tdefaultPath: "./noraview.settings.json",\n\t\t\t\t\t\t}, function(savename)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t   if (savename == undefined)\n\t\t\t\t\t\t      return;\n\t\t\t\t\t\t     fs.writeFile( savename, JSON.stringify(state) ,undefined,function(err)\n\t\t\t\t\t\t     { \n                                    alertify.success(\'successfully saved \' + savename);\n\t\t\t\t\t\t     });\n\t\t\t\t\t\t});\n     \n\t\t}\n\t\telse\n\t\t{\n\n\t\t\tvar row = {type:\'state\',  json:state, project:currentModule, MDB_uniquekey: \' type like "state" AND project like "\' + currentModule + \'" AND owner like "\' + userinfo.username + \'"\' }\n\t\t\t\treq[0].push( {command:\'jsonTable_insertOrUpdate\', state:state,json: [row]} );\n\t\t\t\treq[1].push(  function(result)\n\t\t\t\t{\t\n\t\t\t\t\tif(result.json) state.id = result.json[0].id; \n\t\t\t\t} ); // update id , important in case this was first insertion\n\n\t\n\t\t\tajaxRequest( req, whendone );\n\t\t}\n\n\n\n\t}\n \n\t// This function loads the current state from database. Normally done when new project is selected.\n// \tthat.loadCurrentState = function()\n// \t{\n// \t\tjsonTable_load({type:\'state\'}, whendone);\n// \t\tfunction whendone(result)\n// \t\t{\n// \t\t\tthat.applyState( result.json[0] ); // take the first row found.\n// \t\t}\n\n// \t}\n\nreturn that;\n}\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n/////////////////////// Main Settings Forms\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n  \n   var form_project_user = \n   { \n\tname \t\t: "project_user",\n\t//classdef  : ".viewersettings .KFormItem {padding:6px;} .viewersettings .KFormItem label {min-width: 170px!important;}",\n\titems : { "class" : \'KFormItemSettings\' },\n\tlayout: \n\t[\n\t { type: \'title\', val: "State settings"}\n\t\t,{name:"startupState"  , type: \'option\',  style:"radio vert" , title:\'What happens on fresh startup/login\'\n\t\t\t,choices: ["take most recent state", "choose favourite preset", "use a standard preset, if exists"]\n\t\t\t,ids: ["rememberState", "rememberPreset", "tryUsingStandard"], defaultval:"rememberState"}\n\t\t,{name:"updateInterval" \t    , type: \'input\',  \t defaultval:60   , title:\'Update interval of subject table(in seconds)\'}\n\t\t,{name:"updateInterval_gridstat", type: \'input\',  \t defaultval:30   , title:\'Update interval of gridengine statistics (in seconds)\'}\n\t\t,{name:"localstoragesizeMB"     , type: \'input\',  \t defaultval:0    , title:\'Size of local hard disk cache, use this if you are remote (in MB)\'   }\n\n\n\t]\n   }\n\n\n  var form_autoloader = \n   {\n\tname \t\t: "autoloader",\n\tlastchange  : "",\n\ttype: \'form\',\n\tlayout: \n\t[\n\t \t      {name:"enabled"\t    \t, type: \'check\',     defaultval:true, class:"autoloaderitem" }\n\t \t     ,{name:"viewportID"\t    , type: \'input\',     defaultval:"0" , class:"autoloaderitem"  }\n\t         ,{name:"pattern"\t    \t, type: \'textarea\',     defaultval:"FFilename:"  , class:"autoloaderitem"  }\n\t \t     ,{name:"intent"\t    \t, type: \'json\',     defaultval:""  , class:"autoloaderitem"  }\n\t]\n   }\n\n   var presetForm_autoload = \n   { \n\tname \t\t: "presetForm_autoload",\n\tlastchange  : "",\n\tlayout: \n\t[\n\t\t { type: \'title\', val: "Autoloaders"}\n\t \t,{name:"enableAutoloaders"\t\t, type: \'check\',     defaultval:false, css:[\'display\',\'inline-block\']  }\n\t\t,{name:"autoloaderLevel"   \t    , type: \'option\',  style:"",  choices: ["patient or study", "patient", "study"],\n\t\t\t\t\t\t\t\t\t\t\tids: [0, 1,2], defaultval:0}\n \t    ,{name:"mainViewport"\t   \t, type: \'input\',     defaultval:-1    }\n\t\t,{type: \'separator\' }\n\t   ,{\n\t\t\tname: "autoloaders",\n\t\t\ttitle: "",\n\t\t\ttype: \'formarray\',\n\t\t\tcreatebutton:\'Add image loader\',\n\t\t\taltcreatebuttons:[{text:"Add annotation loader",fun:addanno}],\n\t\t\tlayout: \n\t\t\t[\n\t\t\t\t {name:"pattern"\t  , type: \'textarea\',  defaultval:"FFilename:"  , class:"autoloaderitem"  }\n\t\t\t\t ,{name:"viewportID"  , type: \'input\',     defaultval:"0" , class:"autoloaderitem" ,element:"span"}\n\t\t\t\t ,{name:"enabled"\t  , type: \'check\',     defaultval:true, class:"autoloaderitem" ,element:"span"}\n\t\t\t\t ,{name:"intent"\t  , type: \'json\',      defaultval:{}  , class:"autoloaderitem"  , class:"intentfield" ,   onchange: intentchange}\n\n\t\t \t  \t ,{type: \'customelement\',  val: variableOptions  , element:"div"   }\n\n\t\t\t]\n\t   },\n\t   {type: \'separator\' },\n\t   {type: \'separator\' },\n\n\t   { type: \'title\', val: "Calculation Panel"},\n\n\t   {\n\n\t\t\tname \t\t: "calcpanel",\n\t\t\tlastchange  : "",\n\t\t\ttype: \'form\',\n\t\t\tlayout: \n\t\t\t[\n\t\t\t\t\t  {name:"enabled"\t    \t, type: \'check\',     defaultval:false, class:"autoloaderitem" },\t\t\t\t\n\t\t\t\t\t  {name:"code"\t    \t\t, type: \'textarea\',  mode:\'javascript\',  defaultval:"layout = []; \\nfunction exec(objs,pinfo) \\n{}", class:"autoloaderitem" },\n\t\t\t]\n\t\t   }\n    ]};\n\n\n   \tfunction addanno(content)\n   \t{\n        content.intent.autocreate_ano =\n\t\t\t{\n\t\t\t\ttype:"points",\n\t\t\t\tshowPanel:true,\n\t\t\t\ttemplates:\n\t\t\t\t{\n\t\t\t\t\tsome_name:\n\t\t\t\t\t{\n\t\t\t\t\t\tcolor:"#00FFFF",\n\t\t\t\t\t\tradius:4,\n\t\t\t\t\t\tviewport:0\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\tcontent.pattern = "FFilename:youranno.ano.json\\nFSubfolder:annotations"\n        content.update("intent");\n\n        content.update("pattern");\n   \t}\n\n\tfunction variableOptions(x)\n\t{\n\t\tvar $div = $("<div class=\'autoloadvaroption\' ></div>")\n\n\t\tvar $autoroi= $(\'<span class="Kautocreateroi"><input type="checkbox" name="autocreateroi" \' + (x.intent.autocreateroi != undefined?\'checked\':\'\') + \n                      \'> <label for="autocreateroi"> autocreate ROI </label></span>\')\n        $autoroi.on("change",function(e)\n        {\n        \tif ($(e.target).is(\':checked\'))\n        \t    x.intent.autocreateroi="0";\n        \telse\n        \t    delete x.intent.autocreateroi;\n        \tx.update("intent")\n        })\n        \n\t\tvar $overlay= $(\'<span class="notroi"><input type="checkbox" name="overlay" \' + (x.intent.overlay==1?\'checked\':\'\') + \n                      \'> <label for="overlay"> overlay </label></span>\')\n        $overlay.on("change",function(e)\n        {\n        \tif ($(e.target).is(\':checked\'))\n        \t    x.intent.overlay = 1;\n        \telse\n        \t    delete x.intent.overlay;\n        \tx.update("intent")\n        })\n\n        var $colmap = $("<select class=\'notroi\' name=\'colmaps\'></select>")\n\t\tfor (var k = 0; k < colormap.names.length; k++)\n\t\t{\n\t\t\tif (x.intent.cmap == k)\n\t\t\t\t$colmap.append($("<option id=\'" + k + "\' selected > " + colormap.names[k] + "  </option>"));\n\t\t\telse\n\t\t\t\t$colmap.append($("<option id=\'" + k + "\' > " + colormap.names[k] + " </option>"));\n\t\t}\n\t\t$div.append($("<label  class=\'notroi\' for=\'colmaps\'>Colormap:</label>"));\n        $colmap.on("change",function(e)\n        {\n        \tx.intent.cmap = e.target.selectedIndex\n        \tx.update("intent")\n        })\n\n\n\n        var defcol = {color:0};\n        if (x.intent.color != undefined)\n            defcol = {color:(x.intent.color.length>0?x.intent.color[0]:x.intent.color)}\n\t\tvar colors = KColor.list;\n \t    var $colselector = KColorSelector(colors,function colencode(c) {\n                                return "background:" + RGB2HTML(c[0], c[1], c[2]) + ";";\n                                },\n\t\t function(c,i) {      \n\t\t    x.intent.color=i;\n        \tx.update("intent")\n\n\t\t}, defcol);\n\t\tvar $colselector_wrap = $("<span class=optioncolsel> ROI color </span>").append($colselector)\n\n\n        $div.append($colmap)\n        $div.append($overlay)\n        $div.append($colselector_wrap)\n        $div.append($autoroi.hide())\n\n\n        intentchange(x.intent,undefined,$div)\n\t\treturn $div;\n\n\t}\n\n   \tfunction intentchange(intent,target,$parent)   \t\n   \t{\n\t\tif (target != undefined)\n   \t\t    $parent = $(target).parent().parent();\n\t\tvar $x = $parent.find(\'.Kautocreateroi,.optioncolsel\')\n\t\tvar $y = $parent.find(\'.notroi\')\n   \t\tif (intent.roi)\n   \t\t{\n   \t\t\t$x.show();\n   \t\t\t$y.hide();\n   \t\t}\n   \t\telse\n   \t\t{\n   \t\t\t$y.show();\n   \t\t    $x.hide();\n   \t\t    delete intent.autocreateroi;\n   \t\t}\n\n\t\t$x = $parent.find(\'input[name=overlay]\');\n\t    $x[0].checked = (intent.overlay > 0)\n\n\t\t$x = $parent.find(\'select[name=colmaps]\');\n\t    $x[0].selectedIndex = intent.cmap;\n\n   \t}\n\n\n\n   var presetForm_general = \n   { \n\tname \t\t: "viewersettings",\n\tlastchange  : "",\n\t\n\tlayout: \n\t[\n\t { type: \'title\', val: "Preset settings"}\n\t \t,{name:"name"  \t\t\t\t\t, type: \'input\',     defaultval:"generic"  }\n\t \t,{name:"project"\t\t\t\t, type: \'input\',     defaultval:""  }\n\t \t//,{name:"rights"\t\t\t\t\t, type: \'input\',     defaultval:"rw"  }\n\t\t,{name:"rights"   \t    , type: \'option\',  style:"",  choices: ["private", "readable", "project standard", "project standard, writable" ],\n\t\t\t\t\t\t\t\t\t\t\tids: ["--","r-","s-","sw"], defaultval:"--"}\n\t ,{ type: \'separator\' }\n\t]\n   }\n\n   var presetForm_viewer_permorder = {name:"permOrder"\t\t        ,  type: \'option\',  style:"",  \n  \t    \tchoices: ["Human (radiological)", "Human (neurological)","Human (upsidedown)", "Mouse Bruker","Mouse upsidedown","Sheep", \'Memory aligned\'],\n  \t    \tids:     ["human", "human_neuro", "human_flipped", "mouse","mouse_flipped", "sheep","fixed_heart"],\n \t\t\ttitle: \'Viewing mode (swaps/flips)\', defaultval:"human" }\t\t\n\n   var presetForm_viewer = \n   { \n\tname \t\t: "presetForm_viewer",\n\tlastchange  : "",\n\titems : { "class" : \'KFormItemSettings\' },\n//\tclassdef  : ".viewersettings .KFormItem {padding:6px;} .viewersettings .KFormItem label {min-width: 170px!important;}",\n\tlayout: \n\t[\n\t { type: \'title\', val: "Viewer"}\n\t\t,{name:"defaultFOVwidth_mm" \t, type: \'input\',     defaultval:""   ,  title:\'Default size of field of view (FOV) in mm, if empty, FOV is automatically computed\'  }\n\t \t, presetForm_viewer_permorder\t\t\t\t\t\t\t\t\t\t\t\n\t\t,{name:"globalCoordinates" \t, type: \'check\',     defaultval:true ,  title:\'Global coordinates\'  }\n\t\t,{name:"loadBitmapAsNifti" \t, type: \'check\',     defaultval:false ,  title:\'Load bitmap as nifti\'  }\n\t\t,{name:"preferqform" \t, type: \'check\',     defaultval:false ,  title:\'Prefer quaternions during nifti load (qform)\'  }\n  \t    ,{name:"spacedef" , type: \'option\',    style:"",  title: \'Apply space definition on image load\',\n\t\t  choices: ["No",    \'right-anterior-superior\',\'left-anterior-superior\',\'right-posterior-superior\',\n     \t\t\t\t\t\'left-posterior-superior\',\'right-anterior-inferior\',\'left-anterior-inferior\',\'right-posterior-inferior\',\'left-posterior-inferior\'],\n\t\t  ids:     ["NO", \'right-anterior-superior\',\'left-anterior-superior\',\'right-posterior-superior\',\n \t\t\t\t\t    \'left-posterior-superior\',\'right-anterior-inferior\',\'left-anterior-inferior\',\'right-posterior-inferior\',\'left-posterior-inferior\'],\n\t\t   defaultval:"NO"} \n\n\n\n\t\t,{name:"maxfilesizeImage"     , type: \'input\',  \t defaultval:4000    , title:\'Maximum filesize of image data (in MB)\'   }\n\n\t\t,{name:"worldVoxelsize" \t, type: \'input\',     defaultval:"[1.5,1.5,1.5]" ,  title:\'Voxelsize of worldcoordinates (mm)\'  }\n\t\t,{name:"defaultsizemarker" \t, type: \'input\',     defaultval:5 ,  title:\'Defaultsize of Marker (mm)\'  }\n\t\t,{type: \'separator\'}\n\t\t,{name:"quality3D"\t\t\t, type: \'input\',     defaultval:7  ,  title:\'Quality 3D\'  }\n\t\t,{name:"background3D"\t\t\t, type: \'input\',     defaultval:"#111111"  ,  title:\'Background Color in 3D\'  }\n\t\t,{name:"fiberAlpha"\t\t\t, type: \'check\',     defaultval:false ,  title:\'Transparency on Fibers\'  }\n\t\t,{name:"picto3D"\t\t\t, type: \'option\',  title:\'Pose pictogram\' ,\n\t\t\t\t\t\t\t\t\t\t  style:"radio vert",  choices: ["none","Male Body", "Girl", "Minion","Head"],\n\t\t\t\t\t\t\t\t\t\t   ids: [-1,0,1,2,3],\n\t\t    \t\t\t\t\t\t\t   defaultval:1}\n\t\t,{type: \'separator\'}\n\t\t,{name:"sizeTablePercent"\t\t, type: \'input\',     defaultval:20   ,  title:\'Size of table in percent\'  }  \n\t\t,{name:"nVisibleCols"\t\t\t, type: \'input\',     defaultval:2    ,  title:\'Number of columns of visible viewports\'  }\n\t\t,{name:"nVisibleRows" \t\t\t, type: \'input\',     defaultval:2    ,  title:\'Number of rows of visible viewports\'   }\n\t\t,{name:"nVisibleBarports" \t\t, type: \'input\',     defaultval:0    ,  title:\'Number of rows of bar viewports\'   }\n\t\t,{name:"barportSizePercent" \t, type: \'input\',     defaultval:30    ,  title:\'Size of Barports (in percent)\'   }\n\t\t,{name:"nVisibleVertports" \t\t, type: \'check\',     defaultval:0    ,  title:\'Is the big left Viewport visible\'   }\n\t\t,{name:"vertportSizePercent" \t, type: \'input\',     defaultval:60   ,  title:\'Size of big left one in Percent\'   }\n\n\t\t,{name:"stickytoolbar" \t\t\t, type: \'check\',     defaultval:true    ,  title:\'Toolbar of overlays/ROIs/etc. stay\'   }\n\t\t,{type: \'separator\'}\n\t\t,{name:"histoModeDefault"   \t, type: \'check\',     defaultval:true ,  title:\'Visibility of histograms\' }\n\t\t,{name:"histoSizeFac" \t\t\t, type: \'input\',     defaultval:1    ,  title:\'Relative size of histograms\'  }\n\t\t,{name:"crosshairModeDefault" \t, type: \'check\',     defaultval:true ,  title:\'Visibility of crosshair\'  }\n\t\t,{name:"showInfoBar"   \t\t\t, type: \'check\',     defaultval:true  ,  title:\'Visibility of infobar\'  }\n\t\t\n\t\t,{type: \'separator\'}\n\t\t,{name:"globalCoordinates" \t, type: \'check\',     defaultval:true ,  title:\'Global coordinates\'  }\n\t\t,{name:"roiTransparency"   \t\t\t, type: \'input\',     defaultval:.5  ,  title:\'Transparency of ROIs\'  }\n\t\t,{name:"showOutlines"   \t\t\t, type: \'check\',     defaultval:true  ,  title:\'Show ROI/Atlas outlines by default\'  }\n\t\t,{name:"showOutlinesOverlay"   \t\t\t, type: \'check\',     defaultval:false  ,  title:\'Show overlay outlines by default\'  }\n\t] };\n\n   var presetForm_ptable = \n   { \n\tname \t\t: "presetForm_ptable",\n\tlastchange  : "",\n//\tclassdef  : ".viewersettings .KFormItem {padding:6px;} .viewersettings .KFormItem label {min-width: 170px!important;}",\n\tlayout: \n\t[\n\t { type: \'title\', val: "Patient Table"}\n\t\t,{name:"numberDisplayedItems"   , type: \'input\',     defaultval:100       }\n\t\t,{name:"displayOffset"     \t\t, type: \'input\',     defaultval:0   ,css:[\'display\',\'none\']    }\n\t\t,{name:"selectionMode"   \t    , type: \'option\',    style:"radio vert",  choices: ["Working/Patient", "Working/Study", "Patient" , "Study"],\n\t\t\t\t\t\t\t\t\t\t   ids: ["wp","ws","mp","ms"],\n\t\t    \t\t\t\t\t\t\t   defaultval:"ms"}\n\n\t\t,{name:"sortOrder"   \t        , type: \'option\',    style:"radio vert",  \n\t\t  choices: ["Patientname", "Date"],\n\t\t  ids:     ["NAME",        "DATE"],\n\t\t   defaultval:"NAME"} \n\n\n\t\t,{name:"sortDirection"   \t    , type: \'option\',    style:"radio vert",  choices: ["Ascending", "Descending" ],\n\t\t\t\t\t\t\t\t\t\t\tids: ["ASC","DESC"],\n\t\t\t\t\t\t\t\t\t\t\tdefaultval:"ASC"} \n\n\t\t,{name:"treeAutoExpand"   \t    , type: \'option\',    style:"radio vert",  choices: ["Expand nothing", "Expand first", "Expand everything" ],\n\t\t\t\t\t\t\t\t\t\t\tids: ["expandNothing","expandFirstStudy","expandEverything"],\n\t\t\t\t\t\t\t\t\t\t\tdefaultval:"expandFirstStudy"} \n\t\t,{name:"defaultTags"   , type: \'input\',     defaultval:"mask,atlas", title: \'Tag suggestions\'      }\n \t    ,{ type: \'separator\' }\n\t\t,{name:"physrename" \t, type: \'check\',     defaultval:true ,  title:\'Physical rename\'  }\n\t\t,{name:"physdelete" \t, type: \'check\',     defaultval:false ,  title:\'Physical delete\'  }\n\n\t]};\n\n\n\t\n\n\tvar presetForm  = $.extend(true, {}, presetForm_general);\n\n    presetForm.layout = presetForm.layout\n\t\t\t   .concat(presetForm_viewer.layout)\n\t\t\t   .concat(presetForm_ptable.layout)\n\t\t\t   .concat(presetForm_autoload.layout)\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  Settings dialog\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\nfunction SettingsDialog()\n{\n    var that = new Object();\n\n\tvar dialog = new dialog_generic();\n\tvar $container = dialog.$container;\n\tdialog.$frame.width(950);\n\t//dialog.$container.css(\'overflow\', \'hidden\');\n\tthat.dialog = dialog;\n\n\tvar MList = new KList({$menucontainer:dialog.$menu, $targetcontainer:$container, classes:[] });\n\tdialog.$menu.replaceWith(MList.$ul);\n\n\tif (electron)\n\t{\n\t\tMList.append(\'presets\', \'Settings\', \tprojectSettings);\t\t\n\t}\n\telse\n\t{\n\t\tMList.append(\'projectManagement\',  \'Project Management\', projectManagement);\n\t\tMList.append(\'presets\', \'Viewer Settings\', \tprojectSettings);\n\t}\n\tMList.activeID = \'presets\';\n\n\t/***************************************************************************************\n\tThe project management dialog\n\t****************************************************************************************/\n\n\tfunction projectManagement()\n\t{\n\t\tprojectSettingsDialog($container);\n\t}\n\n \n\t/***************************************************************************************\n\tThe user specific project settings \n\t****************************************************************************************/\n\tfunction projectSettings()\n\t{\n\t\treturn presetManager.renderPresetDialog();\n\t}\n\n\n\t/***************************************************************************************\n\tSave state and presets on hide dialog \n\t****************************************************************************************/\n\tdialog.ontoggle = function()\n\t{ \n\t\tif (!electron)\n\t\t{\n\t\t\tif(that.dialog.$frame.css(\'display\')!==\'none\')\n\t\t\t{\n\t\t\t\t //saveAllSettings() ; // is now intrinsically done in saveCurrentState\n\t\t\t\t stateManager.saveCurrentState(); \n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// choose the \n\t\t\t\tsettingsDialog.updateDialog()\n\t\t\t}\n\t\t}\n\t}\n\n\t/***************************************************************************************\n\tUpdate currrent dialog by re-click simulation\n\t****************************************************************************************/\n\tthat.updateDialog = function updateDialog()\n\t{\n\t\tMList.updateOrSelectByID(MList.activeID);\n\t}\n    \n\n\t/***************************************************************************************\n\tChoose a tab from outside\n\t****************************************************************************************/\n\tthat.selectDialog = function selectDialog(activeID)\n\t{\n\t\tif(activeID == \'projectManagement\' | activeID == \'presets\')\n\t\t{\n\t\t\tMList.activeID = activeID;\n\t\t\tMList.updateOrSelectByID(MList.activeID);\n\t\t}\n\t}\n\n\n    signalhandler.attach("projectchanged",function()\n    {\n    \tsetTimeout(function() {\n  \t \t  \t  that.updateDialog();\n    \t},0);\n   \t});\t\n\n\tthat.dialog = dialog;\n\tthat.updateDialog();\n\t//dialog.$frame.show();\n\n\treturn that;\n}\n\n\n\n\n\n\n\n\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//  Preset Manager\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\nfunction PresetManager()\n{\n\t/***************************************************************************************\n\tBasic Vars\n\t****************************************************************************************/\n\n\tvar that = new Object();\n\n\n\t// state and presets can have slightly different forms\n\tvar forms_preset = {\tgeneral: [presetForm_general, "content"], \n\t\t\t\t\t\t\tptable: [presetForm_ptable, "content"], \n\t\t\t\t\t\t\tviewer: [presetForm_viewer, "content"],\n\t\t\t\t\t\t\tautoloader: [presetForm_autoload, "content"] };\n\n\tvar forms_state = {\t\tgeneral: [form_project_user, "project_user"], \n\t\t\t\t\t\t\tptable: [presetForm_ptable, "content"], \n\t\t\t\t\t\t\tviewer: [presetForm_viewer, "content"],\n\t\t\t\t\t\t\tautoloader: [presetForm_autoload, "content"] };\n\n\t// create the generic preset\n\tvar genericpreset = {content: KForm.getFormContent(presetForm, {} ), id:"0", forms: forms_preset};\n\tvar genericautoloader  =  KForm.getFormContent(form_autoloader, {}) \n\tthat.genericpreset = genericpreset;\n\n\tvar presetList = new Object();\n\tvar activePreset = undefined;\n\n\tthat.setPresetList = function(list)\t\t{presetList = list\t}\n\tthat.getPresetList = function()\t\t{return presetList;  \t}\n    that.getActivePreset = function()   {return activePreset;    }\n\n\n\t/***************************************************************************************\n\tButton Callbacks\n\t****************************************************************************************/\n\tvar $favstar = $("<i class=\'fa fa-star\' style=\'color: hsl(50, 100%, 50%);\'></li>");\n\tfunction setStartupPreset(sid)\n\t{\n\t\tif(sid =="0")\n\t\t\treturn\n\t\tstate.project_user.selectedViewerPreset = sid  ;\n\t\tif(that.PList[state.project_user.selectedViewerPreset] !== undefined)\n\t\t\t$favstar.appendTo( that.PList[state.project_user.selectedViewerPreset]);\n\t}\n\n\n\tthat.takeautosnapshot = function(presetID, notsmart)\n\t{ \n\t\tif(presetID !== "0" && !activePreset.iswritable)\n\t\t\t{throwReadonlyError(); return}\n\t\tviewportContentToAutoloaders(presetID, notsmart);\n\t\tthat.PList[activePreset.id].trigger("click");\n\t}\n\n\n\n\tthat.pasteit  = function(toinsert)\n\t{\n    \t\ttry\n \t  \t\t{\t  \t\t\n\t\t\t\tvar obj = JSON.parse(toinsert);\n\t  \t\t}\n\t  \t\tcatch (err)\n\t  \t\t{\n\t\t\t\treturn false;\n\n\t  \t\t}\n\t  \t\tif (obj.nVisibleBarports != undefined)\n\t  \t\t{\n\t\t\t\tactivePreset.content = obj;\n\t\t\t\tthat.applyPreset();\n\t\t\t\tpresetManager.PList[activePreset.id].trigger("click");\n\t\t\t\t//that.selectPreset(activePreset );\t\t\t\t\n\t\t\t\treturn true;\n\t  \t\t}\n\n\t}\n\n\n\n\n\n\n\n\t/***************************************************************************************\n\tRender the preset dialog (left list + right content)\n\t****************************************************************************************/\n\tthat.TList = undefined;\n\tthat.PList = undefined;\n\tthat.renderPresetDialog = function()\n\t{\n\t\t// the Preset Container\n\t\tvar $presetContainer = $("<div class=\'KListView\'></div>");\n\t\tvar $listDIV = $("<div></div>").appendTo($presetContainer);\n\t\tvar $rightDIV = $("<div class=\'KFlexVertical\'></div>").appendTo($presetContainer);\n\n\n\n\t\tif (electron)\n\t\t{\n\t\t\t$("<span style=\'width:80px;\' class=\'modernbutton\'> save </span>").appendTo($rightDIV).click(\n\t\t\t\t\tfunction() { stateManager.saveCurrentState(function() { altertify.success("saved")},true); } );\n\t\t\t$("<span style=\'width:80px;\' class=\'modernbutton\'> defaults </span>").appendTo($rightDIV);\n\n\t\t}\n\n\t\t/////// Preset Tools\n\t\tvar $tDIV = $("<div style=\'background:hsl(0, 0%,16%);\'></div>").appendTo($rightDIV);\n\n\t\tif (electron)\n\t\t\t$tDIV.hide();\n\n\t\tvar $tools = $("<div class=\'modernbuttongroup\'></div>").appendTo($tDIV);\n\t\tvar $apply = $("<div class=\'modernbutton small green\'><i class=\'fa fa-arrow-left\'></i>Apply preset as state</div>").appendTo($tools).click( function() {that.applyPreset(that.PList.activeID)  } );\n\t\tvar $asStandard = $("<div class=\'modernbutton small yellow\'><i class=\'fa fa-star\'></i>set preset as startup default</div>").appendTo($tools).click( function(){ setStartupPreset(activePreset.id) }   );\n\t\tvar $delete = $("<div class=\'modernbutton small red\'><i class=\'fa fa-trash\'></i>delete preset</div>").appendTo($tools).click( deletePreset  );\n\n\n\t\t//var $cDIV = $("<div  class=\'KListView_vertical\'></div>").appendTo($rightDIV);\n\n\t\tvar $cDIVupper = $("<div style=\'background:hsl(0, 0%,16%);\' class=\'\'></div>").appendTo($rightDIV);\n\t\tvar $cDIVLower = $("<div class=\'\' ></div>").appendTo($rightDIV);\n\n\n\n\t\t/////// preset List\n\t\tvar PList = new KList({ $targetcontainer:$cDIVLower, classes:["vertical", "classic" ,"inverted"] });\n\t\tif (!electron)\n\t\t\tPList.$ul.appendTo( $listDIV );\n\t\telse\n\t\t\t$listDIV.hide();\n\n\n\t\t/////// viewer List and so on\n\t\tvar TList = new KList({ $targetcontainer:$cDIVLower,  classes:["horizontal", "roundish"]   });\n\t\tTList.$ul.appendTo( $cDIVupper );\n\n\t\tif (!electron)\n\t\t{\n\t\t\tTList.append(\'general\',  \t\'general\', renderPresetSubForm  );\n\t\t\tTList.append(\'autoloader\',  \'autoloaders\', renderPresetSubForm  );\n\t\t}\n\t\t\t\t\n\t\tTList.append(\'viewer\', \t\t\'viewer\', \t renderPresetSubForm);\n\t\t\n\t\tif (!electron)\n\t\t\tTList.append(\'ptable\', \t\t\'table\', \trenderPresetSubForm);\n\t\t\n\t\tTList.append(\'jsoncode\', \t\t\'jsoncode\', \trenderJSONCode);\n\n\t\t// this is to remember which tab was clicked need referencing\n\t\tPList.subList = TList;\n\n\t\t\n\t\tfunction renderPresetList()\n\t\t{\n\t\t\tactivePreset = undefined;\n\t\t\tPList.$ul.empty();\n\t\t\t\n\t\t\t//first element in list is state\n \t\t\tPList.append("0",  \'current state\', undefined, function() \n \t\t\t{\n \t\t\t\t\tstatePreset = \n \t\t\t\t\t{\n \t\t\t\t\t\tid: "0",\n \t\t\t\t\t\tcontent: state.viewer,\n \t\t\t\t\t\tproject_user: state.project_user,\n \t\t\t\t\t\tforms: forms_state,\n \t\t\t\t\t\tiswritable:true\n \t\t\t\t\t};\n \t\t\t\t\tselectPreset( statePreset );\n \t\t\t} );\n\n\t\t\t// new preset button\n  \t\t\t$("<div class=\'modernbutton small green\' ><i class=\'fa fa-arrow-down\'></i>Copy state as new preset</div>")\n  \t\t\t           .click( function(){copyElement()}).appendTo(PList.$ul);\n\n\n\n\n\t\t\t$("<div class=\'modernbutton small red\' ><i class=\'fa fa-copy\'></i>Copy state to clipboard</div>")\n  \t\t\t           .click( function(){\n\t\t\t\t\t\t\tvar content= $.extend(true, {}, state.viewer);\n\t\t\t\t\t\t\tcontent.toolstate = state.toolstate;\n\n\t\t\t\t\t\t\t  var $temp = $("<textarea style=\'position:absolute; display:block;z-index:99999;top:0px\'>"+JSON.stringify(content)+"</textarea>").appendTo($body).select();\n\t\t\t\t\t\t\t  var successful = document.execCommand(\'Copy\');\n\t\t\t\t\t\t\t  $.notify(" Copied to clipboard","success");\n\t\t\t\t\t\t\t  $temp.remove();\n\n\n  \t\t\t           }).appendTo(PList.$ul);\n\n\t\t\t$("<div class=\'modernbutton small red\' ><i class=\'fa fa-copy\'></i>Paste state from text</div>")\n  \t\t\t           .click( function(){\n\t\t\t\t\t\t\n\n\n\t\t\t\t\t\t\t\t\t\talertify.prompt(\'Please insert JSON String from your clipboard and press enter\', function(a,b)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif(a)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t if (!that.pasteit(b))\n\t\t\t\t\t\t\t\t\t\t\t\talertify.alert("Nora not able to understand your clipboard contents");\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t});\n\n\n\n  \t\t\t           }).appendTo(PList.$ul);\n\n\n\n\n\t\t\tPList.append("spacer", \'presets\');\n\t\t\tfor(var id in presetList)\n\t\t\t{\n\t\t\t\tif(id!="0"){\n\t\t\t\t\tvar p = presetList[id];\n\t\t\t\t\tPList.append(p.id,  p.content.name, undefined, function(id){return function() {selectPreset(id)} }(id) );\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif(that.PList && that.PList.activeID != undefined && PList[that.PList.activeID])\n\t\t\t\tPList[that.PList.activeID].trigger(\'click\');\n\t\t\telse\n\t\t\t\tPList.updateOrSelectByID(); // select first element\n\n\t\t\tif(that.TList && that.TList.activeID != undefined)\n\t\t\t\tTList[that.TList.activeID].trigger(\'click\');\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (electron)\n\t\t\t\t\tTList.updateOrSelectByID(\'viewer\'); // select autoloader tab\n\t\t\t\telse\n\t\t\t\t\tTList.updateOrSelectByID(\'autoloader\'); // select autoloader tab\n\t\t\t}\n\t\t\t\t\n\n\t\t\tthat.PList = PList;\n\t\t\tthat.TList = TList;\n\n\t\t\t// set the star of standard standard\n\t\t\tsetStartupPreset(state.project_user.selectedViewerPreset);\n\n\t\t}\n\n\t\tfunction selectPreset(arg)\n\t\t{\n\t\t\tif(typeof arg =="object")\n\t\t\t\tactivePreset = arg;\n\t\t\telse\n\t\t\t\tactivePreset = presetList[arg];\n\n\t\t\tif(activePreset.id == "0")\n\t\t\t\t{$tools.css(\'visibility\', \'hidden\') }\t\n\t\t\telse\n\t\t\t\t{$tools.css(\'visibility\', \'visible\') }\n\t\t}\n\t\tthat.selectPreset = selectPreset;\n\n\n\t\tfunction renderJSONCode()\n\t\t{\n\t\t\t\n\t\t\tvar jsoneditor = new KJSONEditor(activePreset, \'content\',  { parseonblur:1, editable:activePreset.iswritable, copybutton:1 });\n\t\t\tvar $formDIV = $("<div style=\'position:relative;width:100%;height:95%\'></div>")\n\t\t\t\t.append(jsoneditor.$container);\n\t\t\treturn $formDIV\n\t\t}\n\n\n\t\tfunction renderPresetSubForm(id)\n\t\t{\n\t\t\tvar $formDIV = $("<div style=\'position:relative;width:100%;\'></div>");\n\t\t\t\n\t\t\t// form onchange\n\t\t\tfunction onchange(obj, field, val)\n\t\t\t{\n\t\t\t\tif(field === \'name\') // set the title of this preset in left list\n\t\t\t\t{\n\t\t\t\t\tvar newname = activePreset.content.name;\n\t\t\t\t\tPList[activePreset.id].html(newname);\n\n\t\t\t\t\t//if(KViewer != undefined)\n\t\t\t\t\t//\tKViewer.autoloader_updateList();\n\t\t\t\t}\n\t\t\t\tif (field == \'picto3D\')\n\t\t\t\t{\n\t\t\t\t\tsignalhandler.send(\'picto3dmodel_changed\');\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\t//forms are in forms[0],  target variable can depend on form, is in forms[1] (see createPresetList)\n\t\t\t//KForm.createForm(activePreset.forms[id][0], activePreset[activePreset.forms[id][1]], $formDIV, onchange);\n\t\t\tif(id ==\'general\' && activePreset.id == "0")\n\t\t\t\tKForm.createForm(forms_state[id][0], activePreset[forms_state[id][1]], $formDIV, onchange);\n\t\t\telse\n\t\t\t\tKForm.createForm(forms_preset[id][0], activePreset[forms_preset[id][1]], $formDIV, onchange);\n\t\t\t\n\t\t\t\n\t\t\t\n\t\t\tif(id==\'autoloader\') \n\t\t\t{\n\t\t\t\tvar $snapshot = $("<div class=\'modernbutton small\' style=\'position:absolute;right:0px;top:0px;width:210px\'><i class=\'fa fa-camera\'></i>take snapshot</div>")\n\t\t\t\t\t.appendTo($formDIV).click( that.takeautosnapshot   );\n\t\t\t}\n\n\n\t\t\tif(!activePreset.iswritable)\n\t\t\t{\n\t\t\t\t$formDIV.find("input").attr("disabled", true); \n\t\t\t\t$formDIV.find("textarea").attr("disabled", true); \n\t\t\t\t$formDIV.find("select").attr("disabled", true); \n\t\t\t\t// form array clickers\n\t\t\t\t$formDIV.find(".KFormItem_formarray_tool").off(\'click\').click( function(ev){ return throwReadonlyError()}  ) ;\n\t\t\t}\n\n\t\t\treturn $formDIV;\n\t\t}\n\n\t\t\n\n\t\t/***************************************************************************************\n\t\tDelete Preset\n\t\t****************************************************************************************/\n\t\tfunction deletePreset(listid)\n\t\t{\n\t\t\tvar id = activePreset.id;\n\t\t\tif(id == "0")\n\t\t\t\treturn;\n\n\t\t\tif(!activePreset.iswritable)\n\t\t\t{\n\t\t\t\t$.notify("You do not have the rights to delete this preset!","error");\t\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tjsonTable_delete( {id:id}, whendone);\n\n\t\t\tfunction whendone(result) \n\t\t\t{\n\t\t\t\tif(result.msg==\'\')\n\t\t\t\t{\n\t\t\t\t\tPList[id].remove();\n\t\t\t\t\tdelete presetList[id];\n\t\t\t\t\tif(id == activePreset.id )\n\t\t\t\t\t{\n\t\t\t\t\t\tnextID = Object.keys(presetList)[Object.keys(presetList).length-1] || "0";\n\t\t\t\t\t\tPList[nextID].trigger(\'click\');\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\talert("Could not delete Element in SQL");\n\t\t\t\t}\n\t\t\t}\n\t   }\n\n\t\t/***************************************************************************************\n\t\tExtend current state to Preset\n\t\t****************************************************************************************/\n\t\tthat.overwritePresetWithState = function(id)\n\t\t{\n\t\t\tif(presetList[id] == undefined)\n\t\t\t\treturn false;\n\t\t\tif(!presetList[id].iswritable)\t\t\t\t\n\t\t\t\talert("Preset is not writable");\n\t\t\t\t\n\t\t\t// must keep the name and the id ... so do not do a deep extend! (autloader list will be cleared)\t\n\t\t\tvar oldname = presetList[id].content.name;\n\t\t\tvar oldrights = presetList[id].content.rights;\n\t\t\tvar oldiswritable = presetList[id].iswritable;\n\t\t\t\n\t\t\tpresetList[id].content = $.extend(false, {}, state.viewer);\n\t\t\t\n\t\t\t// make sure project is correct\n\t\t\tpresetList[id].content.project = currentModule;\n\t\t\t\n\t\t\t// keep name and rights of old preset\n\t\t\tpresetList[id].content.name = oldname;\n\t\t\tpresetList[id].content.rights = oldrights;\n\n\n\t\t\tpresetList[id].iswritable = oldiswritable;\n\t\t\t\n// \t\t\tsaveSinglePreset(presetList[id]);\n// \t\t\treturn true\n\t\t\treturn presetList[id]\n\t\t\t\n\t\t}\n\n\t\t/***************************************************************************************\n\t\tCopy Preset\n\t\t****************************************************************************************/\n\t\tfunction copyElement(preset)\n\t\t{\n\t\t\tvar basename = "preset";\n\t\t\tvar newname = basename;\n\n\t\t\tfor(var k=0;k<50;k++)\n\t\t\t{\n\t\t\t\tnewname = basename+ "(" + k + ")";\n\t\t\t\tvar found = false;\n\t\t\t\tfor(var id in presetList)\n\t\t\t\t{\n\t\t\t\t\tif( presetList[id].content.name == newname)\n\t\t\t\t\t\tfound = true;\n\t\t\t\t}\n\t\t\t\tif (!found)   \t  \n\t\t\t\t\tbreak; \n\t\t\t}\n\n\t\t\tvar newPreset = new Object();\n\t\t\tnewPreset.id=  \'temp\' + (Object.getOwnPropertyNames(presetList).length+1);\n\t\t\tnewPreset.content= $.extend(true, {}, state.viewer);\n\t\t\tnewPreset.content.name  = newname;\n\t\t\tnewPreset.content.owner = userinfo.username;\n\t\t\tnewPreset.content.rights = \'--\';\n\t\t\tnewPreset.content.project = currentModule;\n\t\t\tnewPreset.content.toolstate = state.toolstate;\n\n\t\t\t//newPreset.forms= genericpreset.forms,\n\t\t\tnewPreset.iswritable = true;\n\n\t\t\t//save already here to database ...\n\t        saveSinglePreset(newPreset ,  whendone);\n\t\t\tfunction whendone(result) \n\t\t\t{\n\t\t\t  newPreset.id = result.json[0].id;\n\t\t\t  newPreset.content.id = newPreset.id;\n\n\t\t\t  presetList[newPreset.id] = newPreset;\n \t\t\t  renderPresetList();\n \t\t\t  PList[newPreset.id].trigger("click");\n\t\t\t}\n\n\t   }\n\t   that.copyElement = copyElement;\n\n\t   renderPresetList();\n\t   // this would not work with the standalone version\n\t   //that.loadPresets(renderPresetList);\n\t   \n\n\t   return $presetContainer;\t\t\n\t}\n\t/***************************************************************************************\n\tEND OF renderPresetDialog\n\t****************************************************************************************/\n   \n\n\n\n\tfunction throwReadonlyError()\n\t{\n\t\talertify.alert(\'These presets are readonly. Please make a copy if you want to change them.\');\n\t\treturn false;\n\t}\n\n\t/***************************************************************************************\n\tLoad preset list from server\n\t****************************************************************************************/\n    that.loadPresets = function(callback)\n    {\n \t\tjsonTable_load( {type:\'viewersettings\'}, function(result)\n \t\t{\n \t\t\tthat.createpresetListFromAjax(result.json);\n \t\t\tif(callback)\n \t\t\t\tcallback();\n \t\t}) ;\n \t\n    }\n\n\n\t/***************************************************************************************\n\tCreate the list from ajax return\n\t****************************************************************************************/\n\tthat.createpresetListFromAjax = function(ajaxList_in)\n\t{\n\t\tpresetList = new Object();\n\n\t\tif(ajaxList_in == null)\n\t\t\treturn false;\n\t\t\n\t\tvar ajaxList = [];\n\t\tif(!$.isArray(ajaxList_in))\n\t\t{\n\t\t\tfor(var k in ajaxList_in)\n\t\t\t\tajaxList.push(ajaxList_in[k].content);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tajaxList = ajaxList_in;\n\t\t}\n\n\n\t\tfor(var k=0; k < ajaxList.length; k++)\n\t\t{\n\t\t\t//$.extend(true, ajaxList[k], genericpreset);\n\t\t\t// generic as basis\n\t\t\tvar base = $.extend(true, {}, genericpreset.content);\n\t\t\tpresetList[ajaxList[k].id] = \n\t\t\t{\n\t\t\t\tid:ajaxList[k].id, \n\t\t\t\tcontent:  $.extend(true, base,  ajaxList[k] ),\n\t\t\t\tforms: forms_preset \n\t\t\t};\n\n\t\t\t// check if writable\n\t\t\tvar preset = presetList[ajaxList[k].id];\n\t\t\tpreset.iswritable = ( (preset.content.rights.substr(1,1) == \'w\') | preset.content.owner == userinfo.username ) ;\n\t\t\t//preset.iswritable  = false;\n\n\t\t}\n\t}\n\n\n\n\n\t/***************************************************************************************\n\tpreset selection / application \n\t****************************************************************************************/\n \tthat.applyPreset = function(id)\n\t{\n\n\t\tif(id !== undefined)\n\t\t\tvar preset = presetList[id];\n\t\telse\n\t\t\tvar preset = activePreset;\n\n   \t/* ????????? ask Elias \n\t\tif( activePreset  == undefined){ alertify.alert("No valid preset selected. Aborting"); return }\n   \t\tstate.viewer = $.extend(true, {}, activePreset.content);\n\t*/\n\n\t\tif( preset  == undefined){ alertify.alert("No valid pjsonTable_savereset selected. Aborting"); return }\n\n\t\tvar toolstate;\n\t\tif (preset.content.toolstate)\n\t\t{\n\t\t\ttoolstate = preset.content.toolstate;\n\t\t\tconsole.log("toolstate loaded by applyPreset")\n\t\t}\n\t\n   \t\tstate.viewer = $.extend(true, {}, preset.content);\n\t\tstate.viewer.toolstate = undefined;\n\t\t\n\n   \t\tViewerSettings = state.viewer;\n\n\t\t// new: do not apply selection mode or table width.\n\t\t// no harm to project change: there, it is still done with another function\n\t\tswitchto(state.viewer.selectionMode);  \t\n\t \t\n\t\tif( typeof KViewer !== "undefined" ) \n\t\t\tKViewer.applyState(); \n\n\t\tif (toolstate)\n\t\t\tKToolWindow.reestablishToolState(toolstate);\n\t\t\n   \t}\n\n \tthat.applyPresetByName = function(name)\n\t{\n\t\tfor (var k in presetList)\n\t\t{\n\t\t\tif (presetList[k].content.name == name)\n\t\t\t{\t\t\t\n\t\t\t\tthat.applyPreset(k);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\t\talertify.error("Preset " + name + " not found, keeping old preset."); \n\n\t}\n\n\n\n\t/***************************************************************************************\n\tpreset selection / application: Viewer / autoloader settings only\n\t****************************************************************************************/\n \tthat.applyPresetViewerOnly = function(id)\n\t{\n   \t \n\t\tif(id !== undefined)\n\t\t\tvar preset = presetList[id];\n\t\telse\n\t\t\tvar preset = activePreset;\n\n\t\tstate.viewer.nVisibleVertports =  preset.content.nVisibleVertports;\n\t\tstate.viewer.nVisibleCols =  preset.content.nVisibleCols;\n\t\tstate.viewer.nVisibleRows =  preset.content.nVisibleRows;\n\t\tstate.viewer.nVisibleBarports =  preset.content.nVisibleBarports;\n\t\tstate.viewer.autoloaders = $.extend(true, [], preset.content.autoloaders );\n\t\tstate.viewer.autoloaderLevel = preset.content.autoloaderLevel;\n\t\n\t\tif( typeof KViewer !== "undefined" ) \n\t\t\tKViewer.applyNewViewportLayout();\n\n   \t}\n\n\n\n   \n\n\t/***************************************************************************************\n\tSave stuff\n\t****************************************************************************************/\n\tfunction saveSinglePreset(preset,  whendone)\n\t{\n\t\tvar row = { type:\'viewersettings\', id: preset.id, json:preset.content}; \n\t\tjsonTable_save(row, whendone)\n\t}\n\n\tthat.saveAllPresets = function savePresets()\n\t{\n\t\tvar rows = that.getRowsForSaving();\n\t\t\tif(rows.length > 0)\t\n\t\t\t\tjsonTable_save(rows)\n\t}\n  \n\tthat.getRowsForSaving = function()\n\t{\n  \t\tvar rows = new Array();\n\t   \tfor(var id in presetList)\n   \t\t{\n   \t\t\tvar preset = presetList[id];\n   \t\t\tif (id !== "0" & preset.iswritable) // do not save the state nor non-writable settings!\n\t\t\t{\n\t\t\t\trows.push( { type:\'viewersettings\', id: id, json:preset.content }  ); \t\t\t\n\n// to be properly implemented: only ask if really changed!!!\n// \t\t\t\tif(preset.content.rights[0] == "s")\n// \t\t\t\t\talertify.confirm("You changed the public standard settings of <b>"+ preset.content.name + "</b> <br>This might affect other users! Press OK to save the changes.", function(ans)\n// \t\t\t\t\t{ \t\n// \t\t\t\t\t\tif(ans)\t\t\n// \t\t\t\t\t\t\trows.push( { type:\'viewersettings\', id: id, json:preset.content }  ); \t\t\t\n// \t\t\t\t\t});\n\t\t\t}\n\n   \t\t}\n \t\t\n  \t\treturn rows;\n\t}\n\n   \n\n\n\t/***************************************************************************************\n\tviewportContentToAutoloaders\n\t****************************************************************************************/\n\tfunction viewportContentToAutoloaders(presetID, notsmart)\n\t{ \n\t\tif(presetID == "0")\n\t\t\t//var autoloaders = statePreset.content.autoloaders;\n\t\t\tvar autoloaders = state.viewer.autoloaders;\n\t\telse\n\t\t\tvar autoloaders = activePreset.content.autoloaders;\n\t\t\t\n\n\t\t// clear the loaders first\n\t\t//autoloaders.length = 0;\n\t\tvar oldloaders =  autoloaders.splice(0, autoloaders.length);\n\t\tvar idlist = {};\n\t\tfor(var k=0; k<oldloaders.length; k++)\n\t\t\tidlist[oldloaders[k].id] = k;\n\t\t\t\n\t\tvar s = gatherState();\n\t\tvar items = s.viewports;\n\t\tif(s.viewports.length == 0 )\n\t\t{\n\t\t\talertify.error(\'There are no images in any of your viewports!\');\n\t\t\treturn false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\talertify.success(\'Snapshot taken.\');\n\t\t\tfunction extendtoArray(dest,src,field)\n\t\t\t{\n\t\t\t\tif( src[field] == undefined) // do not set undefined values !!!\n\t\t\t\t\treturn\n\n\t\t\t\tif (Array.isArray(dest[field]))\n\t\t\t\t\tdest[field].push(src[field]);\n\t\t\t\telse\n\t\t\t\t\tdest[field] = [dest[field] , src[field]];\n\n\t\t\t}\n\n\t\t\tvar params = {};\n\t\t\tfor (var k = 0; k < items.length;k++)\n\t\t\t{\n\t\t\t\tif (items[k].intent.gl)\n\t\t\t\t\titems[k].intent.slicing = \'gl\';\n\n\t\t\t\tif (params[items[k].id] != undefined)\n\t\t\t\t{\n\n\t\t\t\t\textendtoArray(params[items[k].id].intent,items[k].intent,\'color\');\n\t\t\t\t\textendtoArray(params[items[k].id].intent,items[k].intent,\'select\');\n\t\t\t\t\textendtoArray(params[items[k].id].intent,items[k].intent,\'slicing\');\n\t\t\t\t\textendtoArray(params[items[k].id].intent,items[k].intent,\'cmap\');\n\t\t\t\t\textendtoArray(params[items[k].id].intent,items[k].intent,\'viewportID\');\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparams[items[k].id] = items[k];\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var k in params)\n\t\t\t{\n\t\t\t\tif (params[k])\n\t\t\t\t{\n\t\t\t\t\t// do not consider temporary ROIs\n\t\t\t\t\t//if( params[k].fileID.substr(0,3) == "ROI")\n\t\t\t\t\t//\tcontinue;\n\t\t\t\t\t\t\n\t\t\t\t\t// check if a loader with this specific id is already here ...\n\t\t\t\t\tvar loader = $.extend(true, {}, genericautoloader); // create a new empty autoloader;\n\n\t\t\t\t\tvar id =  params[k].id;\n\t\t\t\t\tif(idlist[id] != undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tif(oldloaders[idlist[id]].pattern !=undefined && oldloaders[idlist[id]].pattern.trim() !="")\n\t\t\t\t\t\t\tloader.pattern = oldloaders[idlist[id]].pattern;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tloader.pattern = guessFilePattern(notsmart);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tloader.pattern = guessFilePattern(notsmart);\n\t\t\t\t\t}\n\n\t\t\t\t\tfunction guessFilePattern(notsmart)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar fobj = KViewer.dataManager.getFile(params[k].fileID);\n\t\t\t\t\t\tvar finfo = fobj.fileinfo;\n\t\t\t\t\t\tvar pattern;\n\n\t\t\t\t\t\tvar filename = finfo.Filename;\n\t\t\t\t\t\tif(filename == undefined)\n\t\t\t\t\t\t\tfilename = fobj.filename +".nii.gz";\n\n\t\t\t\t\t\tif(filename == undefined)\n\t\t\t\t\t\t\treturn "";\n\n\t\t\t\t\t\tvar extpos = filename.search("\\\\.");\n\t\t\t\t\t\tvar fname = filename.substring(0,extpos);\n\t\t\t\t\t\tvar ext = filename.substring(extpos);\n\n\t\t\t\t\t\tif (finfo.SubFolder == "forms" |  (finfo.Tag != undefined && finfo.Tag.search("/FORM/") > -1))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern =  "FFilename:"  + filename.split(".")[0] + ".form.json";\n\t\t\t\t\t\t\tparams[k].intent.defaultform = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if(notsmart)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpattern =  "FFilename:"  + filename;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// only add a wildcard for _sXXX files.\n\t\t\t\t\t\t\tif( fname.match(/s\\d\\d\\d/) )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\twhile ($.isNumeric(fname[fname.length-1]))\n\t\t\t\t\t\t\t\t\tfname = fname.substring(0,fname.length-1);\n \t\t\t\t\t\t\t\tfname = fname + \'*\' + ext;\n\t\t\t\t\t\t\t\tpattern = "FFilename:" + fname;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tpattern =  "FFilename:"  + filename;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (finfo.patients_id == \'ANALYSIS\')\n\t\t\t\t\t\t\tpattern = "PPIZ:ANALYSIS\\nSStudyID:" + finfo.studies_id + "\\n" + pattern;\n\n\t\t\t\t\t\tvar subf = finfo.SubFolder;\n\t\t\t\t\t\tif (subf != "" & subf != undefined)\n\t\t\t\t\t\t\tpattern += "\\nFSubFolder:" + subf.substring(0,5) + "*";\n\t\t\t\t\t\t\n\t\t\t\t\t\treturn pattern;\n\t\t\t\t\t}\n\n\n\n\n\t\t\t\t\tloader.id = id;\n\t\t\t\t\tautoloaders.push(loader);\n\n\t\t\t\t\tif(params[k].intent.viewportID !== undefined )\n\t\t\t\t\t{\t\n\t\t\t\t\t\tloader.viewportID = params[k].intent.viewportID; \n\t\t\t\t\t\tdelete params[k].intent.viewportID;\n\t\t\t\t\t}\n\n\t\t\t\t\tvar intent_keys = Object.keys(params[k].intent);\n\t\t\t\t\tfor (var j=0;j < intent_keys.length;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (params[k].intent[intent_keys[j]] == undefined)\n\t\t\t\t\t\t\tdelete params[k].intent[intent_keys[j]];\n\t\t\t\t\t}\n\n\n\t\t\t\t\tif( params[k].fileID.substr(0,3) == "ROI")\n\t\t\t\t\t{\n\t\t\t\t\t\tparams[k].intent.autocreateroi = "0";\n\t\t\t\t\t}\n\n\t\t\t\t\tdelete params[k].intent.gl;\n\n\t\t\t\t\tloader.intent = params[k].intent;\n\n\t\t\t\t}\t   \t\t\n\t\t\t}\n\t\t}\n\t}\n\n\n\treturn that;\n}\n\n\n\n\n\n'},function(t,n){t.exports='\n// ======================================================================================\n// ======================================================================================\n// ============= KDataManager\n// ======================================================================================\n// ======================================================================================\n\nfunction KDataManager()\n{\n  /** The datamanager   \n   * @class \n   *  @alias KDataManager */\n  var that = new Object();\n\n  /** The files/data list (Object key is sqlid/filepath)\n   * @private */\n  var files = {};\n\n  var runningID = 0;\n\n  /** Initiates data request to server/localfilesystem \n   @param {object} params - parameters of file loading task\n   @param {string} params.fileID - sqlid/filepath of file to be loaded    \n   @param {string} params.URLType - from where (serverfile/localfile)\n   @param {callback} params.callback - once file has arrived and processed callback(fileObject) is called\n   @param {callback} params.progressSpinner - neccessary to show progress\n   @function */\n  that.loadData = function (params)\n  {\n    if(params.URLType === \'localfile\' )\n    {\n    \tvar f = KViewer.dataManager.getFile(params.fileID);\n\t\tif (f == undefined)\n      \t\tloadDataFromLocalFile(params)\n      \telse if (params.callback)\n      \t\tparams.callback(f);\n    }\n    else if(params.URLType === \'foreignurl\' )\n    {\n      loadDataFromURL(params);\n    }\n    else if(params.URLType === \'dicomweb\' )\n    {\n      loadDataFromDICOMWEB_URL(params);\n    }\n    else if (params.URLType === \'form\')\n\t{\n\t\tif (params.callback)\n    \t{\n    \t\tparams.callback( {contentType: \'json\', fileinfo:{Tag:\'/FORM/\'}, \n    \t\t              content: {name:params.fileID,content:params.content} });\n\n\t\t\treturn;\n    \t}\n\t}\t\n    else if (params.URLType === \'createROI\')\n\t{\n\t\tif (params.callback)\n    \t{\n    \t\tif (KViewer.dataManager.getFile(params.fileID) == undefined)\n    \t\t{\n\t\t\t\talertify.error("template file for roi creation not present: " + params.fileID);\n\t\t\t\tparams.callback();\n\t\t\t\treturn;\n    \t\t}\n\n    \t\tif (params.intent && params.intent.shared && params.intent.shared.already_present)\n    \t\t\tparams.callback(params.intent.shared.already_present);\n\t\t\telse\n\t\t\t\tKViewer.roiTool.pushROI(params.fileID, params.intendedName, undefined, function (ev){\n\t\t\t\t\tif (params.intent && params.intent.shared)\n\t\t\t\t\t\tparams.intent.shared.already_present = ev;\n\t\t\t\t\tparams.callback(ev);\n\t\t\t\t\t});\n\t\t\treturn;\n    \t}\n\t}\n   else if (params.URLType === \'createANO\')\n\t{\n\t\tif (params.callback)\n    \t{\n\t\t\tvar mset = markerProxy.newSet(params.fileID);  \n\t\t\tparams.fileID= "MSET"+(runningID++);\n    \t\tparams.callback(mset);\n\t//\t    KViewer.roiTool.pushROI(params.fileID, params.intendedName, undefined, params.callback);\n\t\t\treturn;\n    \t}\n\t}\n    else  if(params.URLType === \'cachefile\')\n    {\n\t    var reader = new FileReader();\n\t\treader.onload = function(e) {\n\t\t\t processLoadedFile(params,reader) };\n\t\treader.readAsArrayBuffer(params.file);\n\t}\n    else\n    {\n      loadDataFromServer(params);\n    }\n  }\n\n  /**\n   * @function */\n  that.loadProxy = function (params,update)\n  {\n     var fobj = {proxyev:params,fileID:\'proxy\'+params.fileID.substring(5),fileinfo:{},filename:params.filename.substring(12)};\n\t if (params.SubFolder)\n\t \tfobj.fileinfo.SubFolder = params.SubFolder;\n\n     setFile(fobj.fileID,fobj);\n     if (update == undefined || update == true)\n     \tKViewer.cacheManager.update();\n  }\n\n\n  /**\n   * @function */\n  function setFile(fid,fobj)\n  {\n  \t files[fid] = fobj;\n  }\n  that.setFile = setFile;\n\n  /**\n   * @function */\n  function getFile(fid,params)\n  {\n  \t if (fid.substring(0,5) == \'proxy\' & params != undefined & files[fid.replace("proxy","local")] == undefined)\n  \t {\n\t\t var proxy = files[fid];\n\t\t var reader = new FileReader();\n\t\t proxy.proxyev.progressSpinner = params.progressSpinner;\n\t\t proxy.proxyev.callback = params.callback;\n\t\t reader.onload = function(e) { processLoadedFile(proxy.proxyev,reader);  };\n\n\t\t delFile(fid);\n\n\t\t readBufferFromFile(reader,proxy.proxyev);\n\t\t //reader.readAsArrayBuffer(proxy.proxyev.file);\n\t\t return "proxy";\n  \t }\n  \t else\n  \t {\n  \t \tvar fobj;\n  \t \tif (files[fid.replace("proxy","local")] != undefined)\n  \t \t\tfobj = files[fid.replace("proxy","local")];\n  \t \telse\n\t  \t \tfobj = files[fid];\n\n\t\tif (fobj != undefined)\n\t\t\tfobj.editable = fid.substring(0,9) == "localfile" | fid.substring(0,3) == "FVS" | fid.substring(0,3) == "ROI" | fobj.modified;\n\n\t\treturn fobj;\n\n  \t }\n  }\n  that.getFile = getFile;\n\n  /**\n   * @function */\n  that.getFileIdByNiiFile = function getFileIdByNiiFile(nii)\n  {  \t\n  \tfor(var id in files)\n  \t{\n  \t\tif(files[id].content == nii)\n  \t\t\treturn id;\n  \t}\n\treturn false;\n  }\n\n\n   that.refetchAllFiles = function()\n   {\n\t\tvar keys = Object.keys(files);\n\t\tvar pbar = KProgressBar("updateing","fa-submit",undefined);\n\n\t\titerate(false);\n\t\tvar cnt = 0;\n\t\tfunction iterate(updated)\n\t\t{\n\t\t\tif (updated)\n\t\t\t\tcnt++;\n\t\t\tif (keys.length == 0)\n\t\t\t{\n\t\t\t\tpbar.done();\n\t\t\t\t/*\n\t\t\t\t\tif (cnt == 0)\n\t\t\t\t\t\talertify.error("No files require for update");\n\t\t\t\t\telse\n\t\t\t\t\t\talertify.success(cnt + " files updated");\t\t\t\t\n\t\t\t\t\t\t*/\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar fobj = files[keys[0]];\n\t\t\tkeys.splice(0,1);\n\t\t\tif (fobj.fileinfo.ID != undefined)\n\t\t\t{\n\t\t\t\tif (fobj.subfolder != undefined)\n\t\t\t\t    var txt = fobj.subfolder+"/"+fobj.filename\n\t\t\t\telse\n\t\t\t\t    var txt = fobj.filename\t\t\n\n\t\t\t\tpbar.progress(0,"checking for " + txt)\t\t\t\t    \t    \n\t\t\t\tthat.refetchFile(fobj.fileinfo,function (p) { \n\t\t\t\t    if (p != undefined)\n\t\t\t\t        pbar.progress(p*100,"updateing " + txt)\n\t\t\t\t     } ,iterate);\n\t\t\t}\n\t\t\telse\n\t\t\t\titerate(false);\n\t\t\t\t\t\n\t\t}\n\n   }\n\n\tthat.refetchFile = function(fileinfo,progress,callback)\n\t{\n\t\tajaxRequest(\'command=get_fileidentifier&json=\' + JSON.stringify({fileID:fileinfo.ID}) ,\n\t\t\t\tfunction(e){\n\t\t\t\t\tif (e.identifier != fileinfo.identifier || e.identifier == "")\n\t\t\t\t\t{\n\t\t\t\t\t\tprogress();\n\t\t\t\t\t\tKViewer.dataManager.delFile(fileinfo.ID,true);\n\t\t\t\t\t\tKViewer.dataManager.loadData({fileID:fileinfo.ID,\n\t\t\t\t\t\tprogressSpinner: progress,\n\t\t\t\t\t\tcallback: function ()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t console.log("file " + fileinfo.ID + " was reloaded");\n\t\t\t\t\t\t\t signalhandler.send("updateFilelink",{id:fileinfo.ID});\n\t\t\t\t\t\t\t progress();\n\t\t\t\t\t\t\t callback(true);\n\t\t\t\t\t\t}});\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    console.log("file " + fileinfo.ID + " is up to date");\t\t\t\t\t\t\n\t\t\t\t\t\tprogress();\t\t\t\t\t\t\n\t\t\t\t\t\tcallback(false);\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t}\n\n\n  /**\n   * @function */  \n  function delFile(fid,donotRemoveFromViewer)\n  {\n  \t if (!donotRemoveFromViewer)\n  \t {\n\t\t KViewer.iterateMedViewers(function(medV) {\n\t\t\t   for (var j = 0; j < medV.ROIs.length;j++)\n\t\t\t   {\n\t\t\t\t\tif (medV.ROIs[j].roi.fileID == fid)\n\t\t\t\t\t{\n\t\t\t\t\t\tmedV.ROIs[j].close();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t   }\n\t\t\t   for (var j = 0; j < medV.overlays.length;j++)\n\t\t\t   {\n\t\t\t\t\tif (medV.overlays[j].currentFileID == fid)\n\t\t\t\t\t{\n\t\t\t\t\t\tmedV.overlays[j].close();\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t   }\n\t\t\t   for (var j = 0; j < medV.objects3D.length;j++)\n\t\t\t   {\n\t\t\t   \t\tif ( medV.objects3D[j].fibers && medV.objects3D[j].fibers.fileID == fid)\t\t\t   \t\t\n\t\t\t   \t\t{\n \t\t\t\t\t\tmedV.objects3D[j].close();\n \t\t\t\t\t\tbreak; \n\t\t\t   \t\t}\n\t\t\t   }\n\n\t\t\t   if (medV.currentFileID == fid)\t\n\t\t\t\t\tmedV.close();\n\t\t });\n\t\t if (KViewer.obj3dTool && KViewer.obj3dTool.isinstance && KViewer.obj3dTool.objs)\n\t\t {\n\t\t\t delete KViewer.obj3dTool.objs[fid]\n\t\t\t KViewer.obj3dTool.update();\n\t\t }\n\t\t if (KViewer.atlasTool && KViewer.atlasTool.isinstance && KViewer.atlasTool.objs)\n\t\t {\n\t\t\t delete KViewer.atlasTool.objs[fid]\n\t\t\t KViewer.atlasTool.update();\n\t\t }\n\t\t if (KViewer.roiTool.isinstance && KViewer.roiTool.ROIs)\n\t\t {\n\t\t\t delete KViewer.roiTool.ROIs[fid];\n\t\t\t KViewer.roiTool.update();\n\t\t }\n\n\n\n\n\n\n  \t }\n\n\tif (files[fid] && files[fid].content && files[fid].content.octreeWorker)\n\t\tfiles[fid].content.octreeWorker.kill();\n\n\n    if (files[fid] && files[fid].worker != undefined)\n\t{\n\t\tfiles[fid].worker.postMessage({msg:\'kill\'})\n\t\tfiles[fid].worker = undefined;\n\t}\n\n    if (files[fid] && files[fid].refvisit_tck != undefined)\n\t{\n\t\tif (files[fid].refvisit_tck.visitworker)\n\t\t{\n\t\t\tfiles[fid].refvisit_tck.visitworker.kill();\n\t\t\tfiles[fid].refvisit_tck.visitworker = undefined;\n\t\t}\n\t}\n\n\n  \t delete files[fid];\n  }\n  that.delFile = delFile;\n\n\n  /**\n   * @function */\n  function getFileList()\n  {\n  \t// return keys of file list,  ordered by file name!\n  \tvar keys = Object.keys(files);\n  \tvar arr = [];\n  \tfor(var k=0;k<keys.length; k++)\n  \t{\n\t\tarr.push( [ keys[k].split("file_")[1], keys[k] ] );\n  \t}\n  \tarr.sort(function(a,b) {      return a[0] > b[0];    });\n  \tvar kk = arr.map(function(x){ return x[1] });\n  \treturn kk;//Object.keys(files);\n  }\n  that.getFileList = getFileList;\n\n  function getNextIteratedFilename(basename, baselist)\n  {\n\tvar found = undefined;\n\tbaselist = baselist|| files;\n  \tfor(var f in baselist)\n  \t{\n\t\tif(baselist[f].filename.substring(0,basename.length) == basename)\n\t\t\tfound = f;\n  \t}\n  \tif(found!=undefined)\n  \t{\n  \t\tvar m = baselist[found].filename.match(/\\d+$/);\n  \t\tif(m!=null)\n  \t\t\tbasename = basename.substring(0,m.index) +  (parseInt(m)+1).toFixed(0);\n  \t\telse\n  \t\t\tbasename = basename + "0";\n  \t}\n\telse\n\t\tbasename = basename + "0";\n\n\treturn basename;\n  }\n  that.getNextIteratedFilename = getNextIteratedFilename;\n\n\n\tthat.coregInfos = {};\n\t/**\n\t* @function */\n\tfunction setCoregInfo(psid, coreginfo, del)\n\t{\n\t\tif(del == undefined)\n\t\t\tthat.coregInfos[psid] = coreginfo;\n\t\telse\n\t\t\tdelete that.coregInfos[psid]\n\t}\n\n\tthat.setCoregInfo = setCoregInfo;\n\n\n  \n\n  function loadDataFromLocalFile(params)\n  {\n    var reader = new FileReader();\n    reader.onload = function(e) { processLoadedFile(params,reader) };\n    reader.onprogress = function(pev) {\n\t\t\tif (params.progressSpinner != undefined && pev.total > 0)\n\t\t\t params.progressSpinner(pev.loaded/pev.total,function() {\n\n\t\t\t \tif (typeof xhr != "undefined")\n\t\t\t \t\txhr.abort() \n\t\t\t \telse\n\t\t\t \t\treader.abort();\n\n\t\t\t \t} ); };\n    reader.onerror = function(e) { \n\t\n    alertify.error("problem loading file:" + params.filename); \n    if (params.callback) params.callback(undefined); };\n\treadBufferFromFile(reader,params);\n\n  }\n\n  function loadDataFromURL(params)\n  {\n\n\t\tvar fobj = KViewer.dataManager.getFile(params.fileID)\n\t\tif (fobj != undefined)\n\t\t{\t\t \t\t\t\t \t\n\t\t\tif (params.callback)\n\t\t\t{\n\t\t\t\tparams.callback(fobj);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\t\tif (params.url == undefined && params.fileID != undefined)\n\t\t\tparams.url = params.fileID;\n\n\t\tvar xhr = new XMLHttpRequest();\n\t\t\n\t\tvar suffix = "";\n\t\tvar suffix = "?v=" + Date.now();\n\t\t\n\t\txhr.open(\'GET\', `${window.location.protocol}//${params.url}${suffix}` , true);\n\t\t\n\t\txhr.setRequestHeader(\'Cache-Control\', \'no-cache\');\n\t\txhr.responseType = \'arraybuffer\';\n\t\txhr.onerror = function(e) { alertify.error("url  " +params.url+  " not loaded for unknown reasons"); if (params.callback) params.callback(undefined); };\n\t\txhr.onprogress = function(pev) {\n\t\t\tif (params.progressSpinner != undefined && pev.total > 0)\n\t\t\t params.progressSpinner(pev.loaded/pev.total,function() {xhr.abort() } ); };\n\t\txhr.onload = function(e) {\n\t\t  if (this.status == 200) {\n\t\t\tprocessLoadedFile(params,xhr) \n\t\t\t// myBlob is now the blob that the object URL pointed to.\n\t\t  }\n\t\t  else if (this.status == 404) {\n\t\t\t alertify.error("url " +params.url+  " not loaded (404)"); if (params.callback) params.callback(undefined);\n\t\t  }\n\n\t\t};\n\t\txhr.send();\n  }\n\n  function loadDataFromDICOMWEB_URL(params)\n  {\n\n\n\t    var x = params.fileID.split("/studies/");\n\t    var url = x[0];\n\t    x = x[1].split("/series/");\n\t    var serUID = x[1];\n\t    var stuUID = x[0];\n\n\n        // thi is not yet working (ID are not mapped)\n\t\tvar fobj = KViewer.dataManager.getFile(params.fileID)\n\t\tif (fobj != undefined)\n\t\t{\t\t \t\t\t\t \t\n\t\t\tif (params.callback)\n\t\t\t{\n\t\t\t\tparams.callback(fobj);\n\t\t\t\treturn;\n\t\t\t}\n\t\t}\n\n\n        const client = new DICOMwebClient.api.DICOMwebClient({url});\n\t\tclient.retrieveSeries({\n\t        seriesInstanceUID:serUID,\n\t        studyInstanceUID:stuUID,\n\t\t\tprogressCallback: function(w)\n\t\t\t{\n\t\t\t  KViewer.cacheManager.progressSpinner("dicomweb: "  + Math.round(w.loaded/1000000) + " MB loaded")\n\t\t\t}\n\t\t\t}\n\t\t).then(sers => {\n              var params_arr = []\n\n\t\t  \t  TheDicomReader = new DicomReader();\n\t\t  \t  for (var k = 0;k < sers.length;k++)\n\t\t  \t  {\n\t\t  \t      var p = {}\n                  p.URLType = \'localfile\';\n                  p.fileID = params.fileID\n                  p.filename = "dicomweb"\n                  p.buffer = new Uint8Array(sers[k]);\n                  p.callback = params.callback;\n                  p.progressSpinner = KViewer.cacheManager.progressSpinner\n                  params_arr.push(p);\n\t\t  \t  }\n              TheDicomReader.loadDicoms(params_arr,\n                        function (loadparams)\n                        {\n                            for (var k = 0; k < loadparams.length;k++)\n\t\t\t\t\t\t\t\tKViewer.dataManager.loadData(loadparams[k]);\n\n                            KViewer.cacheManager.update();\n\n                        },KViewer.cacheManager.progressSpinner);\n      \n\t\t})\n  }\n  \n  function loadDataFromServer(params)\n  {\n    if(params.fileID == undefined)\n     return\n      \n\t// fileID is actually a search pattern from autoLoader. special tratment: fileID is used as searchpattern. I\n    // exception: meta files or PACS files, e.g. from a pacs query\n\tif(!$.isNumeric(params.fileID))\n\t{ \n\t\tif (params.fileID.substring(0,5) == \'meta_\' )\n\t\t{\n\n\t\t}\n\t\telse if (params.fileID.substring(0,5) == \'SURF_\' )\n\t\t{\n\n\t\t}\n\t\telse if (params.fileID.substring(0,4) == \'DBS_\' )\n\t\t{\n\n\t\t}\n\t\telse if (params.fileID.substring(0,10) == "ROI_ATLAS_")\n\t\t{\n\t\t    var ids = params.fileID.substring(10).split("_"); \n\t\t\tvar atlas = that.getFile(ids[0])\n\t\t\tif (atlas == undefined)\n\t\t\t{\n\t\t\t\tatlas = that.getFile(ids[0] + "_" +ids[1]);\n\t\t\t\tKViewer.atlasTool.getROIfromSinglelabel(atlas,ids[2],atlas.content.labels[ids[2]].name,atlas,params.callback,params.progressSpinner);\n\t\t\t}\n\t\t\telse\n\t\t\t\tKViewer.atlasTool.getROIfromSinglelabel(atlas,ids[1],atlas.content.labels[ids[1]].name,atlas,params.callback,params.progressSpinner);\n\t\t\treturn;\n\t\t}\n\t\telse if (params.fileID.substring(0,7) != \'PACS://\' )\n\t\t{\n\t\t\t// this will only work from drag of pacs dialog.\n\n\t\t}\n\t\telse // fileID seems to be an autoloader pattern\n\t\t{\n\t\t\tparams.autoLoaderPattern = params.fileID;     \n\t\t\tfor (var id in files)\n\t\t\t{\n\t\t\t\tif( files[id].autoLoaderPattern  == params.fileID) \n\t\t\t\t{\n\t\t\t\t\tif (params.callback)\n\t\t\t\t\t\tparams.callback(files[id]);\n\t\t\t\t\treturn;\n\t\t\t\t}     \t\t\n\t\t\t}\n\t\t}\n\t}\n\n\n    // check if file is already loaded and take from list if yes\n    var fids = getFile(params.fileID,params);\n    if (fids == \'proxy\')\n    {\n    \treturn;\n    }\n    else if (fids != undefined)\n    {\n    \tif (params.callback)\n       \t\tparams.callback(fids);\n        return;\n    }\n\n    // todo: in case of viewer only!\n\tvar docid = currentModule + \'_\' + params.fileID; \n\n\n\tfunction execServerRequest()\n\t{\n\t\tvar fileURL   = myownurl().split("?")[0]; \n\t\tvar xhr = new XMLHttpRequest();\n\t\tvar now = new Date();\n\t\txhr.open(\'POST\', fileURL + \'?time=\' + now.getTime()+\'&asuser=\'+userinfo.username, true);\n\t\txhr.setRequestHeader("Cache-control", "max-age:10");\n\t\txhr.setRequestHeader("Content-type", "application/x-www-form-urlencoded");\n\t\txhr.responseType = \'arraybuffer\';\n\n\t\tvar sigid = signalhandler.attach("close",function() {\n\t\t\txhr.abort();\n\t\t\tparams.progressSpinner();\n\t\t\tsignalhandler.detach("close",sigid);\n\t\t});\n\n\t\txhr.onload = function(e) { \n\t\t\tsignalhandler.detach("close",sigid);\n\t\t\tprocessLoadedFile(params,xhr)\t\n\t\t}\n\t\txhr.onreadystatechange = function() {\n\t\t\tif (xhr.readyState === 4)\n\t\t\t{   //if complete\n\t\t\t\tif(xhr.status === 200)\n\t\t\t\t{  //check if "OK" (200)\n\t\t\t\t\t//success\n\t\t\t\t} \n\t\t\t\telse if(xhr.status === 404)\n\t\t\t\t{\n\t\t\t\t  alertify.error("HTTP error 404:\\nFile not found.\\nMost likely due to missing x-sendfile permissions, or a wrong ROUTE" );\n\t\t\t\t  console.log(xhr.result);\n\t\t\t\t  params.progressSpinner()\n\t\t\t\t  params.callback(undefined);\n\t\t\t\t  return;\n\n\t\t\t\t}\n\t\t\t\telse if(xhr.status === 0)\n\t\t\t\t{\n\t\t\t\t\tparams.progressSpinner();\n\t\t\t\t\txhr.abort();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tparams.progressSpinner();\n\t\t\t\t\talertify.error("Connection to server lost!");\n\t\t\t\t\txhr.abort();\n\t\t\t\t}\n\t\t\t} \n\t\t}\n\n\t\txhr.onprogress = function(pev) {\n\t\t\tif (params.progressSpinner != undefined && pev.total > 0)\n\t\t\t params.progressSpinner(pev.loaded/pev.total,function() {xhr.abort() } ); };\n\t    var json = params.json;\n\t    if (json == undefined)  \n\t    \tjson = {project:currentModule}; // projectmode\n\t    else if (json.project == "")\n\t    \tjson.project = currentModule;   // ??\n\t\tvar addjson = "&json=" + JSON.stringify(json);\n\t\txhr.send(\'fileID=\' + params.fileID + addjson);\n\t}\n\n\n\tif (storage == undefined || params.autoLoaderPattern != undefined)\n\t\texecServerRequest();\n\telse\n\t    storage.getContents(docid).then(function(result) {\n\t\t\tif (result == undefined | result == "")\n\t\t\t\texecServerRequest();\n\t\t\telse\n\t\t\t{\t\t\t\t\n\t\t\t\tvar fileinfo = JSON.parse(result);\n \t\t\t\tsetTimeout(function(){\n \t\t\t\t\tif (params.progressSpinner != undefined)\n \t\t\t\t\t\t params.progressSpinner("checking for file changes"); \n\n\t\t\t\t\tajaxRequest(\'command=get_fileidentifier&json=\' + JSON.stringify({fileID:fileinfo.ID}) ,\n\t\t\t\t\t\tfunction(e){\n\t\t\t\t\t\t\tif (e.identifier == fileinfo.identifier || e.identifier == "")\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tstorage.getAttachment( docid, \'blob\' ).then(function(data) {\n\t\t\t\t\t\t\t\t\t\tif (data != undefined)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (params.progressSpinner != undefined)\n\t\t\t\t\t\t\t\t\t\t\t\tparams.progressSpinner("Retrieving from local disk cache")\n\t\t\t\t\t\t\t\t\t\t\tthat.loadData({fileID:params.fileID, autoLoaderPattern:params.autoLoaderPattern,file:data,URLType:\'cachefile\',callback:params.callback,intent:params.intent,fileinfo:fileinfo,progressSpinner:params.progressSpinner});\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\tconsole.log("Data in local disk cache corrupt! Clean your cache!");\n\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tconsole.log("cache was not found to be up-to-date, reloading");\n\t\t\t\t\t\t\t\tstorage.rm(docid).then(execServerRequest);\n\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t});\n \t\t\t\t   },0);\n\n\n\t\t     \t}\n\n\t     \t});\n\n  }\n\n\n  /** This is the onload callback of the xhr request. It processes/interprets\n  \t   the received binary/text data, e.g. interpreting as nifti/track file, parsing of csv, etc. and\n  \t   it registers the data in the local cache and in the largeLocalStorage.\n  \t   @param {object} params - parameters of file loading task\n  \t   @param {string} params.fileID - sqlid/filepath of file loaded    \n  \t   @param {string} params.URLType - from where (serverfile/localfile)\n  \t   @param {callback} params.callback - once we have processed the file callback(fileObject) is called\n  \t   @param {callback} params.progressSpinner - can be used to show processing progress\n  \t   @param {object} xhr - the xhr request object upon \n  \t   @function */\n  function processLoadedFile(params,xhr)\n  {\n    var response;\n\n    function finalize()\n\t{\n\t\t  if (fileObject.content !== false)\n\t\t  {     \n\t\t    if (fileObject.fileID.substring(0,5) != \'meta_\')\n\t\t    {\n\t\t\t\tfiles[fileObject.fileID] = fileObject;\n\t\t\t\tKViewer.cacheManager.update();\n\n//todoMRC\t\t\t\t  \n\t\t\t  if (0) //params.intent && params.intent.roi)\n\t\t\t  {\n\t\t\t  \t  if(params.intent.color!=undefined)\n\t\t\t  \t  \tfileObject.color = params.intent.color\n\t\t\t\t  KViewer.roiTool.pushROI(fileObject.fileID, "untitled", "frommaskfile",function(fobj)\n\t\t\t\t  {\n\t\t\t\t  \t if (params.intent.ccanalysis)\n\t\t\t\t  \t \tcreateConnCompAnalysis(fobj);   \n\t\t\t\t\t if (params.callback)\n\t\t\t\t\t   params.callback(fobj);\t\t    \n\t\t\t\t  \t \t               \n\t\t\t\t  });\n\t\t\t\t  return;\n\t\t\t  }\n\n\t\t\t\t\n\n\n\t\t\t\tif (fileObject.fileinfo && fileObject.fileinfo.filesize > 250000) // only cache large files\n\t\t\t\t{\t\t\t\n\t\t\t\t\tif (params.URLType == \'serverfile\' & storage != undefined) \n\t\t\t\t\t{\n\n\t\t\t\t\t\tif (state.project_user.localstoragesizeMB*1000000 < storage.size )\n\t\t\t\t\t\t\tstorage.rmOld(tryToSaveInCache,fileObject.fileinfo.filesize);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttryToSaveInCache();\n\t\t\t\t\t\t\t\n\t\t\t\t\t\tfunction tryToSaveInCache()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar docid = currentModule + \'_\' + params.fileID; \n\t\t\t\t\t\t\tvar blob = new Blob([response], {type: \'application/octet-binary\'});\n\t\t\t\t\t\t\tvar finfo = JSON.parse( xhr.getResponseHeader(\'DPX-fileinfo\') );\n\t\t\t\t\t\t\tfinfo.timeOfInsertion = (new Date()).getTime();\n\t\t\t\t\t\t\tstorage.setContents(docid,JSON.stringify(finfo))\n\t\t\t\t\t\t\t.then(function() {\n\t\t\t\t\t\t\t\tstorage.setAttachment(docid, \'blob\',blob).\n\t\t\t\t\t\t\t\tthen(function(){\n\n\t\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\t.catch(function() {\n\t\t\t\t\t\t\t\t\tstorage.rm(docid) \n\t\t\t\t\t\t\t\t\tconsole.log("failed to cache in local storage")\n\t\t\t\t\t\t\t\t})\t\t\t\t\t\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t.catch(function() {\t\t\t\t\t\n\t\t\t\t\t\t\t\tstorage.rm(docid) \n\t\t\t\t\t\t\t\tconsole.log("failed to cache in local storage")\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t }\n\t\t     }\n \t\t\t if (params.callback)\n\t\t\t   params.callback(fileObject);\n\t\t     \n\t\t \n\t\t  }\n  \t  }\n\n\n\n\n    var fileObject = new Object();\n    fileObject.fileID = params.fileID;\n\n    // localfile has other result structure\n    if(params.URLType === \'localfile\' | params.URLType === \'foreignurl\')\n    {\n      if(xhr.customBuffer !== undefined)\n      \txhr.response = xhr.customBuffer;\n      else if (xhr.result != undefined)\n      \txhr.response = xhr.result;\n\n      if (params.filename == undefined || params.URLType === \'foreignurl\')\n      \tparams.filename = params.url.split("/").pop();\n\n      if (params.URLType === \'foreignurl\' && params.intendedName != undefined) \n        params.filename = params.intendedName;\n    \n      \n      if (params.filename.search("//") > -1)\n      \tfileObject.filename = params.filename.split("//")[1];\n      else\n        fileObject.filename = params.filename;\n\n      fileObject.fileinfo = params.fileinfo;\n      if (fileObject.fileinfo == undefined)\n      \tfileObject.fileinfo = {};\n      fileObject.fileinfo.filesize = xhr.response.byteLength,\n      fileObject.fileinfo.SubFolder = params.SubFolder;\n      \n   \n\t  if (params.file && params.file.local)\n\t  {\n          \n\n\t  \t  var p = fileObject.filename.split("/")\n\t  \t  fileObject.filename = p[p.length-1];\n\t  \t  fileObject.fileinfo.filename = p[p.length-1];\n\t  \t  fileObject.fileinfo.SubFolder = p.slice(0,-1).join("/");\n\t  }\n\t  else if (params.file && params.file.path)\n\t  {\n\t\t  fileObject.filename = params.file.name;\n\t\t  fileObject.fileinfo.filename = fileObject.filename;\n\t\t  fileObject.fileinfo.SubFolder = params.file.path.substring(0,params.file.path.length-params.file.name.length-1);\n\n\t  }\n\n\n      runningID++;\n    }\n    else if (params.URLType === \'cachefile\')\n    {\n      xhr.response = xhr.result;\n      fileObject.fileID = params.fileinfo.ID;\n      fileObject.filename = params.fileinfo.Filename;\n      fileObject.fileinfo = params.fileinfo;\n\n    }\n    else  // server file\n    {\n      fileObject.filename = xhr.getResponseHeader(\'DPX-filename\');\n      fileObject.fileinfo = JSON.parse(xhr.getResponseHeader(\'DPX-fileinfo\'));\n      try {\n          fileObject.seqinfo = JSON.parse(xhr.getResponseHeader(\'DPX-jsoninfo\'));\n      } catch(err) {}\n      fileObject.error =  xhr.getResponseHeader(\'DPX-error\');\n      if (xhr.getResponseHeader(\'DPX-note\'))\n      {\n      \talertify.error(xhr.getResponseHeader(\'DPX-note\'));\n      }\n\n\n      try // coregistration info for current study\n      {\n          var coreginfo = JSON.parse(xhr.getResponseHeader(\'DPX-coreginfo\'));\n          fileObject.coreginfo = coreginfo;\n\t\t\t\n\t\t\tvar coregmat = fileObject.coreginfo.spm_coregmat\n\t\t\tvar psid = fileObject.fileinfo.patients_id + fileObject.fileinfo.studies_id;\n\t\t\tthat.setCoregInfo(psid, coreginfo)\n\n          //console.log(studycoreg)\n      } \n      catch(err) {}\n\n    }\n\n\n\t  if (params.SubFolder)\n\t \t fileObject.fileinfo.SubFolder = params.SubFolder;\n\n    response = xhr.response;\n    var uint8Response = new Uint8Array(response);\n\n    if (fileObject.error !== undefined & fileObject.error !== null)\n    {\n//    \tvar err = "Sorry, no match: " + decodeURIComponent(fileObject.fileID);\n    \tvar err = fileObject.error;\n    \tconsole.warn(fileObject.error.replace(/newline/g, "\\n"));\n    \tif (params.onerror != undefined)\n    \t\tparams.onerror(err);\n    \telse\n    \t{\n\t\t\t\t\n\t\t\talertify.lazy_error(err,"dberror");\n\n        \t//also log the content...\n        \tif(response.byteLength < 10000)\n        \t\tconsole.log(ab2str( new Uint8Array(response) ));\n    \t}\n        if (params.progressSpinner)\n        \tparams.progressSpinner()\n        params.callback(undefined);\n        return;\n    }\n\n\n    if(xhr.status === 404)\n    {\n      $.notify("Oops. An error occured: 404:\\nFile not found.\\nThis is most likely due to missing x-sendfile permissions, or a wrong :ROUTE:.", "error" );\n      console.log(xhr.result);\n      params.progressSpinner()\n      params.callback(undefined);\n      return;\n\n    }\n\n    if (fileObject.filename == undefined)\n    {\n        $.notify("Sorry. The file was not found","error");\n        params.progressSpinner()\n        params.callback(undefined);\n        return;\n    }\n\n\n\n\t// set the ID again, just in case it was an SQL search.\n\tif (params.autoLoaderPattern != undefined)\n\t{\t\n\t\tfileObject.autoLoaderPattern = params.autoLoaderPattern;\n\t\tfileObject.fileID = fileObject.fileinfo.ID; \n\t}\n\n\n\n\n\n    if (fileObject.fileinfo.fileseries)\n    {\n      \t  var finfo = fileObject.fileinfo;\n      \t  var fobjs = [];\n      \t  var pos = 0;\n\t\t  for (var k = 0; k < finfo.filesize.length;k++)\n\t\t  {\n\t\t\t\tvar fobj = new Object();\n\t\t\t\tfobj.fileID = params.fileID;\n\t\t  \t    fobj.filename = finfo.filenames[k];\n                fobj.fileinfo = fileObject.fileinfo;\n\t\t\t\tfobj.content = new Uint8Array(uint8Response.buffer.slice(pos,pos+finfo.filesize[k]));\n                pos = pos + finfo.filesize[k];\n                fobjs.push(fobj);\n\t\t  }\n\n\t\t  var bruker = BrukerReader.checkForBrukerData( fobjs)\n\t\t  if (bruker !== undefined )\n\t\t  {\n\t\t\t\tBrukerReader.vis2dseq2Nifti(bruker.headerfile,bruker.datafile,fileObject.fileinfo.Filename, 0,function(fobj)\n\t\t\t\t{\n\t\t\t\t\tparams.callback(fobj);\n\t\t\t\t});\n\n\t\t\t    return;\n\t\t  }\n\n\n   }\n\n\n\n\n\tvar cnter = 0;\t\n\tif(fileObject.filename.search(\'\\\\.gz\') > -1 )\n       if (params.progressSpinner != undefined)\n       \t params.progressSpinner("unpacking");      \n\n    if(fileObject.filename.search(\'\\\\.gz\') > -1 | fileObject.filename.search(\'\\\\.mgz\') > -1 )\n    {\n    \t//pakoWorker = 1;\n\t\t\n    \tif (!pakoWorker)\n    \t{\n    \t\tpako.stat =0;\n    \t\tconsole.time("pako")\n    \t\tprocessfileObject(pako.inflate(uint8Response))\n    \t\tconsole.timeEnd("pako");\n    \t}\n    \telse\n    \t{\n    \t\t\n\t\t\texecuteUnpackWorker(uint8Response,params.progressSpinner,function(e)\n\t\t\t{\n\t\t\t\tif (!e.error)\n\t\t\t\t{\n\t\t\t\t\tresponse = e.back; // necessary to transfer transferable back\n\t\t\t\t\tprocessfileObject(e.arraybuf);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t      logProcess(e.error)\n\t\t\t\t}\n\t\t\t});\n    \t}\n    }\n    else if(params.filetype == "analyze75")\n    {\n\t\t\tzip.workerScriptsPath = "zip/";\n\t\t\tzip.useWebWorkers = false;\n\t\t\tzip.createReader(new zip.BlobReader(new Blob([uint8Response])), function(reader) {\n\t\t\t\t// get all entries from the zip\n\t\t\t\treader.getEntries(function(entries) {\n\t\t\t\t\treader.close();\n\t\t\t\t\tvar fis = {}\n\t\t\t\t\tfor (var j = 0; j < entries.length; j++)\n\t\t\t\t\t\tif (!entries[j].directory)\n\t\t\t\t\t\t\tfis[entries[j].filename] = entries[j]\n\t\t\t\t\tif (fis["hdr"] !=undefined &&  fis["img"] != undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tprepA75_HdrImg(fis,params.progressSpinner,fileObject,processfileObject)\n\t\t\t\t\t}\n\n\t\t\t\t});\n\t\t\t}, function(err) {\n\t\t\t\talertify.error("Error during reading zipfile: " + err.toString());\n\t\t\t});\n    }\n\telse\n\t{\t    \n\t\t/* in some cases, we want to convert a bmp to a nifti, so we have all drawing tools etc available \n\t\tmust implement this here, image conversion is callback based (img.attr = ... onload)\n\t\t*/\n\n\t\tif ( state.viewer.loadBitmapAsNifti &&  \n\t\t\t( fileObject.filename.search(\'\\\\.jpeg\') > 0 | fileObject.filename.search(\'\\\\.jpg\') > 0 | fileObject.filename.search(\'\\\\.png\') > 0 | fileObject.filename.search(\'\\\\.tiff\') > 0 | fileObject.filename.search(\'\\\\.bmp\') > 0)\n\t\t\t)\n\t\t\t{\n\t\t\t\tfileObject.filename += \'.nii\';\n\t\t\t\tfileObject.content = bmpToNIFTI(uint8Response, processfileObject);\n\n\t\t}\n\t\telse\n\t\t\tprocessfileObject(uint8Response);\n\t}\n\t\t\n\n\tfunction processfileObject(uint8Response)\n\t{\n\t\tif(fileObject.filename.search(\'\\\\.nii\') > 0 | fileObject.filename.search(\'\\\\.mgh\') > 0  | fileObject.filename.search(\'\\\\.mgz\') > 0  | fileObject.filename.search(\'\\\\.nrrd\') > 0)\n\t\t{\n\t\t\tfileObject.contentType = \'nii\';\n\t\t\t//try\n\t\t\t{\n\t\t\t\t// parse the NIFTI\n\t\t\t\tvar buf = uint8Response.buffer;\n\t\t\t\tvar niibuf;\n\t\t\t\tif (fileObject.filename.search(\'.nrrd\') > 0 )\n\t\t\t\t\tniibuf = nrrd.parse(buf)\n\t\t\t\telse if (fileObject.filename.search(\'.mgh\') > 0 | fileObject.filename.search(\'.mgz\') > 0)\n\t\t\t\t\tniibuf = parse_mgh(buf)\n\t\t\t\telse\n\t\t\t\t\tniibuf = parse(buf)\n\n\t\t\t\t// prepare NIFTI\n\t\t\t\tfileObject.content = prepareMedicalImageData(niibuf, fileObject, params.intent);\n\n\n\t\t\t\tif (fileObject.seqinfo != undefined)\n\t\t\t\t{\n\t\t\t\t\tfileObject.seqinfo.voxSize = fileObject.content.voxSize;\n\t\t\t\t\tfileObject.seqinfo.sizes = fileObject.content.sizes;\n\t\t\t\t}\n\t\t\t\tfileObject.content.seqinfo = fileObject.seqinfo;\n\n\t\t\t\tif (params.intent != undefined)\n\t\t\t\t{\n\t\t\t\t\tif (params.intent.atlas)\n\t\t\t\t\t{\n\t\t\t\t\t\tKViewer.atlasTool.addAtlas(fileObject);\n\t\t\t\t\t\tfileObject.project = params.intent.project;\t          \t  \n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t/*\n\t\t\tcatch(e) \n\t\t\t{    \n\t\t\t\talertify.error("error preparing image data " + fileObject.filename + ": " + e);      \n\t\t\t\tfileObject.contentType = \'unknown\';        \n\t\t\t}*/\n\n      }\n      else if ( fileObject.filename.search(\'\\\\.jpeg\') > 0 | fileObject.filename.search(\'\\\\.jpg\') > 0 | fileObject.filename.search(\'\\\\.png\') > 0 | fileObject.filename.search(\'\\\\.tiff\') > 0 | fileObject.filename.search(\'\\\\.bmp\') > 0)\n      {\n        fileObject.contentType = \'bmp\';\n        fileObject.content =  uint8Response;\n\n      }\n      else if ( fileObject.filename.search(\'\\\\.rtstruct\') > 0)\n      {\n        fileObject.contentType = \'rtstruct\';\n        if (response.constructor.name == \'ArrayBuffer\')\n        \tfileObject.content =  JSON.parse(ab2str(new Uint8Array(uint8Response)));\n\t\telse\n        \tfileObject.content = response;\n\n        \t\n\n      }      \n      else if (fileObject.filename.search(\'\\\\.txt\') > 0 | fileObject.filename.search(\'\\\\.stats\') > 0 | fileObject.filename.search(\'\\\\.bexclude\') > 0 | fileObject.filename.search(\'\\\\.bval\') > 0 | fileObject.filename.search(\'\\\\.bvec\') > 0  | fileObject.filename.search(\'\\\\.time\') > 0)\n      {\n        fileObject.contentType = \'txt\';\n        //fileObject.content = ab2str( uint8Response);\n        // umlaute did not work so far, with this they do \n        if (typeof response == "string")\n        \tfileObject.content = response;\n        else\n        \tfileObject.content = utf8ab2str( uint8Response);\n      }\n      else if (fileObject.filename.search(\'\\\\.csv\') > 0)\n      {\n        fileObject.contentType = \'tab\';\n        fileObject.content = ab2str( uint8Response);\n      }\n      else if (\n               fileObject.filename.search(\'\\\\.odt\')>0 |\n               fileObject.filename.search(\'\\\\.doc\')>0 |\n               fileObject.filename.search(\'\\\\.docx\')>0 |\n               fileObject.filename.search(\'\\\\.ppt\')>0 |\n               fileObject.filename.search(\'\\\\.pptx\')>0)\n      {\n        fileObject.contentType = \'doc\';\n        fileObject.content = ab2str( uint8Response);\n      }\n  \t else if (fileObject.filename.search(\'\\\\.pdf\') > 0)\n      {\n\n      \t  var blob = new Blob([uint8Response], {type: \'application/pdf\'});\n\n\t\t  var a = document.createElement("a");\n\t\t  a.style = "display: none";\n\t\t  document.body.appendChild(a);\n\t\t  var url = URL.createObjectURL(blob);\n\t\t  a.href = url; // + "?" + fileObject.fileinfo.SubFolder + "/" +  fileObject.fileinfo.Filename ;\n\t\t // a.download = \'myFile.pdf\'; // gives it a name via an a tag\n\t\t  a.target = "_blank_";\n\t\t  a.click();\n\n          params.callback(undefined);\n\t\n\t      return;\n\t      /*\n\n\t//\tconst fileObjectURL = URL.createObjectURL(blob); \n      \twindow.open(fileObjectURL,"mafile.pdf");\n      \tparams.callback(undefined);\n      \treturn;\n        fileObject.contentType = \'doc\';\n        fileObject.content = ab2str( uint8Response);\n           */\n      }      \n\t  else if (fileObject.filename.search("\\\\.ano\\\\.json") != -1  ||  (fileObject.fileinfo.Tag != undefined && fileObject.fileinfo.Tag.search(\'/ANO/\')>-1))\n       {\n       \t  try {\n          \tfileObject.content = JSON.parse(utf8ab2str( uint8Response)); }\n          catch(err)\n          {\n          \t alertify.error("Error during parsing json");\n          \t  params.callback(undefined);\n          \t return;\n          }\n\n\t\t  var sets;\n\t\t  if (params.intent && params.intent.autocreate_ano)\n\t\t  {\n\t\t  \t sets = markerProxy.newSet( params.intent.autocreate_ano);  \n\t\t  \t params.obj = markerProxy.import(fileObject.content.annotations,sets);\n\t\t\tif (KViewer.markerTool.isinstance)\n\t\t\t\tKViewer.markerTool.update();\n\t\t  \t \n\t\t  }\n\t\t  else\n          \t sets = markerProxy.loadAnnotations(fileObject);\n\n          // only show markerTool if no panel / panel not visible\n          if(markerProxy.currentSet &&  markerProxy.currentSet.markerPanel && markerProxy.currentSet.markerPanel.panelvisible)\n          {\n\t\t\t\t// do nothing ( no show )\n          }\n          else\n          {\n          \tif ( !KViewer.markerTool.enabled )\n\t          \t KViewer.markerTool.toggle();\n          }\n          \n\t\t  params.callback();\n          return;\n       }\n  \t    else if (fileObject.filename.search("\\\\.batch\\\\.json") != -1 )\n  \t    {\n  \t    \tif (!commandDialog.visible)\n  \t    \t    commandDialog.toggle();\n  \t    \tcommandDialog.pasteit(utf8ab2str( uint8Response));\n  \t    \tparams.callback();\n  \t    \treturn;\n  \t    }\n\n     /* else if (fileObject.filename.search(\'\\\\.reading\') > 0)\n      {\n\t\tfileObject.formid = ( xhr.getResponseHeader(\'DPX-formid\') );\n        fileObject.contentType = \'json\';\n        fileObject.content = utf8ab2str( uint8Response);\n\n      }*/\n      else if (fileObject.filename.search(\'\\\\.json\') > 0 || fileObject.filename.search(\'\\\\.reading\') > 0)\n      {\n        fileObject.contentType = \'json\';\n        fileObject.content = utf8ab2str( uint8Response);\n        if ( fileObject.content == ""  && typeof response == "string")\n         \tfileObject.content = response;\n        if (params.URLType == \'localfile\')\n        {\n\t\t\tvar tmp = JSONparse_lazy(fileObject.content);\n\t\t\tif (tmp == undefined )\n\t\t\t{\n\t\t\t\tif (params.callback)\n\t\t\t\tparams.callback(undefined);\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t\tif (tmp.content)\n\t\t\t\tfileObject.content = JSON.stringify(tmp.content);\n\t\t\tif (tmp.tag)\n\t\t\t\tfileObject.fileinfo.Tag = tmp.tag;\n        }\n\t\tif ((fileObject.fileinfo.Tag || "").search(\'/TCKSEL/\')>-1 | fileObject.filename.search(\'\\\\.tck\\\\.json\') > 0 )\n\t\t{\n              var tcksel = JSON.parse(fileObject.content);\n              if (tcksel.assoc == undefined)\n              {\n                    if (tcksel.content != undefined & tcksel.content.assoc != undefined)              \t\n                        tcksel = tcksel.content;\n                    else\n                    {\n\t\t\t\t\t alertify.error("Json seems not to be a valid fibeselection.","error");\n\t\t\t\t\t params.callback(undefined);\n\t\t\t\t\t return;\n                    }\n              }\n\n\n              var par = {URLType:\'serverfile\',fileID:tcksel.assoc.fileID, json:params.json,\n              \t\t\t progressSpinner:params.progressSpinner,\n\n\t\t\t\t\t\t callback: function(fp){\n\t\t\t\t\t\t\t  if (fp == undefined)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  \t  var files = KViewer.dataManager.getFileList();\n\t\t\t\t\t\t\t  \t  for (var k = 0; k < files.length; k++)\n\t\t\t\t\t\t\t  \t  {\n\t\t\t\t\t\t\t  \t  \t var fobj = KViewer.dataManager.getFile(files[k]);\n\t\t\t\t\t\t\t  \t  \t if (fobj.content && fobj.content.md5 == tcksel.assoc.md5)\n\t\t\t\t\t\t\t  \t  \t {\n\t\t\t\t\t\t\t  \t  \t \tfp = fobj;\n\t\t\t\t\t\t\t  \t  \t }\n\t\t\t\t\t\t\t  \t  }\n\t\t\t\t\t\t\t  }\n\n\n\n\t\t\t\t\t\t \t\t\n\t\t\t\t\t\t      if (fp == undefined)\n\t\t\t\t\t\t      {\n\t\t\t\t\t\t      \t alertify.error("Tracts associated with selection not found, link broken. " +\n\t\t\t\t\t\t      \t  "Load correct associated tck into workspace and try again.","error");\n\t\t\t\t\t\t\t\t params.callback(undefined);\n\t\t\t\t\t\t      }\n\t\t\t\t\t\t      else\n\t\t\t\t\t\t      {\t\t\t\t\t \t\n\t\t\t\t\t\t\t\t  var fibs = KViewer.dataManager.getFile(fp.fileID) ;\n\t\t\t\t\t\t\t\t  if (params.intent == undefined)\n\t\t\t\t\t\t\t\t  \tparams.intent = {};\n\t\t\t\t\t\t\t\t  if (params.intent.select == undefined)\n\t\t\t\t\t\t\t\t  \t\tparams.intent.select = \'allselections\';\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t  if (fibs.content.selections == undefined)\n\t\t\t\t\t\t\t\t\t  fibs.content.selections = [];\n\t\t\t\t\t\t\t\t  //fibs.content.selections = fibs.content.selections.concat(tcksel.selections);\n\t\t\t\t\t\t\t\t  fibs.content.selections = tcksel.selections;\n\t\t\t\t\t\t\t\t  fibs.tckjsonref = fileObject;\n\t\t\t\t\t\t\t\t  if (params.callback)\n\t\t\t\t\t\t\t\t  \tparams.callback(fibs);\n\t\t\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\t  KViewer.obj3dTool.update();\n\t\t\t\t\t\t      }\n\t\t\t\t\t\t  } };\n\n\n\t\t\t  if (electron)\n\t\t\t  {\n\t\t\t  \t par.URLType = "localfile";\n\t\t\t  \t par.filename = tcksel.assoc.subfolder + "/" + tcksel.assoc.filename;\n\t\t\t  \t par.file = {name: par.filename ,local:true}\n\t\t\t  }\n\n\n\t\t\t  var files = KViewer.dataManager.getFileList();\n\t\t\t  var found = false;\n\t\t\t  for (var k=0;k<files.length;k++)\n\t\t\t  {\n\t\t\t  \t  var file = KViewer.dataManager.getFile(files[k]);\n\t\t\t  \t  if (file.content.md5 == tcksel.assoc.md5)\n\t\t\t\t  {\n\t\t\t\t  \t par.fileID = files[k];\n\t\t\t\t  \t found = true;\n\t\t\t\t  \t break;\n\t\t\t\t  }\n\t\t\t  }\n\n\t\t\t  if (!found)\n\t\t\t  {\n\t\t\t\t  var files = KViewer.dataManager.getFileList();\n\t\t\t\t  for (var k = 0; k < files.length; k++)\n\t\t\t\t  {\n\t\t\t\t\t var fobj = KViewer.dataManager.getFile(files[k]);\n\t\t\t\t\t if (fobj.content && fobj.filename == tcksel.assoc.filename && fobj.fileinfo != undefined && tcksel.assoc.subfolder == fobj.fileinfo.SubFolder)\n\t\t\t\t\t {\n\t\t\t\t\t//\talertify.error("Warning: tracts associated with selection by md5 hash not found, used association by name");\n\t\t\t\t\t\ttcksel.assoc.md5 = fobj.content.md5;\n\t\t\t\t\t\tpar.fileID = files[k];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t }\n\t\t\t\t  }\n\t\t\t  }\n\n              KViewer.dataManager.loadData(par);\n\n//\t\t\t  if (found)\n//                \tKViewer.dataManager.loadData(par);\n  //            else\n    //          \t par.callback();\n\n\n\t\t\t  return\n\t\t}\n \t\telse if (fileObject.filename.search(\'\\\\.cc\\\\.json\') > 0)\n \t\t{\n\t\t\tif (typeof fileObject.content != "object")\n\t\t\t{\n  \t\t\t\tKViewer.obj3dTool.prepareConmatData(fileObject,function(txt) {\n\t\t    \t   params.progressSpinner(txt);      \n\t\t \t\t}, function()\n\t\t \t\t{\n\t\t\t\t\tfinalize();\n\t\t\t\t\tKViewer.obj3dTool.addObject(fileObject);\n\t\t \t\t});\n\t\t \t\treturn;\n\n\t\t\t}\n       \t\t\n\n \t\t}\n \t\telse if ( (fileObject.fileinfo.Tag || "").search(\'workstate\')>=0 )\n \t\t{\n \t\t\t\tKViewer.closeAll(function()\n \t\t\t\t{\n\t\t\t\t\tvar sharedLink = JSONparse_lazy(fileObject.content);\n\t\t\t\t\tif (fileObject.fileinfo && fileObject.fileinfo.SubFolder)\n\t\t\t\t\t\tsharedLink.absolutePath = fileObject.fileinfo.SubFolder;\n\t\t\t\t\tparams.progressSpinner();  \n\t\t\t\t\topenSharedLink(sharedLink,function() { \n                        if (params.callback)\n                            params.callback();\n\t\t\t\t\t});\n \t\t\t\t});\n\t\t\t\treturn;\n \t\t}\n \t\telse if ( (fileObject.fileinfo.Tag || "").search(\'ironsight\')>=0 )\n \t\t{\n \t\t\t\tvar state = JSONparse_lazy(fileObject.content);\n \t\t\t\tif (!ironSight.isVisible())\n \t\t\t\t\tironSight.toggle()\n \t\t\t\tsetTimeout(function() { ironSight.import(state); params.progressSpinner();   },1000)\n\t\t\t\t\n \t\t\t\treturn;\n \t\t}\n \t\telse\n \t\t{\n\n\n \t\t}\n\n\n\n      }\n      else if(fileObject.filename.search(\'\\\\.gii\') > 0 | fileObject.filename.search(\'\\\\.stl\') > 0)\n      {\n        fileObject.contentType = \'gii\';\n \t    KViewer.obj3dTool.prepareSurfaceData(fileObject,uint8Response,function(txt) {\n\t\t    \tparams.progressSpinner(txt);      \n\t\t },\n\t\t function() {\n\t\t\t if (fileObject.content == undefined)\n\t\t\t {\n\t\t\t\t $.notify("Sorry. Not a valid surface file","error");\n\t\t\t\t if (params.callback)\n\t\t\t\t\tparams.callback(undefined);\n\t\t\t\t return;\n\t\t\t }\n\t\t\t fileObject.contentType = \'gii\';\n\t\t\t KViewer.obj3dTool.addObject(fileObject);\n\t\t\t finalize();\n\t\t\t return;\n\t\t });\n\t\t return;\n\n      }\n\n      \n      else if (fileObject.filename.search(\'.tck\') > 0 | fileObject.filename.search(\'.trk\') > 0)\n      {      \t\n\t\t KViewer.obj3dTool.prepareFiberData(fileObject,uint8Response,function(txt) {\n\t\t \t if (params.progressSpinner != undefined)\n\t\t    \tparams.progressSpinner(txt);      \n\n\t\t },\n\t\t function() {\n\t\t\t if (fileObject.content == undefined)\n\t\t\t {\n\t\t\t\t $.notify("Sorry. Not a valid or empty tract file","error");\n\t\t\t\t if (params.callback)\n\t\t\t\t\tparams.callback(undefined);\n\t\t\t\t return;\n\t\t\t }\n\t\t\t fileObject.contentType = \'tracts\';\n\t\t\t KViewer.obj3dTool.addObject(fileObject);\n\t\t\t finalize();\n\t\t\t return;\n\t\t });\n\t\t return;\n      }\n\n      else   if( BrukerReader.checkForBrukerData( [fileObject] ) !== undefined )\n\t  {\n\t\t fileObject.content = uint8Response;\n\t\t params.callback(fileObject);\n\t\t return;\n\t  }\n\t  else if (fileObject.filename.search(\'\\\\.dcm\') > 0)\n\t  {\n\t\t  if (typeof TheDicomReader != "object")\t\t  \n\t\t  \t  TheDicomReader = new DicomReader();\n\t\t  params.filename = fileObject.filename;\n\t\t  params.buffer = uint8Response;\n\t\t   TheDicomReader.loadDicoms([params], function(x)\n\t\t   {\n\t\t\t  var fobj = x[0];\n\t\t\t  if (fobj.filename.search("\\\\.nii") >= 0)\n\t\t\t  {\n\t\t\t  \t  fobj.contentType = "nii";\t\t\t  \n\t\t\t  \t  // not yet done\n\t\t\t  \t  console.log(\'not yet implemented\');\n\t\t\t  }\n\t\t\t  else if (fobj.filename.search("\\\\.rtstruct") >= 0)\n\t\t\t  {\n\t\t\t  \t  fobj.contentType = "rtstruct";\t\t\t  \n\t\t\t  \t  fobj.content = fobj.buffer;\n\t\t\t  }\n\t\t\t  fobj.filename = fileObject.filename;\n\t\t\t  fobj.fileID = fileObject.fileID;\n\t\t\t  fobj.fileinfo = fileObject.fileinfo;\n\n\t\t\t  params.callback(fobj)\n\t\t\t  files[fobj.fileID] = fobj;\n\t\t\t  KViewer.cacheManager.update();\t\t\t   \n  \t   \t   });\n\n  \t   \t   return;\n\t  }\n      else\n      {\n        fileObject.contentType = \'undefined\';\n        fileObject.content = false;\n        alertify.error("Sorry. The file type is not supported \\n"+fileObject.filename );\n        if (params.callback)\n        \tparams.callback(undefined);\n        return;\n      }\n\n\t  finalize();\n\n\t}\n  //  },0);\n\n\n      \n  }\n\n\n\n\tfunction prepA75_HdrImg(fis,progressSpinner,fileObject,processfileObject)\n\t{\n\n\t\t\tfunction progress(str)\n\t\t\t{     \n\t\t\t  if (progressSpinner != undefined)\n\t\t\t\t\t progressSpinner("unpacking");      \n\t\t\t\telse\n\t\t\t\t\tconsole.log(str);\n\t\t\t}\n\n\t\t\tfis[\'hdr\'].getData(new zip.BlobWriter(), function(blob_hdr)\n\t\t\t{\n\t\t\t\tfis[\'img\'].getData(new zip.BlobWriter(), function(blob_img)\n\t\t\t\t{\n\t\t\t\t   blob_hdr.arrayBuffer().then(function(buffer_hdr) {\n\t\t\t\t   blob_img.arrayBuffer().then(function(buffer_img) {\n\t\t\t\t\t\tvar cat = new Uint8Array(buffer_hdr.byteLength+buffer_img.byteLength);\n\t\t\t\t\t\tcat.set(new Uint8Array(buffer_hdr))\n\t\t\t\t\t\tcat.set(new Uint8Array(buffer_img),buffer_hdr.byteLength);\n\t\t\t\t\t\tvar view = new DataView(cat.buffer)                                \n\t\t\t\t\t\tview.setInt32(0, buffer_hdr.byteLength)\n\t\t\t\t\t\tview.setFloat32(108,buffer_hdr.byteLength)\n\t\t\t\t\t\tview.setUint8(344,110)\n\t\t\t\t\t\tview.setUint8(345,43)\n\t\t\t\t\t\tview.setUint8(346,49)\n\t\t\t\t\t\tview.setUint8(347,0)\n\n\n\t\t\t\t\t\t fileObject.filename = fileObject.filename + ".nii";\n\t\t\t\t\t\t processfileObject(cat)\n\n\n\t\t\t\t   })})\n\n\t\t\t\t}, function(current, total) { progress("unzipping " + math.round(current / total * 100) + "%"); })\n\t\t\t}, function(current, total) { progress("unzipping " + math.round(current / total * 100) + "%"); })\n\n\n\t}\n\n\n\n  /** clears all references to all loaded data\n   *  @function */\n  function clearMemory()\n  {\n  \t  if ( KViewer.roiTool && KViewer.roiTool.isinstance)\n\t  \t KViewer.roiTool.clearAll();\n\t  if (typeof KWMQLPanel != "undefined")\n\t  {\n\t\t  for (var k in KWMQLPanel.panels)\n\t\t\t KWMQLPanel.panels[k].close();\n\t\t  KWMQLPanel.panels = {};\n\t  }\t  \n\t  \n\t  if (KViewer.obj3dTool.isinstance)\n\t  {\n\t\t  var obs = Object.keys(KViewer.obj3dTool.objs);\n\t\t  for (var k = 0; k< obs.length;k++)\n\t\t  {\n\t\t  \t\tif ( KViewer.obj3dTool.objs[obs[k]].content.octreeWorker)\n\t\t  \t\t \tKViewer.obj3dTool.objs[obs[k]].content.octreeWorker.kill();\n\t\t\t\tdelete KViewer.obj3dTool.objs[obs[k]].content;\n\t\t  }\n\n\t\t  KViewer.obj3dTool.objs = {};\n\t\t  KViewer.obj3dTool.update();\n\t  }\n\t  \n\t  if (KViewer.atlasTool.isinstance)\n\t  {\n\t\t  KViewer.atlasTool.defField = undefined;\n\t\t  KViewer.atlasTool.clearAll();\n\t\t  KViewer.atlasTool.update();\n\t  }\n\t  \n      var obs = Object.keys(files);\n      for (var k = 0; k< obs.length;k++)\n      {\n\t\t //if (KViewer.atlasTool.objs[files[obs[k]].fileID] == undefined)\n\t\t {\n\t\t \tdelete files[obs[k]].content;\n\t\t \tdelete files[obs[k]];\n\t\t }\n      }\n      \n      KViewer.cacheManager.update();\n\n      // clear the study coreginfos\n      that.coregInfos = {};\n\n  }\n  that.clearMemory = clearMemory;\n\n\n\n  /** clones a nifti as a ROI \n   *  @function */\n  function cloneAsROI(id,name,lim,params)\n  {\n      var fobj = getFile(id);\n      var newobjs = [];\n      if (lim == "frommultiroifile")\n      {\n        var labels = {};\n        var tot = fobj.content.sizes[0]*fobj.content.sizes[1]*fobj.content.sizes[2];\n        for (var k=0;k < tot;k++)\n        {\n            var v = fobj.content.data[k];\n            if (v == 0) continue;\n            if (labels[v] == undefined) labels[v] = true;\n            if (Object.keys(labels).length>10)\n              {\n            //    alert("too many labels");\n                break;\n              }\n        }\n        \n        for (var k in labels)\n        {\n            var newobj =  clone(fobj,fobj.filename+"_"+k,"label"+k);\n            files[newobj.fileID] = newobj;\n            newobj.filename = newobj.filename.replace(".nii","");\n            newobj.filename = newobj.filename.replace(".gz","");\n            newobj.label = parseInt(k);\n            newobjs.push(newobj);\n        }\n\n\n      }\n      else if (lim == "frommaskfile")\n      {\n         var newobj = fobj;\n         newobj.modified = false;\n         files[newobj.fileID] = newobj;\n         newobj.filename = newobj.filename.replace(".nii","");\n         newobj.filename = newobj.filename.replace(".gz","");\n         newobj.fileinfo.Tag = "/mask/" + newobj.fileinfo.Tag;\n         newobjs = [newobj];\n\n      }\n      else // from other image file by thresholding/zero init\n      {\n       \n         var newobj =  clone(fobj,name,lim);\n         files[newobj.fileID] = newobj;\n         newobj.modified = true;\n         newobj.filename = newobj.filename.replace(".nii","");\n         newobj.filename = newobj.filename.replace(".gz","");\n         newobj.fileinfo.patients_id = fobj.fileinfo.patients_id;\n         newobj.fileinfo.studies_id = fobj.fileinfo.studies_id;\n         newobjs = [newobj];\n      }\n\n\n      KViewer.cacheManager.update();\n      return newobjs;\n\n\n      function clone(fobj,name,lim)\n      {\n\n\t\t  if( KViewer.roiTool.mode4D || (params && params.sametdim))\n\t\t  \tvar fileObject = cloneNifti(fobj,name,\'uint8\', \'sametdim\')\n\t\t  else\n\t\t  \tvar fileObject = cloneNifti(fobj,name,\'uint8\')\n\n\t\t  if (fileObject.fileinfo == undefined)\n\t\t  \tfileObject.fileinfo = {};\n\t\t  fileObject.fileinfo.Tag = \'/mask/\';\n\n\t\t  // get a new ID\n\t\t  var roiid = "ROI_0";\n\t\t  var cnt = 1;\n\t\t  while (files[roiid]!=undefined)\n\t\t\t  roiid = "ROI_" + cnt++;\n\n\t\t  if (fobj.intendedROIid != undefined)\n\t\t  \t  roiid = fobj.intendedROIid;\n\n\t\t  fileObject.fileID = roiid;\n\n\t\t  // interpretaion\n\t\t  if (lim)\n\t\t  {\n\t\t  \tvar offs = fobj.content.currentTimePoint.t*fobj.content.widheidep;\n\t\t  \tif (KViewer.roiTool.mode4D) \n\t\t  \t    offs = 0\n\t\t  \tvar thelim = parseFloat(lim.substring(5));\n\t\t\tif (lim.substring(0,5) == "lower")\n\t\t\t  for (var k = 0;k < fileObject.content.data.length;k++)\n\t\t\t  {\n\t\t\t\t  fileObject.content.data[k] = (fobj.content.data[k+offs] < thelim\n\t\t\t\t\t\t\t\t\t\t\t  & fobj.content.data[k+offs] != 0          )?1:0;\n\t\t\t  }\n\t\t\telse if (lim.substring(0,5) == "upper")\n\t\t\t  for (var k = 0;k < fileObject.content.data.length;k++)\n\t\t\t\t  fileObject.content.data[k] = (fobj.content.data[k+offs] > thelim)?1:0;\n\t\t\telse if (lim.substring(0,5) == "label")\n\t\t\t  for (var k = 0;k < fileObject.content.data.length;k++)\n\t\t\t\t  fileObject.content.data[k] = (fobj.content.data[k] == parseInt(lim.substring(5)))?1:0;\n\t\t  }\n\t\t  else\n\t\t\tfor (var k = 0;k < fileObject.content.data.length;k++)\n\t\t\t\tfileObject.content.data[k] = 0;\n\n          return fileObject;\n      }\n\n\n\n  }\n  that.cloneAsROI = cloneAsROI;\n\n  \n  return that;\n}\n\n\n\n\n\n\n\nfunction createLoadParamsFileDrop(e, callback, progress)\n{\n\n    function validFileExt(p)\n    {\n        var exts = [\'trk\',\'nii\', \'tck\', \'json\', \'txt\', \'jpeg\', \'jpg\', \'png\', \'bmp\', \'gii\', \'pdf\', \'csv\', \'bval\', \'bvec\', \'bmat\',\'mgh\',\'nrrd\' ,\'mgz\', \'stl\', \'mat\'];\n        if (p.filename) // only for local files\n        {\n            for (var k = 0; k < exts.length; k++)\n            {\n                if (p.filename.search(RegExp(exts[k] + \'$\')) > -1)\n                    // end of string search\t\t\t\t\t\n                    return true;\n                if (p.filename.search(RegExp(exts[k] + \'.gz$\')) > -1)\n                    // end of string search\t\t\t\t\t\n                    return true;\n            }\n            return false;\n        }\n        else\n            // always accept serverfiles\n            return true;\n    }\n\n    function syncImport(params, finalcb)\n    {\n\n        // bruker \n        var bruker = BrukerReader.checkForBrukerData(params)\n        if (bruker != undefined)\n        {\n            if (progress)\n                progress("converting bruker data");\n            setTimeout(function() {\n                BrukerReader.loadBruker(bruker, function() {\n                    niiImport();\n                    progress()\n                }, "img.nii");\n            }, 1);\n        }\n        else\n            dcmImport()\n\n\n        function dcmImport()\n        {\n            // dicoms\n            var dicomReader = new DicomReader();\n            dicomReader.loadDicoms(params, function(p) {\n                callback(p);\n                niiImport()\n            });\n\n        }\n\n        function niiImport()\n        {\n            // ordinray files\n            callback(processParamsSet(params));\n            if (finalcb)\n                finalcb();\n        }\n    }\n\n\n\n\n\n    function processParamsSet(params, str)\n    {\n\n\n\n        var loadParams = [];\n\n        for (var k = 0; k < params.length; k++)\n        {\n            if (validFileExt(params[k]))\n            {\n                params[k].progressSpinner = progress;\n                params[k].callback = function() {\n                    progress()\n                }\n                ;\n\n                if (str)\n                    params[k].SubFolder = str.replace(/^\\/|\\/$/g, "");\n\n                loadParams.push(params[k]);\n            }\n            else if (params[k].filename.search("\\\\.zip") > -1)\n            {\n                progress("analyzing archive");\n                var loadParamsZip = [];\n                var loadParamsOther = [];\n                var freader = new FileReader();\n                freader.onload = function(e) {\n                    zip.workerScriptsPath = "zip/";\n                    zip.useWebWorkers = false;\n                    zip.createReader(new zip.BlobReader(new Blob([freader.result])), function(reader) {\n                        // get all entries from the zip\n                        reader.getEntries(function(entries) {\n                            reader.close();\n                            for (var j = 0; j < entries.length; j++)\n                                if (!entries[j].directory)\n                                {\n                                    var subfolder = "";\n                                    var name = entries[j].filename;\n                                    var splitslash = name.lastIndexOf("/");\n                                    if (splitslash != -1)\n                                    {\n                                        subfolder = name.substring(0, splitslash);\n                                        name = name.substring(splitslash + 1);\n                                    }\n\n                                    entries[j].name = name;\n                                    entries[j].SubFolder = subfolder;\n                                    var p = createParamsLocalFile(entries[j], undefined, progress);\n                                    p.name = name;\n                                    p.SubFolder = subfolder;\n\n                                    if (validFileExt(entries[j]))\n                                        // this is plane valid file (no brukder or dicom)\n                                        loadParamsZip.push(p);\n                                    else\n                                        loadParamsOther.push(p);\n\n\n                                }\n                            progress();\n\t\t\t\t\t\t \tif(loadParamsOther.length > 0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tvar dicomReader = new DicomReader();\n\t\t\t\t\t\t\t\t\tdicomReader.loadDicoms(loadParamsOther, function(p) {\n\t\t\t\t\t\t\t\t\t\tcallback(p);\n\t\t\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif(loadParamsZip.length > 0)\n\t\t\t\t\t\t\t\t  callback( loadParamsZip) ;\t\t   // rest goes the normal way\n                        });\n                    }, function(err) {\n                        progress();\n                        alertify.error("Error during reading zipfile: " + err.toString());\n                    });\n\n                }\n                readBufferFromFile(freader, params[k]);\n\n\n            }\n        }\n        return loadParams;\n    }\n    // end processParamSet\n\n    if (e.originalEvent)\n        e = e.originalEvent;\n\n\n    // file drop from local files\n    var dt = e.dataTransfer;\n    // this will not work in firefox, that case will be handled below.\n    if (dt.items && dt.items[0] && dt.items.length > 0 && dt.items[0].webkitGetAsEntry && dt.items[0].webkitGetAsEntry())\n    {\n        var ientries = [];\n        for (var k = 0; k < dt.items.length; k++)\n            ientries.push(dt.items[k].webkitGetAsEntry());\n\n\n        var workpackages = [];\n\n        browseDir(ientries, undefined, "", function() {\n\n            function runSync()\n            {\n                if (workpackages.length > 0)\n                {\n                    var p = workpackages[0];\n                    workpackages = workpackages.slice(1);\n                    syncImport(p.params_arr, runSync);\n                }\n            }\n            runSync();\n        });\n\n        function browseDir(entries, parent, str, cb)\n        {\n\n            var params_arr = [];\n            params_arr.parent = parent;\n\n            for (var k = 0; k < entries.length; k++)\n            {\n                var entry = entries[k];\n                var entry_ =  (entry || "").toString()\n                if (  entry_ == "[object DirectoryEntry]" || entry_ == "[object FileSystemDirectoryEntry]"  || entry.isDir)\n                {\n                }\n                else\n                {\n                    if (entry.error == undefined)\n                    {\n                        var tmp = createParamsLocalFile(entry, undefined, progress);\n                        params_arr.push(tmp);\n                    }\n                    else\n                        params_arr.push(entry);\n                }\n            }\n\n\n\n            iterateEntries();\n\n            function iterateEntries()\n            {\n                if (entries.length == 0)\n                {\n                    workpackages.push({\n                        params_arr: params_arr,\n                        str: str\n                    });\n                    cb();\n                    return;\n                }\n                var entry = entries[0];\n                entries = entries.slice(1);\n                readSingleEntry(entry, iterateEntries);\n            }\n\n\n            function readSingleEntry(entry, cb2)\n            {\n                var entry_ =  (entry || "").toString()\n                if (  entry_ == "[object DirectoryEntry]" || entry_ == "[object FileSystemDirectoryEntry]" || entry.isDir)\n                {\n                    var dirReader = entry.createReader();\n                    var new_entries = [];\n                    var readEntries = function() {\n                        dirReader.readEntries(function(results) {\n                            if (!results.length)\n                            {\n                                browseDir(new_entries, params_arr, str + entry.name + "/", cb2);\n                            }\n                            else\n                            {\n                                new_entries = new_entries.concat(toArray(results));\n                                readEntries();\n                            }\n                        });\n                    }\n                    readEntries();\n\n                }\n                else\n                {\n                    /*\tvar tmp = createParamsLocalFile(entry, undefined, progress) ;\t\t\t\t\t\t\t\n\t\t\t\t\t\t\tparams_arr.push(tmp);\n\t\t\t\t\t\t\tparams_arr.parent = parent;*/\n                    cb2();\n                }\n            }\n\n\n\n\n        }\n\n    }\n    // drop from cach table.\n    // what to do? upload?\n    else  if(isDragFromCacheTable(e))\n    {\n        alertify.error(\'Upload by drop not implemented yet.<br>Select a patient and use upload button instead.\')\n        //KViewer.cacheManager.prepTarget(e.target);\n        //KViewer.cacheManager.uploadFiles(undefined, 0);\n        return false;    \n    }\n    // file has size 0 -> probably a folder, not detected by webkitGetAsEntry above => probably we are in firefox.\n    // fil.type would not work, if mime type is not registered in system, it woll also be "".\n    else if( dt.files && dt.files.length > 0 && dt.files[0].size == 0)\n    {\n        alertify.error(\'Dropped item has size zero or is a folder. This is not suppored by your browser.\')\n        return false;    \n    }\n    else\n    {\n\n        var params = getloadParamsFromDrop(e, undefined, progress);\n        syncImport(params);\n\n    }\n\n}\n// end createLoadParamsFileDrop\n\n'},function(t,n){t.exports='\nKFreeView.runningID = 0;\n\nfunction KFreeView(master,$parent)\n{\n\n\t var viewPortID = 50+KPanelView.runningID++;\n\n\t var that = new KViewPort(master, viewPortID);\n     that.$container.appendTo($parent);\n\n     that.resize = function()\n\t {\n\t \tthat.$container.width($parent.width());\n\t\tthat.$container.height($parent.height());\n\t\tif (that.getCurrentViewer())\n\t\t\tthat.getCurrentViewer().setInnerLayout();\n\t }\n\n\t that.kill = function(){\n\n\t \tthat.panel.close()\n\t\tif (that.getCurrentViewer())\n\t\t\tthat.getCurrentViewer().close();\n\t \tKViewer.viewports.splice(viewPortID,1);\n\t };\n\n\t\n\t KViewer.viewports[viewPortID] = that;\t\n\n     that.resize();\n\n\t return that ;\t\n\n\n}\n\n\nKPanelView.runningID = 0;\nfunction KPanelView(master,name,options)\n{\n     if (name == undefined)\n     name = "Viewport";\n\n     if (options == undefined)\n     {\n     \toptions = {\n     \t\tshowElements:false     \t\t\n     \t}\n     }\n\n\n\t var panel = KPanel($(document.body),\'viewportpanel\'+(KPanelView.runningID++), name);\n\t panel.$container.height("500px")\n     panel.$container.width("500px")\n     panel.closeOnHide = true;\n\n\n\t var that = new KFreeView(master,panel.$container);\n\t that.panel = panel;\n\n\n     if (options.addClass)\n         that.panel.$container.addClass(options.addClass);\n\n\n\n     var $resizeTriangle = resizeTriangle(function() {},that.resize,\n      \t\tthat.panel.$container ).appendTo(that.$container);\n\n\t that.setSize = function(w,h)\n\t {\n\t \tpanel.$container.width(w)\n\t \tpanel.$container.height(h)\n\t\tthat.resize();\n\n\t }\n\n\n\t that.onsetContent = function()\n\t {\n\t \tif (that.medViewer != undefined & !options.showElements)\n\t \t{\n\t \t\tthat.medViewer.hideControls();\n\t \t\tthat.medViewer.histoManager.hide()\n\t \t\tthat.medViewer.histoManager.hidden = true;\n\t \t\tthat.medViewer.$infobar.hide();\n\t \t\tthat.medViewer.$infobar.hidden = true;\n\n\t \t}\n\t }\n\n\n\t that.panel.customClose = function()\n\t {\n\t \tthat.$container.remove();\n\t\tsignalhandler.detach("close",that.sigid);\n\t\tthat.kill();\n\n\n\t }\n\n\t that.sigid = signalhandler.attach("close",function() {\n\t\tthat.kill()\n\t\tsignalhandler.detach("close",that.sigid);\n\t});\n \n\n\n\t return that ;\t\n}\n\n\nfunction KViewPort(master, viewPortID)\n{\n  /** @class \n   * The viewport object which can contain different types of viewers.\n   *  @alias KViewPort */\n  var that = new Object();\n\n  /** The main div container\n   *  @member */  \n  var $container = $("<div id=\'KViewPort_container_number"+ viewPortID +"\' class=\'KViewPort_container\'></div>"); \n  that.$container = $container;\n\n  var $spinner  = $("<div class=\'KViewPort_spinner\' ><i class=\'fa fa-spinner fa-spin\'></i> <span >Loading</span></div>").appendTo($container);\n\n\n  /** @inner */ that.viewPortID = viewPortID;   \n\n\n  /** @inner  */\n  that.currentFileinfo = new Object();\n\n  /** @private */\n  var currentViewer;\n\n\n  var $numerator = $("<div  class=\'KView_viewportNumerator\' ></div>");\n  $(\'<img  src="\'+url_pref+\'logo.svg"  >\').appendTo( $numerator );\n  $container.append($numerator);\n\n  \n  var zoomed =0;\n\n  /** @function */\n  that.isZoomed = function(){return zoomed};\n\n  /** @function */\n  that.zoomViewPort = zoomViewPort;\n\n\n   that.$LeftViewportCol_resizer = $("<div class=\'annotion_tool_resizer\'><div><div></div></div></div>")\n\t  .on("mousedown", function (ev)\n\t  {\n\n\t\tvar $pt = $("#patientTableContainer").parent();\n\t\tvar avail_height =  master.$zoomedPortContainer.height();\n\n\t\t$(document.body).on(\'mousemove\', function(ev) {\n\t\t\t\tev.preventDefault();\n\t\t\t\tev.stopPropagation();\n\t\t \t\tvar t = ev.clientY-$pt.offset().top;\n\t\t \t\tKViewer.setSizeLeftViewportCol(t)\n\t\t\t});\n\t\t\t$(document.body).on(\'mouseup\', function() {\n\t\t\t\t$(document.body).off(\'mousemove mouseup\');\n\t\t\t});\n\t  });\n\n\n\n  function zoomViewPort(ev,hideTable)\n  {\n\n    if(zoomed == 0)\n    {\n\n      if (!KViewer.showInfoBar)\n      \t KViewer.toggleInfobar();\n\n      zoomed = 1;\n      master.$zoomedPortContainer.css({visibility: \'visible\'});\n      $(".KViewPort_infoDIV").addClass("zoomPortButton")\n      $(".KViewPort_title").addClass("zoomPortButton")\n      $("#patientThumbBackButton").css(\'display\',\'block\');\n\t  \n/*\n  \t  var $vpcontainer = $("#KView_viewportContainer");\n  \t  $vpcontainer.width("100%");\n\t  $vpcontainer.css(\'left\',0);\n*/\n\n \t  that.$LeftViewportCol_resizer.appendTo($("#patientTableLowerContainer"));\n\t  KViewer.setSizeLeftViewportCol();\n\n\n\t   //   $("[id^=KViewPort_container_number]").css({visibility: \'hidden\'});\n\n\n\n \t  $("#thetable").hide();\n \t  var keys = Object.keys(master.viewports);\n      for(var k = 0; k < keys.length; k++)\n      {\n      \t  if (keys[k] != that.viewPortID && master.viewports[keys[k]].getCurrentViewer() != undefined) \n      \t  {\n      \t  \t var vp = master.viewports[keys[k]];\n      \t  \t var vi = vp.getCurrentViewer();\n      \t  \t if (vi.viewerType != "Manager")\n      \t  \t {\n      \t  \t \t if (vp.$container != undefined)\n\t\t\t\t \tvp.$container.detach()\n\t\t\t\t if (vi.toolbar != undefined)\n\t\t\t\t \tvi.toolbar.hide()\n\t\t\t\t if (vi.layoutbar != undefined)\n\t\t\t\t\t vi.layoutbar.hide()\n\t\t\t\t vi.hiddenHisto = true;\n\t\t\t\t $("#patientThumbContainer").append(vp.$container)\n      \t  \t }\n      \t  }\n      }\n\n\n\n\t  if (!KViewer.standalone)\n\t  {\n\t\t  master.$zoomedPortContainer.width(master.$zoomedPortContainer.parent().width()-8 );\n\t\t  master.$zoomedPortContainer.height(master.$zoomedPortContainer.parent().height()-8 );\n\t  }\n\t  else\n\t  {\n\t\t  master.$zoomedPortContainer.width(window.innerWidth-8 );\n\t\t  master.$zoomedPortContainer.height(window.innerHeight-8 );\n\t\t  var rec = master.$zoomedPortContainer.parent().get(0).getBoundingClientRect()\n\t\t  master.$zoomedPortContainer.css(\'top\',-rec.top-8);\n\t\t  master.$zoomedPortContainer.css(\'left\',-rec.left+30);\n\t  }\n\n\n      //currentViewer.toolbar.$close.hide();\n      currentViewer.toolbar.$zoom.children().addClass("fa-compress");\n\n\t  master.$layoutSelector.addClass(\'inactive\');\n\n \t  master.zoomedViewport = currentViewer.viewport.viewPortID;\n\n\t  master.$dummyPortContainer.insertBefore(currentViewer.viewport.$container);\n\t  currentViewer.viewport.$container.css({visibility: \'visible\'});\n      currentViewer.viewport.$container.detach();\n      currentViewer.viewport.$container.appendTo(master.$zoomedPortContainer);\n\n      master.$dummyPortContainer.width(currentViewer.viewport.$container.width())\n      master.$dummyPortContainer.height(currentViewer.viewport.$container.height())\n      currentViewer.viewport.$container.width(master.$zoomedPortContainer.width())\n      currentViewer.viewport.$container.height(master.$zoomedPortContainer.height())\n\n\n      currentViewer.setInnerLayout();\n\n      if (!TableHidden & hideTable)\n        master.toggleTableHide();\n\n      KViewer.setViewPortLayout();\n\n      signalhandler.send("positionChange layoutHisto");\n\n    }\n    else\n    {\n      zoomed = 0;\n \t\n\t       \n      currentViewer.viewport.$container.insertBefore(master.$dummyPortContainer);\n      master.$dummyPortContainer.detach();\n      currentViewer.viewport.$container.width(master.$dummyPortContainer.width())\n      currentViewer.viewport.$container.height(master.$dummyPortContainer.height())\n\n      \n\t  master.$layoutSelector.removeClass(\'inactive\');\n\n      //currentViewer.$container.detach();\n\n\n\t  master.zoomedViewport = -1;\n\n      master.$zoomedPortContainer.css({visibility: \'hidden\'});\n      $("[id^=KViewPort_container_number]").css({visibility: \'visible\'});\n\n      currentViewer.toolbar.$zoom.children().removeClass("fa-compress");\n      currentViewer.setInnerLayout();\n\n      if (TableHidden & !KViewer.standalone)\n         master.toggleTableHide();\n\n\t  if (userinfo.username != guestuser || static_info.public_projects)     \n      \t$("#thetable").show();\n \n  \t  var keys = Object.keys(master.viewports);\n \t  for(var k = 0; k < keys.length; k++)\n      {\n      \t  if (keys[k] != that.viewPortID && master.viewports[keys[k]].getCurrentViewer() != undefined) \n      \t  {\n      \t  \t var vp = master.viewports[keys[k]];\n      \t  \t var vi = vp.getCurrentViewer();\n\t\t\t if (vi.viewerType != "Manager")\n      \t  \t {\n      \t  \t \t if (vi.toolbar != undefined)\n\t\t\t\t \tvi.toolbar.show()\n      \t  \t \t if (vi.layoutbar != undefined)\n\t\t\t\t\t vi.layoutbar.show() \n\t\t\t\t vi.hiddenHisto = false;\n      \t  \t }\n      \t  }\n      }\n\n \t\n      KViewer.setViewPortLayout(); \n\t  setPatientTableLayout();   \n\t  KViewer.setViewPortLayout(); \n\n      $(".KViewPort_infoDIV").removeClass("zoomPortButton")\n      $(".KViewPort_title").removeClass("zoomPortButton")\n      $("#patientThumbBackButton").css(\'display\',\'none\');\n\n\n      signalhandler.send("positionChange layoutHisto");\n \n\n\n    }\n  }\n\n\n  /** @function */\n  function getCurrentViewer(){return currentViewer};\n  that.getCurrentViewer = getCurrentViewer;\n  \n  /** @function  */\n  that.setCurrentViewer = function(v)\n  {\n\tif (v == currentViewer)\n\t\treturn;\n\n  \tif (v != undefined)\n  \t{\n  \t\t \n  \t\tif (currentViewer != undefined)\n\t\t\tcurrentViewer.$container.detach();\n\t\t\n\t\t$container.append(v.$container);\n\t\tcurrentViewer = v;\n  \t\t$numerator.hide();\n  \t}\n  \telse \n  \t{\n  \t\tif (currentViewer != undefined)\n\t\t\tcurrentViewer.$container.detach();\n  \t\tcurrentViewer = undefined;\n  \t\t$numerator.show();\n  \t}\n  };\n \n  that.progressSpinner = theSpinner($spinner);\n \n  that.setContent = setContent;\n  /** depending on fileObject activates a certain viewer and sets its content\n   *  to fileObject \n   *  @param {object} fileObject - object describing file (see {@link createParamsLocalFile} or \n   \t\t\t\t\t\t\t\t   {@link KDataManager~processLoadedFile} for creation).\n   *  @param {string} fileObject.contentType - What kind of data (nii,tracts,bmp,tab,doc,txt,...)\n   *  @param {object} fileObject.content - the data object\n   *  @param {string} fileObject.fileID - the sql-id (numeric) or url of local file\n   *  @param {string} fileObject.filename - the name of the file\n   *  @param {object} fileObject.fileinfo - more detailed object information\n   *  @param {object} params - additional loading parameters\n   *  @param {object} params.intent - several intentions what to do (use as overlay, show in 3D etc)   \n   *  @param {string} params.URLType \n   *  @param {callback} params.callback\n   */ \n\n\n  function setContent(fileObject,params)\n  {\n    if (fileObject == undefined)\n       return;\n\n    if (fileObject.content == false)\n       return;\n\n    if (that.visible != undefined && that.visible == false)\n        return;\n\n    if (params.intent == undefined)\n\t   params.intent = {};\n        \n\n    if(fileObject.contentType == \'nii\')\n    {\n\t\t\n\t\t// ************ convert a single slice RGB nifti to bmp **********\n\t\tif( !state.viewer.loadBitmapAsNifti & (fileObject.content.datatype == \'rgb24\' && fileObject.content.sizes[2] == 1) )\n\t\t{\n        \tbmpViewer.setContent(fileObject,params);\n\t\t}\n\t\telse\n\t\t{\n        \tif (fileObject.fileinfo.Tag)\n\t\t\t{\n\t\t\t  if (fileObject.fileinfo.Tag.search("/mask/") != -1)\n\t\t\t  {\n\t\t\t//            master.roiTool.pushROI(fileObject.fileID,"untitled","frommaskfile");\n\t\t\t\tif (params.intent == undefined) params.intent = {};\n\t\t\t\tparams.intent.ROI = true;\n\t\t\t\tmedViewer.setContent(fileObject,params);\n\t\t\t  }\n\t\t\t  else\n\t\t\t\tmedViewer.setContent(fileObject,params);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t  medViewer.setContent(fileObject,params);\n\t\t\t}\n\t\t}\n\n    }\n    else if (fileObject.contentType == \'tracts\' | fileObject.contentType == \'gii\' | fileObject.contentType == \'rtstruct\')\n    {\n      medViewer.setContent(fileObject,params);    \t\n    }\n    else if(fileObject.contentType == \'bmp\')\n    {\n      bmpViewer.setContent(fileObject,params);\n    }\n    else if(fileObject.contentType == \'tab\')\n    {\n      tableViewer.setContent(fileObject,params);\n    }\n    else if(fileObject.contentType == \'doc\')\n    {\n      ViewerJS.setContent(fileObject,params);\n    }\n    else if(fileObject.contentType == \'txt\')\n    {\n      txtViewer.setContent(fileObject,params);\n    }\n    else if(fileObject.contentType == \'json\')\n    {\n       var tag = " " + fileObject.fileinfo.Tag;\n       if (params.intent == undefined) params.intent = {};\n       if (!params.intent.asjson && (tag.search("FORM") >= 0 | params.intent.patientedit |             \n            params.intent.studyedit | (fileObject.filename || "").search("\\\\.form\\\\.json") != -1))\n       {\n          formViewer.setContent(fileObject,params);\n       }\n       else if (tag.search("RO") >= 0 | fileObject.filename.search("\\\\.transform\\\\.json") != -1)\n       {\n          master.setReorientationMatrix(fileObject);\n       }\n// moved to datamanager       \n/*       else if (tag.search("ANO") >= 0 | fileObject.filename.search("\\\\.ano\\\\.json") != -1 )\n       {\n          markerProxy.loadAnnotations(fileObject);\n\n          // only show markerTool if no panel / panel not visible\n          if(markerProxy.currentSet &&  markerProxy.currentSet.markerPanel && markerProxy.currentSet.markerPanel.panelvisible)\n          {\n\t\t\t\t// do nothing ( no show )\n          }\n          else\n          {\n          \tif ( !KViewer.markerTool.enabled )\n\t          \t KViewer.markerTool.toggle();\n          }\n       }*/\n       else if (fileObject.filename.search("\\\\.cc.json") != -1)\n       {\n\t\t  medViewer.setContent(fileObject,params);     \t\n       }\n       else\n       {\n         jsonViewer.setContent(fileObject,params);\n       }\n    }\n\n    if (params.json && params.json.project)\n    {\n    \tfileObject.project = params.json.project; \n    }\n\n    if (that.onsetContent)\n    {\n    \tsetTimeout(function() {that.onsetContent(fileObject,params)},0);\n    }\n    \t\n\n\n   }\n\n   var isFiberVol = false;\n\n   // to improve Kview startup dragster creation is postponed by timeout\n   setTimeout(function($container,that) { return function() {\n\t   new Dragster($container.get(0));\n\t   $container.get(0).addEventListener(\'dragenter\',showDropIndicators);\n\t   $container.get(0).addEventListener(\'dragster:leave\',hideDropIndicators);\n\n\t   var $dropIndicator = $("<div class=\'KView_viewportdropIndicator\' ></div>").hide().appendTo($container);\n\t   that.$dropIndicator = $dropIndicator;\n\n\t   var isOrthoDropper = true; //viewPortID === 0 | viewPortID == 4 ;\n\t   var orthodrop = "";\n\n\n\t   if (isOrthoDropper)\n\t\t  orthodrop = "<div droptag=\'orthooverlay\'> as orthoview </div>";\n\n\t   that.dragster = {};\n\t   that.dragster.notpossible =  $("<div> not possible</div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.loadworkspace =  $("<div>load workspace</div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.tool =  $("<div>drop tool</div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.doc =  $("<div>drop document</div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.roi =  $("<div>drop ROI "+orthodrop+" </div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.fibers =  $("<div droptag=\'fibers\'>drop fibers</div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.asjson =  $("<div droptag=\'asjson\'> drop as json</div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.obj3D =  $("<div>drop 3D object</div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.surfacecol =  $("<div  droptag=\'surfcol\'>drop as surface coloring</div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.image =  $("<div droptag=\'image\'>drop image</div>").hide().appendTo(that.$dropIndicator);\n\t   that.dragster.ortho = $("<div droptag=\'orthoview\'>drop as orthoview</div>").hide();\n\t   if(isOrthoDropper)\n\t\t   that.dragster.ortho.appendTo(that.$dropIndicator);\n\t   that.dragster.overlay = $("<div droptag=\'overlay\'>drop as overlay "+orthodrop+" </div>").hide().appendTo(that.$dropIndicator); \n\t   that.dragster[\'default\'] = $("<div> drop content</div>").hide().appendTo(that.$dropIndicator);\n\n\t   $dropIndicator.children().each(function(k,e){ \n\t\t\t$(e).on(\'dragover\',  function(ev){ $(e).css(\'background\', \'rgba(0,139,139,0.6)\');}) \n\t\t\t$(e).on(\'dragleave\', function(ev){ $(e).css(\'background\', \'rgba(139, 0, 0, 0.6)\');}) \n\t\t\t});\n\n\t  } }($container,that),100);\n\n\t  function showDropIndicators(e)\n\t  {\n\t  \tvar $dropIndicator = that.$dropIndicator;\n\n\t\tif (currentViewer != undefined && currentViewer.viewerType == "Manager")\n\t\t\t\treturn;\n\t  \t\n\t  \tfor (var obj in that.dragster)\n\t\t    that.dragster[obj].hide();     \n\n\t  \tif (e.dataTransfer && e.dataTransfer.types && e.dataTransfer.types[0] == \'text/plain\')\n\t  \t{\n\t  \t\tthat.dragster.notpossible.show();\n\t  \t\t$dropIndicator.fadeIn(150)\n\t  \t\treturn;\n\t  \t}\n\n\t\tif (tempObjectInfo != undefined && tempObjectInfo.length > 0)\n\t\t{\n\t\t\tif (KViewer.zoomedViewport != -1 && !that.isZoomed() )\n\t\t\t\tthat.dragster[\'notpossible\'].show();\t\t\t\t\n\t\t\telse if ((tempObjectInfo[0].tag || "").search("/mask/") > -1)\n\t\t\t{\n\t\t\t\tthat.dragster.roi.show();\n\t\t\t}\n\t\t\telse if ((tempObjectInfo[0].tag || "").search("/WORKSPACE/") > -1)\n\t\t\t{\n\t\t\t\tthat.dragster.loadworkspace.show();\n\t\t\t}\n\t\t\telse if ((tempObjectInfo[0].filename || "").search("\\\\.gii") > -1)\n\t\t\t{\n\t\t\t\tthat.dragster.obj3D.show();\n\t\t\t}\n\t\t\telse if (tempObjectInfo[0].mime == \'nii\')\n\t\t\t{\n\t\t\t\tthat.dragster.image.show();\n\t\t\t\tthat.dragster.ortho.show();\n\t\t\t\tthat.dragster.overlay.show();\n\t\t\t\tif (that.medViewer != undefined && that.medViewer.hasContent(\'surf\') != undefined)\n\t\t\t\t \tthat.dragster.surfacecol.show();\n \t\t\t\tif ((tempObjectInfo[0].filename || "").search("cosl") > -1 |\n \t\t\t\t    (tempObjectInfo[0].filename || "").search("rgb") > -1 |\n \t\t\t\t    (tempObjectInfo[0].tag || "").search("tck") > -1 )\t\n \t\t\t\t{\t\t \t\n\t\t\t\t\tthat.dragster.fibers.show();\n\t\t\t\t\tisFiberVol = true\n \t\t\t\t}\n\n\t\t\t}\n\t\t\telse if ((tempObjectInfo[0].filename || "").search("\\\\.tck") > -1)\n\t\t\t{\n\t\t\t\tthat.dragster.fibers.show();\n\t\t\t}\n\t\t\telse if (tempObjectInfo[0].mime == \'json\' | tempObjectInfo[0].mime == \'form\')\n\t\t\t{\n\t\t\t\tthat.dragster.asjson.show();\n\t\t\t}\n\t\t\telse if (tempObjectInfo[0].mime == \'pdf\')\n\t\t\t\tthat.dragster.doc.show();\n\t\t\telse if (tempObjectInfo[0].type == \'markertemplate\')\n\t\t\t\t1\n\t\t\telse\n\t\t\t\tthat.dragster[\'default\'].show();\n\t\t}\n\t\telse if (KToolWindow.dragTool != undefined)\n\t\t\tthat.dragster.tool.show();\t\t\t\n\t\telse\n\t\t\tthat.dragster[\'default\'].show();\n\t\t$dropIndicator.fadeIn(150)\n\t  }\n\n\t  function hideDropIndicators(e)\n\t  {    \n\t     if (that.$dropIndicator)\n\t\t\t that.$dropIndicator.fadeOut(150,undefined, function(){ });\n\t  }\n\t  that.hideDropIndicators = hideDropIndicators;\n\n\t  $container.on("dragover",  function(ev)\n\t  {\t  \n\t\tev.preventDefault(); \n\t\treturn false;\n\t  });\n/*\t  $container.on("dragenter",  function(ev)\n\t  {\t  \n\t\tev.preventDefault(); \n\t\treturn false;\n\t  });\n  \t  $container.on("dragleave",  function(ev)\n\t  {\t  \n\t    ev.preventDefault(); \n\t\treturn false;\n\t  });\n*/\n\t\n\t  var ondrop = function(ev)\n\t  {\n\t  \tif (ev.originalEvent)\n\t\t    ev = ev.originalEvent;\n\t\tthat.$dropIndicator.fadeOut(150);\n\t\tthat.$dropIndicator.children().each(function(k,e){$(e).css(\'background\', \'rgba(139, 0, 0, 0.6)\') });\n\t\t\n\t\tev.preventDefault();\n\t\tev.stopPropagation();\n\n\t\tif (ev.dataTransfer && ev.dataTransfer.types && ev.dataTransfer.types[0] == \'text/plain\')\n\t  \t\treturn;\n\t  \n\n\n\t\tif (KToolWindow.dragTool != undefined)\n\t\t{\n\t\t\tKToolWindow.dragTool.show(that);\n\t\t\tKToolWindow.dragTool = undefined;\n\t\t\treturn;\n\t\t}\n\n\t\tif (currentViewer != undefined && currentViewer.viewerType == "Manager")\n\t\t\treturn;\n\n\t\tif (KViewer.zoomedViewport != -1 && !that.isZoomed())\n\t\t\treturn;\n\n\n\t\tif (KViewer.zoomedViewport != -1 && tempObjectInfo[0].intent && tempObjectInfo[0].intent.viewport != undefined)\n\t\t{\n\t\t\tzoomViewPort();\n\t\t\tKViewer.viewports[tempObjectInfo[0].intent.viewport].zoomViewPort();\n\t\t\treturn;\n\t\t}\n\n\t\tvar droptag = $(ev.target).attr(\'droptag\');\n\t\t\n\t\tvar params = getloadParamsFromDrop(ev,{});\n\t\tvar dt = ev.dataTransfer;\n\t\tif(dt && dt.items && dt.items[0] && dt.items.length > 0 && dt.items[0].webkitGetAsEntry() && dt.items[0].webkitGetAsEntry().isDirectory)\n\t\t{\n\t\t\talertify.error("You cannot drop folders here. <br> Drop on left panel instead to read folder content.")\n\t\t\treturn;\n\t\t}\n\t\tif (params.patient_study_drop)\n\t\t{\n\t\t\tvar psid = params.patient_study_drop.split(riddelim);\n\t\t\tstartAutoloader(ViewerSettings.autoloaders, {piz:psid[0],sid:psid[1]});\n\t\t\treturn;\n\t\t}\n\n\t\tif(droptag==\'fibers\' && isFiberVol)\n\t\t{\n            \n\t\t\tfor (var k = 0; k < params.length;k++)\n\t\t\t\tparams[k].intent = {overlay:true,visible:false,hideview:true};\n\t\t\t\n\t\t\tinitiateLoadData(params,function() {\n\t\t\t\tfor (var k = 0; k < params.length;k++)\n\t\t\t\t\tparams[k].intent = {createFiberTracking:{color:3}};\n\t\t\t\tinitiateLoadData(params);\n\t\t\t});\n\t\t\t\n\t\t}\n\t    else if(droptag==\'orthoview\')\n\t\t{\n\t\t\tloadOrthoview(params[0],viewPortID);\n\t\t}\n\t\telse if(droptag==\'orthooverlay\')\n\t\t{\n            var cnt = 0;\n    \t\tcleanAllDropIndicators();\n\n\t\t\tfunction itovl()\n\t\t\t{\n\t\t\t\tif (cnt >= params.length)\n\t\t\t\t    return;\t\t\t\t   \n\t\t\t\tif (params[cnt].intent == undefined)\n\t\t\t\t\tparams[cnt].intent = {overlay:true};\n\t\t\t\telse\n\t\t\t\t\tparams[cnt].intent.overlay = true;\n\t\t\t\tloadOrthoview(params[cnt++],viewPortID,itovl);\t\t\t\t    \n\t\t\t}\n\n\t\t\titovl();\n\t\t}\n\t\telse if(droptag==\'surfcol\')\n\t\t{\n\n\t\t\t var surfs = that.medViewer.hasContent(\'surf\');\n\t\t\t if (surfs.length > 1)\n\t\t\t {\n\t\t\t\t var menu = KContextMenu(\n\t\t\t\t  function() {\n\t\t\t\t\tvar $menu = $("<ul class=\'menu_context\'>");\n\t\t\t\t\tfor(var k = 0; k < surfs.length;k++)\n\t\t\t\t\t\t$menu.append($("<li onchoice=\'"+surfs[k].surf.fileID+"\' > "+surfs[k].surf.filename+" ("+surfs[k].surf.fileID+")</li>"));\n\t\t\t\t\treturn  $menu;                \t\t\t\t\t\t\t\t\t  \n\n\t\t\t\t  },\n\t\t\t\t  function(str,ev)\n\t\t\t\t  {\n\t\t\t\t\t\t\tfor (var k = 0; k < params.length;k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (params[k].intent == undefined)\n\t\t\t\t\t\t\t\t\tparams[k].intent = {surfcol:str};\n\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\tparams[k].intent.surfcol = str;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tinitiateLoadData(params);\n\t\t\t\t  },false)\n\t\t\t\t  menu(ev);\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t\tfor (var k = 0; k < params.length;k++)\n\t\t\t\t\tif (params[k].intent == undefined)\n\t\t\t\t\t\tparams[k].intent = {surfcol:surfs[0].surf.fileID};\n\t\t\t\t\telse\n\t\t\t\t\t\tparams[k].intent.surfcol = surfs[0].surf.fileID;\n\t\t\t\tinitiateLoadData(params);\n\t\t\t }\n\t\t}\n\t\telse if (tempObjectInfo && tempObjectInfo[0] && tempObjectInfo[0].mime == "tck" && tempObjectInfo[0].dirvolref)\n\t\t{\n\t\t  \tparams[0].intent = {createFiberTracking:tempObjectInfo[0].dirvolref};\n\t\t  \tinitiateLoadData(params[0]);\n\t\t}\n\t\telse if(droptag==\'overlay\' | ev.ctrlKey)\n\t\t{\n\t\t\tfor (var k = 0; k < params.length;k++)\n\t\t\t{\n\t\t\t\tif (params[k].intent == undefined)\n\t\t\t\t\tparams[k].intent = {overlay:true};\n\t\t\t\telse\n\t\t\t\t\tparams[k].intent.overlay = true;\n\t\t\t}\n\t\t\tinitiateLoadData(params);\n\t\t}\n\t\telse \n\t\t{\n\t\t\tif(params.type == \'markertemplate\')\n\t\t\t{\n\t\t\t\tparams.callback(ev, params, that);\n\t\t\t\treturn \n\t\t\t}\n\t\t\telse if(params.type == \'tagpaneltag\')\n\t\t\t{\n\t\t\t\tparams.callback(ev, params, that);\n\t\t\t\treturn \n\t\t\t}\n\t\t\telse if(params.length > 1 && ev.dataTransfer.files.length > 0)\n\t\t\t{\n\t\t\t\talertify.error("You cannot drop multiple local files. Drop on left panel instead.");\n\t\t\t\treturn\n\t\t\t}\n\n\t\t\tvar bruker;\n\t\t\tif(BrukerReader) \n\t\t\t\tbruker = BrukerReader.checkForBrukerData(params)\n\t\t\tif (bruker !== undefined )\n\t\t\t{\n\t\t\t\tBrukerReader.loadBruker(bruker, master.viewports[viewPortID].setContent) ;\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (typeof DicomReader != "undefined")\n\t\t\t{\n\t\t\t\tvar dicomReader = new DicomReader();\n\t\t\t\tvar dicomFileList = dicomReader.checkForDicomData(params)\n\t\t\t\tif(dicomFileList.length > 0)\n\t\t\t\t{\n\t\t\t\t\t//for(var k=0;k<params.length;k++) \n\t\t\t\t\t//\tparams[k].progressSpinner = that.progressSpinner;\n\t\t\t\t\t// dicomReader.loadDicoms(params, master.viewports[viewPortID].setContent);\n\t\t\t\t\talertify.error("You cannot drop DICOMS directly to viewport.<br> Drop on left panel instead.")\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tfor (var k = 0; k < params.length;k++)\n\t\t\t{\n\t\t\t\tif (droptag==\'image\' && params[k].intent)\n\t\t\t\t  params[k].intent.overlay = false;\n\t\t\t\tif (droptag==\'asjson\' && params[k].intent)\n\t\t\t\t params[k].intent.asjson = true;\n\t\t\t}\n\n            params[0].intent.drop = true;\n\t\t\tinitiateLoadData(params);\n\t\t\t\n\t\t}\n\n\t\tif (typeof tempObjectInfo != "undefined" && tempObjectInfo.shiftKey)\n\t\t{\n\t\t\tif (params[0].close)\n\t\t\t\tparams[0].close();\n\t\t}\n\n\t\tcleanAllDropIndicators();\n\n\t  }\n\n  \t  $container[0].ondrop= ondrop;\n  \t  that.ondrop = ondrop;\n\n\n\n      // horizontal viewport resizer\n\n\n\t\tthat.$container.on("mouseleave",function(ev)\n\t\t{\n\t\t\tif (KViewer.in_viewport_resizing_phase)\n\t\t\t\treturn;\n\t\t\t$container.removeClass("resizebar-x resizebar-y");\n\t\t\t$container.css(\'cursor\', \'\');\n\t\t\t\n\t\t});\n\n\t\tthat.$container.on("mousemove",function(ev)\n\t\t{\n\t\t\tif (zoomed || KViewer.in_viewport_resizing_phase || that.viewPortID > 11)\n\t\t\t\treturn;\n\t\t\tKViewer.on_viewport_resizing = false;\n\t\t\tif (Math.abs(ev.originalEvent.clientX-$container.offset().left-$container.width()) < 5)\n\t\t\t{\n\t\t\t\t$container.css(\'cursor\', \'ew-resize\');\n\t\t\t\t$container.addClass("resizebar-x");\n\t\t\t\tKViewer.on_viewport_resizing = true;\n\t\t\t}\n\t\t\telse if (Math.abs(ev.originalEvent.clientY-$container.offset().top) < 5) \n\t\t\t{\n\t\t\t\tif ($container.attr("id") == "KViewPort_container_number15")\n\t\t\t\t{\n\t\t\t\t\t$container.css(\'cursor\', \'ns-resize\');\n\t\t\t\t\t$container.addClass("resizebar-y");\n\t\t\t\t\tKViewer.on_viewport_resizing = true;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$container.css(\'cursor\', \'\');\n\t\t\t\t$container.removeClass("resizebar-x resizebar-y");\n\t\t\t}\n\n\t\t});\n\n\n\t\tthat.$container.on("mouseenter",function(ev)\n\t\t{\n\t\t\tthat.hasMouse = true;\n\t\t})\n\n\t\tthat.$container.on("mouseleave",function(ev)\n\t\t{\n\t\t\tthat.hasMouse = undefined;\n\t\t})\n\n\n\t\tthat.$container.on("mousedown",function(ev)\n\t\t{\n\n\t\t    KViewer.on_viewport_resizing = false;\n\n\t\t\tif (that.right_neighbor == "cartridge")\n\t\t\t{\n\t\t\t\tif (Math.abs(ev.originalEvent.clientX-$container.offset().left-$container.width()) < 5)\n\t\t\t\t{\t\n\t\t\t\t\tvar wid = KViewer.$viewportContainer.width();\n\t\t\t\t\tvar startx;\n\t\t\t\t\tvar start_wid_that = that.width_in_perc\n\t\t\t\t\tKViewer.in_viewport_resizing_phase = true;\n\n\t\t\t\t\t$(document.body).css(\'cursor\', \'ew-resize\');\n\t\t\t\t\t$(document.body).on("mousemove", movehandler_x);\n\t\t\t\t\t$(document.body).on("mouseup.resizer", uphandler);\n\t\t\t\t\t$(document.body).on("mouseleave.resizer", uphandler);\n\t\t\t\t\tstartx = ev.pageX;\n\t\t\t\t}\n\t\t\t\tfunction movehandler_x(ev)\n\t\t\t\t{\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t\tev.stopPropagation();\n\t\t\t\t\tvar delta = (startx-ev.pageX)/wid*50;\n\t\t\t\t\tthat.width_in_perc = start_wid_that - delta;\n\t\t\t\t\tKViewer.setViewPortLayout();\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\n\n\t\t\t\tif (KViewer.viewports[that.right_neighbor] == undefined)\n\t\t\t\t\treturn;\n\n\n\t\t\t\tif (Math.abs(ev.originalEvent.clientX-$container.offset().left-$container.width()) < 5)\n\t\t\t\t{\t\n\t\t\t\t\tvar wid = KViewer.$viewportContainer.width();\n\t\t\t\t\tvar startx;\n\t\t\t\t\tvar start_wid_that = that.width_in_perc\n\t\t\t\t\tvar start_wid_next = KViewer.viewports[that.right_neighbor].width_in_perc;\n\n\t\t\t\t\tKViewer.in_viewport_resizing_phase = true;\n\n\t\t\t\t\t$(document.body).css(\'cursor\', \'ew-resize\');\n\t\t\t\t\t$(document.body).on("mousemove", movehandler_x);\n\t\t\t\t\t$(document.body).on("mouseup.resizer", uphandler);\n\t\t\t\t\t$(document.body).on("mouseleave.resizer", uphandler);\n\t\t\t\t\tstartx = ev.pageX;\n\t\t\t\t}\n\n\t\t\t\tfunction movehandler_x(ev)\n\t\t\t\t{\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t\tev.stopPropagation();\n\t\t\t\t\tvar delta = (startx-ev.pageX)/wid*100;\n\t\t\t\t\tthat.width_in_perc = start_wid_that - delta;\n\t\t\t\t\tKViewer.viewports[that.right_neighbor].width_in_perc = start_wid_next + delta;\n\t\t\t\t\tKViewer.setViewPortLayout();\n\t\t\t\t}\n\n\t\t\t\tfunction movehandler_y(ev)\n\t\t\t\t{\n\t\t\t\t\tev.preventDefault();\n\t\t\t\t\tev.stopPropagation();\n\t\t\t\t\tvar delta = (starty-ev.pageY)/hei;\n\t\t\t\t\tstate.viewer.barportSizePercent = start_hei_that + delta*100;\n\n\t\t\t\t\tKViewer.setViewPortLayout();\n\t\t\t\t}\n\n\t\t\t}\n\n\n\t\t\tfunction uphandler()\n\t\t\t{\n\t\t\t\t$(document.body).off();\n\t\t\t\t$(document.body).css(\'cursor\', \'\');\t\t\t\n\t\t\t\t$container.removeClass("resizebar-x resizebar-y");\t\n\t\t\t\tKViewer.in_viewport_resizing_phase = false;\n\t\t\t}\n\n\t\t});\n\n\n\n\n\t \n      function initiateLoadData(params,onready)\n\t  {\n\t  \t  if(!params )\n\t  \t\treturn false;\n\t  \t  if(currentViewer != undefined && currentViewer.viewerType == \'Manager\')\n\t  \t \t return false;\n\n\t\t  if (Array.isArray(params))\n\t\t  {\n\t\t  \t  if (params.length > 0)\n\t\t  \t  {\n\t\t\t\t  initiateLoadData(params[0],function(){\n\n\t\t\t\t\tinitiateLoadData(params.slice(1),onready);\n\n\t\t\t\t  })\t\t\t  \n\t\t  \t  }\n\t\t  \t  else\n\t\t  \t  \t{\n\t\t  \t  \t\tif (onready) onready();\n\t\t  \t  \t}\n\n\t\t\t  return;\n\t\t  }\n\t\t\n\n\t\t  params.callback = function(ev){\n\t\t  \t  if (ev != undefined)\n\t\t\t  \t params.obj = ev;\n\t\t\t  master.viewports[viewPortID].setContent(ev,params);                    \n\t\t\t  params.progressSpinner(undefined);\n\t\t\t  if (onready) onready(ev);\n\t\t  }\n\n\t\t  params.progressSpinner = that.progressSpinner;\n\t\t  that.progressSpinner("Loading data");\n\t\t  master.dataManager.loadData(params);\n\t  }\n\n\t  that.openFile = initiateLoadData;\n\n\n      that.closeContextMenu = function(from) { \n\n      return KContextMenu(\n              function() {\n              \tvar suffix = "";\n              \tif (from != undefined)\n\t\t\t\t\tsuffix = \'(\'+from.type+\')\';\n              \t\t\n              \tvar $menu = $("<ul class=\'menu_context\'>").append($("<li onchoice=\'all\' > close all "+suffix+" </li>"));\n              \t\n                return  $menu;                \t\t\t\t\t\t\t\t\t  \n                \n              },\n              function(str,ev)\n              { \n\n\t\t\t\t\n\t\t\t\t function delAllObjs(type,subtype)\n\t\t\t\t {\n\t\t\t\t \tKViewer.iterateMedViewers(function (mv){\n\t\t\t\t\t\tvar objs = mv[type].slice();\n\t\t\t\t\t\tfor (var j = 0 ; j < objs.length;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (subtype != undefined)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (objs[j][subtype] != undefined)\n\t\t\t\t\t\t\t\t\tobjs[j].close();\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tobjs[j].close();\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t }\n\n\n              \tif (str == "all")\n                {\n                \tif (from == undefined)\n                \t{\n\t\t\t\t\t\tvar unsaved = unsavedChanges();\n\t\t\t\t\t\tif (userinfo.username != guestuser & state.viewer.selectionMode[0] == "w" & unsaved != "")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\talertify.confirm("Are you sure to close all, there are unsaved " + unsaved + "!",function(e)\n\t\t\t\t\t\t\t{ if (e) \n\t\t\t\t\t\t\t   KViewer.closeAll() });\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \n\t\t\t\t\t\t{\n\t\t\t\t\t\t   signalhandler.send("close");\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn;\n                \t}\n                \telse if (from.type == \'overlay\')\n                \t\tdelAllObjs("overlays");\n                \telse if (from.type == \'surface\')\n                \t\tdelAllObjs("objects3D","surf");\n                \telse if (from.type == \'fiber\')\n                \t\tdelAllObjs("objects3D","fibers");\n                \telse if (from.type == \'roi\')\n                \t\tdelAllObjs("ROIs");\n                \telse if (from.type == \'atlas\')\n                \t\tdelAllObjs("atlas");\n                \n                }\n              \telse if (str == "ortho")\n                {\n\n                \n                }\n\n              } , false) };\n              \n\t\n\t  that.close = function()\n\t  {\n\t  \t if (zoomed)\n\t  \t \tzoomViewPort();\n\t\t if (that.getCurrentViewer())\n\t\t {\n\t\t \tif (that.getCurrentViewer().viewerType != \'Manager\')\n\t\t\t\t that.setCurrentViewer();\t\t \t\n\t\t }\n\t  }\n\n\t//  var medViewer  = new KMedViewer(that, master);\n\t//  that.medViewer =  medViewer;\n\n\n\t  function dummyViewer(which,constr)\n\t  {\n\t  \treturn { setContent:\n\t  \t\tfunction(c,p)\n\t  \t\t{\n\t\t\t\tvar x = constr(that,master);\n\t\t\t\teval(which + \'=x\');\n\t\t\t\teval(\'that.\' + which + \'=x\');\n\t\t\t\tx.setContent(c,p);\n\t  \t\t}\n\t  \t}\n\t  }\n\n\t  var medViewer  = dummyViewer(\'medViewer\',KMedViewer);\n\t  var bmpViewer  = dummyViewer(\'bmpViewer\',KBmpViewer);\n\t  var jsonViewer = dummyViewer(\'jsonViewer\',KJsonViewer);\n\t  var tableViewer = dummyViewer(\'tableViewer\',KTableViewer);\n\t  var txtViewer = dummyViewer(\'txtViewer\',KTXTViewer);\n\t  var ViewerJS = dummyViewer(\'ViewerJS\',KViewerJS);\n//\t  var formViewer = new KFormViewer(that,master  ); //  dummyViewer(\'formViewer\',KFormViewer);\n\t  var formViewer = dummyViewer(\'formViewer\',KFormViewer);\n\n\t  var currentViewer = undefined;\n\n\t  return that;\n\n}\n\n\n'},function(t,n){t.exports='\n\n// ======================================================================================\n// ======================================================================================\n// ============= KMedViewer\n// ======================================================================================\n// ======================================================================================\n\n\n\nfunction KMedViewer(viewport, master)\n{\n\n    \n    /**  @class \t   \n     *  @alias KMedViewer */\n    var that = KPrototypeViewer(viewport, master);\n    that.viewerType = \'medViewer\';\n    that.type = \'mainview\';\n\n    var $container = that.$container;\n    var $topRow = that.$topRow;\n    var toolbar = that.toolbar;\n\n    toolbar.$info.hide();\n\n    var $canvascontainer = $("<div class=\'KViewPort_canvascontainer\'></div>").appendTo($container);\n    that.$canvascontainer = $canvascontainer;\n\n    // attach the histogram\n    that.histoManagercnt = 0;\n    var histoManager = createHistoManager(that);\n    /** @type {KHistoManager} \n     */\n    that.transfactor = 1;\n    that.histoManager = histoManager;\n    histoManager.blending = undefined;\n    histoManager.posnegsym = undefined;\n    histoManager.blocky = undefined;\n    histoManager.onclimchange = function(ev)\n    {\n        sliceDrawUpdateNeeded = true;\n        histoManager.clim_manually_modified = true;\n        signalhandler.send("climChange", {\n            id: that.currentFileID,\n            val: histoManager.clim,            \n            ev: ev\n        });\n    }\n\n\n\n    var infomenu = function(_that) {\n        return KContextMenu(function() {\n            var nii = that.nii;\n            var msz;\n            if (nii.sizes.length > 3)\n                msz = "matrix: " + nii.sizes[0].toFixed(0) + \'&nbsp;&nbsp;\' + nii.sizes[1].toFixed(0) + \'&nbsp;&nbsp;\' + nii.sizes[2].toFixed(0) + \'&nbsp;&nbsp;\' + nii.sizes[3].toFixed(0);\n            else\n                msz = "matrix: " + nii.sizes[0].toFixed(0) + \'&nbsp;&nbsp;\' + nii.sizes[1].toFixed(0) + \'&nbsp;&nbsp;\' + nii.sizes[2].toFixed(0);\n\n            if (nii.currentTimePoint.t != 0)\n                msz += "  (t:" + (nii.currentTimePoint.t + 1) + ")";\n\n            if (that.currentFileinfo)\n                var psid = that.currentFileinfo.patients_id + " " + that.currentFileinfo.studies_id;\n            else\n                var psid = "localfile";\n\n            msz = that.currentFilename + " <br> ID: " + psid +\n            "<br>" + msz + "<br>voxsize: " +\n            nii.voxSize[0].toFixed(1) + \'&nbsp;&nbsp;\' + nii.voxSize[1].toFixed(1) + \'&nbsp;&nbsp;\' + nii.voxSize[2].toFixed(1)\n\n\n            return $("<ul class=\'menu_context\'>").append($("<li >" + msz + " </li>"));\n\n        }, function(str, ev) {})\n    }(that);\n\n\n    that.switchToMosaic = function()\n    {\n          if (gl_enabled)\n                    toggle3D();\n            that.mosaicview.active = true;\n            setCanvasLayout();\n            drawSlice();\n    }\n\n    that.switchToSingle= function()\n    {\n\n            if (gl_enabled)\n                    toggle3D();\n                if (that.mosaicview.active)\n                    that.mosaicview.active = false;\n                setCanvasLayout();\n                if (!that.mosaicview.active)\n                    drawSlice();\n    }\n\n    that.switchTo3D = function(callback)\n    {\n                if (that.mosaicview.active)\n                    that.mosaicview.active = false;\n                if (!gl_enabled)\n                    toggle3D(undefined,callback);\n                else\n                {\n                    setCanvasLayout();\n                    drawSlice();\n                }\n    }\n\n    that.viewContextMenu = new KContextMenu(\n    function() {\n        var $menu = $("<ul class=\'menu_context\'>");\n        var name = [\'Saggital\', \'Coronal\', \'Transversal\'];\n\n        $menu.append($("<hr width=\'100%\'> "));\n        $menu.append($("<span> &nbsp View</span>"));\n        $menu.append($("<hr width=\'100%\'> "));\n        var sel = (!gl_enabled && !that.mosaicview.active) ? \'check-\' : \'\';\n        $menu.append($("<li  onchoice=\'single\' > <i  onchoice=\'single\' class=\'fa fa-" + sel + "circle-o\'></i><i class=\'leftaligned fa fa-user\'></i>   Single slice   </li>"));\n        var sel = that.mosaicview.active ? \'check-\' : \'\';\n        $menu.append($("<li  onchoice=\'mosaic\' > <i  onchoice=\'mosaic\' class=\'fa fa-" + sel + "circle-o\'></i>  <i class=\'leftaligned fa fa-th\'></i>   Mosaic  </li>"));\n        var sel = gl_enabled ? \'check-\' : \'\';\n        \n        if (typeof KMedImg3D != "undefined")\n            $menu.append($("<li  onchoice=\'3dview\' >  <i  onchoice=\'3dview\' class=\'fa fa-" + sel + "circle-o\'></i>  <i class=\'leftaligned fa fa-cube\'></i>   3D view </li>"));\n\n     //   $menu.append($("<li  onchoice=\'curveview\' >  <i  onchoice=\'curveview\' class=\'fa fa-" + sel + "circle-o\'></i>  <i class=\'leftaligned fa fa-line-chart\'></i>   Curve view </li>"));\n\n        $menu.append($("<hr width=\'100%\'> "));\n        var sel = worldLockedToMaster ? \'check-\' : \'\';\n        $menu.append($("<li  onchoice=\'lock\' > Global coordinates<i  onchoice=\'lock\' class=\'fa fa-" + sel + "square-o\'></i> </li>"));\n\n\n         var permstr = "<li  onchoice=\'...\' >Permutation<i  onchoice=\'lock\' class=\'fa fa-caret-right\'></i> <ul>" ;\n         for (var k = 0; k < presetForm_viewer_permorder.choices.length;k++ )\n         {\n             var sel = (that.nii.reordering == presetForm_viewer_permorder.ids[k]) ? \'check-\' : \'\';\n             permstr += " <li  onchoice=\'permorder_"+presetForm_viewer_permorder.ids[k]+"\' >"+ presetForm_viewer_permorder.choices[k] + "<i  onchoice=\'lock\' class=\'fa fa-"+sel+"square-o\'></i> </li> "\n         }\n         permstr += "</ul></li>";\n         $menu.append($(permstr));\n\n        if (!gl_enabled)\n        {\n            $menu.append($("<hr width=\'100%\'> "));\n            $menu.append($("<span> &nbsp Slicing</span>"));\n            $menu.append($("<hr width=\'100%\'> "));\n            var perm = [0, 1, 2];\n            //[viewer.nii.permutationOrder[0],viewer.nii.permutationOrder[1],viewer.nii.permutationOrder[2]];\n            perm[-1] = -1;\n            for (var k = 0; k < 3; k++)\n            {\n                var sel = \'\';\n//                 if (slicingDimOfWorld == that.nii.permutationOrder[k])\n//                     sel = \'check-\';\n                if (slicingDimOfWorld == k)\n                    sel = \'check-\';\n\n                $menu.append($("<li  onchoice=\'vis_" + k + "\' > " + name[k] + "  <i  onchoice=\'vis_" + k + "\' class=\'fa fa-" + sel + "circle-o\'></i> </li>"));\n\n\n            }\n        }\n\n        return $menu;\n    }\n    ,function(str, ev)\n    {\n        if (str != undefined)\n        {\n            if (str.search("vis") != -1)\n            {\n                setSlicingDimOfWorld(parseInt(str.substring(4)));\n            }\n            else if (str == "single")\n            {\n                that.switchToSingle();\n            }\n            else if (str == "mosaic")\n            {\n                that.switchToMosaic();\n            }\n            else if (str == "3dview")\n            {\n\n                that.switchTo3D();\n\n            }\n            else if (str == "curveview")\n            {\n                if (that.mosaicview.active)\n                    that.mosaicview.active = false;\n                if (gl_enabled)\n                    toggle3D();\n                \n                KMedImgCurve( that );    \n\n            }\n            else if (str == \'lock\')\n            {\n                changeWorldLock();\n//                 if (worldLockedToMaster)\n//                     customPoint = math.matrix(getWorldPosition());\n//                 worldLockedToMaster = !worldLockedToMaster;\n//                 drawSlice({\n//                     mosaicdraw: true\n//                 });\n            }\n            else if (str.substring(0,10) == \'permorder_\')\n            {\n                var id = str.substring(10);\n                that.niiOriginal.applyReordering(id);\n                signalhandler.send("updateImage",{id:that.currentFileID});\n            }\n        }\n    }\n    ,undefined,false);\n\n\n    function KIcon(name,$div,style)\n    {\n        if (style == undefined)\n            style = "";\n\n        var $icon;\n        if (name == "planecube")\n        {\n            style = style = style +"stroke:lightgray;stroke-width:1";\n            $icon = [];\n            $icon[2] = $("<div> <svg style=\'\' height=12 width=12>"+\n            " <polygon points=\'1,3 1,9 6,11 6,5\' style=\'fill:none;"+style+"\' />"+\n            " <polygon points=\'11,3 11,9 6,11 6,5\' style=\'fill:none;"+style+"\' />"+\n            " <polygon points=\'1,3 6,5 11,3 6,1\' style=\'fill:yellow;"+style+"\' />"+\n            +"</svg> </div>");\n            $icon[1] = $("<div> <svg style=\'\' height=12 width=12>"+\n            " <polygon points=\'1,3 1,9 6,11 6,5\' style=\'fill:none;"+style+"\' />"+\n            " <polygon points=\'11,3 11,9 6,11 6,5\' style=\'fill:yellow;"+style+"\' />"+\n            " <polygon points=\'1,3 6,5 11,3 6,1\' style=\'fill:none;"+style+"\' />"+\n            +"</svg> </div>");\n            $icon[0] = $("<div> <svg style=\'\' height=12 width=12>"+\n            " <polygon points=\'1,3 1,9 6,11 6,5\' style=\'fill:yellow;"+style+"\' />"+\n            " <polygon points=\'11,3 11,9 6,11 6,5\' style=\'fill:none;"+style+"\' />"+\n            " <polygon points=\'1,3 6,5 11,3 6,1\' style=\'fill:none;"+style+"\' />"+\n            +"</svg> </div>");\n        }\n\n        $div.append($icon);\n\n        return $icon;\n    }\n\n\n\n\n    toolbar.$cmapReset = $("<div class=\'KViewPort_tool KViewPort_tool_cmapReset\'><i class=\'fa fa-reply fa-1x\'></i></div>").click(function() {\n        resetColorMapLims();\n    }).appendTooltip("resetclims")\n    toolbar.$cmap = $("<div class=\'KViewPort_tool KViewPort_tool_cmap\'><i class=\'fa fa-empty fa-1x\'>&nbsp&nbsp&nbsp&nbsp</i></div>").click(histoManager.cmapSelectorMenu).appendTooltip("changecolormap")\n    toolbar.$quiver = $("<div  class=\'KViewPort_tool\'>  <i class=\'fa fa-code-fork fa-1x\'> </div>").click(function(e) {\n        quiver.menu(e,that)\n    }).appendTooltip("quiverprops")\n    that.quiverdiv =  toolbar.$quiver\n    toolbar.$info = $("<div  class=\'KViewPort_tool\'>  <i class=\'fa fa-info-circle fa-1x\'> </div>").click(infomenu);\n    toolbar.$lock = $("<div  class=\'KViewPort_tool\'>  <i class=\'fa fa-lock fa-1x\'> </div>").click(changeWorldLock);\n    toolbar.$view = $("<div  class=\'KViewPort_tool\'>  <i class=\'fa fa-photo fa-1x\'> </div>").click(that.viewContextMenu);\n    toolbar.$createIso = $("<div  class=\'KViewPort_tool\'>  <i class=\'fa fa-play fa-1x\'> </div>");\n    \n   \n\n    toolbar.$toggle3D = $("<div class=\'KViewPort_tool KViewPort_tool_toggle3D\'><i class=\'fa fa-1x\'><span>3D</span></i></div>").click(function() {\n        toggle3D()\n    }).appendTooltip("switchto3d");\n    toolbar.$slicingDim = $("<div class=\'KViewPort_tool KViewPort_tool_slicingDim\'></div>").click(toggleSlicingDim).appendTooltip("changeslicing")\n    toolbar.$sliceCubes = KIcon(\'planecube\',toolbar.$slicingDim);\n\n    toolbar.attach(toolbar.$cmapReset).attach(toolbar.$cmap).attach(toolbar.$info).attach(toolbar.$quiver).attach(toolbar.$toggle3D).attach(toolbar.$lock).attach(toolbar.$view).attach(toolbar.$slicingDim);\n\n    var layoutbar = that.layoutbar;\n    layoutbar.$slicing = $("<div class=\'KViewPort_tool_layout\'><i class=\'fa  fa-1x\'></i></div>").click(toggleSlicingDim).appendTooltip("changeslicing")\n\n    if (typeof KMedImg3D != "undefined")\n    {\n\n        layoutbar.$shortcut3d   = $("<span class=\'KViewPort_tool_layout layout3dshortcut\'> 3D</span>");\n\n        layoutbar.$shortcut3d.click(function()\n        {\n           toggle3D(); \n        });\n    }\n    layoutbar.$sliceCubes = KIcon(\'planecube\',layoutbar.$slicing);\n    layoutbar.$center = $("<div class=\'KViewPort_tool_layout\'><i class=\'fa fa-dot-circle-o fa-1x\'></i></div>").click(\n            function() { signalhandler.send("centralize"); }\n    ).appendTooltip("centerview");\n\n    layoutbar.attach(layoutbar.$slicing);\n    if (typeof KMedImg3D != "undefined")\n        layoutbar.attach(layoutbar.$shortcut3d);\n    \n    // ******** slide slices and slide zoom\n    layoutbar.$slideslices = $("<span class=\'KViewPort_tool_layout\'> <i class=\'fa fa-unsorted fa-1x\'></i> </span>");\n    layoutbar.$slidezoom   = $("<span class=\'KViewPort_tool_layout\'> <i class=\'fa fa-search fa-1x\'></i> </span>");\n\n    // slice slider\n    attachMouseSlider(layoutbar.$slideslices, {\n            mousedown: function(){ return { startval: currentSlice, startval_percent: currentSlice / (that.nii.sizes[slicingDimOfArray]-1) } } , \n            mousemove:function(ev,dx,dy,mousedownvar) {  \n                return that.setSlicePos(slicingDimOfArray, mousedownvar.startval - that.nii.arrayReadDirection[slicingDimOfArray]*dy*(that.nii.sizes[slicingDimOfArray]-1) ) }, \n            mouseup: function(){ } \n            });\n    \n    // zoom slider\n    attachMouseSlider(layoutbar.$slidezoom, \n        {\n            mousedown: function()\n            { \n                return { startzoomFac: that.zoomFac, startMosaicZoom: that.mosaicview.zoom} \n            }, \n            mousemove:function(ev,dx,dy,mousedownvar, lastdx, lastdy) \n            {\n                if (gl_enabled)\n                {\n                    var zoominc = 1 - lastdy*0.004;\n                    var maxex = that.computeMaxExtentFac()\n                    that.gl.camera.inertialRadiusOffset -= maxex * (1 - zoominc);\n                    if (isNaN(that.gl.camera.inertialRadiusOffset))\n                        that.gl.camera.inertialRadiusOffset = 1;\n                    that.gl.sync3DViews(that.gl.camera.inertialAlphaOffset,that.gl.camera.inertialBetaOffset,\n                        that.gl.camera.inertialPanningX,that.gl.camera.inertialPanningY,that.gl.camera.inertialRadiusOffset );\n\n                    that.gl.activateRenderLoop();\n                    setTimeout(that.gl.setQuality,350);\n                }\n                else if (that.mosaicview.active)\n                {\n                    that.mosaicview.zoom  =  mousedownvar.startMosaicZoom + dy*10;\n                    if (that.mosaicview.zoom > 1)\n                        that.mosaicview.zoom = 1;\n                    if (KViewer.mainViewport != -1)\n                        signalhandler.send("mosaic_changelayout",that.mosaicview);\n                    else\n                    { \n                        setCanvasLayout();\n                        drawHairCross();\n                    }             \n                }\n                else\n                {\n                    var zoominc = 1 - lastdy*0.01;\n                    $(".markerpoint,.markerruler").css(\'display\',\'none\')\n                    if (worldLockedToMaster & master.globalCoordinates)\n                    {                    \n                        signalhandler.send("setZoom", zoominc );\n                        signalhandler.send("positionChange", {nosliceupdate:true},that.positionChanger); // why this ...markers?\n                    }\n                    else\n                    {\n                        setZoom(zoominc);\n                        signalhandler.send("positionChange", {nosliceupdate:true},that.positionChanger); // why this ...markers?\n                    }\n\n                }\n                return  true;\n\n            }, \n            mouseup: function(){ \n            } \n        },\n        {hideCurrentval:true}\n        );\n\n    layoutbar.attach(layoutbar.$slideslices)\n\n    layoutbar.attach(layoutbar.$center);\n\n    layoutbar.attach(layoutbar.$slidezoom)\n\n    layoutbar.$resetzoom  = $("<span class=\'KViewPort_tool_layout\'> <i class=\'fa fa-reply fa-1x\'></i> </span>");\n    layoutbar.$resetzoom.mousedown(function(ev){ KViewer.resetCrossHair()  })\n    layoutbar.attach(layoutbar.$resetzoom)\n\n\n    layoutbar.$zoomin.on("mousedown", function(e)\n    {\n        if (layoutbar.$zoomin.iid != -1)\n            clearInterval(layoutbar.$zoomin.iid);\n        var maxex = that.computeMaxExtentFac()\n        layoutbar.$zoomin.fac = 1.002;\n        if (gl_enabled)\n        {\n            layoutbar.$zoomin.iid = setInterval(function()\n            {\n                that.gl.camera.inertialRadiusOffset -= maxex * (1 - layoutbar.$zoomin.fac);\n                if (isNaN(that.gl.camera.inertialRadiusOffset))\n                    that.gl.camera.inertialRadiusOffset = 1;\n\n\n                that.gl.activateRenderLoop();\n                that.gl.setQuality()\n                \n            }, 0);\n        }\n        else if (that.mosaicview.active)\n        {\n            var amount = 1;\n            that.mosaicview.zoom += ((amount > 0) ? -1 : 1) * 0.3 * scrollSpeed;\n            if (that.mosaicview.zoom > 1)\n                that.mosaicview.zoom = 1;\n            setCanvasLayout();\n            drawHairCross();\n        }\n        else {\n            layoutbar.$zoomin.iid = setInterval(function()\n            {\n               $(".markerpoint,.markerruler").css(\'display\',\'none\')\n                 signalhandler.send("setZoom", layoutbar.$zoomin.fac);\n                signalhandler.send("positionChange", {nosliceupdate:true},that.positionChanger);\n                if (layoutbar.$zoomin.fac < 1.01)\n                    layoutbar.$zoomin.fac += 0.0002;\n            }, 0);\n        }\n    });\n    layoutbar.$zoomin.on("mouseup mouseleave", function(e)\n    {\n        clearInterval(layoutbar.$zoomin.iid);\n        layoutbar.$zoomin.iid = -1;\n    });\n    layoutbar.$zoomout.on("mousedown", function(e)\n    {\n        if (layoutbar.$zoomout.iid != -1)\n            clearInterval(layoutbar.$zoomin.iid);        \n        var maxex = that.computeMaxExtentFac()        \n        layoutbar.$zoomout.fac = 0.998;\n        if (gl_enabled)\n        {\n            layoutbar.$zoomout.iid = setInterval(function()\n            {\n                that.gl.camera.inertialRadiusOffset += maxex * (1 - layoutbar.$zoomin.fac);\n                if (isNaN(that.gl.camera.inertialRadiusOffset))\n                    that.gl.camera.inertialRadiusOffset = 1;\n                \n                that.gl.activateRenderLoop();\n                that.gl.setQuality()\n            }, 0);\n        }\n        else if (that.mosaicview.active)\n        {\n            var amount = -1;\n            that.mosaicview.zoom += ((amount > 0) ? -1 : 1) * 0.3 * scrollSpeed;\n            if (that.mosaicview.zoom > 1)\n                that.mosaicview.zoom = 1;\n            if (KViewer.mainViewport != -1)\n                signalhandler.send("mosaic_changelayout",that.mosaicview);\n            else\n            { \n                setCanvasLayout();\n                drawHairCross();\n            }                      \n        }\n        else {\n            layoutbar.$zoomout.iid = setInterval(function()\n            {\n                    $(".markerpoint,.markerruler").css(\'display\',\'none\')                \n                signalhandler.send("setZoom", layoutbar.$zoomout.fac);\n                signalhandler.send("positionChange", {nosliceupdate:true},that.positionChanger);                \n                if (layoutbar.$zoomout.fac > 0.99)\n                    layoutbar.$zoomout.fac -= 0.0002;\n            }, 0);\n        }\n    });\n    layoutbar.$zoomout.on("mouseup mouseleave", function(e)\n    {\n        clearInterval(layoutbar.$zoomout.iid);\n    });\n\n    layoutbar.$zoomin.hide();\n    layoutbar.$zoomout.hide();\n\n    \n    layoutbar.$moszoomin = $("<span class=\'KViewPort_tool_layout\'> <i class=\'fa fa-plus\'></i> </span>").hide().click(\n    function(e)\n    {\n        var amount = -1;\n        that.mosaicview.nx_cont += ((amount > 0) ? -1 : 1);\n        if (that.mosaicview.nx_cont < 2)\n            that.mosaicview.nx_cont = 2;\n        that.mosaicview.nx = Math.round(that.mosaicview.nx_cont);\n        if (KViewer.mainViewport != -1)\n            signalhandler.send("mosaic_changelayout",that.mosaicview);\n        else\n        { \n            setCanvasLayout();\n            drawHairCross();\n        }                });\n    layoutbar.$moszoomout = $("<span class=\'KViewPort_tool_layout\'> <i class=\'fa fa-minus\'></i> </span>").hide().click(\n    function(e)\n    {\n        var amount = 1;\n        that.mosaicview.nx_cont += ((amount > 0) ? -1 : 1);\n        if (that.mosaicview.nx_cont < 2)\n            that.mosaicview.nx_cont = 2;\n        that.mosaicview.nx = Math.round(that.mosaicview.nx_cont);\n       if (KViewer.mainViewport != -1)\n            signalhandler.send("mosaic_changelayout",that.mosaicview);\n       else\n       { \n            setCanvasLayout();\n            drawHairCross();\n       }            \n    });\n\n\n    layoutbar.$leftrot = $("<span class=\'KViewPort_tool_layout\'> <i class=\'fa fa-rotate-left\'></i> </span>").hide();\n    layoutbar.$rightrot = $("<span class=\'KViewPort_tool_layout\'> <i class=\'fa fa-rotate-right\'></i> </span>").hide();\n\n    function ani3D(e, dir)\n    {\n        layoutbar.$rightrot.removeClass(\'KViewPort_tool_enabled\');\n        layoutbar.$leftrot.removeClass(\'KViewPort_tool_enabled\');\n        if (that.gl.animate3D(dir))\n            $(e).addClass(\'KViewPort_tool_enabled\');\n    }\n\n    layoutbar.$leftrot.click(function() {\n        ani3D(this, +1)\n    });\n    layoutbar.$rightrot.click(function() {\n        ani3D(this, -1)\n    });\n    layoutbar.attach(layoutbar.$moszoomin)\n    .attach(layoutbar.$moszoomout)\n    .attach(layoutbar.$rightrot)\n    .attach(layoutbar.$leftrot);\n\n    layoutbar.showLayout3D = function() {\n        layoutbar.$leftrot.show();\n        layoutbar.$rightrot.show();\n        if ( layoutbar.$shortcut3d)\n            layoutbar.$shortcut3d.text("2D");\n\n        layoutbar.$slicing.hide();\n        layoutbar.$slideslices.hide();\n        layoutbar.$center.hide();\n    }\n    layoutbar.hideLayout3D = function() {\n        layoutbar.$leftrot.hide();\n        layoutbar.$rightrot.hide();\n        if ( layoutbar.$shortcut3d)\n        {\n            layoutbar.$shortcut3d.show();\n            layoutbar.$shortcut3d.text("3D");\n        }\n        layoutbar.$slicing.show();\n        layoutbar.$slideslices.show();\n        layoutbar.$center.show();\n        \n    }\n\n\n\n\n    // this should be implemented at another place ( in roiPanel)\n    var ROIadder = function(_that) {\n        return KContextMenu(\n        function() {\n            var upperadder\n            var loweradder\n            var $menu = $("<ul class=\'menu_context small\'>")\n            .append($("<hr width=\'100%\'> "))\n            .append($("<span>  &nbsp <i class=\'fa leftaligned fa-pencil-square-o fa-1x\'></i>  ROI  </span>"))\n            .append($("<hr width=\'100%\'> "))\n            .append($("<li onchoice=\'empty\' > create empty </li>"))\n            .append(upperadder= $("<li onchoice=\'upper\' > larger than lower limit  </li>"))\n            .append(loweradder=$("<li onchoice=\'lower\' > lower than lower limit  </li>"))\n            .append($("<hr width=\'100%\'> "))\n            .append($("<span> &nbsp <i class=\'fa leftaligned fa-shopping-basket fa-1x\'></i> Miscellaneous  </span>"))\n            .append($("<hr width=\'100%\'> "))\n\n            var currentid = _that.currentFileID;\n            var matrices_available = [];\n\n            if (that.currentFileID != currentid)\n                  matrices_available.push({n:that.currentFilename,id:that.currentFileID})\n\n            for (var i = 0; i < that.ROIs.length;i++)\n                if (that.ROIs[i].roi.fileID != currentid)\n                    matrices_available.push({id:that.ROIs[i].roi.fileID,n:that.ROIs[i].roi.filename})\n            for (var i = 0; i < that.overlays.length;i++)\n                if (that.overlays[i].currentFileID != currentid)\n                    matrices_available.push({n:that.overlays[i].currentFilename,id:that.overlays[i].currentFileID})\n            if (matrices_available.length>0)\n            {\n                var str_upper = "";\n                var str_lower = "";\n                for (var i = 0; i < matrices_available.length;i++)                    \n                {\n                    str_upper += "<li onchoice=\'upper_"+ matrices_available[i].id +"\'> " + matrices_available[i].n + "  </li> "\n                    str_lower += "<li onchoice=\'lower_"+ matrices_available[i].id +"\'> " + matrices_available[i].n + "  </li> "\n                }\n                \n                upperadder.append($(" <ul>  " + str_upper +" </ul>" ))\n                loweradder.append($(" <ul>  " + str_lower +" </ul>" ))\n            }\n            if (_that.nii.sizes[3]%3 == 0)\n            {\n                var sel = _that.showcolored ? \'check-\' : \'\';\n                var type = _that.showcolored_type;\n                $menu.append($("<li onchoice=\'rgbinterpret\' > RGB interpret <i class=\'fa fa-caret-right\'></i> <ul> " +\n                "<li onchoice=\'rgbinterpret\' > colored <i  onchoice=\'lock\' class=\'fa fa-"+sel+"square-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_raw\' > raw <i onchoice=\'lock\' class=\'fa fa-"+((type=="raw") ? \'check-\' : \'\')+"circle-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_RGB\' > RGB <i onchoice=\'lock\' class=\'fa fa-"+((type=="RGB") ? \'check-\' : \'\')+"circle-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_BRG\' > BRG <i onchoice=\'lock\' class=\'fa fa-"+((type=="BRG") ? \'check-\' : \'\')+"circle-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_GBR\' > GBR <i onchoice=\'lock\' class=\'fa fa-"+((type=="GBR") ? \'check-\' : \'\')+"circle-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_GRB\' > GRB <i onchoice=\'lock\' class=\'fa fa-"+((type=="GRB") ? \'check-\' : \'\')+"circle-o\'></i> </li>"));\n\n            }\n\n            if (_that.refSurfView != undefined)\n            {\n                var showview = "";\n                if (!_that.refSurfView.toolbarAttached)\n                    showview= " <i  onchoice=\'showisoview\' class=\'fa button\' style=\'right:30px;\'>show view</i> "\n             \n                $menu.append($("<li onchoice=\'iso\' > remove isosurface "+showview+" </li>"));\n            }\n            else\n                $menu.append($("<li onchoice=\'iso\' > create isosurface </li>"));\n\n            if (_that.outlines == undefined)\n                $menu.append($("<li onchoice=\'outline\' > show contours </li>"));\n            else\n            { \n                $menu.append($("<li onchoice=\'outline\' > hide contours </li>"));\n                $menu.append($("<li onchoice=\'contcol\' > > contour color  </li>"));\n            }\n\n\n\n            if (_that.nii.sizes[3]%3 == 0)\n                $menu.append($("<li onchoice=\'tracking\' >create fiber tracking </li>"));\n\n            $menu.append($("<li onchoice=\'refetch\' > refetch file </li>"));\n            \n            if (_that.content && _that.content.refvisit_tck)\n                $menu.append($("<li onchoice=\'unlinktck\' > unlink fiber visits </li>"));\n\n\n            return $menu;\n\n\n        },\n        function(str, ev)\n        {\n            function arrived(fobj)\n            {\n                    master.iterateMedViewers(function(m)\n                    {\n                        if (_that.currentFileID == m.currentFileID)\n                                m.setContent(fobj, {intent: { ROI: true }  });\n                        else \n                            for (var k = 0; k < m.overlays.length; k++)\n                            {\n                                if (_that.currentFileID == m.overlays[k].currentFileID)\n                                {\n                                    m.setContent(fobj, {intent: {ROI: true}});\n                                    return;\n                                }\n                            }\n                    });\n                    that.ROIs[that.ROIs.length - 1].makeCurrent();\n            }\n            if (str == undefined)\n                return;\n\n            if (str == "unlinktck")\n            {\n                if (_that.content.refvisit_tck.visitworker != undefined)\n                {\n                    _that.content.refvisit_tck.visitworker.kill();\n                    _that.content.refvisit_tck.visitworker = undefined;\n                }\n                if (_that.content.refvisit_tck.visitworker_terms != undefined)\n                {\n                    _that.content.refvisit_tck.visitworker_terms.kill();\n                    _that.content.refvisit_tck.visitworker_terms = undefined;\n                }                \n                _that.content.refvisit_tck = undefined;\n            }\n            else if (str.substring(0,5) == "upper" | str.substring(0,5) == "lower" )            \n            {\n                var typ = str.substring(0,5);\n                if (str.length == 5)\n                    master.roiTool.pushROI(_that.currentFileID, "mask_"+ _that.currentFilename, typ + _that.histoManager.clim[0], arrived);\n                else\n                {\n                    var id = str.substring(6)\n                    $(document.body).addClass("wait");\n                    setTimeout( function() {\n                      master.roiTool.pushROI(id, "mask_"+ _that.currentFilename,undefined, function(fobj) {\n\n                        var thres = _that.histoManager.clim[0];\n                        var eqfun;\n                        if (typ == "lower")\n                            eqfun = function(x) { return x < thres; }\n                        else\n                            eqfun = function(x) { return x > thres; }\n\n\n                        var nii = _that.nii;\n                        var roi = fobj.content;\n                        var offset = 0;\n                        if (nii.currentTimePoint)\n                            offset = nii.currentTimePoint.t * nii.sizes[0] * nii.sizes[1] * nii.sizes[2] ;\n                        var A = (math.multiply(math.inv(nii.edges), roi.edges))._data;\n                        for (var z = 0; z < roi.sizes[2]; z++)\n                            for (var y = 0; y < roi.sizes[1]; y++)\n                                for (var x = 0; x < roi.sizes[0]; x++)\n                                {\n                                    if (eqfun(trilinInterp(nii, x, y, z, A, offset)))\n                                        roi.data[roi.sizes[1] * roi.sizes[0] * z + roi.sizes[0] * y + x] = 1;\n                                }\n\n                        arrived(fobj)\n                       $(document.body).removeClass("wait");\n\n                      } );\n                    },0);\n\n                }\n\n            }\n            else if (str == "empty")\n                master.roiTool.pushROI(_that.currentFileID, "mask_untitled", undefined, arrived);\n            else if (str == "iso")\n                that.attachSurfaceRef(_that,_that.content);  \n            else if (str == \'rgbinterpret\')\n            {\n                _that.showcolored = !_that.showcolored;\n                signalhandler.send("updateImage",{id:_that.currentFileID});                \n            }\n            else if (str.substring(0,17) == \'type_rgbinterpret\')\n            {\n                _that.showcolored_type = str.substring(18);\n                signalhandler.send("updateImage",{id:_that.currentFileID});                \n            }\n            else if (str == "showisoview")\n            {\n                    if (_that.refSurfView && !_that.refSurfView.toolbarAttached)\n                    {\n                        ev.preventDefault();\n                        ev.stopImmediatePropagation();\n                        that.toolbar.append(_that.refSurfView.divs,\'surface\')\n                        _that.refSurfView.toolbarAttached = true;\n                    }\n            }\n            else  if (str == "tracking")\n            {\n                if (that.isGLenabled())\n                    createfibview()\n                else\n                    toggle3D(undefined,createfibview);\n                function createfibview()\n                {\n                    var filename = _that.currentFilename.replace(".nii","").replace(".gz","") + ".tck";\n                    var imageStruct = {filename:filename,content:{tracts:[  ]} }     ;     \n                    var fv = master.obj3dTool.createFiberView(imageStruct,that,{ dirvolref: _that,isParentView:true });\n                    that.objects3D.push(fv);\n                }\n            }\n            else if (str == "outline")\n            {\n                var contvis = _that.outlines == undefined;\n\n\n                if (!ev.shiftKey)\n                {\n                    var ev_ = ev;\n                    master.iterateMedViewers(function(m)\n                    {\n                        for (var k = 0; k < m.overlays.length; k++)\n                            if (_that.currentFileID == m.overlays[k].currentFileID)\n                            {\n                                m.overlays[k].setOutlines(contvis,ev_)          \n                                ev_ = undefined\n                                break;\n                            }\n\n                    });            \n                }\n                else\n                    _that.setOutlines(contvis,ev)\n\n\n\n            }\n            else if (str == "refetch")\n            {\n                KViewer.dataManager.refetchFile(_that.currentFileinfo, that.viewport.progressSpinner)\n            }\n            else if (str == "contcol")\n            {\n        \n                _that.chooseContColor(ev);\n\n            }\n\n      \n        });\n\n\n       \n    }\n\n\n    that.quivers = [];\n\n    that.addQuiver = function(histoobj)\n    {\n        for (var k = 0; k < that.quivers.length;k++)\n            {\n                if (that.quivers[k] == histoobj)\n                    return;\n            }\n        that.quivers.push(histoobj);\n\n    }\n\n    that.removeQuiver = function(histoobj)\n    {\n        for (var k = 0; k < that.quivers.length;k++)\n            {\n                if (that.quivers[k] == histoobj)\n                {\n                    that.quivers.splice(k,1);\n                    return;\n                }\n            }\n    }\n\n\n\n\n\n\n\n\n\n\n    that.addAsROIMenu = ROIadder(that);\n\n\n    /* this was used as a roi adder per viewport\n    var toolbarRoi = {};\n    toolbarRoi.$container =   $("<div class=\'KViewPort_roiAdder\' style=\'position:relative;right:0px;\'>add Roi</div>").appendTo(that.toolbar.$container).click(function(ev){return false;})\n                                .hide();\n    toolbarRoi.$addroi = $("<div class=\'KViewPort_tool\'>  <i class=\'fa fa-plus fa-1x\'> </div>").appendTo(toolbarRoi.$container )\n            .appendTooltip("create new roi from this viewport image").click( function(){master.roiTool.createEmptyRoi(that, \'untitled\');} );\n    */\n\n\n    // old: allow creation of roi here                          \n    toolbar.$addroi = $("<div  class=\'KViewPort_tool\'>  <i class=\'fa fa-cog fa-1x\'> </div>").click(that.addAsROIMenu);\n    //toolbar.$addroi = $("<div  class=\'KViewPort_tool\'>  <i class=\'fa fa-pencil fa-1x\'> </div>")\n    //.appendTooltip("roitool_open").click(function() {\n    //    master.roiTool.show()\n    //});\n\n    toolbar.$mainViewportSelector = $("<div myid=\'KViewPort_tool_toggleMainViewport\' class=\'KViewPort_tool\'><i class=\'fa fa-maxcdn fa-1x\'></i></div>")\n    .appendTooltip("masterviewport").click(function() {\n        master.toggleMainViewport(viewport.viewPortID);\n    });\n\n\n\n    toolbar.$movie = $("<div class=\'KViewPort_movie_tool\'><i class=\'fa fa-play fa-1x\'></i></div>").click(function() {\n        toggleMovie(this);\n    });\n    toolbar.$movie.hide();\n\n    toolbar.attach(toolbar.$addroi).attach(toolbar.$mainViewportSelector).attach(toolbar.$movie);\n\n\n\n\n\n\n    /************************* movie stuff  *********************/\n\n    that.movieSpeedFPS = 5;\n    function changemoviespeed()\n    {\n        toggleMovie();\n        \n        if(that.movieGlobalMode)\n        {\n            master.iterateMedViewers(function(m)\n            {\n                if (m.nii !=undefined && m.$timediv.maxt > 1 & m.movieGlobalMode)\n                {\n                    m.$timeinput_fps.val( $timeinput_fps.val() );\n                    m.movieSpeedFPS = $timeinput_fps.val();\n                }\n\t\t\t\n    \t\t});\n        }\n        else\n        {\n            that.movieSpeedFPS = $timeinput_fps.val();\n        }\n\n        toggleMovie();\n    }\n\n\n    var $timeinput_fps = $("<input class=\'KViewPort_tool\' style=\'\' type=\'\' min=1 max=100000 value=" + that.movieSpeedFPS + " />")\n    .appendTooltip("Movie Speed (frames per second")\n    .on(\'change input\', changemoviespeed);\n    that.$timeinput_fps = $timeinput_fps;\n    /*\n     movie can be played \n        - globally: link all viewports (default), given by master.currentTimePointGlobal, master.movieIsPlayedGlobal\n        - individually\n    */\n    var $setMovieGlobalMode = $("<div class=\'KViewPort_movie_tool\'><i class=\'fa fa-link fa-1x\'></i></div>").click( setMovieGlobalMode );\n    \n    that.movieGlobalMode = 1;\n    function setMovieGlobalMode(state)\n    {\n        // do not allow to change mode during  play, otherwise will be a mess\n        if(movieIsPlayed | master.movie.isPlayed)\n            return false\n\n        that.movieGlobalMode = !that.movieGlobalMode;\n        if(!that.movieGlobalMode)\n        {\n            $setMovieGlobalMode.css(\'background\', \'red\');\n        }\n        else\n        {\n            $setMovieGlobalMode.css(\'background\', \'\');\n        }\n    }    \n\n    var $timeinput = $("<input class=\'KViewPort_tool KViewPort_tool_movie_slider\' type=\'range\' min=0 max=100 value=0>");\n    var $timeCurrent = $("<span class=\'KViewPort_movie_tool\' style=\'width:20px; background: none;color:white;\'>0</span>");\n    var $timediv = $("<div class=\'KViewPort_toolbar KTimeRangeSlider\'> </div>").appendTo($container)\n    .append($timeCurrent).append($timeinput).append(toolbar.$movie).append($timeinput_fps).append($setMovieGlobalMode)\n    .hide();\n    that.$timediv = $timediv;\n    that.$timediv.$timeinput = $timeinput;\n    \n    // this is called when new image is loaded\n    $timediv.update = function()\n    {\n\n        var maxt = 1;\n        if (that.nii != undefined && that.nii.numTimePoints > 1)\n            maxt = that.nii.numTimePoints;\n\n        for (var k = 0; k < that.overlays.length; k++)\n            if (that.overlays[k].nii.numTimePoints > maxt)\n                 maxt = that.overlays[k].nii.numTimePoints;\n\n        for (var k = 0; k < that.ROIs.length; k++)\n            if (that.ROIs[k].nii.numTimePoints > maxt)\n                 maxt = that.ROIs[k].nii.numTimePoints;\n\n        if (maxt > 1)\n        {\n            $timediv.maxt = maxt;\n            that.toolbar.$movie.show();\n            $timediv.show();\n            $timeinput.attr("max", maxt-1 );\n            that.setMovieState(movieIsPlayed | master.movie.isPlayed);\n                        \n        }\n        else\n        {\n            $timediv.maxt = 1;\n            that.toolbar.$movie.hide();\n            $timediv.hide();\n        }\n    }\n\n    KMouseSlider($timeinput_fps, {min:1, incrementPerPixel:0.1});\n\n\n    $timeinput.on(\'change input\', function(){setCurrentTimePoint( $(this).val() ); } );\n    //$timeCurrent.on(\'mousewheel\', timeinputwheel)\n    //$timediv.on(\'mousewheel\', timeinputwheel)\n\n    if (/Firefox/i.test(navigator.userAgent))\n        $timediv.get(0).addEventListener("DOMMouseScroll", timeinputwheel, false);\n    else\n        $timediv.get(0).addEventListener("mousewheel", timeinputwheel, false);\n\n\n\n    function timeinputwheel(e)\n    {\n        if(e.wheelDelta || -e.detail) \n            var amount = (e.wheelDelta || -e.detail) > 0 ?1:-1;\n        else\n            var amount = (e.originalEvent.wheelDelta || -e.originalEvent.detail) > 0 ?1:-1;\n\n        var newval =  parseInt($timeinput.val()) + amount;\n        if(newval >= 0)\n        {\n            setCurrentTimePoint(newval)\n        }\n        e.preventDefault();\n        e.stopPropagation();\n        return false;\n    }\n\n    \n    // set the current time global/local from gui or from an iteration loop\n    function setCurrentTimePoint(val)\n    {\n        if(that.movieGlobalMode)\n        {   \n            master.movie.currentTimePoint = val;\n            master.iterateMedViewers(function(m)\n            {\n                if (m.nii !=undefined & m.movieGlobalMode)\n                {\n                    m.updateCurrentTimePoint(val);\n                }\n\t\t\t\n    \t\t});\n\n        }\n        else\n        {\n            that.updateCurrentTimePoint(val);\n        }\n    }\n\n    that.updateCurrentTimePoint = function(val)\n    {\n        if ($timediv.maxt <= 1)\n            return;\n        \n        if( val > $timediv.maxt-1)\n            val = $timediv.maxt-1;    \n        if(val < 0)\n            val = 0;    \n            \n        val = parseInt(val);\n\n        if (that.nii.numTimePoints > 1 && val < that.nii.numTimePoints )\n            that.nii.currentTimePoint.t = val;\n\n        $timeinput.val(  val );\n        $timeCurrent.text( val );\n\n        for (var k = 0; k < that.overlays.length; k++)\n        {\n            var xnii = that.overlays[k].nii;\n            if (xnii.numTimePoints > 1 && xnii.numTimePoints >= val)\n            {\n                xnii.currentTimePoint.t = val;\n                that.overlays[k].$timeinput.val(val);\n                signalhandler.send("overlay_climChange", { \n                    id:  that.overlays[k].currentFileID,\n                    val: that.overlays[k].histoManager.clim        \n                });\n\n            }\n        }\n        for (var k = 0; k < that.ROIs.length; k++)\n        {\n            var xnii = that.ROIs[k].nii;\n            if (xnii.numTimePoints > 1 && xnii.numTimePoints >= val)\n            {\n                xnii.currentTimePoint.t = val;\n                that.ROIs[k].$timeinput.val(val);\n                signalhandler.send("updateImage", { \n                    id:  that.ROIs[k].roi.fileID,\n                });\n            }\n        }\n\n\n        // seems to be simpelst way to initiate all updates\n        signalhandler.send("climChange", { \n            id: that.currentFileID,\n            val: that.histoManager.clim,            \n        });\n     \n        if(KViewer.curveTool.enabled)\n            KViewer.curveTool.updateCurrentTimePoint(val);\n    }\n    \n    \n\n    function toggleMovie( )\n    {\n        // global play\n        if(that.movieGlobalMode)\n        {\n            master.movie.maxNumTimePoints = 1;\n            master.iterateMedViewers(function(m)\n            {\n                if (m.nii !=undefined && m.$timediv.maxt > 1  && m.movieGlobalMode)\n                {\n                    m.setMovieState( !master.movie.isPlayed );\n                    if(m.$timediv.maxt > master.movie.maxNumTimePoints)\n                        master.movie.maxNumTimePoints = m.$timediv.maxt;\n                }\n\n            });\n\n            if(master.movie.isPlayed)\n            {\n                clearInterval( master.movie.timerId);\n                master.timerId = false;\n        \t}\n        \telse\n        \t{\n                master.movie.timerId = setInterval(function()\n                {\n\n                    if (typeof executeImageWorker != "undefined" && executeImageWorker.createIsoSurf_running)\n                        return;\n                    master.movie.currentTimePoint =  (  master.movie.currentTimePoint + 1 ) %  master.movie.maxNumTimePoints; \n                    master.iterateMedViewers(function(m)\n                    {\n                        if (m.nii !=undefined &&  m.$timediv.maxt > 1  && m.movieGlobalMode)\n                        {\n                            m.updateCurrentTimePoint(master.movie.currentTimePoint);\n                        }\n\n                    });\n\n\n                }, 1000 * 1 / that.movieSpeedFPS);\n        \t}\n            \n            master.movie.isPlayed = !master.movie.isPlayed;\n\n\n        }\n        else // local play\n        {\n            if(movieIsPlayed)\n            {\n                clearInterval( timerId);\n                timerId = false;\n                that.setMovieState(false);\n            }\n            else\n            {\n                timerId = setInterval(function()\n                {\n                    that.updateCurrentTimePoint( (parseInt($timediv.$timeinput.val()) + 1) %  $timediv.maxt );\n\n                }, 1000 * 1 / that.movieSpeedFPS);\n\n                that.setMovieState(true);\n            }\n        }\n    }\n\n    // set movie playing state in gui\n    that.setMovieState = function(state )\n    {\n        movieIsPlayed = state;\n\n        if (movieIsPlayed)\n            toolbar.$movie.find(\'i\').removeClass(\'fa-play\').addClass(\'fa-stop\');\n        else\n            toolbar.$movie.find(\'i\').addClass(\'fa-play\').removeClass(\'fa-stop\');\n    }\n/*\n    signalhandler.attach("positionChange", function()\n    {\n        if (that.$timediv.nii)\n        {\n            $timeinput.val(that.$timediv.nii.currentTimePoint.t);\n            $timeCurrent.html(that.$timediv.nii.currentTimePoint.t);\n        }\n    })\n*/\n    var movieIsPlayed = false;\n    var timerId = 0;\n\n\n\n    /* get full filename */\n    that.getFullFilename = function()\n    {\n        if(that.currentFileinfo == undefined)\n            return;\n \t    if(that.currentFileinfo.SubFolder!=="")\n\t\t\treturn that.currentFileinfo.SubFolder + "/" +  that.currentFileinfo.Filename;\n        else\n            return that.currentFileinfo.Filename;\n\n    }\n\n    /************************* getCurrentReadDirections *********************/\n    that.getCurrentReadDirections = function()\n    {\n        var nii = that.nii;\n        if (slicingDimOfWorld == 0)\n        {\n            return [nii.arrayReadDirection[nii.invPermOrder[1]] , nii.arrayReadDirection[nii.invPermOrder[2]] ];\n        }\n        if (slicingDimOfWorld == 1)\n        {\n            return [nii.arrayReadDirection[nii.invPermOrder[0]] , nii.arrayReadDirection[nii.invPermOrder[2]] ];\n        }\n        if (slicingDimOfWorld == 2)\n        {\n            return [nii.arrayReadDirection[nii.invPermOrder[0]] , nii.arrayReadDirection[nii.invPermOrder[1]] ];\n        }\n    }\n\n\n    /************************* world position management *********************/\n\n    function getWorldPosition()\n    {\n        if (worldLockedToMaster & master.globalCoordinates)\n            return master.currentPoint;\n        else\n            return customPoint;\n\n    }\n    that.getWorldPosition = getWorldPosition;\n\n    function setWorldPosition(p)\n    {\n        if (worldLockedToMaster & master.globalCoordinates )\n            master.currentPoint = p;\n        else\n            customPoint = p;\n\n    }\n    that.setWorldPosition = setWorldPosition;\n\n\n\n\n    var worldLockedToMaster = true;\n    var customPoint = math.matrix([0,0,0,1])\n    function changeWorldLock(e)\n    {\n        var $target = toolbar.$lock;//$(e.target);\n        if (!$target.hasClass(\'fa\'))\n            $target = $target.find("i");\n        $target.toggleClass(\'fa-lock\');\n        $target.toggleClass(\'fa-unlock\');\n        \n        if (worldLockedToMaster)\n            customPoint = math.matrix(getWorldPosition());\n        worldLockedToMaster = !worldLockedToMaster;\n        drawSlice({\n            mosaicdraw: true\n        });\n\n    }\n\n\n\n    // attach misc stuff\n    var $infobar = $("<div draggable=true id=\'KViewPort_infobar\' class = \'KViewPort_infoDIV\'></div>").appendTo($topRow);\n    $infobar.attr("draggable", \'true\');\n    that.$infobar = $infobar;\n\n    that.$infobar.on("click",function(ev)\n    {\n       if (KViewer.zoomedViewport != -1)\n       {\n           if (!that.viewport.isZoomed())\n           {\n               KViewer.unZoomViewport();\n               that.viewport.zoomViewPort();\n           }\n           else\n                that.viewport.zoomViewPort();\n          \n       }\n        \n    });\n\n\n  that.$infobar.on("mousedown",function(ev)\n    {\n        if (ev.button == 2)\n            showInfoContextNifti(that,ev)                \n    });\n\n\n\n    var $LeftRightSign = $("<div class=\'KViewPort_description\'>R</div>").hide().appendTo($container);\n    that.$LeftRightSign = $LeftRightSign;\n\n    // attach the scrollAccel\n    var scrollSpeed = 1;\n\n    var $scrollAccelerator = $("<div class=\'KViewPort_scrollAccelerator\' ></div>").appendTo(that.layoutbar.$container)\n    that.layoutbar.$container.mouseenter(function(ev) {\n        ev.preventDefault();\n        scrollSpeed = 4;\n        //$scrollAccelerator.text(\'scroll speed +\' +scrollSpeed);\n    });\n    that.layoutbar.$container.mouseleave(function(ev) {\n        scrollSpeed = 1;\n        //$scrollAccelerator.text(\'\');\n    });\n    \n   \n\n    // attach the canvas\n    var $canvas = $("<canvas class=\'KViewPort_canvas\'></canvas>").appendTo($canvascontainer);\n    that.$canvas = $canvas;\n    var ctx = $canvas.get(0).getContext("2d");\n\n\n    var $canvas3D = $("<canvas class=\'KViewPort_canvas3D\'></canvas>").appendTo($container);\n    that.$canvas3D = $canvas3D;\n    $canvas3D.hide();\n    var gl;\n    var gl_enabled = false;\n    that.isGLenabled = function()\n    {\n        return gl_enabled;\n    }\n\n\n    // attach the haircross\n    var haircross = {\n        X: {\n            t: "X",\n            tilt: 0\n        },\n        nX: {\n            t: "X",\n            tilt: 0\n        },\n        Y: {\n            t: "Y",\n            tilt: 0\n        },\n        nY: {\n            t: "Y",\n            tilt: 0\n        },\n        C: {}\n    };\n    that.haircross = haircross;\n    //haircross.C.$circle = $("<div class=\'haircrossFocus\'></div>").appendTo($canvascontainer);\n    //haircross.C.$circle = $("<div class=\'haircrossFocus_new\'><i class=\'fa fa-3x fa-refresh\'></i><i class=\'fa fa-3x fa-arrows\'></i><div></div></div>").appendTo($canvascontainer);\n    haircross.C.$circle = $("<div class=\'haircrossFocus_new\'></div>").appendTo($canvascontainer);\n    haircross.C.$circle_center = $("<i class=\'fa fa-3x fa-refresh\'></i>").appendTo(haircross.C.$circle).append($("<i class=\'fa fa-3x fa-arrows\'></i>"));\n    haircross.C.$circle_rotIndicator = $("<div class=\'\'></div>").appendTo(haircross.C.$circle);\n\n    haircross.X.lineN = new KHaircross(); haircross.X.lineN.$main.appendTo($canvascontainer)\n    haircross.Y.lineN = new KHaircross(); haircross.Y.lineN.$main.appendTo($canvascontainer);\n\n    that.overlays = [];\n    that.objects3D = [];\n    that.ROIs = [];\n    that.ROIs_temp = [];\n    that.atlas = [];\n    that.currentROI = undefined;\n    that.getCurrentROIobj = function()\n    {\n        for (var k = 0; k < that.ROIs.length; k++)\n        {\n            if (that.ROIs[k].roi == that.currentROI)\n                return that.ROIs[k];\n        }\n        return undefined;\n    }\n\n    var sx = 10;\n    var sy = 10;\n    var xdir = -1;\n    var ydir = -1\n    var xflip, yflip;\n\n    that.zoomFac = 1;\n    that.zoomOriginX = 0;\n    that.zoomOriginY = 0;\n    that.widoffs_px = 0;\n    that.heioffs_px = 0;\n    that.embedrelfac = 1;\n\n\n    var swapXY = false;\n    // sizes for the canvases\n    var csx, csy, voxSize_x, voxSize_y, wid_cm, hei_cm, wid_px, hei_px;\n\n    //    var embedfac_height,embedfac_width;\n\n    var sliceData;\n    // =  ctx.createImageData(10, 10);\n\n    var currentSlice = 0;\n    that.getCurrentSliceInMM = function() {\n        return (currentVoxel._data[slicingDimOfArray] + .5) * that.nii.voxSize[slicingDimOfArray]\n    }\n    ;\n    var currentVoxel = math.matrix([0, 0, 0, 1]);\n    var currentValue = 0;\n    var tOffset = 0;\n    var slicingDimOfWorld = 2;\n    var slicingDimOfArray;\n    function getCurrentSlice() {\n        return currentSlice;\n    }\n    that.getCurrentSlice = getCurrentSlice;\n    function getSlicingDimOfArray() {\n        return slicingDimOfArray;\n    }\n    that.getSlicingDimOfArray = getSlicingDimOfArray;\n\n\n    //    var MouseWheelHandler = moveUnlagger(MouseWheelHandler_);\n    //    var MouseWheelHandler = MouseWheelHandler_;\n\n    var icontainer = $container[0];\n    if (icontainer.addEventListener) {\n        // Firefox\n        if (/Firefox/i.test(navigator.userAgent))\n            icontainer.addEventListener("DOMMouseScroll", moveUnlagger(MouseWheelHandler_), false);\n        else\n        // IE9+, Chrome, Safari, Opera\n            icontainer.addEventListener("mousewheel", MouseWheelHandler_, false);\n        //       var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" //FF doesn\'t recognize mousewheel as of FF3.x\n        //     icontainer.addEventListener(mousewheelevt,MouseWheelHandler,false);\n    }\n    else\n    {\n        // IE 6/7/8\n        icontainer.attachEvent("onmousewheel", MouseWheelHandler);\n    }\n\n\n    that.$container = $container;\n\n    that.setSlicingDimOfWorld = setSlicingDimOfWorld;\n    that.getSlicingDimOfWorld = function() {\n        return slicingDimOfWorld;\n    }\n    ;\n    that.setCurrentVoxel = setCurrentVoxel;\n    that.setInnerLayout = setCanvasLayout;\n    that.setZoomLims = setZoomLims;\n    that.setZoomLimsRelative = setZoomLimsRelative;\n    that.drawHairCross = drawHairCross;\n    that.updateInfoBar = updateInfoBar;\n\n\n    that.setContent = setContent;\n    that.setColorMapLims = setColorMapLims;\n\n    that.showcolored = false;\n    that.showcolored_type = "RGB";\n\n\n    function toggle3D(ev, callback)\n    {\n        if (webgl_detect())\n        {\n            toolbar.$toggle3D.toggleClass(\'KViewPort_tool_enabled\');\n            toolbar.$slicingDim.show();\n            if (gl_enabled)\n            {\n                gl_enabled = false;\n                $canvas3D.hide();\n                layoutbar.hideLayout3D();\n\n\n                for (var k = 0; k < that.objects3D.length; k++)\n                {\n                    if (that.objects3D[k].fibers && that.objects3D[k].fiberUpdater)\n                        that.objects3D[k].fiberUpdater.clear();\n                }\n\n                setSlicingDimOfWorld(slicingDimOfWorld);\n                $scrollAccelerator.show();\n                drawSlice();\n\n                if (callback)\n                    callback();\n            }\n            else\n            {\n\n                that.mosaicview.active = false;\n\n                that.viewport.progressSpinner("loading webGL");\n                var onBabylon = function()\n                {\n                    gl_enabled = true;\n                    that.viewport.progressSpinner();\n                    layoutbar.showLayout3D();\n\n                    setCanvasLayout();\n\n                    if (KViewer.roiTool.isinstance)\n                        KViewer.roiTool.hidePen(that);\n                    //resliceOnMaster(); \n                    $scrollAccelerator.hide();\n                    drawSlice();\n                    if (callback)\n                        callback();\n                }\n                \n                if (typeof BABYLON == "undefined")\n                    initBabylon(onBabylon); \n                else\n                    onBabylon();\n\n            }\n        }\n        else\n        {\n            alertify.error("Your browser has no WebGL enabled!")\n        }\n    }\n    that.toggle3D = toggle3D;\n\n    function toggleSlicingDim(ev)\n    {\n        if (!gl_enabled)\n        {\n            setSlicingDimOfWorld(\'toggle\');\n            \n            //// if crosshair is out view,then center view\n            var coords = getCanvasCoordinates(getWorldPosition());\n            var absy = (that.heioffs_px * that.zoomFac - that.zoomOriginY +coords.y_pix);\n            var absx = (that.widoffs_px * that.zoomFac - that.zoomOriginX +coords.x_pix);\n            if (absy<0 | absy>$container.height())\n            {\n                 var dy = coords.y_pix+that.heioffs_px*that.zoomFac-$container.height()/2;\n                 setZoomLims([that.zoomFac, dy,undefined]);            \n            }\n            if (absx<0 | absx>$container.width())\n            {\n                 var dx = coords.x_pix+that.widoffs_px*that.zoomFac-$container.width()/2;\n                 setZoomLims([that.zoomFac, undefined,dx]);            \n            }\n\n            drawHairCross();\n        }\n        else\n        {\n            gl.planesVisContextMenu(ev);\n        }\n    }\n\n\n    that.showControls = function() {\n\n        // this should avoid the style bug of the viewport tools\n        // the bug: from somwehere some viewport tools get a display:block,\n        // with this we get rid of any style attributes\n        that.toolbar.reset_mainview ();        \n\n        that.toolbar.show();\n        that.layoutbar.show();\n        if (gl_enabled)\n            layoutbar.showLayout3D();\n        else\n            layoutbar.hideLayout3D();\n\n\n        $timediv.update();\n\n\n\n        that.toolbar.$addroi.show();\n\n        if (that.nii.singleSlice)\n        {\n            //that.toolbar.$mainViewportSelector.hide()\n            that.toolbar.$toggle3D.hide()\n            that.toolbar.$cmap.hide()\n            that.toolbar.$cmapReset.hide()\n            that.toolbar.$slicingDim.hide();\n        }\n        else\n        {\n        //    that.toolbar.$mainViewportSelector.hide()\n            that.toolbar.$toggle3D.show()\n            that.toolbar.$slicingDim.show();\n\n            that.toolbar.$cmap.show()\n            that.toolbar.$cmapReset.show()\n            \n\n        }\n        if (!interpretAsColoredVolume(that.nii,that))\n            that.toolbar.$quiver.hide();\n        else\n            that.toolbar.$quiver.show();\n\n        if (that.nii.dummy)\n        {\n            that.toolbar.$cmap.hide();\n            that.toolbar.$addroi.hide();\n            that.toolbar.$view.hide();\n        }\n        else\n        {            \n            that.toolbar.$view.show();\n        }\n\n\n        that.toolbar.$info.hide();\n      //  that.toolbar.$slicingDim.hide();\n        that.toolbar.$toggle3D.hide();\n        that.toolbar.$lock.hide();\n        that.toolbar.$cmapReset.hide();\n\n \n    }\n\n    that.hideControls = function(whichcontrols) \n    {\n        \n        if(whichcontrols == true || whichcontrols == undefined)\n        {\n            that.toolbar.hide();\n            that.layoutbar.hide();\n            $timediv.hide();\n        }\n        else\n        {\n            if(whichcontrols.toolbar)\n                 that.toolbar.hide();\n            if(whichcontrols.layoutbar)\n                 that.toolbar.hide();\n            if(whichcontrols.timediv)\n                 $timediv.hide();\n        }\n        // why? we do not want to see that\n        //layoutbar.showLayout3D();\n        \n    }\n\n\n    function changeColorMap()\n    {\n        histoManager.cmapindex = (histoManager.cmapindex + 1) % colormap.maps.length;\n        drawSlice({\n            noquiver: true\n        });\n        drawHairCross();\n    }\n\n    function close()\n    {\n        toolbar.hide();\n\n        $timediv.hide();\n//        layoutbar.hideLayout3D();\n        $infobar.hide();\n        hideHairCross();\n        $canvas.hide();\n        $canvas3D.hide();\n        if (that.gl != undefined)\n        {\n            that.gl.disposePlanes();\n            var tmpobjects3d = that.objects3D.slice(0);\n            for (var k = 0; k < tmpobjects3d.length; k++)\n                tmpobjects3d[k].close();\n            if (gl_enabled)\n            {\n                toolbar.$toggle3D.toggleClass(\'KViewPort_tool_enabled\');\n                gl_enabled = false;\n                that.gl.dispose();\n                that.gl = undefined;\n                gl = undefined;\n            }\n        }\n\n        if (that.refSurfView)\n            that.refSurfView = undefined;\n\n        if (that.currentFileinfo && that.currentFileinfo.surfreference)\n            that.currentFileinfo.surfreference = undefined;\n\n        that.currentFileID = undefined;\n        that.currentFilename = undefined;\n        that.currentFileinfo = undefined;\n        that.content = undefined;\n\n        clearInterval(timerId);\n        movieIsPlayed = false;\n        that.nii = undefined;\n        histoManager.hide();\n        histoManager.nii = undefined;\n        lastSlice = undefined;\n\n        //slicingDimOfWorld = 2;\n        histoManager.cmapindex = 0;\n\n        quiver.clear();\n        that.removeQuiver(histoManager);\n        that.toolbar.$quiver.hide();\n\n        that.toolbar.update();\n\n        if (that.outlines != undefined)\n        {\n            that.outlines.close();\n            that.outlines = undefined;\n        }\n\n        $timeinput.val(  KViewer.movie.currentTimePoint );\n        $timeCurrent.text(  KViewer.movie.currentTimePoint );\n\n\n        var tmp = that.overlays.slice(0);\n        for (var k = 0; k < tmp.length; k++)\n            tmp[k].close();\n         \n        that.overlays.splice(0);\n\n        var tmp = that.ROIs.slice(0);\n        for (var k = 0; k < tmp.length; k++)\n            tmp[k].close();\n\n        that.ROIs.splice(0);\n\n        viewport.close();\n\n    }\n    that.close = close;\n\n\n    toolbar.$screenshot.mousedown(KContextMenu(\n    function() {\n\n        var $menu = $("<ul class=\'menu_context\'>")\n        .append($("<li onchoice=\'normal\' > 2D still png</li>"))\n        .append($("<li onchoice=\'renderRGB\' > render volume (RGB) as nifti</li>"))\n        .append($("<li onchoice=\'render\' > render volume as nifti </li>"));\n        \n        if (that.isGLenabled())\n        {\n            $menu.append($("<li> 3D views <i class=\'fa fa-caret-right\'></i> <ul> <li onchoice=\'3dview_all\'> all </li> " +\n                                              "<li onchoice=\'3dview_sag\'> saggital </li> " +\n                                              "<li onchoice=\'3dview_ax\'> axial/coronal </li> " +\n                                              " </ul> "));        }\n                                              \n\n        return $menu;\n\n    },\n    function(str, ev)\n    {\n\n        function saveRenderedVolume(name, rgb)\n        {\n            var fobj;\n            var nC;\n            if (rgb)\n                nC = 3;\n            else\n                nC = 1;\n            if (KViewer.mainViewport == -1)\n                fobj = cloneNifti(that.content, name, \'uint8\', nC);\n            else\n            {\n                var content;\n                if (KViewer.mainViewport == "world")\n                    content = {content:KViewer.viewports[KViewer.mainViewport].medViewer.nii};\n                else\n                    content = KViewer.viewports[KViewer.mainViewport].getCurrentViewer().content;\n                fobj = cloneNifti(content, name, \'uint8\', nC);\n                if (fobj.fileinfo.patients_id == undefined && patientTableMirror)\n                {\n                     fobj.fileinfo = $.extend(fobj.fileinfo,patientTableMirror.getCurrentUniquePSID());\n                }\n            }\n\n            var nii = fobj.content;\n            var tmp_slW = slicingDimOfWorld;\n\n            applySlicingDimOfWorld(that.nii.permutationOrder[2]);\n\n            sliceData = ctx.createImageData(csx, csy);\n\n            var drawSliceFun;\n            if (KViewer.mainViewport != -1)\n                drawSliceFun = drawSlice_interpolate;\n            else\n                drawSliceFun = drawSlice_normal;\n\n            var totsz = nii.sizes[0] * nii.sizes[1] * nii.sizes[2];\n            for (var k = 0; k < nii.sizes[2]; k++)\n            {\n                setTimeout(function(k) {\n                    return function() {\n                        sliceData.data.fill(0);\n                        drawSliceFun(k, undefined, true);\n                        var idx;\n                        for (var c = 0; c < nC; c++)\n                            for (var x = 0; x < nii.sizes[0]; x++)\n                                for (var y = 0; y < nii.sizes[1]; y++)\n                                {\n                                    if (swapXY)\n                                        idx = ((nii.sizes[0] * xflip + xdir * (x) - xflip) * sy + yflip * nii.sizes[1] + ydir * (y) - yflip) * 4;\n                                    else\n                                        idx = ((nii.sizes[1] * yflip + ydir * y - yflip) * sx + xflip * nii.sizes[0] + xdir * (x) - xflip) * 4;\n                                    nii.data[c * totsz + k * nii.sizes[0] * nii.sizes[1] + y * nii.sizes[0] + x] = sliceData.data[idx + c];\n                                }\n\n                        that.viewport.progressSpinner("rendering volume " + Math.round(100 * k / nii.sizes[2]) + "%");\n                        if (k == nii.sizes[2] - 1)\n                        {\n\n                            applySlicingDimOfWorld(tmp_slW);\n                            sliceData = undefined;\n\n                            fobj.modified = true;\n                            fobj.content = prepareMedicalImageData(parse(fobj.buffer), fobj, {});\n                            fobj.fileID = \'REN\' + (ovlcnt++);\n                            fobj.fileinfo.permission = "rwp";\n                            KViewer.dataManager.setFile(fobj.fileID, fobj);\n\n                            uploadUnregisteredBinary(fobj, {}, that.viewport.progressSpinner, function() {});\n\n                        }\n\n                    }\n                }(k), 1);\n            }\n\n\n\n        }\n\n        if (str == \'normal\')\n            toolbar.$screenshot.trigger("click");\n        else if (str != undefined && str.substring(0,6) == "3dview")\n        {\n\n            var $C = that.$container.find(".KViewPort_canvas:visible, .KViewPort_canvas3D:visible");\n  \n            var horizontal = true;\n\n            KViewer.toggleElementsForScreenShot();\n        \n            var views;\n            if (str.substring(7) == \'all\')\n            {\n                var views = [[0, Math.PI/2-0.3 ,0.9,0],        // frontal\n                             [Math.PI, Math.PI/2-0.3, 1,0],            // occipital\n                             [Math.PI/2, Math.PI/2 ,0.9,1],\n                             [-Math.PI/2, Math.PI/2 ,0.9,1],\n                             [Math.PI,0 ,0.9,0],                     // top\n                             [0,Math.PI ,1,0],                     // bottom\n                  //           [-Math.PI/2, Math.PI/2 ,1,0],         \n                  //           [Math.PI/2, Math.PI/2 ,0.9,-1],\n                  //           [Math.PI/2, Math.PI/2 ,1,0],\n                             ];\n            }\n            else if (str.substring(7) == \'ax\')\n            {\n                var views = [[0, Math.PI/2-0.3 ,0.9,0],        // frontal\n                  //           [Math.PI, Math.PI/2 ,1,0],            // occipital\n                             [Math.PI,0 ,1,0],                     // top\n                             [0,Math.PI ,1 ,0],                     // bottom\n                             ];\n            }\n            else if (str.substring(7) == \'sag\')\n            {\n                var views = [\n                             [Math.PI/2, Math.PI/2, 0.9,-1],\n                             [Math.PI/2, Math.PI/2,1 ,0],\n                             \n                             [-Math.PI/2, Math.PI/2,1 ,0],         \n                             [-Math.PI/2, Math.PI/2,0.9 ,1],\n                             ];\n            }\n            var shots = []\n            var cnt = 0;\n            var rad_def = that.gl.camera.radius;\n            getShot();\n            function getShot()\n            {\n                if (cnt>= views.length)\n                {\n\n                    var w = $C.get(0).width;\n                    var h = $C.get(0).height;\n                    var canvas,image;\n                    if (horizontal)\n                    {\n                        canvas = $("<canvas width="+w*views.length+" height="+h+"></canvas>").get(0);\n                        image = new Image(w*views.length,h);\n                    }\n                    else\n                    {\n                        canvas = $("<canvas width="+w+" height="+h*views.length+"></canvas>").get(0);\n                        image = new Image(w,h*views.length);\n                    }\n                    var context = canvas.getContext(\'2d\');\n                    var image = new Image(w*views.length,h);\n                    for (var k = 0; k < shots.length; k++)\n                    {\n                        image.src = shots[k];\n                        if (horizontal)\n                            context.drawImage(image,w*k,0);\n                        else\n                            context.drawImage(image,0,h*k);\n\n                    }\n\n                    var blob = dataURItoBlob(canvas.toDataURL())\n                    var finfo = that.viewport.getCurrentViewer().currentFileinfo; \n                    that.gl.camera.radius = rad_def;\n\n                       saveScreenShot(blob,finfo);\n                     KViewer.toggleElementsForScreenShot();\n                     $(".KViewPort_container").removeClass(\'noBorder\');\n                    return;\n                }\n                if (that.objects3D.length > 0 && that.objects3D[0].cuts)\n                {\n                    for (var j = 0; j < that.objects3D.length; j++ )\n                    {\n                        if (that.objects3D[j].cuts != undefined)\n                        {\n                            that.objects3D[j].cuts[that.nii.permutationOrder[0]] = views[cnt][3];\n                            that.objects3D[j].update();\n                        }\n                    }\n                }\n                that.gl.camera.alpha= views[cnt][0];\n                that.gl.camera.beta= views[cnt][1];\n                that.gl.camera.radius = rad_def*views[cnt][2];\n                that.gl.activateRenderLoop();\n                cnt++;\n                setTimeout(function(){\n                    that.gl.screenShot(function(s)\n                    {\n                        shots.push(s);\n                        getShot();    \n                    }); },10);\n                //html2canvas($C).then(function(canvas)  {  \n                //shots.push( $C.get(0).toDataURL());  getShot();   });  \n            }\n\n\n\n\n\n\n\n\n        }\n        else if (str == "render" | str == "renderRGB")\n        {\n\n            alertify.prompt("Please enter a name", function(e, name) {\n                if (e)\n                {\n                    $(document.body).addClass("wait");\n                    setTimeout(function() {\n                        saveRenderedVolume(name, str == "renderRGB")\n                    }, 100);\n                    $(document.body).removeClass("wait");\n                }\n            });\n\n\n\n\n        }\n\n    }, false));\n\n\n\n\n\n\n\n\n    /////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////// crosshair/vew stuff///////////////////////////\n    /////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\n    function center()\n    {\n        if (!gl_enabled && that.nii != undefined)\n        {\n            var coords = getCanvasCoordinates(getWorldPosition());\n            var dy = coords.y_pix+that.heioffs_px*that.zoomFac-$container.height()/2;\n            var dx = coords.x_pix+that.widoffs_px*that.zoomFac-$container.width()/2;\n            setZoomLims([that.zoomFac, dy, dx]);\n            \n            setCanvasLayout();\n            drawHairCross();\n        }\n\n    }\n    signalhandler.attach("centralize",center);\n\n\n    function getReorientationMatrixFromTiltAngles(sg, old_reorient, old_point)\n    {\n        if (old_point == undefined)\n            old_point = getWorldPosition()._data;\n        if (old_reorient == undefined)\n            old_reorient = that.reorientationMatrix.matrix;\n\n        var xy = sg * Math.sin(-KViewer.currentTilts_(2, 0).v / 180 * Math.PI);\n        var xz = sg * Math.sin(-KViewer.currentTilts_(1, 0).v / 180 * Math.PI);\n        // 1er + 0er flipped !!!!\n        var xx = Math.sqrt(1 - xy * xy - xz * xz);\n\n        var yx = sg * Math.sin(KViewer.currentTilts_(2, 1).v / 180 * Math.PI);\n        var yz = sg * Math.sin(-KViewer.currentTilts_(0, 0).v / 180 * Math.PI);\n        var yy = Math.sqrt(1 - yx * yx - yz * yz);\n\n        var zy = sg * Math.sin(KViewer.currentTilts_(0, 1).v / 180 * Math.PI);\n        var zx = sg * Math.sin(KViewer.currentTilts_(1, 1).v / 180 * Math.PI);\n        var zz = Math.sqrt(1 - zy * zy - zx * zx);\n\n        R = math.transpose(math.matrix([[xx, xy, xz, 0], [yx, yy, yz, 0], [zx, zy, zz, 0], [0, 0, 0, 1]]));\n\n        var t = old_point;\n        var Q = math.matrix([[1, 0, 0, t[0]], [0, 1, 0, t[1]], [0, 0, 1, t[2]], [0, 0, 0, 1]]);\n\n        var s = math.multiply(math.inv(old_reorient), t);\n        var T = math.matrix([[1, 0, 0, s._data[0]], [0, 1, 0, s._data[1]], [0, 0, 1, s._data[2]], [0, 0, 0, 1]]);\n\n        var w = math.multiply((R), t);\n        var Z = math.matrix([[1, 0, 0, w._data[0]], [0, 1, 0, w._data[1]], [0, 0, 1, w._data[2]], [0, 0, 0, 1]]);\n\n        return {\n            Q: Q,\n            T: T,\n            R: R,\n            Z: Z,\n            t: t,\n            s: s\n        };\n\n\n    }\n\n    that.getMinVoxSize = function() {\n        return math.min(that.nii.voxSize)\n    }\n\n\n\n    function computeMaxExtentFac()\n    {\n        var nii = that.nii;\n        if (nii == undefined)\n        {\n            return KViewer.defaultFOV_mm;\n        }\n        var ext = [nii.sizes[0] * nii.voxSize[0], nii.sizes[1] * nii.voxSize[1], nii.sizes[2] * nii.voxSize[2]];\n        var max_extent_perc = Math.max.apply(null , ext);\n        return max_extent_perc;\n    }\n    that.computeMaxExtentFac = computeMaxExtentFac;\n\n\n\n\n\n    function getReorientMat(matrix_on_start, point_on_start)\n    {\n        if (matrix_on_start == undefined)\n            matrix_on_start = math.diag([1,1,1,1]);\n        if (point_on_start == undefined)\n            point_on_start = [0,0,0,1];\n\n\n        if (master.viewports[master.mainViewport].medViewer == undefined || master.viewports[master.mainViewport].medViewer.nii == undefined)\n            return math.diag([1,1,1,1]);\n\n        var mnii = master.viewports[master.mainViewport].medViewer.nii\n        var edges = mnii.edges;\n\n        var sg = -1;\n\n\n        var t = 1;\n        if (KViewer.currentTilts_(2, 0).v > 90 | KViewer.currentTilts_(2, 0).v < -90 | \n            KViewer.currentTilts_(1, 0).v > 90 | KViewer.currentTilts_(1, 0).v < -90 |\n            KViewer.currentTilts_(2, 1).v > 90 | KViewer.currentTilts_(2, 1).v < -90 |\n            KViewer.currentTilts_(0, 0).v > 90 | KViewer.currentTilts_(0, 0).v < -90 |\n            KViewer.currentTilts_(0, 1).v > 90 | KViewer.currentTilts_(0, 1).v < -90 |\n            KViewer.currentTilts_(1, 1).v > 90 | KViewer.currentTilts_(1, 1).v < -90)\n           t=-1;\n\n\n        var xy = sg * Math.sin(-KViewer.currentTilts_(2, 0).v / 180 * Math.PI);\n        var xz = sg * Math.sin(-KViewer.currentTilts_(1, 0).v / 180 * Math.PI);\n        // 1er + 0er flipped !!!!\n        var xx = t*Math.sqrt(1 - xy * xy - xz * xz);\n\n        var yx = sg * Math.sin(KViewer.currentTilts_(2, 1).v / 180 * Math.PI);\n        var yz = sg * Math.sin(-KViewer.currentTilts_(0, 0).v / 180 * Math.PI);\n        var yy = t*Math.sqrt(1 - yx * yx - yz * yz);\n\n        var zy = sg * Math.sin(KViewer.currentTilts_(0, 1).v / 180 * Math.PI);\n        var zx = sg * Math.sin(KViewer.currentTilts_(1, 1).v / 180 * Math.PI);\n        var zz = t*Math.sqrt(1 - zy * zy - zx * zx);\n    \n\n        var R = math.transpose(math.matrix([[xx, xy, xz, 0], [yx, yy, yz, 0], [zx, zy, zz, 0], [0, 0, 0, 1]]));\n\n        edges = math.multiply(edges, permMat(mnii));\n\n        var T = transMat(math.multiply(math.inv(edges), math.multiply(math.inv(matrix_on_start), point_on_start)));\n\n        var E = math.multiply(edges, T);\n\n        return math.multiply(matrix_on_start, math.inv(math.multiply(E, math.multiply(R, math.inv(E)))));\n\n\n    }\n\n    that.getReorientMat = getReorientMat;\n\n    //////// slice tilting and shifting handler\n    haircrossmousehandler = function(Z, type) {\n        return function(ev)\n        {\n            if(ev.button != 0)\n                return ;\n            \n            // always show on move\n            if( $(this).css !== undefined)\n            {\n                var $ccontrol = $(this);\n                $ccontrol.addClass(\'visibility_isvisible\');\n            }\n             \n\n            if ( ( (ev.ctrlKey || type == \'rotator\') & master.mainViewport === -1) & !ev.shiftKey)\n            {\n                master.toggleMainViewport(that.viewport.viewPortID);\n                //$.notify("Tilting of image only possible if you choose one viewport as master (m)", "error")\n            }\n\n            if ( (ev.ctrlKey || type == \'rotator\') & master.mainViewport !== -1) // only in coupled mode tilted views are possible\n            {\n\n                var matrix_on_start = math.multiply(1, KViewer.reorientationMatrix.matrix);\n                var point_on_start = math.multiply(1, getWorldPosition());\n\n                ev.preventDefault();\n                ev.stopPropagation();\n                haircross.start = {\n                    X: ev.clientX,\n                    Y: ev.clientY\n                };\n                var coords = getCanvasCoordinates(getWorldPosition());\n                var centerX = coords.x_pix + $canvas.offset().left;\n                var centerY = coords.y_pix + $canvas.offset().top;\n   \n                haircross.centerPoint = {\n                    X: centerX,\n                    Y: centerY\n                };\n                haircross.start = {\n                    X: ev.clientX,\n                    Y: ev.clientY,\n                    dx: ev.clientX - haircross.centerPoint.X,\n                    dy: -ev.clientY + haircross.centerPoint.Y,\n                    deg: -Math.atan2(-ev.clientY + haircross.centerPoint.Y, ev.clientX - haircross.centerPoint.X) / Math.PI * 180\n\n                };\n\n                haircross.starttilt = {\n                    X: haircross.X.tilt,\n                    Y: haircross.Y.tilt\n                };\n\n                var rad = 2*(Math.sqrt( haircross.start.dx*haircross.start.dx + haircross.start.dy*haircross.start.dy));\n                haircross.C.$circle_rotIndicator.show().width(rad ).height(rad);\n\n                /// mousemove event\n                $container.on("mousemove", moveUnlagger(function(ev) {\n\n                    var dy = -ev.clientY + haircross.centerPoint.Y;\n                    var dx = ev.clientX - haircross.centerPoint.X;\n                    var deg2 = -Math.atan2(dy, dx) / Math.PI * 180;\n                    \n                    if(1) // new method, more generic)\n                    {\n                        deg2 = deg2 - haircross.start.deg\n                    }\n                    else\n                    {\n                        // find out what was grepped: L / R , Top bottom of haircross. \n                        // must keep track of start tilt, this indicates whether to swap (abs(angle) > 90 deg)\n                        var dxneg = (haircross.start.dx < 0);\n                        var dyneg = (haircross.start.dy > 0);\n                        var isswapped = (math.abs(haircross.starttilt.Y) > 90);\n\n                        var isrightgrep = dxneg ? isswapped : !isswapped;\n                        var isbottompgrep = dyneg ? isswapped : !isswapped;\n\n                        if (Z.t == "Y" & !isrightgrep)\n                            // left grep\n                            deg2 = deg2 - 180;\n\n                        if (Z.t == "X")\n                        {\n                            deg2 = (deg2 - 90);\n                            if (!isbottompgrep)\n                                // grep at top\n                                deg2 = -(180 - deg2) + 360;\n                        }\n                    }\n\n                    // put to interval -180 ...  180\n                    if (deg2 > 180)\n                        deg2 = deg2 - 360;\n                    if (deg2 < -180)\n                        deg2 = (deg2 + 360);\n                    \n                //    console.log(deg2);\n\n\n                    haircross.X.tilt = deg2;\n                    haircross.Y.tilt = deg2;\n\n                    \n                    var saveTilt = {\n                        X: haircross.X.tilt,\n                        Y: haircross.Y.tilt\n                    };\n\n\n                    if (!updateHairCrossTilts(haircross.X.tilt, haircross.Y.tilt))\n                    {\n                        haircross.X.tilt = saveTilt.X;\n                        haircross.Y.tilt = saveTilt.Y;\n                    }\n\n                    if (KViewer.navigationMode == 0 | KViewer.navigationMode == 2 )\n                    {\n                        KViewer.reorientationMatrix.matrix = getReorientMat(matrix_on_start, point_on_start);\n                        KViewer.reorientationMatrix.notID = true;\n                    }\n\n\n                    signalhandler.send("positionChange",{},that.positionChanger);\n\n                }));\n                /// mouseup event\n                $container.on("mouseup mouseleave", function(ev) {\n                    $container.off("mousemove mouseup mouseleave");\n                    haircross.C.$circle_rotIndicator.hide();\n                    // hide when done\n                    if( $ccontrol !== undefined)\n                         $ccontrol.removeClass(\'visibility_isvisible\');\n\n                    // call mouseup with "resetHandlersOnly" to true. this wil reset default mousemove\n                    mouseManager.mouseup(ev, true);\n\n\n                    if (KViewer.navigationMode == 0 | KViewer.navigationMode == 2 )\n                    {\n\n                        KViewer.reorientationMatrix.matrix = getReorientMat(matrix_on_start, point_on_start);\n                        KViewer.currentTilts(0, 0).v = 0;\n                        KViewer.currentTilts(0, 1).v = 0;\n                        KViewer.currentTilts(1, 0).v = 0;\n                        KViewer.currentTilts(1, 1).v = 0;\n                        KViewer.currentTilts(2, 0).v = 0;\n                        KViewer.currentTilts(2, 1).v = 0;\n\n\n                        if (KViewer.mainViewport == \'world\') // to update boundix box in worldview\n                        {\n                            KViewer.navigationTool.worldMaster();\n                            KViewer.toggleMainViewport(\'world\');\n                        }\n\n\n                    }\n                    signalhandler.send("positionChange", {\n                        mosaicdraw: true\n                    },that.positionChanger);\n\n                });\n            }\n            else if (ev.shiftKey || type == \'mover\') /// shifting the slice on grabbing the hc-line\n            {\n                ev.preventDefault();\n                ev.stopPropagation();\n                var cpos = $canvas.offset();\n\n                var startx = ev.clientX;\n                var starty = ev.clientY;\n                // remember offset from haricross center to mouse center\n                var hcc = getCanvasCoordinates(getWorldPosition());\n                var mcc = getCanvasCoordinates(getRealWorldCoordinatesFromMouseEvent(startx, starty));\n                var offx = (mcc.x_pix - hcc.x_pix);\n                var offy = (mcc.y_pix - hcc.y_pix);\n\n                var cosa =  Math.cos( haircross.X.tilt / 180*Math.PI );\n                var sina =  Math.sin( haircross.X.tilt / 180*Math.PI );\n\n                $container.on("mousemove", moveUnlagger(function(ev) {\n\n                    if (Z.t == "X")\n                    {\n                        // vector from haircross center to mouse tip\n                        var dx =  ev.clientX -startx + offx;\n                        var dy =  ev.clientY -starty + offy;\n                        // project to rotated X - haircross \n                        var proj = cosa*dx  +  sina*dy ;\n                        // calc x and y component along rotated X\n                        var xnew = (startx - offx) + proj*cosa ;\n                        var ynew = (starty - offy) + proj*sina;\n                        xnew = Math.round(xnew);\n                        ynew = Math.round(ynew);\n                        \n                        setWorldPosition(getRealWorldCoordinatesFromMouseEvent(xnew, ynew));\n                        var csr = (haircross.X.tilt < 45 || haircross.X.tilt > 90 + 45)?"col-resize":"row-resize"\n                    }\n                    else\n                    {\n                        // vector from haircross center to mouse tip\n                        var dx =  ev.clientX -startx + offx;\n                        var dy =  ev.clientY -starty + offy;\n                        // project to rotated Y - haircross \n                        var proj = -sina*dx  +  cosa*dy ;\n                        // calc x and y component along rotated X\n                        var xnew = (startx - offx) - proj*sina ;\n                        var ynew = (starty - offy) + proj*cosa;\n                        xnew = Math.round(xnew);\n                        ynew = Math.round(ynew);\n                        \n                        setWorldPosition(getRealWorldCoordinatesFromMouseEvent(xnew, ynew));\n                        var csr = (haircross.X.tilt < 45  || haircross.X.tilt > 90 + 45)?"row-resize":"col-resize"\n                    }\n                    $container.css("cursor", csr);\n\n                    signalhandler.send("positionChange",{},that.positionChanger);\n\n                }));\n                /// mouseup event\n                $container.on("mouseup mouseleave", function(ev)\n                {\n                    $container.off("mousemove mouseup mouseleave");\n                    $container.css("cursor", "default");\n\n                    // hide when done\n                    if( $ccontrol !== undefined)\n                         $ccontrol.removeClass(\'visibility_isvisible\');\n\n                    // call mouseup with "resetHandlersOnly" to true. this wil reset default mousemove\n                    mouseManager.mouseup(ev, true);\n\n                    signalhandler.send("positionChange", {\n                        mosaicdraw: true\n                    },that.positionChanger);\n                });\n\n            }\n\n\n        }\n        ;\n    }\n    \n    if(0) // haircross old\n    {\n        haircross.X.lineN.$rot1i.on("mousedown", haircrossmousehandler(haircross.X, \'rotator\') );\n        haircross.X.lineN.$rot2i.on("mousedown", haircrossmousehandler(haircross.X, \'rotator\') );\n        haircross.Y.lineN.$rot1i.on("mousedown", haircrossmousehandler(haircross.Y, \'rotator\') );\n        haircross.Y.lineN.$rot2i.on("mousedown", haircrossmousehandler(haircross.Y, \'rotator\') );\n    }\n\n    ///////// take the focus blob and tilt the slice\n    haircrossfocusmousehandler = function() {\n        return function(ev)\n        {\n//            if (master.mainViewport !== -1 & ev.ctrlKey ) // only in coupled mode tilted views are possible\n            if (ev.ctrlKey ) // only in coupled mode tilted views are possible\n            {\n\n                if ( master.mainViewport === -1)\n                {\n                    master.toggleMainViewport(that.viewport.viewPortID);\n                    //$.notify("Tilting of image only possible if you choose one viewport as master (m)", "error")\n                }\n\n                var referencePoint = {\n                    X: ev.clientX,\n                    Y: ev.clientY\n                };\n                var matrix_on_start = math.multiply(1, KViewer.reorientationMatrix.matrix);\n                var p0 = getRealWorldCoordinatesFromMouseEvent(referencePoint.X, referencePoint.Y)._data;\n\n                var lastX = ev.clientX;\n                var lastY = ev.clientY;\n\n                ev.preventDefault();\n                ev.stopPropagation();\n                //haircross.C.$circle.css("pointer-events", "none");\n                $container.on("mousemove", moveUnlagger(function(ev)\n                {\n                    var movx = -lastX + ev.clientX;\n                    var movy = -lastY + ev.clientY;\n                    lastX = ev.clientX;\n                    lastY = ev.clientY;\n\n                    if (KViewer.navigationMode == 0 | KViewer.navigationMode == 2 )\n                    {\n                        KViewer.reorientationMatrix.matrix = matrix_on_start;\n                        var p1 = getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY)._data;\n                        var Tmat = math.matrix([[1, 0, 0, p0[0] - p1[0]], [0, 1, 0, p0[1] - p1[1]], [0, 0, 1, p0[2] - p1[2]], [0, 0, 0, 1]]);\n                        KViewer.reorientationMatrix.matrix = math.multiply(Tmat, matrix_on_start);\n                    }\n                    else\n                    {\n\n                        if (swapXY)\n                        {\n                            var tmp = movx;\n                            movx = movy;\n                            movy = tmp;\n                        }\n                        if (slicingDimOfArray == 0)\n                        {\n                            if (validTiltAngles(master.currentTilts(2, 0).v + movx, master.currentTilts(1, 0).v + movy))\n                            {\n                                master.currentTilts(2, 0).v = master.currentTilts(2, 0).v + movx;\n                                master.currentTilts(1, 0).v = master.currentTilts(1, 0).v + movy;\n                            }\n                        }\n                        if (slicingDimOfArray == 1)\n                        {\n                            if (validTiltAngles(master.currentTilts(2, 1).v + movx, master.currentTilts(0, 0).v + movy))\n                            {\n                                master.currentTilts(2, 1).v = master.currentTilts(2, 1).v + movx;\n                                master.currentTilts(0, 0).v = master.currentTilts(0, 0).v + movy;\n                            }\n                        }\n                        if (slicingDimOfArray == 2)\n                        {\n                            if (validTiltAngles(master.currentTilts(1, 1).v + movx, master.currentTilts(0, 1).v + movy))\n                            {\n                                master.currentTilts(1, 1).v = master.currentTilts(1, 1).v + movx;\n                                master.currentTilts(0, 1).v = master.currentTilts(0, 1).v + movy;\n                            }\n                        }\n                    }\n                    signalhandler.send("positionChange",{},that.positionChanger);\n\n                }));\n                /// mouseup event\n                $container.on("mouseup mouseleave", function(ev) {\n                    $container.off("mousemove mouseup mouseleave");\n                    $container.css("cursor", "default");\n/*\n                    if (KViewer.navigationMode == 0 | KViewer.navigationMode == 2 )\n                        if (KViewer.mainViewport == \'world\') // to update boundix box in worldview\n                        {\n                            KViewer.navigationTool.worldMaster();\n                            KViewer.toggleMainViewport(\'world\');\n                        }\n*/\n\n                    signalhandler.send("positionChange", {\n                        mosaicdraw: true\n                    },that.positionChanger);\n\n                ev.stopPropagation();\n                return false;\n                });\n\n            }\n        }\n    }\n    ;\n    //haircross.C.$circle.on("mousedown", haircrossfocusmousehandler());\n    \n    haircross.C.$circle.on("mousedown", haircrossmousehandler({}, \'rotator\') );\n    haircross.C.$circle_center.on("mousedown", haircrossfocusmousehandler());\n\n    function hairfocus_receive_event()\n    {\n        if (!KViewer.MouseInViewport)\n            return;\n        if(markerProxy.currentSet && markerProxy.currentSet.type == \'scribble\' && markerProxy.currentSet.state.createonclick)\n        {   \n            markerProxy.currentSet.markerPanel.toggleModifyScribble(1);\n            return\n        }    \n        haircross.C.$circle.css("pointer-events", "all");             \n        if (!gl_enabled & that.currentROI == undefined){\n            haircross.C.$circle.css(\'display\', \'inline-block\');\n        }\n    }\n    signalhandler.attach("hairfocus_receive_event", hairfocus_receive_event);\n\n\n    function hairfocus_ignore_event()\n    {\n        if(markerProxy.currentSet && markerProxy.currentSet.type == \'scribble\'  &&  markerProxy.currentSet.state.createonclick)\n        {   \n            markerProxy.currentSet.markerPanel.toggleModifyScribble(0);\n            return\n        }    \n        haircross.C.$circle.css("pointer-events", "none");             \n        if (!gl_enabled & that.currentROI == undefined){\n            haircross.C.$circle.css(\'display\', \'none\');\n        }\n    }\n    signalhandler.attach("hairfocus_ignore_event", hairfocus_ignore_event);\n\n\n    function hairfocus_detach_event()\n    {\n\n        //haircross.X.lineN.hideRot()\n        //haircross.Y.lineN.hideRot()\n        haircross.X.lineN.$main.css("pointer-events","none");\n        haircross.Y.lineN.$main.css("pointer-events","none");\n        haircross.C.$circle.css("pointer-events","none");\n        haircross.C.$circle.hide()\n    }\n    signalhandler.attach("hairfocus_detach_event", hairfocus_detach_event);\n\n\n    function resetHaircrossTilts()\n    {\n        haircross.X.tilt = 0;\n        haircross.Y.tilt = 0;\n        haircross.nX.tilt = 0;\n        haircross.nY.tilt = 0;\n    }\n    signalhandler.attach("resetHaircrossTilts", resetHaircrossTilts);\n\n\n    function updateHairCrossTilts(X, Y)\n    {\n        //  if (swapXY)\n        //      { var tmp = X; X = Y; Y = tmp; }\n\n        if (slicingDimOfArray == 0)\n        {\n            if (validTiltAngles(X, master.currentTilts(2, 1).v) & validTiltAngles(Y, master.currentTilts(1, 1).v))\n            {\n                master.currentTilts(0, 0).v = X;\n                master.currentTilts(0, 1).v = Y;\n                return true;\n            }\n        }\n        if (slicingDimOfArray == 1)\n        {\n            if (validTiltAngles(X, master.currentTilts(2, 0).v) & validTiltAngles(Y, master.currentTilts(0, 1).v))\n            {\n                master.currentTilts(1, 0).v = X;\n                master.currentTilts(1, 1).v = Y;\n                return true;\n            }\n        }\n        if (slicingDimOfArray == 2)\n        {\n            if (validTiltAngles(X, master.currentTilts(1, 0).v) & validTiltAngles(Y, master.currentTilts(0, 0).v))\n            {\n                master.currentTilts(2, 0).v = X;\n                master.currentTilts(2, 1).v = Y;\n                return true;\n            }\n        }\n        return false;\n    }\n\n\n    function drawHairCross()\n    {\n        if (that.nii !== undefined & master.crosshairMode & !gl_enabled & (KViewer.zoomedViewport==-1 | that.viewport.isZoomed()))\n        {\n            showHairCross()\n\n            var edges = that.nii.edges;\n\n            var coords = getCanvasCoordinates(getWorldPosition());\n\n            var x = coords.x_pix;\n            var y = coords.y_pix;\n\n            var testoffset = -3;// correct one !! never change this!!\n            haircross.X.lineN.$main.css({ left: x+testoffset , top: y+testoffset  } );\n            haircross.Y.lineN.$main.css({ left: x+testoffset , top: y+testoffset  } );\n\n            // set the distances of the mover / rotator lines\n            // --\x3e is done in setCanvasLayout\n            \n            if (haircross.C.$circle.css(\'display\') == \'none\')\n            {\n                haircross.C.$circle.css(\'display\', \'none\');\n                haircross.X.lineN.hideRot()\n                haircross.Y.lineN.hideRot()\n            }\n\n                haircross.X.lineN.$main.css("transform", "rotate(0deg)");\n                haircross.Y.lineN.$main.css("transform", "rotate(90deg)");\n\n            //if (master.mainViewport !== -1) \n           // {\n                var radX = 0;\n                var radY = 0;\n                if (slicingDimOfArray == 0)\n                {\n                    haircross.X.tilt = master.currentTilts(0, 0).v;\n                    haircross.Y.tilt = master.currentTilts(0, 1).v;\n                    radX = (master.currentTilts(2, 0).v);\n                    radY = (master.currentTilts(1, 0).v);\n                }\n                if (slicingDimOfArray == 1)\n                {\n                    haircross.X.tilt = master.currentTilts(1, 0).v;\n                    haircross.Y.tilt = master.currentTilts(1, 1).v;\n                    radX = (master.currentTilts(2, 1).v);\n                    radY = (master.currentTilts(0, 0).v);\n                }\n                if (slicingDimOfArray == 2)\n                {\n                    haircross.X.tilt = master.currentTilts(2, 0).v;\n                    haircross.Y.tilt = master.currentTilts(2, 1).v;\n                    radX = (master.currentTilts(1, 1).v);\n                    radY = (master.currentTilts(0, 1).v);\n                }\n                if (swapXY)\n                {\n                    var tmp = radX;\n                    radX = radY;\n                    radY = tmp;\n                    var tmp = haircross.X.tilt;\n                    haircross.X.tilt = haircross.Y.tilt;\n                    haircross.Y.tilt = tmp;\n                }\n\n\n                haircross.C.$circle.css({ left: x  + radX,  top: y  + radY });\n\n                if (KViewer.navigationMode == 1)\n                {\n                    haircross.X.lineN.$main.css("transform", "rotate(" + haircross.X.tilt + "deg) ");\n                    haircross.Y.lineN.$main.css("transform", "rotate(" + (haircross.Y.tilt  +90) +"deg) ");\n                }\n          /*  }\n            else\n            {\n\n                haircross.C.$circle.css(\'display\', \'none\');\n\n                haircross.X.lineN.$main.css("transform", "rotate(0deg)");\n                haircross.Y.lineN.$main.css("transform", "rotate(90deg)");\n            }*/\n        }\n        else\n            hideHairCross();\n\n    }\n    signalhandler.attach("drawHairCross", drawHairCross);\n\n    that.getCanvasCoordinates = getCanvasCoordinates;\n\n    that.matrixcache = {};\n\n\n\n    function getCanvasCoordinates(point) // calculates the canvas coordinates in all possible units given a point in real world coordinates\n    {\n\n    //    var currentVoxel = math.multiply(math.inv(that.nii.edges), getWorldPosition());\n\n        \n        var p;\n        if (master.mainViewport !== -1)\n        {\n            var R = getTiltMat(slicingDimOfArray);\n            var M;\n            var cacheid = master.reorientationMatrix.matrix._data.toString() + R.toString();\n            if (that.matrixcache.id != cacheid)\n            {\n                M = math.multiply(math.inv(R), math.multiply(math.inv(that.nii.edges), math.inv(master.reorientationMatrix.matrix)));\n                that.matrixcache = {\n                    M: M,\n                    id: cacheid\n                };\n            }\n            else\n            {\n                M = that.matrixcache.M;\n            }\n            p = math.multiply(M, point)._data;\n        }\n        else\n        {\n            if (that.nii.invedges == undefined)\n                that.nii.invedges = math.inv(that.nii.edges);\n            p = math.multiply( that.nii.invedges , point)._data;\n\n        }\n        // voxel coordinates\n\n\n        var pi;\n        if (slicingDimOfArray == 0)\n            pi = [1, 2, 0];\n        else if (slicingDimOfArray == 1)\n            pi = [0, 2, 1];\n        else\n            pi = [0, 1, 2];\n\n\n\n\n        var c_norm = [0, 0, 0, 1];\n        var c_mm = [0, 0, 0, 1];\n        var c_size_mm = [0, 0, 0, 1];\n        for (var i = 0; i < 3; i++)\n        {\n            c_norm[i] = (that.nii.arrayReadDirection[pi[i]] == 1) ? (1 - (p[pi[i]] + 0.5) / that.nii.sizes[pi[i]]) : ((p[pi[i]] + 0.5) / that.nii.sizes[pi[i]]);\n            c_mm[i] = (p[pi[i]] + 0.5) * that.nii.voxSize[pi[i]];\n            c_size_mm[i] = that.nii.voxSize[pi[i]] * that.nii.sizes[pi[i]];\n        }\n\n        if (swapXY)\n        {\n            c_norm = [c_norm[1], c_norm[0], c_norm[2], 1];\n            c_size_mm = [c_size_mm[1], c_size_mm[0], c_size_mm[2], 1];\n        }\n\n\n        if (that.mosaicview.active)\n        {\n            currentSlice = math.round(currentVoxel._data[slicingDimOfArray]);\n            var nz = currentSlice;\n            if (that.mosaicview.current_readDir == -1)\n                nz = that.mosaicview.current_sz_- currentSlice;\n\n            var nv = Math.round((nz - that.mosaicview.z0) / that.mosaicview.dz);\n            var x = nv % that.mosaicview.nx;\n            var y = Math.floor(nv / that.mosaicview.nx);\n\n            c_norm[0] = (c_norm[0] - 0.5) / (1 - that.mosaicview.clipratio) + 0.5;\n            c_norm[1] = (c_norm[1] - 0.5) / (1 - that.mosaicview.clipratio) + 0.5;\n\n            return {\n                x_pix: (x + c_norm[0]) * that.mosaicview.csx_ * $canvas.width() / ctx.canvas.width,\n                y_pix: (y + c_norm[1]) * that.mosaicview.csy_ * $canvas.height() / ctx.canvas.height,\n                x_norm: c_norm[0],\n                y_norm: c_norm[1],\n                x_pixPerMM: cwid / c_size_mm[0],\n                y_pixPerMM: chei / c_size_mm[1],\n                z_mm: c_mm[2]\n            };\n\n\n        }\n\n        var cwid = $canvas.width() * that.embedfac_width;\n        var chei = $canvas.height() * that.embedfac_height;\n\n\n        return {\n            x_pix: c_norm[0] * cwid,\n            y_pix: c_norm[1] * chei,\n            x_norm: c_norm[0],\n            y_norm: c_norm[1],\n            x_pixPerMM: cwid / c_size_mm[0],\n            y_pixPerMM: chei / c_size_mm[1],\n            z_mm: c_mm[2]\n        };\n    }\n\n    that.getRealWorldCoordinatesFromMouseEvent = getRealWorldCoordinatesFromMouseEvent;\n    function getRealWorldCoordinatesFromMouseEvent(clientX, clientY, structuredOutput) // calculates the real world coords from pixel coordinates. \n    {\n        clientY += window.pageYOffset;\n        clientX += window.pageXOffset;\n\n        // 1/2 pixel correction\n        if (swapXY)        \n        {\n            var offY = 0.5 / ctx.canvas.width / that.embedfac_width;\n            var offX = 0.5 / ctx.canvas.height / that.embedfac_height;\n        }\n        else\n        {\n            var offX = 0.5 / ctx.canvas.width / that.embedfac_width;\n            var offY = 0.5 / ctx.canvas.height / that.embedfac_height;\n        }\n        \n\n\n        var cpos = $canvas.offset();\n        var X = clientX - cpos.left;\n        // position on canvas\n        var Y = clientY - cpos.top;\n        // position on canvas\n\n        var x_norm, y_norm;\n        var voxelCoordinates = currentVoxel._data.slice(0);\n        if (that.mosaicview.active)\n        {\n            var wx = $canvas.width() / that.mosaicview.nx;\n            var wy = $canvas.height() / that.mosaicview.ny_div;\n            var vx = Math.floor(X / wx);\n            var vy = Math.floor(Y / wy);\n            x_norm = X / wx - vx;\n            y_norm = Y / wy - vy;\n            x_norm = (x_norm - 0.5) * (1 - that.mosaicview.clipratio) + 0.5;\n            y_norm = (y_norm - 0.5) * (1 - that.mosaicview.clipratio) + 0.5;\n\n\n            voxelCoordinates[slicingDimOfArray]\n                = (that.mosaicview.z0 + (vy * that.mosaicview.nx + vx) * that.mosaicview.dz);\n            if (that.mosaicview.current_readDir == -1)\n                voxelCoordinates[slicingDimOfArray] = that.mosaicview.current_sz_ - voxelCoordinates[slicingDimOfArray];\n        }\n        else\n        {\n            x_norm = X / $canvas.width() / that.embedfac_width;\n            // must add one half pixel\n            y_norm = Y / $canvas.height() / that.embedfac_height;\n        }\n\n        if (swapXY)\n        {\n            var tmp = x_norm;\n            x_norm = y_norm;\n            y_norm = tmp;\n        }\n\n\n        var perm = that.nii.permutationOrder;\n        var pi;\n        if (slicingDimOfArray == 0)\n            pi = [1, 2, 0];\n        else if (slicingDimOfArray == 1)\n            pi = [0, 2, 1];\n        else\n            pi = [0, 1, 2];\n\n        if (x_norm)\n        {\n            voxelCoordinates[pi[0]] = (that.nii.arrayReadDirection[pi[0]] == 1) ? ((1 - x_norm - offX) * that.nii.sizes[pi[0]]) : ((x_norm - offX) * that.nii.sizes[pi[0]]) ;\n        }\n        if (y_norm)\n        {\n            voxelCoordinates[pi[1]] = (that.nii.arrayReadDirection[pi[1]] == 1) ? ((1 - y_norm - offY) * that.nii.sizes[pi[1]]) : ((y_norm - offY) * that.nii.sizes[pi[1]]);\n        }\n\n        var realWorldCoordinates;\n        if (master.mainViewport !== -1)\n        {\n            var R =  (getTiltMat(slicingDimOfArray));\n            realWorldCoordinates = math.multiply(that.nii.edges, math.multiply(R, voxelCoordinates));\n            realWorldCoordinates = math.multiply(master.reorientationMatrix.matrix, realWorldCoordinates);\n        }\n        else\n        {\n            realWorldCoordinates = math.multiply((that.nii.edges), voxelCoordinates);\n        }\n        if(structuredOutput)\n            return {realWorldCoordinates:realWorldCoordinates, voxelCoordinates:voxelCoordinates} ;\n        else\n            return realWorldCoordinates;\n\n    }\n\n\n    function hideHairCross()\n    {\n        haircross.C.$circle.css({ display: "none" });\n        haircross.X.lineN.$main.hide();\n        haircross.Y.lineN.$main.hide();\n    }\n    function showHairCross()\n    {\n        haircross.X.lineN.$main.show();\n        haircross.Y.lineN.$main.show();\n    }\n    \n    that.toggleHairCrossControls  = function( state )\n    {\n        haircross.X.lineN.toggleControls( state );\n        haircross.Y.lineN.toggleControls( state );\n    }\n\n\n\n\n\n    function validTiltAngles(a, b)\n    {\n        var s1 = Math.sin(a / 180 * Math.PI);\n        var s2 = Math.sin(b / 180 * Math.PI);\n        if (s1 * s1 + s2 * s2 + myeps >= 1)\n            return false;\n        else\n            return true;\n    }\n\n\n\n\n    /////////////////////////////////////////////////////////////////////////////////\n    ////////////////////////////////// clims histo  /////////////////////////////////\n\n    that.createHistoManager = createHistoManager;\n    function createHistoManager(parentviewbar)\n    {\n        /**  @class \n\t     *  @alias KHistoManager */\n        var histoman = new Object();\n        histoman.nii = undefined;\n        histoman.parentviewbar = parentviewbar;\n        histoman.clim = [0, 1];\n        histoman.clim_manually_modified = false;\n        histoman.mode = 0;\n        histoman.gamma = 1;\n        histoman.blending = true;\n        histoman.posnegsym = false;\n        histoman.blocky = false;\n        histoman.cmapindex = 0;\n        histoman.onclimchange = undefined;\n        that.histoManagercnt++;\n\n\n        histoman.getManuallyEnteredClim = function(force)\n        {\n            if (force | histoman.clim_manually_modified)\n                return [parseFloat(histoman.clim[0].toFixed(2)), parseFloat(histoman.clim[1].toFixed(2))];\n            else\n                return undefined;\n        }\n\n\n        var $histogramdiv = $("<div class=\'histogram\'><div class=\'histoname\'><div></div></div><svg height=40 width=120>" +\n        " <polygon points=\'\' style=\'fill:yellow;stroke:purple;stroke-width:1\' />sdkldk</svg></div>")\n\n        var $histoname = $($histogramdiv.find(".histoname").children()[0]);\n        if ($topRow.find(".histogram").length > 0)\n        {\n            var hists = $topRow.find(".histogram");\n            $histogramdiv.insertAfter($(hists[hists.length - 1]));\n        }\n        else\n            $histogramdiv.appendTo($topRow);\n        \n        //$histogramdiv.on("contextmenu", function(ev){histoman.cmapSelectorMenu(ev)} );\n\n\n        var $climL = $("<div class=\'clim\'><div class=\'climL\'></div></div>").appendTo($histogramdiv);\n        var $climR = $("<div class=\'clim\'><div class=\'climR\'></div></div>").appendTo($histogramdiv);\n        var $climLtxt = $("<div contenteditable=\'true\' class=\'climtxt climhistotxt\' style=\'top:5%\'></div>").appendTo($histogramdiv);\n        var $climRtxt = $("<div contenteditable=\'true\' class=\'climtxt climhistotxt\'></div>").appendTo($histogramdiv);\n        $climLtxt.on(\'focus\', function() {  setTimeout(function() { document.execCommand(\'selectAll\', false, null)  }, 0); })\n        $climRtxt.on(\'focus\', function() {  setTimeout(function() { document.execCommand(\'selectAll\', false, null)  }, 0); })\n\n        var climDivs = {\n            L: {\n                div: $climLtxt,\n                t: \'L\'\n            },\n            R: {\n                div: $climRtxt,\n                t: \'R\'\n            }\n        };\n\n\n\n\n\n\n        histoman.cmapSelectorMenu = KContextMenu(\n        function() {\n            var $menu = $("<ul class=\'menu_context small\'>");\n            $menu.append($("<hr width=\'100%\'> "));\n            if (!histoman.parentviewbar.showcolored)\n            {\n                $menu.append($("<span> &nbsp Colormapping  </span>"));\n                $menu.append($("<hr width=\'100%\'> "));\n                for (var k = 0; k < colormap.names.length; k++)\n                {\n                    if (histoman.cmapindex == k)\n                        $menu.append($("<li onchoice=\'" + k + "\' > " + colormap.names[k] + "<i class=\'fa fa-dot-circle-o\'></i>  </li>"));\n                    else\n                        $menu.append($("<li onchoice=\'" + k + "\' > " + colormap.names[k] + "<i class=\'fa fa-circle-o\'></i> </li>"));\n                    //if (k == colormap.names.length - 3)\n                    //    $menu.append($("<hr>"));\n                }\n            $menu.append($("<hr>"));\n            }\n\n             if (histoman.parentviewbar.nii.sizes[3]%3 == 0)\n            {\n                var sel = histoman.parentviewbar.showcolored ? \'check-\' : \'\';\n                var type = histoman.parentviewbar.showcolored_type;\n                $menu.append($("<li onchoice=\'rgbinterpret\' > RGB interpret <i class=\'fa fa-caret-right\'></i> <ul> " +\n                "<li onchoice=\'rgbinterpret\' > colored <i  onchoice=\'lock\' class=\'fa fa-"+sel+"square-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_raw\' > raw <i onchoice=\'lock\' class=\'fa fa-"+((type=="raw") ? \'check-\' : \'\')+"circle-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_RGB\' > RGB <i onchoice=\'lock\' class=\'fa fa-"+((type=="RGB") ? \'check-\' : \'\')+"circle-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_BRG\' > BRG <i onchoice=\'lock\' class=\'fa fa-"+((type=="BRG") ? \'check-\' : \'\')+"circle-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_GBR\' > GBR <i onchoice=\'lock\' class=\'fa fa-"+((type=="GBR") ? \'check-\' : \'\')+"circle-o\'></i> </li>" +\n                "<li onchoice=\'type_rgbinterpret_GRB\' > GRB <i onchoice=\'lock\' class=\'fa fa-"+((type=="GRB") ? \'check-\' : \'\')+"circle-o\'></i> </li>"));\n\n            }\n\n\n            if (histoman.blending != undefined)\n            {\n                if (histoman.blending == 0)\n                    $menu.append($("<li onchoice=\'blending\' > Transparent <i class=\'fa fa-square-o\'></i> </li>"));\n                else\n                {\n                    if (that.transfactor == undefined)\n                        that.transfactor = 1;\n                    $menu.append($("<li onchoice=\'noblending\' > Transparent  <i class=\'fa fa-check-square-o\'></i> </li>"));\n                    var $factor = $("<input onchoice=\'preventSelection\' type=\'number\' step=\'0.05\' min=\'0\' max=\'1\'>").val(  that.transfactor).\n                             on(\'change\', function(ev) {\n                            var $input = $(ev.target);\n                             that.transfactor = $input.val();\n                              that.drawSlice({\n                            mosaicdraw: true\n                            });\n                           });\n                    $menu.append($("<li  onchoice=\'preventSelection\'> opacity: </li>").append($factor));\n\n                }\n            }\n\n\n            if (histoman.posnegsym != undefined)\n            {\n                if (!histoman.posnegsym)\n                    $menu.append($("<li onchoice=\'posnegsym\' > For Z/T-values <i class=\'fa fa-square-o\'></i> </li>"));\n                else\n                    $menu.append($("<li onchoice=\'noposnegsym\' > For Z/T-values  <i class=\'fa fa-check-square-o\'></i> </li>"));\n            }\n\n            \n            var $gamma = $("<input onchoice=\'preventSelection\' type=\'number\' step=\'0.05\' min=\'0\' max=\'10\'>").val(histoman.gamma).\n                     on(\'change\', function(ev) {\n                    var $input = $(ev.target);\n                    histoman.gamma = $input.val();\n                      that.drawSlice({\n                    mosaicdraw: true\n                    });\n                   });\n              $menu.append($("<li  onchoice=\'preventSelection\'> gamma: </li>").append($gamma));\n\n\n            if (histoman.blocky != undefined)\n            {\n                if (histoman.blocky)\n                    $menu.append($("<li onchoice=\'blocky\' > Trilinear interpolation <i class=\'fa fa-square-o\'></i> </li>"));\n                else\n                    $menu.append($("<li onchoice=\'noblocky\' > Trilinear interpolation <i class=\'fa fa-check-square-o\'></i> </li>"));\n            }\n\n\n            $menu.append($("<hr width=\'100%\'> "));\n            $menu.append($("<span> &nbsp Windowing  </span>"));\n            $menu.append($("<hr width=\'100%\'> "));\n\n            \n            \n            // contrast presets (for CT mainly)\n            var p = colormap.colorlimpresets;\n            for(var k=0; k < p.length;  k++)\n                $menu.append($("<li onchoice=\'reset\' data-min=\'"+ p[k].min +"\' data-max=\'"+ p[k].max +"\'  > "+ p[k].title +" </li>"));    \n            \n            return $menu;\n        },\n        function(str, ev)\n        {\n           \n            if (str)\n            {\n                if (str != "")\n                {\n                    if (str == \'reset\')\n                    {\n                        resetColorMapLims( [ $(ev.target).attr(\'data-min\'), $(ev.target).attr(\'data-max\')  ]   );\n                    }\n                    else if (str == "posnegsym")\n                        histoman.posnegsym = true;\n                    else if (str == "noposnegsym")\n                        histoman.posnegsym = false;\n                    else if (str == "blending")\n                        histoman.blending = true;\n                    else if (str == "noblending")\n                        histoman.blending = false;\n                    else if (str == "blocky")\n                        histoman.blocky = false;\n                    else if (str == "noblocky")\n                        histoman.blocky = true;\n                    else if (str == \'rgbinterpret\')\n                    {\n                         histoman.parentviewbar.showcolored = !histoman.parentviewbar.showcolored;\n                         signalhandler.send("updateImage",{id:histoman.parentviewbar.currentFileID});  \n                         updateHistogramClim();              \n                    }\n                    else if (str.substring(0,17) == \'type_rgbinterpret\')\n                    {\n                        histoman.parentviewbar.showcolored_type = str.substring(18);\n                        signalhandler.send("updateImage",{id:histoman.parentviewbar.currentFileID});                \n                    }\n\n                    else\n                    {\n                        if (colormap.names[str] == "unicolor")\n                        {\n                            if (histoman.parentviewbar.color == undefined)\n                                histoman.parentviewbar.color = 0;\n                            var colors = KColor.list;\n                            function colencode(c) {\n                                return "background:" + RGB2HTML(c[0], c[1], c[2]) + ";";\n                                }\n                              var $colselector = KColorSelector(colors, colencode,\n                                function() {      \n                                    histoman.setCmap("uni"+histoman.parentviewbar.color);   \n                                    if (histoman.oncmapchange)\n                                        histoman.oncmapchange();\n                                    that.drawSlice({\n                                        mosaicdraw: true\n                                    });\n                               \n                                }, histoman.parentviewbar);\n\n                            $colselector.themenu(ev);\n                            return "close";\n                          \n\n                        }\n                        else\n                            histoman.setCmap(parseInt(str));\n\n                    }\n                    if (histoman.oncmapchange)\n                        histoman.oncmapchange();\n                }\n                that.drawSlice({\n                    mosaicdraw: true\n                });\n            }\n        }, undefined, true\n        );\n\n\n\n\n        var $colorbardiv = $("<div class=\'colorbar\'></div>")\n        var $colorbarcanvas = $("<canvas  style=\'height:100%;width:100%\'></canvas>").appendTo($colorbardiv)\n            .click(histoman.cmapSelectorMenu)\n            .on("contextmenu", histoman.cmapSelectorMenu);\n        if ($topRow.find(".colorbar").length > 0)\n        {\n            var cdivs = $topRow.find(".colorbar");\n            $colorbardiv.insertAfter($(cdivs[cdivs.length - 1]));\n        }\n        else\n            $colorbardiv.appendTo($topRow);\n\n        var cbarctx = $colorbarcanvas.get(0).getContext("2d");\n\n        var $cbarLtxt = $("<div contenteditable=\'true\'  class=\'climtxt\'></div>").appendTo($colorbardiv);\n        var $cbarRtxt = $("<div contenteditable=\'true\'  class=\'climtxt\'></div>").appendTo($colorbardiv);\n        $cbarLtxt.on(\'focus\', function() {  setTimeout(function() { document.execCommand(\'selectAll\', false, null)  }, 0); })\n        $cbarRtxt.on(\'focus\', function() {  setTimeout(function() { document.execCommand(\'selectAll\', false, null)  }, 0); })\n\n        \n        var oncbartextchange = function(ev) { return climTextChange(ev,$cbarLtxt,$cbarRtxt) };\n        $cbarLtxt.keyup( oncbartextchange);\n        $cbarRtxt.keyup(oncbartextchange);\n        $cbarLtxt.blur(oncbartextchange);\n        $cbarRtxt.blur(oncbartextchange);\n\n        //makeEditableOnDoubleClick($cbarLtxt);\n        //makeEditableOnDoubleClick($cbarRtxt);\n\n\n        function remove()\n        {\n            that.histoManagercnt--;\n            $colorbardiv.remove();\n            $histogramdiv.remove();\n            $climL.remove();\n            $climR.remove();\n            $climLtxt.remove();\n            $climRtxt.remove();\n            signalhandler.detach("layoutHisto", sig_layout_id);\n\n        }\n        histoman.remove = remove;\n\n        function hide()\n        {\n            $histogramdiv.hide();\n            $colorbardiv.hide();\n        }\n        histoman.hide = hide;\n\n        function hideHisto()\n        {\n            $histogramdiv.hide();\n        }\n        histoman.hideHisto = hideHisto;\n\n        function hideCbar()\n        {\n            $colorbardiv.hide();\n        }\n        histoman.hideCbar = hideCbar;\n        signalhandler.attach("hideHistoOnly", histoman.hideHisto);\n\n\n        climtxtchange = function(ev) { return climTextChange(ev,$climLtxt,$climRtxt) };\n\n        function climTextChange(ev,$ltxt,$rtxt)\n        {\n\n            // remove focus on enter; this will also take care of clim change\n            if( ev.keyCode == 13)\n            {\n                if(ev.target == $ltxt.get(0))\n                    $ltxt.blur();\n                if(ev.target == $rtxt.get(0))\n                    $rtxt.blur();\n\n                window.getSelection().removeAllRanges();\n                return false;\n            }\n\n            if ( ev.type == "blur")\n            {\n                var ds = histoman.nii.datascaling;\n                if (ds == undefined)\n                {\n                    ds = {ie :function(x) {\n                        return x\n                    } };\n                    \n                }\n                if (ds.ie != undefined)\n                {\n                    var l = ds.ie(parseFloat($ltxt.text()));\n                    var r = ds.ie(parseFloat($rtxt.text()));\n                }\n                else\n                {\n                    var l = (parseFloat($ltxt.text()));\n                    var r = (parseFloat($rtxt.text()));\n                }\n                \n                if (!isNaN(l))\n                    histoman.clim[0] = l;\n                if (!isNaN(r))\n                    histoman.clim[1] = r;\n                updateHistogramClim();\n                \n                if (ev.shiftKey)\n                    histoman.setColorMapLims(histoman.clim);\n                else\n                    histoman.onclimchange(ev);\n                \n                window.getSelection().removeAllRanges();\n                return false;\n\n            }\n            return true;\n        }\n\n\n\n        signalhandler.attach("datascalingChanged", function(ev) {\n            if (histoman.nii)\n            {\n               if (that.content.fileID == ev.id)\n                climtxtchange({keyCode:13}); \n            }\n\n             } );\n        $climLtxt.keyup(climtxtchange);\n        $climRtxt.keyup(climtxtchange);\n        $climLtxt.blur(climtxtchange);\n        $climRtxt.blur(climtxtchange);\n\n        // this is the mousedwon handler\n        climhandler = function(Z, setInitial) {\n            return function(ev)\n            {\n                \n                // set on click\n                if(setInitial)\n                {\n                    if($(ev.target).hasClass(\'climtxt\'))\n                    {\n                        return true;\n                    }\n\n                    var d = ev.clientX - $histogramdiv.offset().left;\n                    //if (ev.which == 1)\n                    if(  (ev.clientY -  $histogramdiv.offset().top)/ $histogramdiv.height() > .5)\n                    {\n                        if(ev.which == 1)\n                        {\n                            histoman.clim[0] = histoman.nii.histogram.min + d / $histogramdiv.width() * (histoman.nii.histogram.max - histoman.nii.histogram.min);\n                            Z = climDivs.L\n                        }\n                        else if(ev.which == 3)\n                        {\n                            histoman.clim[1] = histoman.nii.histogram.min + d / $histogramdiv.width() * (histoman.nii.histogram.max - histoman.nii.histogram.min);\n                            Z = climDivs.R\n                        }\n                        updateHistogramClim();\n                    }\n                    else\n                    {\n                        if(ev.which == 3)\n                        {\n                            histoman.cmapSelectorMenu(ev)                        \n                        }\n                        return false;\n                    } \n\n                }\n\n\n                var referencePoint = {\n                    X: ev.clientX,\n                    Y: ev.clientY\n                };\n                var referenceLims = [histoman.clim[0], histoman.clim[1]];\n\n                ev.preventDefault();\n                ev.stopPropagation();\n                Z.div.css("pointer-events", "none");\n                $(document.body).on("mousemove", moveUnlagger(function(ev)\n                {\n                    var d = (ev.clientX - referencePoint.X);\n                    if (Z.t == "L")\n                    {\n                        histoman.clim[0] = referenceLims[0] + d / Z.div.parent().width() * (histoman.nii.histogram.max - histoman.nii.histogram.min);\n                        // old version with mov\n                        //histoman.clim[0] = histoman.clim[0] + mov(ev).X/Z.div.parent().width()*(histoman.nii.histogram.max-histoman.nii.histogram.min);\n                    }\n                    else\n                    {\n                        histoman.clim[1] = referenceLims[1] + d / Z.div.parent().width() * (histoman.nii.histogram.max - histoman.nii.histogram.min);\n                    }\n                    //  setColorMapLims(histoman.clim);\n                    updateHistogramClim();\n                    $(document.body).css("cursor", "ew-resize");\n                    if (ev.shiftKey)\n                        histoman.setColorMapLims(histoman.clim);\n                    else\n                        histoman.onclimchange(ev);\n\n                }));\n                /// mouseup event\n                $(document.body).on("mouseup mouseleave", function(ev) {\n                    $(document.body).off("mousemove mouseup mouseleave");\n                    $(document.body).css("cursor", "default");\n                    Z.div.css("pointer-events", "all");\n                    histoman.clim_manually_modified = true;\n                    if (ev.shiftKey)\n                        histoman.setColorMapLims(histoman.clim);\n                    else\n                    {\n                        histoman.onclimchange(ev);\n                    }\n                });\n            }\n        }\n\n        $climL.on("mousedown", climhandler(climDivs.L));\n        $climR.on("mousedown", climhandler(climDivs.R));\n        $histogramdiv.on("mousedown", climhandler(climDivs.L, 1));\n\n/*\n        $histogramdiv.on("mousedown", \n            function(Z) {\n            return function(ev)\n            {\n                var d = ev.clientX - $histogramdiv.offset().left;\n                if (1)//ev.which == 1)\n                    histoman.clim[0] = histoman.nii.histogram.min + d / $histogramdiv.width() * (histoman.nii.histogram.max - histoman.nii.histogram.min);\n                else if (ev.which == 2)\n                    histoman.clim[1] = histoman.nii.histogram.min + d / $histogramdiv.width() * (histoman.nii.histogram.max - histoman.nii.histogram.min);\n                 updateHistogramClim();\n                 //$climL.trigger(\'mousedown\')\n\n            }\n            }(climDivs.L))\n*/\n\n\n//         $histogramdiv.on("mousedown", function(ev){\n//             var x = ev.clientX - $histogramdiv.offset().left;\n//             climhandler(climDivs.L)\n//             console.log(x)\n\n//             } );\n\n\n        function setCmap(cmap)\n        {\n            if (typeof (cmap) == "string")\n            {\n                if (cmap.substring(0,3) == "uni")\n                {\n                    histoman.cmapindex = 100 + parseInt(cmap.substring(3));  \n                    histoman.mode = 0;                 \n                    updateHistogramClim();\n                    return;\n\n                }\n                else\n                    cmap = colormap.mapIndex(cmap);\n\n            }\n\n            histoman.cmapindex = cmap;\n            if (cmap >= 100)\n                histoman.mode = 0;\n            else if (cmap >= colormap.names.length - 2)\n                histoman.mode = cmap - colormap.names.length + 3;\n            else\n                histoman.mode = 0;\n\n            updateHistogramClim();\n        }\n        histoman.setCmap = setCmap;\n\n        function updateClimTxt()\n        {\n            var d = histoman.nii.datascaling;\n            if (d.e == undefined)\n                d.e = function(x) {\n                    return x\n                }\n            function render(a)\n            {\n                a = d.e(a);\n                if (Math.abs(a)<0.0000001)\n                    return "0";\n                var dig = Math.log10(Math.abs(a))\n                if (dig > 2)\n                    return a.toFixed(0);\n                else if (dig > 0)\n                    return a.toFixed(1);\n                else if (dig > -4)\n                    return a.toFixed(1+Math.ceil(Math.abs(dig)));\n                else                \n                    return a.toFixed(6);\n            }\n\n            $climLtxt.text(render(histoman.clim[0]))\n            $climRtxt.text(render(histoman.clim[1]))\n            $cbarLtxt.text(render(histoman.clim[0]))\n            $cbarRtxt.text(render(histoman.clim[1]))\n\n        }\n\n\n        function updateHistogramClim()\n        {\n            if (histoman.nii)\n                if (histoman.nii.histogram)\n                {\n                    var hwid = $histogramdiv.width();\n                    $climLtxt.css("height", 0);\n                    $climRtxt.css("height", 0);\n\n                    $climL.css("left", hwid * (histoman.clim[0] - histoman.nii.histogram.min) / (histoman.nii.histogram.max - histoman.nii.histogram.min));\n                    $climR.css("left", hwid * (histoman.clim[1] - histoman.nii.histogram.min) / (histoman.nii.histogram.max - histoman.nii.histogram.min));\n                    $climLtxt.css("left", hwid * (histoman.clim[0] - histoman.nii.histogram.min) / (histoman.nii.histogram.max - histoman.nii.histogram.min));\n                    $climRtxt.css("left", hwid * (histoman.clim[1] - histoman.nii.histogram.min) / (histoman.nii.histogram.max - histoman.nii.histogram.min));\n\n                    updateClimTxt();\n\n                    if (histoman.clim[0] < histoman.nii.histogram.min)\n                    {\n                        $climL.css("left", 0);\n                        $climLtxt.css("left", 0);\n                    }\n                    if (histoman.clim[1] > histoman.nii.histogram.max)\n                    {\n                        $climR.css("left", hwid);\n                        $climRtxt.css("left", hwid);\n                    }\n                    $climL.css("display", "inline-block");\n                    if (histoman.mode == 0)\n                    {\n                        $climR.css("display", "inline-block");\n                        $climRtxt.css("display", "inline-block");\n                    }\n                    else\n                    {\n                        $climR.css("display", "none");\n                        $climRtxt.css("display", "none");\n                    }\n\n\n\n\n                    if (colormap.maps[histoman.cmapindex])\n                    {\n\n                        if (histoman.parentviewbar != undefined && histoman.parentviewbar.showcolored)\n                        {\n                            var n = 20;\n                            var cbardata = cbarctx.createImageData(3, n);\n                            for (var k = 0; k < n; k++)\n                            {\n                                var v = k/n*255;\n                                cbardata.data[3*4 * k] = v\n                                cbardata.data[3*4 * k + 1] = 0\n                                cbardata.data[3*4 * k + 2] = 0\n                                cbardata.data[3*4 * k + 3] = 255;\n                                cbardata.data[3*4 * k + 4] = 0\n                                cbardata.data[3*4 * k + 5] = (255-v);\n                                cbardata.data[3*4 * k + 6] = 0\n                                cbardata.data[3*4 * k + 7] = 255;\n                                cbardata.data[3*4 * k + 8] = 0\n                                cbardata.data[3*4 * k + 9] = 0\n                                cbardata.data[3*4 * k + 10] = v\n                                cbardata.data[3*4 * k + 11] = 255;\n                            }\n\n                            cbarctx.canvas.width = 3;\n                            cbarctx.canvas.height = n;\n                        }\n                        else\n                        {\n                            var cbardata = cbarctx.createImageData(1, colormap.maps[histoman.cmapindex][0].length);                         \n                            for (var k = 0; k < colormap.maps[histoman.cmapindex][0].length; k++)\n                            {\n                                cbardata.data[4 * k] = colormap.maps[histoman.cmapindex][0][colormap.maps[histoman.cmapindex][0].length - k - 1];\n                                cbardata.data[4 * k + 1] = colormap.maps[histoman.cmapindex][1][colormap.maps[histoman.cmapindex][0].length - k - 1];\n                                cbardata.data[4 * k + 2] = colormap.maps[histoman.cmapindex][2][colormap.maps[histoman.cmapindex][0].length - k - 1];\n                                cbardata.data[4 * k + 3] = 255;\n                            }\n                            cbarctx.canvas.width = 1;\n                            cbarctx.canvas.height = colormap.maps[histoman.cmapindex][0].length;\n                        }\n\n\n                        cbarctx.putImageData(cbardata, 0, 0);\n                    }\n                }\n        }\n        histoman.updateHistogramClim = updateHistogramClim;\n\n\n        function layoutHistogram()\n        {\n            if (histoman.nii == undefined)\n                return;\n\n            var histoSizeFac = state.viewer.histoSizeFac;\n            // layout histogram\n            var pwid = $container.width();\n            if (pwid > $container.height())\n                pwid = $container.height();\n            pwid *= 1.5;\n\n\n            var hwid = pwid * 0.3 * histoSizeFac;\n            var hhei = pwid * 0.1 * histoSizeFac;\n\n            if ((hwid+35)*that.histoManagercnt > $container.width())\n            {\n                 histoSizeFac = ($container.width()/that.histoManagercnt -35)/(pwid * 0.3)\n                 hwid = pwid * 0.3 * histoSizeFac;\n                 hhei = pwid * 0.1 * histoSizeFac;        \n            }\n\n\n\n            var left = 2;\n            if ($histogramdiv.prev().hasClass("histogram"))\n            {\n                var hists = $histogramdiv.parent().find(".histogram");\n                for (var k = 0; k < hists.length;k++)\n                {\n                    if (hists[k] == $histogramdiv[0])\n                    {\n                        left = $(hists[0]).position().left + k*(hwid+35);                        \n                    }\n                }\n//                left = $histogramdiv.prev().position().left + hwid + 35;\n            }\n            $histogramdiv.css({\n                display: "inline-block",\n                left: left,\n                width: hwid,\n                height: hhei\n            });\n            $histogramdiv.find("svg").width(hwid);\n            $histogramdiv.children().height(hhei);\n\n\n            // layout colorbar\n            var hwid = $container.width() * 0.04 * histoSizeFac;\n            if (hwid > 25)\n                hwid = 25;\n            if (hwid < 17)\n                hwid = 17;\n            var hhei = 50; //$container.height() * 0.2 * histoSizeFac;\n            var left = 5; //$container.width() * 0.04;\n            var top = $container.height() * 0.25;\n            if ($colorbardiv.prev().hasClass("colorbar"))\n            {\n                top = top + hhei + $container.height() * 0.1;\n                \n                var cbars = $colorbardiv.parent().find(".colorbar");\n\n                for (var k = 1; k < cbars.length;k++)\n                    if (cbars[k] == $colorbardiv[0])\n                    {\n                        left = left + (k-1)*(hwid*1.7);                        \n                    }\n\n            }\n\n            $colorbardiv.css({\n                display: "inline-block",\n                left: left,\n                top: top,\n                width: hwid,\n                height: hhei\n            });\n\n            if (histoman.hidden | that.hiddenHisto)\n                 $colorbardiv.css({ display: "none"})\n\n            $colorbardiv.children().first().width(hwid);\n            $colorbardiv.children().height(hhei);\n\n            $cbarRtxt.css("top", -18);\n            $cbarRtxt.css("left", \'-50%\', \'transform\', \'translate -50%\');\n            $cbarLtxt.css("top", hhei);\n            $cbarLtxt.css("left", \'-50%\', \'transform\', \'translate -50%\');\n\n\n\n\n            updateHistogram();\n            updateHistogramClim();\n        }\n        histoman.layoutHistogram = layoutHistogram;\n        var sig_layout_id = signalhandler.attach("layoutHisto", layoutHistogram);\n\n\n        function updateHistogram()\n        {\n            if (histoman.nii != undefined && that.viewport.barport == undefined)\n            {\n                if (master.histoMode != 0)\n                {\n                    if (master.histoMode == 2 & that.overlays.length > 0)\n                    {\n                        histoman.hide();\n                        return;\n                    }\n                    // 2 means main image only\n                    if (master.histoMode == 3 & that.overlays.length == 0) // 3 means overlay image only\n                    {\n                        histoman.hide();\n                        return;\n                    }\n                    if (histoman.hidden  | that.hiddenHisto)\n                        $histogramdiv.css({\n                            display: "none"\n                        });\n                    else\n                        $histogramdiv.css({\n                            display: "inline-block"\n                        });\n                    var histoheight = $histogramdiv.height();\n                    var histowidth = $histogramdiv.width();\n\n                    var $poly = $histogramdiv.find("polygon");\n                    var pstr = "";\n                    if( histoman.nii.histogram.accus.maxfreq )\n                    {\n                        var scfac = 1 / histoman.nii.histogram.accus.maxfreq * 0.95;\n                        for (var i = 0; i < histoman.nii.histogram.accus.length; i++)\n                            pstr = pstr + (histowidth * i / histoman.nii.histogram.accus.length) + "," +\n                                 (histoheight - histoheight * scfac * ((0 + histoman.nii.histogram.accus[i]))) + " ";\n                        pstr = pstr + histowidth + "," + histoheight + " 0," + histoheight;\n                    }\n                    $poly.attr("points", pstr);\n                    if (histoman.name)\n                        $histoname.text(histoman.name).show();\n                    else\n                        $histoname.hide();\n                    \n                    return;\n                }\n            }\n            // else\n            histoman.hide();\n\n        }\n        histoman.updateHistogram = updateHistogram;\n\n\n        function mapVal(val)\n        {\n            if (val != undefined)\n                if (val.length == 3)\n                {\n                    return [255 * (val[0] - histoman.clim[0]) / (histoman.clim[1] - histoman.clim[0]),\n                    255 * (val[1] - histoman.clim[0]) / (histoman.clim[1] - histoman.clim[0]),\n                    255 * (val[2] - histoman.clim[0]) / (histoman.clim[1] - histoman.clim[0])];\n                }\n                else\n                {\n                    if (histoman.mode == 0)\n                    {\n                        if (histoman.gamma == 1)\n                        {\n                            return (val - histoman.clim[0]) / (histoman.clim[1] - histoman.clim[0]);\n                        }\n                        else                           \n                            return (val > histoman.clim[0])?Math.pow((val - histoman.clim[0]) / (histoman.clim[1] - histoman.clim[0]),histoman.gamma):0;\n                    }\n                    else if (histoman.mode == 1)\n                        return (val > histoman.clim[0]) ? 1 : 0;\n                    else\n                        return (val > histoman.clim[0]) ? 0 : 1;\n                }\n        }\n        histoman.mapVal = mapVal;\n\n\n\n        return histoman;\n\n    }\n\n\n\n    ////////////////////////////////// mouse handler//////////////////////////\n\n\n\n\n    var mouseManager = new Object();\n    that.mouseManager = mouseManager;\n    mouseManager.scaleFac = .005;\n    mouseManager.referenceRange = 1;\n    mouseManager.lasteClickedPoint = new Array(0,0);\n    mouseManager.lasteClickedColormap = new Array(0,1);\n    mouseManager.didMove = false;\n    mouseManager.dom = $container;\n\n\n\n\n    function ROIpreviewUpdate() {\n        if (master.roiTool.lastPreviewPoints != undefined)\n        {\n            var changedPoints = master.roiTool.lastPreviewPoints ;\n            for (var k = 0; k < changedPoints.length;k++)\n                    that.currentROI.content.data[changedPoints[k]] = 0;  \n            master.roiTool.lastPreviewPoints = undefined;\n\n        }\n    }\n\n\n    mouseManager.mouseleave_default = function(ev)\n    {\n        KViewer.MouseInViewport = false;\n\n        // roi Tool painter will take care to hide circle\n        if (that.currentROI != undefined)\n        {\n            master.roiTool.hidePen(that);\n            if(master.roiTool.livepreview)\n            {\n                ROIpreviewUpdate();\n                signalhandler.send("updateImage",{id:that.currentROI.fileID,no3d:true,lazy:false},that.imageupdater);\n            }\n        }\n    }\n\n\n    mouseManager.mousemove_default = moveUnlagger(function(ev)\n    {\n        if (!$(ev.target).hasClass(\'KViewPort_canvas\') &&  KViewer.MouseInViewport)\n        {\n             mouseManager.mouseleave_default();\n             return;\n        }\n\n        KViewer.MouseInViewport = true;\n\n        if (that.currentROI != undefined && !that.isGLenabled() )\n        {\n            if (ev.buttons == 0 )\n            {\n                if (master.roiTool.drawPen(ev, that))\n                {        \n                    if (!master.roiTool.regionGrow && master.roiTool.livepreview)\n                    {\n                        ev.roipreview = true;\n                        if (master.roiTool.lastPreviewPoints != undefined)\n                            ROIpreviewUpdate();\n                        master.roiTool.modifyRoi(ev, that,function(changedPoints){                    \n\n                            signalhandler.send("updateImage",{id:that.currentROI.fileID,no3d:true,lazy:false},that.imageupdater);\n                            ROIpreviewUpdate.tobecleaned = true;\n                            master.roiTool.lastPreviewPoints = changedPoints;\n                            //ROIpreviewUpdate();\n                         \n                        });\n                    }\n                }\n                else\n                 {\n                     if (master.roiTool.livepreview)\n                     {\n                        if (ROIpreviewUpdate.tobecleaned)\n                           signalhandler.send("updateImage",{id:that.currentROI.fileID,no3D:true},that.imageupdater);\n                        ROIpreviewUpdate.tobecleaned = false;\n                     }\n                 } \n\n            }\n        }\n    });\n\n    mouseManager.mousedown = function(ev)\n    {\n        if (KViewer.on_viewport_resizing)\n            return;\n        //      if (!$(this).hasClass("KViewPort_canvas3D") & !$(this).hasClass("KViewPort_canvas")  & !$(this).hasClass("KViewPort_scrollAccelerator") & !$(this).hasClass("KViewPort_icontainer") )\n        if (!$(ev.target).hasClass("KViewPort_canvas3D") & !$(ev.target).hasClass("KViewPort_canvas")  & !$(ev.target).hasClass("KViewPort_icontainer") & ($(ev.target).attr(\'class\') !== "roiTool_svg"))\n            return;\n\n        if (that.nii != undefined & !gl_enabled)\n        {\n\n            mouseManager.whichbutton = ev.button;\n            mouseManager.whichbuttons = ev.buttons;\n\n            var markerOnClickCreate = (!ev.shiftKey && !ev.ctrlKey && markerProxy && markerProxy.currentSet && markerProxy.currentSet.state.createonclick && markerProxy.currentSet.state.visible )\n\n\n\n            if (!markerOnClickCreate & that.currentROI != undefined & !ev.ctrlKey & !ev.shiftKey)\n            {\n                ROIpreviewUpdate();\n                master.roiTool.history.record(\'startRecording\', that);\n                master.roiTool.modifyRoi(ev, that,function()\n                {\n                    signalhandler.send("updateImage",{id:that.currentROI.fileID},that.imageupdater);\n                });\n            }\n            else if ((ev.button == 0 & !ev.ctrlKey & !ev.shiftKey) | (ev.button == 0 && that.currentROI != undefined && (ev.shiftKey||ev.ctrlKey)))\n            {\n                /********** new: check if the clicked point is outside of array */\n\n                var rwc = getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY, true);\n\n                if (that.currentROI != undefined)\n                {\n                    signalhandler.send("updateImage",{id:that.currentROI.fileID},that.imageupdater);\n                    ROIpreviewUpdate();\n                }                \n                var voxelCoordinates = rwc.voxelCoordinates;\n                if( voxelCoordinates[slicingDimOfArray] < 0 |  voxelCoordinates[slicingDimOfArray] >  that.nii.sizes[slicingDimOfArray])\n                {\n                    voxelCoordinates[slicingDimOfArray] = that.nii.centerVoxel._data[slicingDimOfArray];\n                    var realWorldCoordinates = (math.multiply((that.nii.edges), voxelCoordinates));\n                    if (master.mainViewport !== -1)\n                    {\n                        realWorldCoordinates = math.multiply(master.reorientationMatrix.matrix, realWorldCoordinates);\n                    }\n                }\n                else\n                {\n                    var realWorldCoordinates = rwc.realWorldCoordinates;\n\n                }\n                setWorldPosition( realWorldCoordinates );\n                /*************/\n\n                //setWorldPosition(getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY));\n                signalhandler.send("positionChange",{respectSliceChange: that.atlas.length==0},that.positionChanger);\n            } // right click \n            if (ev.button == 2 && that.currentROI == undefined)\n            {\n\n                function roi_ccanalysis_contextmenu(ev)\n                {\n                     mouseManager.cid_roipicker = undefined;\n                     var res = KViewer.roiTool.contextPicker(ev,that);\n                     if (res)\n                     {\n                        $(document).off("mousemove mouseup mouseleave");\n                        $(mouseManager.dom).off(\'mousemove mouseup mouseleave\');\n                        $(mouseManager.dom).on(\'mousemove\',mouseManager.mousemove_default);\n                        $(mouseManager.dom).on(\'mouseleave\', mouseManager.mouseleave_default);\n                        return true;\n                      }\n                      else\n                      {\n                        return false;\n                      }\n                }\n                // switch off delayed mode for now, some people wanted that\n                // mouseManager.cid_roipicker = setTimeout(roi_ccanalysis_contextmenu,150)\n                if( roi_ccanalysis_contextmenu(ev) )\n                {\n                    return false\n                }\n            }\n\n            if (KViewer.atlasTool != undefined && KViewer.atlasTool.isinstance)\n                KViewer.atlasTool.updatePoint();\n\n            if (ev.button == 0 & ev.ctrlKey & ev.shiftKey & that.nii.sizes[3] > 1)\n            {\n                setWorldPosition(getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY));\n                createTSeriesPinViewer(ev);\n            }\n\n            if (markerOnClickCreate)\n            {\n                if(KViewer.markerTool.enabled != 0  || ( markerProxy.currentSet.markerPanel &&  markerProxy.currentSet.markerPanel.panelvisible ) )\n                { \n                    markerProxy.setDraggedPoint(  markerProxy.createMarker(ev, markerProxy.currentSet, that ), true );\n                }\n            }\n\n            $(document).on("mousemove", mouseManager.mousemove);\n            $(document).on("mouseup mouseleave", mouseManager.mouseup);\n\n            mouseManager.didMove = false;\n            mouseManager.shift = ev.shiftKey;\n            mouseManager.lasteClickedPoint[0] = ev.clientX;\n            mouseManager.lasteClickedPoint[1] = ev.clientY;\n            mouseManager.lasteMovedPoint = [ev.clientX, ev.clientY]\n\n            mouseManager.lasteClickedColormap = histoManager.clim;\n            mouseManager.climReferenceRange = histoManager.clim[1] - histoManager.clim[0];\n            mouseManager.referenceSlice = currentSlice;\n            mouseManager.referenceZoomFac = function() {\n                return that.zoomFac\n            }();\n            mouseManager.referenceZoomOriginX = function() {\n                return that.zoomOriginX\n            }();\n            mouseManager.referenceZoomOriginY = function() {\n                return that.zoomOriginY\n            }();\n        }\n  \n  \n    }\n\n\n    mouseManager.mousemove = moveUnlagger(function(ev)\n    {\n        if (mouseManager.cid_roipicker != undefined)\n        {\n            clearTimeout(mouseManager.cid_roipicker)\n            mouseManager.cid_roipicker = undefined;\n\n        }\n       \n        var markerOnClickCreate = (!ev.shiftKey && !ev.ctrlKey && markerProxy && markerProxy.currentSet && markerProxy.currentSet.state.createonclick && markerProxy.currentSet.state.visible )\n\n        mouseManager.didMove = true;\n        ev.preventDefault();\n        var stretchFacX = -(mouseManager.lasteClickedPoint[0] - ev.clientX);\n        var stretchFacY = (mouseManager.lasteClickedPoint[1] - ev.clientY);\n        var increment = [mouseManager.lasteMovedPoint[0] - ev.clientX, mouseManager.lasteMovedPoint[1] - ev.clientY];\n        if (stretchFacX % 3 == 0 || stretchFacY % 3 == 0)\n        {\n\n            if (!markerOnClickCreate && master.roiTool.isinstance && master.roiTool.penEnabled & that.currentROI != undefined & !ev.ctrlKey & !ev.shiftKey)\n            {\n                master.roiTool.drawPen(ev, that);\n                master.roiTool.modifyRoi(ev, that,function(){\n                    signalhandler.send("updateImage",{id:that.currentROI.fileID,frommove:true},that.imageupdater);\n                });\n\n                return;\n            }\n\n            if (mouseManager.whichbutton == 2) // right click \n            {\n                if (mouseManager.whichbutton == 2 && master.roiTool.isinstance &&  master.roiTool.enabled && master.roiTool.penEnabled ) // in roi mode: only set current point\n                {\n                    signalhandler.send("positionChange",{},that.positionChanger);\n                }\n                else // no roi selected:\n                {\n                    if (ev.shiftKey)\n                    {\n                        if (KViewer.atlasTool.isinstance)\n                        {\n                            KViewer.atlasTool.point = getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY);\n                            KViewer.atlasTool.update();\n                            signalhandler.send("drawSlices labelChange");\n                        }\n\n                    }\n                    else if (0) //ev.ctrlKey)\n                    // right click + control: fast zoom\n                    {\n                        var r = math.round([(mouseManager.lasteClickedPoint[1] - $canvas.offset().top), (mouseManager.lasteClickedPoint[0] - $canvas.offset().left)]);\n\n\n                        var a = math.exp(stretchFacY * 0.005);\n                        var zf = mouseManager.referenceZoomFac * a;\n                        var dy = -r[0] * (1 - a) + mouseManager.referenceZoomOriginY;\n                        var dx = -r[1] * (1 - a) + mouseManager.referenceZoomOriginX;\n                        //master.setZoomLims([zf, dy/$canvas.width() * wid_cm, dx / $canvas.height() * hei_cm]);\n\n                        //signalhandler.send("setZoomLimsRelative", {zoomfac: zf, delta: [-1500,-1500], sender: slicingDimOfWorld} );\n                        signalhandler.send("setZoomLims", [zf, 0, 0]);\n                        signalhandler.send("positionChange", {nosliceupdate:true},that.positionChanger);\n    \n                        //signalhandler.send("setZoom", 1 + .08 * math.sign(increment[1]));\n                        //signalhandler.send("positionChange", {nosliceupdate:true});\n\n\n                        // signalhandler.send("setZoom", 1.1*math);\n                        //signalhandler.send("setZoomLimsRelative", {zoomfac: zf, delta: [0, 0], sender: slicingDimOfWorld} )\n                    }\n                }\n            }\n\n\n             //       if (0) //(!ev.ctrlKey & !ev.shiftKey) // default: set colormap limits\n            if (mouseManager.whichbutton == 1 )\n            {\n                // adjust left and right clim on l/r click\n                //var clim = [mouseManager.lasteClickedColormap[0] + (stretchFacX * mouseManager.climReferenceRange * mouseManager.scaleFac * master.static.mousespeed_clims), mouseManager.lasteClickedColormap[1] + (stretchFacY * mouseManager.climReferenceRange * mouseManager.scaleFac** master.static.mousespeed_clims)];\n                \n                // adjust center and window\n                //var refRange = mouseManager.climReferenceRange;\n\n                // take the min / max of image as scaling reference\n                var refRange = (that.nii.histogram.max - that.nii.histogram.min) * .25;\n                var ww = (mouseManager.lasteClickedColormap[1] -  mouseManager.lasteClickedColormap[0] );\n                var wc = (mouseManager.lasteClickedColormap[1] +  mouseManager.lasteClickedColormap[0] ) / 2;\n                var wcnew = wc - (stretchFacY * refRange * mouseManager.scaleFac * master.static.mousespeed_clims);\n                var wwnew = ww + (stretchFacX * refRange * mouseManager.scaleFac * master.static.mousespeed_clims);\n                var lnew = wcnew - wwnew / 2;\n                var rnew = wcnew + wwnew / 2;\n                var clim = [lnew, rnew];\n                signalhandler.send("climChange", {\n                    id: that.currentFileID,\n                    val: clim\n                });\n\n                if( 0 ) // press scroll wheel and slide --\x3e fast slice change \n                {\n                    var a = mouseManager.referenceSlice + stretchFacY * 0.3;\n                    that.setSlicePos( slicingDimOfArray, a)\n                }\n\n\n            }\n\n            if (mouseManager.whichbutton == 2 & !ev.ctrlKey & !ev.shiftKey)\n            {\n                var dy = mouseManager.referenceZoomOriginY + stretchFacY;\n                var dx = mouseManager.referenceZoomOriginX - stretchFacX;\n                if (worldLockedToMaster & master.globalCoordinates)                    \n                {\n                    signalhandler.send("setZoomLimsRelative", {\n                        zoomfac: that.zoomFac,\n                        delta: [dx - that.zoomOriginX, dy - that.zoomOriginY],\n                        sender: slicingDimOfWorld\n                    })\n                }\n                else\n                {\n                    setZoomLims([that.zoomFac, dy, dx]);   \n                }\n            }\n\n            if (mouseManager.whichbutton == 2 & !ev.ctrlKey & ev.shiftKey)\n            {\n                \n                var dy = mouseManager.referenceZoomOriginY + stretchFacY;\n                var dx = mouseManager.referenceZoomOriginX - stretchFacX;\n                setZoomLims([that.zoomFac, dy, dx]);\n            }\n\n            if (mouseManager.whichbutton == 0) // pan all images\n            {\n\n                if (ev.ctrlKey & !ev.shiftKey)\n                {\n                    var dy = mouseManager.referenceZoomOriginY + stretchFacY;\n                    var dx = mouseManager.referenceZoomOriginX - stretchFacX;\n                    if (worldLockedToMaster & master.globalCoordinates)                    \n                    {\n                        signalhandler.send("setZoomLimsRelative", {\n                            zoomfac: that.zoomFac,\n                            delta: [dx - that.zoomOriginX, dy - that.zoomOriginY],\n                            sender: slicingDimOfWorld\n                        })\n                    }\n                    else\n                    {\n                        setZoomLims([that.zoomFac, dy, dx]);   \n                    }\n\n                }\n                else if (!ev.ctrlKey & ev.shiftKey) // pan only this viewport\n                {\n\n                    {\n                        var dy = mouseManager.referenceZoomOriginY + stretchFacY;\n                        var dx = mouseManager.referenceZoomOriginX - stretchFacX;\n                        setZoomLims([that.zoomFac, dy, dx]);\n                    }\n                }\n                else \n                \n                if (ev.ctrlKey & ev.shiftKey) // show the time series of this point\n                {\n                    if (that.nii.sizes[3] > 1)\n                    {\n                        setWorldPosition(getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY));\n                        createTSeriesPinViewer(ev);\n                    }\n                }\n                else // move haircross\n                {\n                    setWorldPosition(getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY));\n                    signalhandler.send("positionChange",{respectSliceChange:that.atlas.length==0},that.positionChanger);\n\n                    if (markerProxy && markerProxy.draggedPoint !=undefined)\n                    {\n                        markerProxy.draggedPoint.obj.setsizeFromMouseEvent(0, mouseManager.lasteClickedPoint, [ev.clientX,ev.clientY], that, \'donotrecalc\' );\n                    }\n                }\n\n            }\n\n        }\n\n        \n        mouseManager.lasteMovedPoint[0] = ev.clientX;\n        mouseManager.lasteMovedPoint[1] = ev.clientY;\n    });\n\n\n    mouseManager.mouseup = function(ev, resetHandlersOnly)\n    {\n        if (mouseManager.cid_roipicker != undefined)\n        {\n            clearTimeout(mouseManager.cid_roipicker)\n            mouseManager.cid_roipicker = undefined;\n        }\n\n\n        $(document).off("mousemove mouseup mouseleave");\n        $(mouseManager.dom).off(\'mousemove mouseup mouseleave\');\n        $(mouseManager.dom).on(\'mousemove\',mouseManager.mousemove_default);\n        $(mouseManager.dom).on(\'mouseleave\', mouseManager.mouseleave_default);\n\n        createTSeriesPinViewer(\'close\');\n        \n        if(resetHandlersOnly)\n            return false;\n\n        if (that.currentROI != undefined && ev.ctrlKey && mouseManager.whichbutton == 2)\n        {\n              KViewer.roiTool.contextPicker(ev,that)\n        }            \n        else \n        if (that.currentROI != undefined & !ev.ctrlKey & !ev.shiftKey)\n        {\n            ev.buttons = mouseManager.whichbuttons;\n            \n            master.roiTool.modifyRoi(ev, that,function()\n            {\n                KViewer.roiTool.update3D(that.currentROI)\n                signalhandler.send("updateImage",{id:that.currentROI.fileID},that.imageupdater);\n            });\n        }\n        else\n        if ((mouseManager.whichbutton == 0 | (mouseManager.whichbutton == 2 && master.roiTool.isinstance && master.roiTool.enabled && master.roiTool.penEnabled)) & !ev.shiftKey & !ev.ctrlKey)\n            if (mouseManager.didMove)\n            {\n                setWorldPosition(getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY));\n                signalhandler.send("positionChange",{respectSliceChange:true},that.positionChanger);\n            }\n\n        if ((mouseManager.whichbutton == 0 | (mouseManager.whichbutton == 2 && master.roiTool.isinstance && master.roiTool.enabled && master.roiTool.penEnabled)) & !ev.shiftKey & !ev.ctrlKey)\n        {\n\n            if(markerProxy && markerProxy.draggedPoint !=undefined)\n            {\n                markerProxy.draggedPoint.obj.setsizeFromMouseEvent(0, mouseManager.lasteClickedPoint, [ev.clientX,ev.clientY], that, \'recalc\' );\n                markerProxy.setDraggedPoint();\n            }\n\n        }\n\n    }\n\n\n    $canvas.on(\'contextmenu\', function() {\n        return false;\n    });\n    $(mouseManager.dom).on(\'contextmenu\', function() {\n        return false;\n    });\n    $(mouseManager.dom).on(\'mousedown\', mouseManager.mousedown);\n    $(mouseManager.dom).on(\'mousemove\', mouseManager.mousemove_default);\n    $(mouseManager.dom).on(\'mouseleave\', mouseManager.mouseleave_default);\n\n    function containerWidth()\n    {\n        return viewport.$container.width();\n    }\n\n    function containerHeight()\n    {\n        return viewport.$container.height();\n    }\n\n    function getRelativeZoomLims()\n    {\n        return [that.zoomFac, that.zoomOriginY / containerHeight(), that.zoomOriginX / containerWidth()]\n    }\n    that.getRelativeZoomLims = getRelativeZoomLims;\n\n    function setZoom(fac)\n    {\n        if (that.nii == undefined)\n            return;\n        if (!gl_enabled)\n        {\n\n            var coords = getCanvasCoordinates(getWorldPosition());\n            var cx = coords.x_pix+math.round(that.widoffs_px * that.zoomFac - that.zoomOriginX);\n            var cy = coords.y_pix+math.round(that.heioffs_px * that.zoomFac - that.zoomOriginY);\n  \n            that.zoomFac = fac * that.zoomFac;\n\n            that.zoomOriginY = (that.zoomOriginY + cy) * fac - cy;\n            that.zoomOriginX = (that.zoomOriginX + cx) * fac - cx;\n            setGlobalZoomsLims();\n\n \n            setCanvasContainerPos();\n            drawHairCross();\n\n            renderOutlines("draw")\n\n\n            if (that.largeContent() | (that.lastPaint_lowres &&  !that.useLowres()  ))\n                drawSlice();\n\n            that.lastPaint_lowres = that.useLowres();\n\n\n        }\n    }\n    signalhandler.attach("setZoom", setZoom);\n\n    function setZoomLimsRelative(zl)\n    {\n        if (!gl_enabled)\n        {\n            var mapdelta = zl.delta;\n            if (slicingDimOfWorld != zl.sender)\n            {\n                if (zl.sender == 0)\n                {\n                    if (slicingDimOfWorld == 1)\n                        mapdelta = [0, zl.delta[1]];\n                    else\n                        mapdelta = [0, 0];\n                }\n                if (zl.sender == 1)\n                {\n                    if (slicingDimOfWorld == 2)\n                        mapdelta = [zl.delta[0], 0];\n                    else\n                        mapdelta = [0, zl.delta[1]];\n                }\n                if (zl.sender == 2)\n                {\n                    if (slicingDimOfWorld == 1)\n                        mapdelta = [zl.delta[0], 0];\n                    else\n                        mapdelta = [0, 0];\n                }\n            }\n\n\n            that.zoomFac = zl.zoomfac;\n            that.zoomOriginX = that.zoomOriginX + mapdelta[0];\n            that.zoomOriginY = that.zoomOriginY + mapdelta[1];\n            setGlobalZoomsLims();\n\n            setCanvasContainerPos();\n            drawHairCross();\n\n\n            if (that.largeContent())\n                drawSlice();            \n        }\n    }\n    signalhandler.attach("setZoomLimsRelative", setZoomLimsRelative);\n\n\n    function setGlobalZoomsLims()\n    {\n        master.zoomLims[slicingDimOfWorld] = [that.zoomFac, that.zoomOriginY, that.zoomOriginX];\n    }\n\n    function largeContent()\n    {\n        if (that.nii == undefined)\n            return false;\n        if (that.nii.datatype == \'rgb24\')\n            return false;\n        var threshold = 150000;\n        if (slicingDimOfArray == 2)\n            return that.nii.sizes[0]*that.nii.sizes[1] > threshold; // & that.nii.sizes[2] > 1;\n        else if (slicingDimOfArray == 1)\n            return that.nii.sizes[0]*that.nii.sizes[2] > threshold; // & that.nii.sizes[1] > 1;\n        else if (slicingDimOfArray == 0)\n            return that.nii.sizes[2]*that.nii.sizes[1] > threshold; // & that.nii.sizes[0] > 1;\n        \n        return false;\n\n    }\n    that.largeContent = largeContent;\n\n    function useLowres()\n    {   \n        if (that.nii.datatype == \'rgb24\' || that.isGLenabled())\n            return false;     \n        else\n            return that.$canvas.width()/csx < 1.2;\n    }\n    that.useLowres = useLowres;\n\n\n    function setZoomLims(zl,local)\n    {\n        if (!gl_enabled)\n        {\n            that.zoomFac = zl[0];\n            if (zl[1] != undefined)\n                that.zoomOriginY = zl[1];\n            if (zl[2] != undefined)\n                that.zoomOriginX = zl[2];\n            if (!(local != undefined & local))\n                setGlobalZoomsLims();\n\n            setCanvasContainerPos();\n            drawHairCross();\n            if (that.largeContent())\n                drawSlice();            \n        }\n    }\n    signalhandler.attach("setZoomLims", setZoomLims);\n\n\n    function MouseWheelHandler_(e)\n    {\n        if (gl_enabled)\n            return;\n        if (KViewer.zoomedViewport != -1 & !that.viewport.isZoomed())\n            return;\n\n\n        var e = window.event || e;\n        // old IE support\n        e.preventDefault();\n        if (that.nii == undefined)\n            return;\n        var nii = that.nii;\n\n        var amount = (e.wheelDelta || -e.detail);\n        if (e.ctrlKey)\n        {\n            if (that.mosaicview.active)\n            {\n                that.mosaicview.zoom += ((amount > 0) ? -1 : 1) * 0.3 * scrollSpeed * master.static.mousespeed_zoom;\n                if (that.mosaicview.zoom > 1)\n                    that.mosaicview.zoom = 1;\n                setCanvasLayout();\n                drawHairCross();\n\n            }\n            else if(markerProxy.currentSet && markerProxy.currentSet.type == \'scribble\' && markerProxy.currentSet.state.createonclick)\n            {\n                markerProxy.currentSet.markerPanel.scribbleTool.updateSpenRadius(e)\n            }\n            else\n            {\n                var fac = 1;\n                if (amount > 0)\n                    fac += 0.02 * scrollSpeed * master.static.mousespeed_zoom;\n                else\n                    fac -= 0.02 * scrollSpeed * master.static.mousespeed_zoom;\n                if (that.zoomFac * fac < 0.3)\n                    return;\n                $(".markerpoint,.markerruler").css(\'display\',\'none\')                    \n                if (worldLockedToMaster & master.globalCoordinates)                    \n                    signalhandler.send("setZoom", fac);\n                else\n                    setZoom(fac);\n       //         signalhandler.send("positionChange", {nosliceupdate:true});\n\n            }\n        }\n        else if (e.shiftKey)\n        {\n            if (master.roiTool.enabled) // shift +scroll in roi mode == change pencil size\n            {\n                e.myScrollAmount = master.static.mousespeed_roipensize * scrollSpeed * math.sign(e.wheelDelta || -e.detail);\n                master.roiTool.pensizechange(e, "radius", that);\n\n                if (!master.roiTool.regionGrow && master.roiTool.livepreview)\n                {\n                    e.roipreview = true;\n                    if (master.roiTool.lastPreviewPoints != undefined)\n                        ROIpreviewUpdate();\n                    master.roiTool.modifyRoi(e, that,function(changedPoints){                    \n                        signalhandler.send("updateImage",{id:that.currentROI.fileID,no3d:true,lazy:false},that.imageupdater);\n                        ROIpreviewUpdate.tobecleaned = true;\n                        master.roiTool.lastPreviewPoints = changedPoints;\n                        ROIpreviewUpdate();\n\n                    });\n                }\n            }\n            else\n            {\n                if (that.mosaicview.active)\n                {\n                    that.mosaicview.nx_cont += ((amount > 0) ? -1 : 1) * 0.3 * scrollSpeed;\n                    if (that.mosaicview.nx_cont < 2)\n                        that.mosaicview.nx_cont = 2;\n                    that.mosaicview.nx = Math.round(that.mosaicview.nx_cont);\n                    setCanvasLayout();\n                    drawHairCross();\n\n                }\n                else\n                {\n                    if( that.nii.numTimePoints > 1 )\n                        setCurrentTimePoint( parseInt(that.nii.currentTimePoint.t) + (amount > 0?1:-1)*scrollSpeed)\n                }\n            }\n\n        }\n        else\n        {\n\n            if (0) //(that.mosaicview.active)\n            {\n\n            }\n            else\n                that.handleSliceChange(slicingDimOfArray, amount)\n        }\n\n\n    }\n\n\n    that.handleSliceChange = function(slicingDimOfArray, amount,inc)\n    {\n        var nii = that.nii;\n        var temp = currentVoxel._data[slicingDimOfArray];\n        \n\tamount *= nii.arrayReadDirection[slicingDimOfArray];\n\n        if (amount > 0) {\n            if (inc != undefined)\n                temp += inc;\n            else\n                temp += Math.round(scrollSpeed * master.globalScrollSpeed);\n        } else {\n            if (inc != undefined)\n                temp -= inc;\n            else\n                temp -= Math.round(scrollSpeed * master.globalScrollSpeed);\n        }\n        currentVoxel._data[slicingDimOfArray] = temp;\n\n        var wasinrange = true;\n        if (currentVoxel._data[slicingDimOfArray] >= that.nii.sizes[slicingDimOfArray] - 0.0001 )\n        {\n            currentVoxel._data[slicingDimOfArray] = that.nii.sizes[slicingDimOfArray] - 1;\n            wasinrange = false;    \n        }\n        if (currentVoxel._data[slicingDimOfArray] < 0)\n        {\n            currentVoxel._data[slicingDimOfArray] = 0;\n            wasinrange = false;    \n        }\n        var realWorldCoordinates = (math.multiply((nii.edges), currentVoxel));\n        if (master.mainViewport !== -1)\n        {\n            realWorldCoordinates = math.multiply(master.reorientationMatrix.matrix, realWorldCoordinates);\n        }\n\n        if(!wasinrange)\n        {\n            if(that.$container.find(\'.KViewPort_sliceOutsideRange\').length == 0 )\n                var $stop = $("<div class=\'KViewPort_sliceOutsideRange\'>STOP</div>").appendTo(that.$container).fadeOut(850, function(){$stop.remove();}); ;\n        }\n\n        setWorldPosition(realWorldCoordinates);\n        signalhandler.send("positionChange",{respectSliceChange:true},that.positionChanger);\n\n    }\n\n    that.setSlicePos = function(slicingDimOfArray, pos)\n    {\n \n        var nii = that.nii;\n        var wasinrange = true;\n\n        if (pos > that.nii.sizes[slicingDimOfArray] - 1 - .000000001)\n        {\n            currentVoxel._data[slicingDimOfArray] = that.nii.sizes[slicingDimOfArray] - 1;\n            wasinrange = false;    \n        }\n        else if (pos < .0000001)\n        {\n            currentVoxel._data[slicingDimOfArray] = 0;\n            wasinrange = false;    \n        }\n        else\n        {\n            currentVoxel._data[slicingDimOfArray] = pos;\n            wasinrange = true;    \n\n        }\n\n        var realWorldCoordinates = (math.multiply((nii.edges), currentVoxel));\n        if (master.mainViewport !== -1)\n        {\n            realWorldCoordinates = math.multiply(master.reorientationMatrix.matrix, realWorldCoordinates);\n        }\n        setWorldPosition(realWorldCoordinates);\n        signalhandler.send("positionChange",{respectSliceChange:true},that.positionChanger);\n        \n        if(!wasinrange)\n        {\n            if(that.$container.find(\'.KViewPort_sliceOutsideRange\').length == 0 )\n                var $stop = $("<div class=\'KViewPort_sliceOutsideRange\'>STOP</div>").appendTo(that.$container).fadeOut(850, function(){$stop.remove();}); ;\n        }\n        return {wasinrange: wasinrange, value:  currentVoxel._data[slicingDimOfArray] };\n    }\n\n\n\n    ////////////////////////////// canvas//imaging layout //////////////////////////\n\n\n    function setSlicingDimOfWorld(sd)\n    {\n        if (sd === \'toggle\')\n        {\n            slicingDimOfWorld = ((slicingDimOfWorld + 1) % 3);\n        }\n        else if (sd != undefined)\n        {\n            slicingDimOfWorld = sd;\n        }\n \n        for (var k = 0; k < 3; k++)\n            if (slicingDimOfWorld == k)\n            {\n                toolbar.$sliceCubes[k].show();    \n                layoutbar.$sliceCubes[k].show();    \n            }\n            else\n            {\n                toolbar.$sliceCubes[k].hide();    \n                layoutbar.$sliceCubes[k].hide();    \n            }\n            \n\n        applySlicingDimOfWorld(slicingDimOfWorld);\n        setCanvasLayout();\n\n    \n        drawSlice();\n\n    }\n\n    function applySlicingDimOfWorld(slicingDimOfWorld)\n    {\n        var nii = that.nii;\n        if (nii == undefined)\n            return;\n\n        slicingDimOfArray = nii.permutationOrder.indexOf(slicingDimOfWorld);\n\n\n        if (slicingDimOfArray == 0) {\n            swapXY = (nii.permutationOrder[1] > nii.permutationOrder[2]) ? 1 : 0;\n            sx = nii.sizes[1];\n            sy = nii.sizes[2];\n            xdir = -nii.arrayReadDirection[1];\n            ydir = -nii.arrayReadDirection[2];\n            sliceAspectRatio = sx / sy * nii.voxSize[1] / nii.voxSize[2];\n            var voxSizeX = nii.voxSize[1];\n            var voxSizeY = nii.voxSize[2];\n\n        }\n\n        if (slicingDimOfArray == 1) {\n            swapXY = (nii.permutationOrder[0] > nii.permutationOrder[2]) ? 1 : 0;\n            sx = nii.sizes[0];\n            sy = nii.sizes[2];\n            xdir = -nii.arrayReadDirection[0];\n            ydir = -nii.arrayReadDirection[2];\n            sliceAspectRatio = sx / sy * nii.voxSize[0] / nii.voxSize[2];\n            var voxSizeX = nii.voxSize[0];\n            var voxSizeY = nii.voxSize[2];\n        }\n\n        if (slicingDimOfArray == 2) {\n            swapXY = (nii.permutationOrder[0] > nii.permutationOrder[1]) ? 1 : 0;\n            sx = nii.sizes[0];\n            sy = nii.sizes[1];\n            xdir = -nii.arrayReadDirection[0];\n            ydir = -nii.arrayReadDirection[1];\n            sliceAspectRatio = sx / sy * nii.voxSize[0] / nii.voxSize[1];\n            var voxSizeX = nii.voxSize[0];\n            var voxSizeY = nii.voxSize[1];\n        }\n        that.swapXY = swapXY;\n\n        xflip = xdir == 1 ? 0 : 1;\n        yflip = ydir == 1 ? 0 : 1;\n\n\n        var asx, asy;\n        asx = swapXY ? sy : sx;\n        asy = swapXY ? sx : sy;\n\n        csx = asx;\n        csy = asy;\n        that.embedfac_width = asx / csx;\n        that.embedfac_height = asy / csy;\n\n\n        voxSize_x = swapXY ? voxSizeY : voxSizeX;\n        voxSize_y = swapXY ? voxSizeX : voxSizeY;\n        wid_cm = voxSize_x * csx;\n        hei_cm = voxSize_y * csy;\n\n    }\n\n    function applySlicingDimOfArray(d)\n    {\n        //slicingDimOfArray = slicingDimOfArray_;\n        slicingDimOfWorld = that.nii.permutationOrder[d];\n        applySlicingDimOfWorld(slicingDimOfWorld)\n    }\n\n\n\n    ///////////////////// mosaic ////////////////////////////////////////////////////\n\n    that.mosaicview = KMosaicView(that);\n    that.mosaicview.$sliderdiv.appendTo($topRow).hide();\n\n\n    ///////////////////// setCanvasLayaout //////////////////////////////////////////\n\n\n    var container_width_old;\n    var container_height_old;\n    function setCanvasLayout()\n    {\n        var $ref = viewport.isZoomed() ? master.$zoomedPortContainer : viewport.$container;\n     \n        $container.width($ref.width());\n        $container.height($ref.height());\n        if (ViewerSettings.pixelated)\n            $canvas.addClass(\'KViewPort_canvas_pixelated\');\n        else\n            $canvas.removeClass(\'KViewPort_canvas_pixelated\');\n\n        if (that.nii != undefined)\n        {\n            var nii = that.nii;\n            if (master.defaultFOV_mm == "")\n            {\n                var ext = [nii.sizes[0] * nii.voxSize[0], nii.sizes[1] * nii.voxSize[1], nii.sizes[2] * nii.voxSize[2]];\n                master.defaultFOV_mm = Math.max.apply(null , ext);\n            }\n            \n            /* this should go somewhere else, best into nifti conversion\n            if (that.nii.singleSlice)\n            {\n                that.nii.singleSlice = true;\n                $canvas.css(\'transform\', \'scale(1, -1)\');\n            }\n            else\n            {\n                $canvas.css(\'transform\', \'scale(1, 1)\');\n            }\n            */\n        }\n\n\n\n        if (gl == undefined & gl_enabled)\n        {\n            gl = new KMedImg3D(that,$canvas3D);\n            that.gl = gl;\n        }\n\n\n        if (gl_enabled & (that.nii != undefined | that.objects3D.length > 0))\n        {\n            //$canvascontainer.css({height: "100%", width: "100%", top:0, left:0});\n            that.mosaicview.hideControls();\n            $canvascontainer.hide();\n\n            $canvas3D.show();\n\n\n            $canvas3D.css({\n                height: "100%",\n                width: "100%",\n                top: 0,\n                left: 0\n            });\n\n            gl.updateLayout();\n            gl.engine.resize();\n            $scrollAccelerator.hide();\n            signalhandler.send("canvasLayoutChanged", that.viewport);\n  \n        }\n\n        if (that.nii != undefined & !gl_enabled)\n        {\n            $canvascontainer.show();\n\n            $LeftRightSign.css({\n                top: $container.offset().top + math.floor($container.height() / 2) - 90 + \'px\'\n            });\n            var nii = that.nii;\n            //  want to see at least the defaultFOVwidth_mm, no matter if width or height\n            var fac;\n\n\n            if ($container[0].offsetWidth < $container[0].offsetHeight)\n                fac = $container[0].offsetWidth / master.defaultFOV_mm;\n            else\n                fac = $container[0].offsetHeight / master.defaultFOV_mm;\n\n            that.wid_px = wid_cm * fac;\n            that.hei_px = hei_cm * fac;\n\n\n            // we need this to have intuitive scaling during viewerresize\n            if (container_width_old != undefined && container_width_old > 0 && container_height_old > 0)\n            {\n                var facX = $container[0].offsetWidth / container_width_old;\n                var facY = $container[0].offsetHeight / container_height_old;\n                that.zoomOriginX *= facX;\n                that.zoomOriginY *= facY\n                if (master.zoomLims[slicingDimOfWorld] != undefined && (that.zoomOriginX != 0 || that.zoomOriginX != 0))\n                {\n                    if (facX != 1 | facY != 1)\n                    {\n                        master.zoomLims[slicingDimOfWorld][1] = that.zoomOriginY;\n                        master.zoomLims[slicingDimOfWorld][2] = that.zoomOriginX;\n                    }\n                    else\n                    {\n                        that.zoomOriginY = master.zoomLims[slicingDimOfWorld][1]\n                        that.zoomOriginX = master.zoomLims[slicingDimOfWorld][2]\n                    }\n                }\n\n\n            }\n\n\n            container_width_old = $container[0].offsetWidth;\n            container_height_old = $container[0].offsetHeight;\n\n\n            that.embedrelfac = fac;\n\n            var orig = math.multiply(math.inv(nii.edges), master.viewcenter);\n            var origin = math.matrix([((nii.arrayReadDirection[0] == 1) ? (nii.sizes[0] - orig._data[0] - 0.5) : (0.5 + orig._data[0])) * nii.voxSize[0],\n            ((nii.arrayReadDirection[1] == 1) ? (nii.sizes[1] - orig._data[1] - 0.5) : (0.5 + orig._data[1])) * nii.voxSize[1],\n            ((nii.arrayReadDirection[2] == 1) ? (nii.sizes[2] - orig._data[2] - 0.5) : (0.5 + orig._data[2])) * nii.voxSize[2]]);\n\n            var idx = [[0, 1, 2]];\n            idx[nii.permutationOrder[0]] = 0;\n            idx[nii.permutationOrder[1]] = 1;\n            idx[nii.permutationOrder[2]] = 2;\n\n\n\n            if (slicingDimOfWorld == 0)\n            {\n                that.widoffs_px = -origin._data[idx[1]] * fac + $container.width() / 2;\n                that.heioffs_px = -origin._data[idx[2]] * fac + $container.height() / 2;\n            }\n            if (slicingDimOfWorld == 1)\n            {\n                that.widoffs_px = -origin._data[idx[0]] * fac + $container.width() / 2;\n                that.heioffs_px = -origin._data[idx[2]] * fac + $container.height() / 2;\n            }\n            if (slicingDimOfWorld == 2)\n            {\n                that.widoffs_px = -origin._data[idx[0]] * fac + $container.width() / 2;\n                that.heioffs_px = -origin._data[idx[1]] * fac + $container.height() / 2;\n            }\n\n\n\n            if (that.mosaicview.active)\n            {\n                that.mosaicview.showControls();\n                var sx_, sy_, sz_;\n\n                var perm = [];\n                if (slicingDimOfArray == 0)\n                    perm = [1, 2, 0];\n                if (slicingDimOfArray == 1)\n                    perm = [0, 2, 1];\n                if (slicingDimOfArray == 2)\n                    perm = [0, 1, 2];\n                var sz_ = that.nii.sizes[perm[2]];\n                that.mosaicview.current_sz_ = sz_;\n                that.mosaicview.current_readDir = -that.nii.arrayReadDirection[perm[2]];\n\n                var vasp = that.nii.voxSize[perm[0]] / that.nii.voxSize[perm[1]];\n\n\n                that.mosaicview.clipratio = 0.1 * (1 - that.mosaicview.zoom);\n\n                var csx_ = math.floor((1 - that.mosaicview.clipratio) * csx);\n                var csy_ = math.floor((1 - that.mosaicview.clipratio) * csy);\n\n                that.mosaicview.csx_ = csx_;\n                that.mosaicview.csy_ = csy_;\n\n\n                var height = Math.round(vasp * csx_ * that.mosaicview.nx / $container.width() * $container.height());\n                that.mosaicview.ny = Math.floor(height / csy_);\n                if (that.mosaicview.numrows != undefined)\n                    that.mosaicview.ny = that.mosaicview.numrows;\n                that.mosaicview.ny_div = height / csy_;\n\n                that.mosaicview.z0 = Math.round(that.mosaicview.start * sz_);\n                that.mosaicview.dz =((that.mosaicview.end - that.mosaicview.start) * sz_ / (that.mosaicview.nx * that.mosaicview.ny -1));\n\n                that.mosaicview.dz = (that.mosaicview.dz < 1) ? 1 : that.mosaicview.dz;\n\n\n                var width = csx_ * that.mosaicview.nx;\n\n\n\n                ctx.canvas.width = width;\n                ctx.canvas.height = height;\n\n                var nrow = math.floor(that.mosaicview.ny + 0.5);\n\n                var nrow_ = (sz_ - that.mosaicview.z0) / that.mosaicview.dz / that.mosaicview.nx;\n                if (nrow > nrow_)\n                    nrow = nrow_;\n\n\n                var top = $container.height() / ctx.canvas.height *\n                (ctx.canvas.height - nrow * csy_) / 2;\n                if (top < 0)\n                    top = 0;\n\n\n                $canvascontainer.css({\n                    height: math.round($container.height()) + \'px\',\n                    width: math.round($container.width()) + \'px\',\n                    top: top + \'px\',\n                    left: math.round(0) + \'px\'\n                });\n\n\n\n                that.mosaicview.draw = function(slicedrawer)\n                {\n                    if (that.mosaicview.interval != -1)\n                        clearInterval(that.mosaicview.interval);\n\n\n\n\n                    that.$topRow.find(".mosaiclabels").remove();\n                    var z = that.mosaicview.z0;\n                    for (var y = 0; y < that.mosaicview.ny; y++)\n                        for (var x = 0; x < that.mosaicview.nx; x++)\n                        {\n                            var p = [0,0,0,1];\n                            if (that.mosaicview.current_readDir == -1)\n                                p[perm[2]] = sz_ - z;\n                            else\n                                p[perm[2]] = z;\n                            p = math.multiply(that.nii.edges,p)._data;\n\n                            var $d = $("<div class=\'mosaiclabels\'> "+ Math.round(p[slicingDimOfWorld]) +" </div>");\n                            $d.css(\'left\',10+x/that.mosaicview.nx*$container.width());\n                            $d.css(\'top\',10+top+ y*csy_* $container.height() / ctx.canvas.height);\n                            that.$topRow.append($d);\n                            z+=that.mosaicview.dz;\n                        }\n\n\n\n\n                    var z = that.mosaicview.z0;\n                    var done = false;\n                    var y = 0;\n                    var x = 0;\n\n\n                    if (master.static.lazydraw_timeout == 0 || typeof eagerDrawActive != "undefined")\n                    {\n                           while(true)\n                           {\n                               iterateOverMosaic();\n                               if (y >= that.mosaicview.ny - 0.5 | z > sz_)\n                                break;\n                           }\n                           \n                    }\n                    else\n                        that.mosaicview.interval = setInterval(function()\n                        {\n                            if (that.nii == undefined)\n                            {\n                                clearInterval(that.mosaicview.interval);\n                                that.mosaicview.interval = -1;\n                                return;\n                            }\n                            iterateOverMosaic()\n                            if (y >= that.mosaicview.ny - 0.5 | z > sz_)\n                            {\n                                clearInterval(that.mosaicview.interval);\n                                that.mosaicview.interval = -1;\n                            }\n\n\n                        }, 0);\n\n\n\n\n                    function iterateOverMosaic()\n                    {\n                        sliceData = ctx.createImageData(csx_, csy_);\n                        var dir = that.nii.arrayReadDirection[that.getSlicingDimOfArray()] == -1;\n                        if (that.mosaicview.mosaic_direction)\n                            dir = !dir;\n                        if (dir)\n                            slicedrawer(Math.round(z), that.mosaicview.clipratio);\n                        else\n                            slicedrawer(Math.round(sz_-z), that.mosaicview.clipratio);\n                        z += that.mosaicview.dz;\n                        ctx.putImageData(sliceData, x * csx_, y * csy_);\n\n                        if (++x >= that.mosaicview.nx)\n                        {\n                            x = 0;\n                            y++;\n                        }\n                    }\n\n/*\n                    that.mosaicview.interval = setInterval(function()\n                    {\n                        if (that.nii == undefined)\n                        {\n                            clearInterval(that.mosaicview.interval);\n                            that.mosaicview.interval = -1;\n                            return;\n                        }\n\n                        sliceData = ctx.createImageData(csx_, csy_);\n                        if (that.nii.arrayReadDirection[that.getSlicingDimOfArray()] == -1)\n                            slicedrawer(z, that.mosaicview.clipratio);\n                        else\n                            slicedrawer(sz_-z, that.mosaicview.clipratio);\n                        z += that.mosaicview.dz;\n                        ctx.putImageData(sliceData, x * csx_, y * csy_);\n\n                        if (++x >= that.mosaicview.nx)\n                        {\n                            x = 0;\n                            y++;\n                        }\n\n\n                        if (y >= that.mosaicview.ny - 0.5 | z > sz_)\n                        {\n                            clearInterval(that.mosaicview.interval);\n                            that.mosaicview.interval = -1;\n                        }\n\n\n                    }, 0);\n*/\n\n                }\n                if (master.mainViewport != -1)\n                    that.mosaicview.draw(drawSlice_interpolate);\n                else\n                    that.mosaicview.draw(drawSlice_normal);\n\n            }\n            else\n            {\n\n\n                that.mosaicview.hideControls()\n\n                if (ctx.canvas.height != csy)\n                    ctx.canvas.height = csy;\n                if (ctx.canvas.width != csx)\n                    ctx.canvas.width = csx;\n\n//qwe\n/*\n                if (ctx.canvas.height != csy/2)\n                    ctx.canvas.height = csy/2;\n                if (ctx.canvas.width != csx/2)\n                    ctx.canvas.width = csx/2;\n*/\n     \n\n               drawHairCross();\n                setCanvasContainerPos()\n            }\n\n            // set the distances of the mover / rotator lines\n            var siz = that.$container.width();\n            var hei = that.$container.height();\n            if(siz > hei)\n                siz = hei;\n\n            haircross.X.lineN.setsizes(siz);\n            haircross.Y.lineN.setsizes(siz);\n    \n            $canvas.show();\n            signalhandler.send("canvasLayoutChanged", that.viewport);\n\n\t\n\n        }\n        histoManager.layoutHistogram();\n    }\n\n    function setCanvasContainerPos()\n    {\n        if (that.mosaicview.active)\n        {\n        /*   $canvascontainer.css({height: math.round($container.height())  + \'px\', \n                                  width:  math.round($container.width())   + \'px\', \n                                  top:    math.round(0) + \'px\',\n                                  left:   math.round(0) + \'px\'});*/\n        }\n        else\n        {\n\n//qwe\n            \n            quiver.draw();\n            $canvascontainer.css({\n                height: math.round(that.hei_px * that.zoomFac ) + \'px\',\n                width: math.round(that.wid_px * that.zoomFac ) + \'px\',\n                top: math.round(that.heioffs_px * that.zoomFac - that.zoomOriginY) + \'px\',\n                left: math.round(that.widoffs_px * that.zoomFac - that.zoomOriginX) + \'px\'\n            });\n        }\n\n    }\n\n\n    function createOverlay(imageStruct,intent)\n    {\n\n        var ovl = {\n            type: \'overlay\',\n            nii: imageStruct.content,\n            content: imageStruct,\n            visible: true,\n            showcolored: false,\n            \n            showcolored_type :"RGB",\n            currentFilename: imageStruct.filename,\n            currentFileinfo: imageStruct.fileinfo,\n            fileinfo: imageStruct.fileinfo,\n            currentFileID: imageStruct.fileID,\n        };\n        ovl.histoManager = createHistoManager(ovl);\n        ovl.toggle = function(e)\n        {\n            var vis = !ovl.visible;\n            if (!e.shiftKey)\n            {\n                master.iterateMedViewers(function(m)\n                {\n                    for (var k = 0; k < m.overlays.length; k++)\n                        if (ovl.currentFileID == m.overlays[k].currentFileID)\n                        {\n                            m.overlays[k].setVisibility(vis)\n                            break;\n                        }\n\n                });            \n            }\n            else\n                ovl.setVisibility(vis)\n        }\n\n        ovl.setVisibility = function(visible)\n        {\n            if (!visible)\n            {\n                ovl.visible = false;\n                ovl.eye.css(\'color\', \'red\');\n                if (ovl.refSurfView != undefined)\n                {\n                   ovl.refSurfView.visible = false;\n                   ovl.refSurfView.update();\n                }\n                if (ovl.surfacecolref)\n                    ovl.surfacecolref.update();\n\n            }\n            else\n            {\n                ovl.visible = true;\n                ovl.eye.css(\'color\', \'\');\n                if (ovl.refSurfView != undefined)\n                {\n                   ovl.refSurfView.visible = true;\n                   ovl.refSurfView.update();\n                }\n                if (ovl.surfacecolref)\n                    ovl.surfacecolref.update();\n            }\n            that.drawSlice({\n                mosaicdraw: true\n            });\n        }\n\n\n\n        ovl.setOutlines = function(visible,ev)\n        {\n\n                if (visible)\n                {\n                    if (ovl.outlines == undefined)\n                        ovl.outlines = Outlines(ovl);\n\n                    if (ovl.color == undefined && ev != undefined)\n                       ovl.chooseContColor(ev);\n                    else\n                        ovl.outlines.update(that);\n\n                }\n                else\n                {\n                    if (ovl.outlines != undefined)\n                    {\n                        ovl.outlines.close();\n                        ovl.outlines = undefined;\n                    }\n                }\n\n        }\n \n       ovl.chooseContColor = function(ev)\n        {\n\n              if (ovl.color == undefined)\n                ovl.color = 0;\n\n            var colors = KColor.list;\n\n            function colencode(c) {\n                return "background:" + RGB2HTML(c[0], c[1], c[2]) + ";";\n                }\n              var $colselector = KColorSelector(colors, colencode,\n                function() { \n                    ovl.outlines.update(that);                  \n                    if (!ev.shiftKey)\n                         master.iterateMedViewers(function(m)\n                         {\n                            for (var k = 0; k < m.overlays.length; k++)\n                                if (ovl.currentFileID == m.overlays[k].currentFileID)\n                                {\n                                    if (m.overlays[k].outlines != undefined)\n                                    {\n                                        m.overlays[k].color = ovl.color;\n                                        m.overlays[k].outlines.update(m);    \n                                    }\n                                    break;\n                                }\n\n                         });            \n\n                }, ovl);\n\n            $colselector.themenu(ev);\n\n\n            ovl.outlines.update(that);                  \n\n        }\n\n\n        function close()\n        {\n\n            for (var k = 0; k < ovl.divs.length; k++)\n                ovl.divs[k].remove();\n\n            ovl.histoManager.remove();\n\n            if (movieIsPlayed)\n                toggleMovie();\n            //$timediv.hide();\n            $timediv.update();\n\n           if (ovl.refSurfView != undefined)\n            {\n                signalhandler.detach("overlay_climChange",ovl.refSurfView.surf.clim_updater);\n                ovl.refSurfView.close();\n                ovl.refSurfView = undefined;\n \n            }\n\n\n            if (ovl.outlines != undefined)\n              {\n                    ovl.outlines.close();\n                    ovl.outlines = undefined;\n              }\n\n\n            signalhandler.send("layoutHisto");\n\n            if (ovl.customClose)\n            {\n                ovl.customClose();\n                return;\n            }\n\n\n            quiver.clear();\n\n            for (var k = 0; k < that.overlays.length; k++)\n            {\n                if (ovl == that.overlays[k])\n                {\n                    that.overlays.splice(k, 1);\n                    break;\n                }\n            }\n\n            that.removeQuiver(ovl.histoManager);\n\n            if (that.nii)\n                that.drawSlice({\n                    mosaicdraw: true\n                });\n\n            that.toolbar.update(\'overlay\')\n         \n        }\n        var filenameToShow;\n        if (ovl.currentFileinfo.SubFolder==undefined)\n            filenameToShow = "<b>" + ovl.currentFilename + "</b>";\n        else\n            filenameToShow = ovl.currentFileinfo.SubFolder+ "/<b>" + ovl.currentFilename + "</b>";\n\n        var mlen = 40;\n        if (filenameToShow.length > mlen)\n        {\n            filenameToShow = "..." + filenameToShow.substring(filenameToShow.length-mlen);\n        }\n\n        var $dragdiv, $quiverdiv, $captiondiv,$createIso,$createFib;\n        ovl.divs = [\n            $("<br style=\'clear:both\' />"),\n            $("<div  class=\'KViewPort_tool overlay persistent\'>  <i class=\'fa fa-close fa-1x\'></i></div>").appendTooltip("closeOVL")\n            .click(close).mousedown(viewport.closeContextMenu(ovl)),\n            $quiverdiv = $("<div  class=\'KViewPort_tool overlay\'>  <i class=\'fa fa-code-fork fa-1x\'> </div>").click(function(e) {\n                quiver.menu(e,ovl)\n            }).appendTooltip("quiverprops"),\n\n            ovl.eye = $("<div  class=\'KViewPort_tool overlay\'>  <i class=\'fa fa-eye fa-1x\'></i></div>").appendTooltip("showhide")\n            .click(function(e) {\n                ovl.toggle(e);\n            }),\n            $("<div  class=\'KViewPort_tool overlay\'>  <i class=\'fa fa-cog fa-1x\'> </div>").appendTooltip("createroi")\n            .click(ROIadder(ovl))\n            .click(function() {\n            // master.roiTool.pushROI(ovl.currentFileID,"untitled","upper"+ovl.histoManager.clim[0]);\n            }),\n            $createIso = $("<div  class=\'KViewPort_tool overlay\'>  <i class=\'fa fa-1x\'>3D</i></div>").appendTooltip("isosurf").hide(),                                 \n            $createFib = $("<div  class=\'KViewPort_tool overlay\'>  <i class=\'fa fa-tree fa-1x\'></i></div>").appendTooltip("isosurf").hide(),                                 \n            $captiondiv = $("<div  class=\'KViewPort_tool fibers caption\'> " +filenameToShow + "</div>"),\n            $("<div  class=\'KViewPort_tool KViewPort_tool_cmap overlay\'>  <i class=\'fa fa-empty fa-1x\'>&nbsp&nbsp&nbsp&nbsp</i></div>").appendTooltip("changecolormap")\n            .click(ovl.histoManager.cmapSelectorMenu),\n            $dragdiv = $("<div  class=\'KViewPort_tool draganddrop\'>  <i class=\'fa fa-hand-paper-o fa-1x\'></i></div>").appendTooltip("dragdropviewport"),\n        ];\n\n        if(ovl.nii.numTimePoints > 1)\n        {\n            var $timesliderDIV = $("<div  class=\'KViewPort_tool roi\' style=\'padding:0px;height:21px\'> </div>");\n            var $timeinput = $("<input class=\'KViewPort_roiview_timeindicator KViewPort_tool roi\' value=\'0\' min=\'0\'  style_=\'display:inline-block;width:25px\'  class=\'KViewPort_tool roi\' />").appendTo($timesliderDIV)\n                .on(\'change\', function(){ \n                    ovl.nii.currentTimePoint.t = $(this).val()   \n                    signalhandler.send("updateImage",{id: ovl.content.fileID});\n                });\n            function timeinputwheel(ev, delta) { ev = ev.originalEvent || ev;var newval = parseInt($(this).val())+((ev.wheelDelta>0)?1:-1);if(newval >= 0 && newval <ovl.nii.numTimePoints) {$(this).val( newval ); $(this).trigger(\'change\'); }ev.stopPropagation(); return false;  }\n            $timeinput.bind("mousewheel", timeinputwheel);\n                \n            ovl.divs.splice(2, 0, $timesliderDIV);    \n            ovl.$timeinput = $timeinput;\n        }    \n\n\n\n        ovl.$captiondiv = $captiondiv;\n        $captiondiv.on(\'mouseenter\',function(){\t\t\t\n               if (ovl.refSurfView)\n               {\n                   var obj = ovl.refSurfView;\n                   obj.alphaMode = (obj.alphaMode+1)%6;\n                   obj.update();\n               }\n        });\n        $captiondiv.on(\'mouseleave\',function(){\t\n               if (ovl.refSurfView)\n               {\n                   var obj = ovl.refSurfView;\n                   obj.alphaMode = (obj.alphaMode+5)%6;\n                   obj.update();\n               }\n        });\n        $captiondiv.on(\'mousedown\',function(ev){\t\t\n            if (ev.button == 2)\n                showInfoContextNifti(ovl,ev)                \n        });\n\n\n        if (interpretAsColoredVolume(ovl.nii,ovl))\n        {\n            ovl.showcolored = true;\n            $createFib.click(function(ev) {  \n                if (that.isGLenabled())\n                    createfibview()\n                else\n                    toggle3D(undefined,createfibview);\n                function createfibview()\n                {\n                    var filename = ovl.currentFilename.replace(".nii","").replace(".gz","") + ".tck";\n                    var imageStruct = {filename:filename,content:{tracts:[  ]} }     ;     \n                    var fv = master.obj3dTool.createFiberView(imageStruct,that,{ dirvolref: ovl,isParentView:true });\n                    that.objects3D.push(fv);\n                }\n\n            });\n        }\n        else\n        {\n            $createFib.hide();\n               ovl.showcolored = false;\n        }\n\n\n\n         $createIso.click(function(ev) {            \n            if ($createIso.onhold)\n            {\n                $createIso.onhold = undefined;\n                return;\n            }\n            that.attachSurfaceRef(ovl,imageStruct);\n        });\n\n        $createIso.mousedown(function(ev)\n        {\n            if (ovl.refSurfView && !ovl.refSurfView.toolbarAttached)\n            {\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n                var id = setTimeout(function()\n                {\n                    $createIso.onhold = true;\n                    that.toolbar.append(ovl.refSurfView.divs,\'surface\')\n                    ovl.refSurfView.toolbarAttached = true;\n\n                },500);            \n                $createIso.on("mouseleave mouseup",function(ev)\n                {\n                     clearTimeout(id);\n                     $createIso.off("mouseleave mouseup");\n                });\n            }\n\n        }    );\n\n        if (imageStruct.editable)\n        {\n            attachNameDivHandler(imageStruct, $captiondiv, KViewer.cacheManager.update);\n\n            var $savediv = $("<div  class=\'KViewPort_tool overlay\'>  <i class=\'fa fa-save fa-1x\'></i></div>")\n            .appendTooltip("saveovl").click(function(o) {\n                return function() {\n                    tempObjectInfo = [{\n                        type: \'file\',\n                        sid: imageStruct.fileinfo.studies_id,\n                        piz: imageStruct.fileinfo.patients_id,\n                        subfolder: \'\',\n                        tag: \'\',\n                        mime: \'nii\',\n                        filename: imageStruct.filename,\n                        fileID: imageStruct.fileID\n                    }];\n                    KViewer.cacheManager.uploadFiles(that.viewport.progressSpinner, \'usenativeID\');\n\n                }\n            }(ovl));\n            ovl.divs.splice(2, 0, $savediv);\n\n        }\n\n\n        if ( ! (intent != undefined && intent.hideview ) )\n             toolbar.append(ovl.divs, "overlay");\n        else\n             ovl.hideview = true;\n\n        ovl.quiverdiv = $quiverdiv;\n        $dragdiv.attr("draggable", \'true\');\n        $dragdiv.on("dragstart", dragstarter(function() {\n            return {\n                type: \'file\',\n                mime: \'nii\',\n                filename: ovl.currentFilename,\n                fileID: ovl.currentFileID,\n                intent: {\n                    outlines:(ovl.outlines==undefined?undefined:ovl.color),\n                    overlay: true,\n                    cmap: ovl.histoManager.cmapindex,\n                    clim: ovl.histoManager.clim\n                },\n                close: close\n            }\n        }));\n\n\n\n\n\n\n        if (interpretAsColoredVolume(ovl.nii,ovl))\n        {\n            that.addQuiver(ovl.histoManager);\n            $quiverdiv.show();\n        }\n        else\n            $quiverdiv.hide();\n\n        ovl.histoManager.name = imageStruct.filename;\n        ovl.histoManager.cmapindex = 1;\n\n        ovl.histoManager.blending = true;\n        ovl.histoManager.nii = ovl.nii;\n        ovl.histoManager.setColorMapLims = function(clim)\n        {\n            ovl.histoManager.clim = clim.slice(0);\n            ovl.histoManager.updateHistogramClim();\n            that.drawSlice({\n                mosaicdraw: true\n            });\n        }\n\n\n\n        if (KViewer.defaults.overlay)\n        {\n            var d = KViewer.defaults.overlay;\n            if (d.cmapindex != undefined)            \n                ovl.histoManager.cmapindex = d.cmapindex;\n            if (d.clim != undefined)            \n                 ovl.histoManager.setColorMapLims(d.clim);\n        }\n\n\n        if(state.viewer.showOutlinesOverlay)\n            ovl.outlines = Outlines(ovl);\n\n\n        ovl.histoManager.onclimchange =\n        function(ev)\n        {\n            signalhandler.send("overlay_climChange", {\n                id: ovl.currentFileID,\n                val: ovl.histoManager.clim,\n                ev: ev\n            });\n        }\n\n        signalhandler.attach("overlay_climChange",\n        function(event)\n        {\n            if (event.id == ovl.currentFileID)\n            {\n                ovl.histoManager.setColorMapLims(event.val);\n                ovl.histoManager.clim_manually_modified = true;          \n            }\n        });\n\n        ovl.histoManager.oncmapchange =\n        function(ev)\n        {\n            signalhandler.send("overlay_cmapChange", {\n                id: ovl.currentFileID,\n                blend: ovl.histoManager.blending,\n                cval: ovl.histoManager.cmapindex,\n                ev: ev\n            });\n        }\n\n        signalhandler.attach("overlay_cmapChange",\n        function(event)\n        {\n            if (event.id == ovl.currentFileID)\n            {\n                if (ovl.histoManager.cmapindex != event.cval)\n                {\n                    ovl.histoManager.setCmap(event.cval);\n                    that.drawSlice({\n                        mosaicdraw: true\n                    });\n                }\n                if (ovl.histoManager.blending != event.blend)\n                {\n                    ovl.histoManager.blending = event.blend;\n                    that.drawSlice({\n                        mosaicdraw: true\n                    });\n                }\n            }\n        });\n\n        ovl.close = close;\n        return ovl;\n\n    }\n\n\n    function appendObject3D(imageStruct, intent)\n    {\n        var fv = master.obj3dTool.createView(imageStruct, that, intent);\n        that.objects3D.push(fv);\n        KViewer.obj3dTool.addObject(imageStruct);\n\n        if (imageStruct.contentType == \'gii\')\n            signalhandler.send(\'surfcoldrop_\' + that.viewport.viewPortID);\n\n\n        return fv;\n    }\n    that.appendObject3D = appendObject3D;\n\n\n    var exTimeout = function(fun,time)\n    {\n        if (fun.id !== undefined)\n            clearTimeout(fun.id);\n        fun.id = setTimeout(fun,time);\t\t\t\t\t\n\n    }\n\n\n    function attachSurfaceRef(obj,fobj,progress,intent)\n    {\n        var viewer = that;\n        if (obj.refSurfView == undefined)\n        {\n            $(this).addClass("current");\n            function loadSurfIntoViewport(fobj)\n            {\n                function append() {\n                    var alreadyInVP = false;\n                    for (var k = 0; k < viewer.objects3D.length; k++)\n                        if ( fobj.fileinfo.surfreference != undefined && viewer.objects3D[k].surf == fobj.fileinfo.surfreference)\n                        {\n                            alreadyInVP = true;\n                            break;\n                        }\n                    if (!alreadyInVP)\n                    {\n                        var curRoiView = obj;\n                        var intent_iso = {\n                            color: curRoiView.color,\n                            visible: obj.visible\n                        };\n                        if (intent != undefined)\n                            intent_iso = $.extend(intent_iso,intent);\n                        var surfView = viewer.appendObject3D(fobj,intent_iso);\n                            \n                        curRoiView.refSurfView = surfView;\n                        surfView.refRoiView = curRoiView;\n                    }\n                }\n\n                if (obj.type == \'overlay\' | obj.type == \'mainview\')\n                {\n                    fobj.toolbar_visible = false;\n                    var which_clim = ""\n                    if (obj.type == \'overlay\')\n                        which_clim = "overlay_"\n                    else\n                    {\n                        fobj.toolbar_visible = true;\n                    }\n                    fobj.clim_updater =\n                        signalhandler.attach(which_clim + "climChange",\n                         function(event)\n                            {\n                                if (event.ev != undefined && event.ev.type == \'mousemove\')\n                                    return;\n                                if (event.id == obj.currentFileID)\n                                {\n                                      KViewer.roiTool.update3D(obj,that.viewport.progressSpinner);\n                                }\n                            } );\n                }                            \n\n\n                if (!viewer.isGLenabled())\n                    viewer.toggle3D(undefined, append);\n                else\n                    append();\n            }\n\n            var thres;\n            if (obj.type == \'overlay\' || obj.type == \'mainview\')\n                thres = obj.histoManager.clim[0];\n\n            if (fobj.fileinfo.surfreference == undefined)\n                KViewer.obj3dTool.createSurfaceFromROI(fobj, function() {\n                    KViewer.dataManager.setFile(fobj.fileinfo.surfreference.fileID,fobj.fileinfo.surfreference);\n                    KViewer.cacheManager.update();\n                    loadSurfIntoViewport(fobj.fileinfo.surfreference); } ,thres,that.viewport.progressSpinner);\n            else\n            {\n                loadSurfIntoViewport(fobj.fileinfo.surfreference);\n                //KViewer.roiTool.update3D(obj,that.viewport.progressSpinner);\n//                loadSurfIntoViewport(fobj.fileinfo.surfreference);\n            }\n           \n        }\n        else\n        {\n            if (obj.fileinfo)\n                obj.fileinfo.surfreference = undefined;\n            if (obj.roi && obj.roi.fileinfo)\n               obj.roi.fileinfo.surfreference = undefined;\n            KViewer.dataManager.delFile(obj.refSurfView.surf.fileID);\n            KViewer.cacheManager.update();\n            if (obj.refSurfView.surf.clim_updater)\n            {\n                var which_clim = ""\n                if (obj.type == \'overlay\')\n                    which_clim = "overlay_"\n                signalhandler.detach(which_clim + "climChange",obj.refSurfView.surf.clim_updater);\n            }\n            obj.refSurfView.close();\n            obj.refSurfView = undefined;\n            //fobj.fileinfo.surfreference = undefined;\n\n            $(this).removeClass("current");\n        }\n\n\n    }\n    that.attachSurfaceRef = attachSurfaceRef;\n\n\n    function setContent(imageStruct, params)\n    {\n    \n            if (!that.toolbar.issticky)\n                that.toolbar.hide_addons();\n\n            if (typeof KAtlasTool != "undefined")\n            if ((KAtlasTool.isAtlas(imageStruct) | params.intent.atlas) & !params.intent.overlay)\n            {\n\n                    if (params.intent.atlaskey != undefined) // this is auto roi convert\n                    {\n                       KViewer.atlasTool.getROIfromSinglelabel(imageStruct,params.intent.atlaskey,params.intent.labelname,imageStruct,function(roi){\n                             that.viewport.setContent(roi,{});\n                       }, that.viewport.progressSpinner)                        \n                       return;\n                    }\n                    else\n                    {\n\n                        imageStruct = KViewer.atlasTool.addAtlas(imageStruct);\n                        if (params.intent.atlasiso != undefined)\n                        {\n                             KViewer.atlasTool.attachSurf(imageStruct,imageStruct.content.labels[params.intent.atlasiso],that);\n                             return;\n                        }\n                        else\n                        {\n                            for (var k = 0; k < that.atlas.length; k++)\n                            {\n                                if (that.atlas[k].atlas.fileID == imageStruct.fileID)\n                                    return;\n                            }\n                            if (that.currentFileID == undefined)\n                            {\n                                alertify.error(\'Please drop a background image first\');\n                                viewport.setCurrentViewer();\n                                return;\n                            }\n\n                            var av = master.atlasTool.createView(imageStruct, that,params.intent);\n\n                            if (params.intent.surfcol)\n                            {\n                                var sviews = hasContent(\'surf\');\n                                if (sviews != undefined)\n                                {\n                                    var thesurfview = sviews[0];\n                                    av.surfacecolref = thesurfview;\n                                    thesurfview.overlays.push(av);\n                                    thesurfview.update();\n\n                                }\n                            }\n                            else\n                            {\n\n                                that.atlas.push(av);\n                                that.drawSlice({\n                                    mosaicdraw: true\n                                });\n                            }\n                            return;\n                        }\n                    }\n            }\n\n            viewport.setCurrentViewer(that);\n\n            if (imageStruct.contentType == \'rtstruct\')\n            {\n                if (Array.isArray(imageStruct.content.Contours) && params.intent.select == undefined)\n                    for (var k= 0;k < imageStruct.content.Contours.length;k++)\n                        appendObject3D(imageStruct, $.extend(params.intent,{select:k}));\n                else\n                    appendObject3D(imageStruct, params.intent);\n                signalhandler.send(\'positionChange\');\n\n                return;\n            }\n\n            if (imageStruct.contentType == \'tracts\' | imageStruct.contentType == \'gii\' |  imageStruct.filename.search("\\\\.cc.json") != -1)\n            {\n                if (that.content == undefined)\n                {\n                    that.nii = createDummyNifti([100,100,100],imageStruct.content.max,imageStruct.content.min,[0,1,2],[1,1,1]);\n                    that.content = {content:that.nii};\n                    niiOriginal = that.nii;\n                }\n\n                for (var k = 0; k < that.objects3D.length; k++) // avoid double insertion\n                {\n                    var obj3d = that.objects3D[k];\n                    if ((obj3d.surf && obj3d.surf == imageStruct))\n                            return;\n                }\n\n                if (webgl_detect())\n                {\n                    var load3DObject = function() {\n                        if (params.intent == undefined)\n                            params.intent = {};\n\n                        if (imageStruct.content.selections != undefined & params.intent.select == \'allselections\')\n                        {\n\n\n                            var list_to_sort = []\n                            for (var j = 0; j < imageStruct.content.selections.length;j++)\n                                list_to_sort.push({id:j,name:imageStruct.content.selections[j].name})\n\n                            list_to_sort.sort(function(a,b) {return (a.name > b.name)?-1:1 })\n\n                            for (var j_ = 0; j_ < imageStruct.content.selections.length;j_++)\n                            {\n                                var k = list_to_sort[j_].id;\n\n                                var col = k;\n                                if (imageStruct.content.selections[k].color != undefined)\n                                    col = imageStruct.content.selections[k].color;\n                                appendObject3D(imageStruct, {\n                                    select: k,\n                                    color: col\n                                });\n                            }\n                        }\n                        else\n                        {\n                            if (Array.isArray(imageStruct.content.Contours) && params.intent.select == undefined)\n                                for (var k= 0;k < imageStruct.content.Contours.length;k++)\n                                    appendObject3D(imageStruct, $.extend(params.intent,{select:k}));\n/*                            else if (Array.isArray(params.intent.select))\n                            {\n                                var toselect = params.intent.select;\n                                for (var k= 0;k < toselect.length;k++)\n                                    appendObject3D(imageStruct, $.extend(params.intent,{select:toselect[k]}));                            \n                            }*/\n                            else\n                                appendObject3D(imageStruct, params.intent);\n                        }\n                        that.showControls();\n                        setCanvasLayout();\n                        resliceOnMaster();\n                    }\n                    if (!gl_enabled)\n                        toggle3D(undefined,function() {\n                            that.gl.setprops(params.intent.gl_props);\n                            if (that.viewport.onsetContent)\n                                that.viewport.onsetContent();\n                            load3DObject()\n                        })\n                    else\n                        load3DObject();\n\n                }\n                else\n                    alertify.error("Your browser has no WebGL enabled!")\n                return;\n            }\n\n\n\n\n\n            if (params.intent)\n            {\n\n                if (params.intent.createFiberTracking)\n                {\n                    if (gl_enabled)\n                        openFiberTracking()\n                    else\n                        toggle3D(undefined, openFiberTracking);\n                    return;\n\n                    function openFiberTracking()\n                    {\n                        var filename = imageStruct.filename.replace(".nii","").replace(".gz","") + ".tck";\n                        var view_on_trackvol;\n                        if (that.content.fileID == imageStruct.fileID)\n                            view_on_trackvol = that;\n                        else\n                        {\n                            for (var k = 0; k < that.overlays.length;k++)\n                            {\n                                if (that.overlays[k].currentFileID == imageStruct.fileID)\n                                {\n                                   view_on_trackvol = that.overlays[k];\n                                   break;\n                                }\n                            }\n                        }\n\n                        if (params.intent.createFiberTracking.viewport != undefined) // if the view is somewhere else\n                            view_on_trackvol = params.intent.createFiberTracking;\n\n\n                        if (view_on_trackvol == undefined)\n                        {\n                            alertify.error("associated contrast for tracking not found");\n                            return;\n                        }\n\n                        var new_imageStruct = {filename:filename,content:{tracts:[  ]} }     ;  \n\n                        var intent = { dirvolref: view_on_trackvol ,isParentView:true } ;\n                        intent = $.extend(intent,params.intent.createFiberTracking);\n                           \n                        var fv = master.obj3dTool.createFiberView(new_imageStruct,that,intent);\n                        that.objects3D.push(fv);\n                        return;\n                    }\n                }\n\n                if  (params.intent.quiver_params)\n                    imageStruct.content.quiver_params = params.intent.quiver_params;\n\n\n                if (params.intent.slicing == \'gl\' | params.intent.slicing == -1)\n                {\n                    params.intent.gl = true;\n                    params.intent.slicing = 0;\n                }\n\n                //if ( (params.intent.ROI | params.intent.roi) &&  (imageStruct.content.datatype != \'uint8\') ||   imageStruct.content.datatype != \'uint16\') \n                if (0) // (params.intent.ROI | params.intent.roi) &&  (imageStruct.content.datatype == \'float\'))\n                {\n                    alertify.error(\'ROI-filetype was "\'+ imageStruct.content.datatype +\'", cannot work with this directly, please create ROI manually with thresholding.\')\n                    params.intent.ROI = false;\n                    params.intent.roi = false;\n\n                }\n\n                if (params.intent.ROI | params.intent.roi)\n                {\n                    for (var k = 0; k < that.ROIs.length; k++)\n                    {\n                        // check if roi is already loaded\n                        if (that.ROIs[k].roi.fileID == imageStruct.fileID)\n                            return;\n                    }\n                    // no background image in this viewport\n                    if (that.currentFileID == undefined)\n                    {\n                        //if( !params.intent.isosurf )\n                        //    alertify.error(\'You dropped a ROI, but there was no background image.<br>I set this ROI also as background. Drop other image if desired.\');\n                        //alertify.error(\'Please drop a background image first\');\n                        //viewport.setCurrentViewer();\n                        //return;\n                        var goOnAndloadasBackground = true;\n                    }\n//todoMRC\n\n                    function doit(fobj)\n                    {\n                        var fv = master.roiTool.createView(fobj, that, params.intent);\n                       \n                        if (notzipped)\n                            fobj.notzipped = true;\n\n                        that.ROIs.push(fv);\n                        that.drawSlice({\n                            mosaicdraw: true\n                        });\n\n                        if (params.intent.makeCurrent && !fv.isCurrent)\n                            fv.makeCurrent();\n\n                        $timediv.update();\n                    }\n\n                    var notzipped = false\n                    if (imageStruct.fileID.substring(0,3) != "ROI" && imageStruct.filename.search("\\\\.gz") == -1)\n                        notzipped = true\n\n\n                    if (params.intent.roilim | imageStruct.content.datatype != \'uint8\')\n                    {\n                        var threshold = params.intent.roilim\n                        if (threshold == undefined)\n                        {\n                            threshold = 0;\n                            alertify.error(\'nifti cloned, mask need uint8 datatype\')\n                        }\n                        var name  = imageStruct.filename.replace("\\.nii","").replace("\\.gz","")\n                        imageStruct.intendedROIid = imageStruct.fileID;\n                        master.roiTool.pushROI(imageStruct.fileID, name, "upper" + imageStruct.content.datascaling.ie(threshold),\n                        function(fobj) {\n                            fobj.fileinfo.SubFolder = imageStruct.fileinfo.SubFolder;\n                            doit(fobj);\n\n                            },undefined,{sametdim:true});\n                    }\n                    else\n                        master.roiTool.pushROI(imageStruct.fileID, "untitled", "frommaskfile",doit);\n\n\n                    if(goOnAndloadasBackground == undefined)\n                        return;\n                }\n\n\n\n                if ((params.intent.ctrlKey | params.intent.overlay) & that.nii != undefined & params.intent.surfcol == undefined)\n                {\n\n                    for (var k = 0; k < that.overlays.length; k++) // check if ovl already in VP\n                    {\n                        if (that.overlays[k].content.fileID == imageStruct.fileID)\n                            return;\n                    }\n                    var newovl = createOverlay(imageStruct,params.intent);\n                   \n                    newovl.histoManager.clim = [newovl.nii.histogram.min + 0.5 * (newovl.nii.histogram.max - newovl.nii.histogram.min),\n                                                newovl.nii.histogram.max - 0.1 * (newovl.nii.histogram.max - newovl.nii.histogram.min)];\n                    if (KViewer.defaults.overlay)\n                    {\n                        var d = KViewer.defaults.overlay;                        \n                        if (d.clim != undefined)            \n                             newovl.histoManager.clim = [imageStruct.content.datascaling.ie(d.clim[0]),imageStruct.content.datascaling.ie(d.clim[1])];\n                    }\n\n              \n                    if(imageStruct.content.cal_max!=imageStruct.content.cal_min)\n                    {\n                        newovl.histoManager.clim = [imageStruct.content.datascaling.ie(imageStruct.content.cal_min), imageStruct.content.datascaling.ie(imageStruct.content.cal_max)];\n                    }\n                    \n                    if (imageStruct.content.descrip && imageStruct.content.descrip.clim)\n                        newovl.histoManager.clim = [imageStruct.content.descrip.clim[0],imageStruct.content.descrip.clim[1]];\n\n              \n\n                    if (params.intent.clim != undefined)\n                        newovl.histoManager.clim = params.intent.clim;\n                    if (params.intent.visible != undefined)\n                    {\n                        newovl.visible = params.intent.visible;\n                        if (!newovl.visible)\n                            newovl.divs[4].css(\'color\', \'red\');\n                    }\n                    if (params.intent.cmap != undefined)\n                        newovl.histoManager.setCmap(params.intent.cmap);\n                    if (params.intent.transparent != undefined)\n                        newovl.histoManager.blending = params.intent.transparent;\n                    if (params.intent.posnegsym != undefined)\n                        newovl.histoManager.posnegsym = params.intent.posnegsym;\n                    if (params.intent.blocky != undefined)\n                        newovl.histoManager.blocky = params.intent.blocky;\n                    if (params.intent.initialTimePoint != undefined)\n                        newovl.nii.currentTimePoint.t = parseInt(params.intent.initialTimePoint);\n                    else\n                    {\n                        if (newovl.nii.numTimePoints > KViewer.movie.currentTimePoint)\n                        {\n                           newovl.nii.currentTimePoint.t = KViewer.movie.currentTimePoint;\n                           $timeinput.val( newovl.nii.currentTimePoint.t  );\n                           $timeCurrent.text(  newovl.nii.currentTimePoint.t );\n\n                        }\n                    }\n\n                    if (params.intent.isosurf || newovl.fileinfo.surfreference )                                            \n                        that.attachSurfaceRef(newovl,imageStruct, undefined,params.intent.isosurf );\n\n                    if (params.intent.quiver_params)\n                          newovl.nii.quiver_params = params.intent.quiver_params;\n\n                    signalhandler.send("layoutHisto");\n\n\n                    if (params.intent)\n                    {\n                        if (params.intent.showcolored != undefined)\n                            newovl.showcolored = params.intent.showcolored;\n                        if (params.intent.showcolored_type != undefined)\n                            newovl.showcolored_type = params.intent.showcolored_type;\n\n                        if (params.intent.outlines != undefined)\n                        {\n                            newovl.color = params.intent.outlines;\n                            newovl.outlines = Outlines(newovl);\n                        }\n                    }\n\n\n\n\n\n                    that.overlays.push(newovl);\n                    $timediv.update();\n\n                    that.drawSlice({\n                        mosaicdraw: true\n                    });\n                    return;\n                }\n\n                if (params.intent.surfcol)\n                {\n\n                    var sviews = hasContent(\'surf\');\n                    if (sviews != undefined)\n                        createSurfColoring(sviews,params.intent.surfcol,imageStruct);\n                    else\n                    {\n                        signalhandler.attach(\'surfcoldrop_\' + that.viewport.viewPortID,function()\n                        {\n                                setTimeout(function() { signalhandler.detach(\'surfcoldrop_\' + that.viewport.viewPortID,\'all\'); },10);\n                                var sviews = hasContent(\'surf\');\n                                if (sviews != undefined)\n                                    createSurfColoring(sviews,params.intent.surfcol,imageStruct);                            \n                        });\n/*                        \n                        var cnt = 0;\n\n                        function tryAgain(){\n                            if (cnt < 4)\n                            {\n                                var sviews = hasContent(\'surf\');\n                                if (sviews != undefined)\n                                    createSurfColoring(sviews,params.intent.surfcol,imageStruct);                            \n                                else \n                                    setTimeout(tryAgain,500)\n                                cnt++;\n                            }\n                        }\n                        tryAgain();*/\n                    }\n\n                    function createSurfColoring(sviews,surfid,imageStruct)\n                    {\n\n                        var newovl = createOverlay(imageStruct);\n\n                        var thesurfview = sviews[0];\n                        for (var k = 0; k < sviews.length;k++)\n                            if (sviews[k].surf.fileID == surfid)\n                            {\n                                thesurfview = sviews[k]\n                                break;\n                            }\n                            \n                        newovl.surfacecolref = thesurfview;\n\n\n                        thesurfview.overlays.push(newovl);\n\n\n                        newovl.histoManager.clim = [newovl.nii.histogram.min + 0.5 * (newovl.nii.histogram.max - newovl.nii.histogram.min),\n                        newovl.nii.histogram.max - 0.1 * (newovl.nii.histogram.max - newovl.nii.histogram.min)];\n\n                         if (KViewer.defaults.overlay)\n                                        {\n                                            var d = KViewer.defaults.overlay;                        \n                                            if (d.clim != undefined)            \n                                                 newovl.histoManager.clim = [imageStruct.content.datascaling.ie(d.clim[0]),imageStruct.content.datascaling.ie(d.clim[1])];\n                                        }                        \n\n    \n                        if (imageStruct.content.descrip && imageStruct.content.descrip.clim)\n                            newovl.histoManager.clim = [imageStruct.content.descrip.clim[0],imageStruct.content.descrip.clim[1]];\n\n\n\n                        if (params.intent.clim)\n                            newovl.histoManager.clim = params.intent.clim;\n                        if (params.intent.cmap != undefined)\n                            newovl.histoManager.setCmap(params.intent.cmap);\n                        if (params.intent.cuts != undefined)\n                            thesurfview.cuts = params.intent.cuts; \n                        newovl.histoManager.onclimchange = function(ev)\n                                {\n                                    thesurfview.update();\n                                }\n                        newovl.histoManager.oncmapchange = function(ev)\n                                {\n                                    thesurfview.update();\n                                }\n                        newovl.customClose = function()\n                        {\n                            for (var k = 0; k < thesurfview.overlays.length; k++)\n                                if (this == thesurfview.overlays[k])\n                                {\n                                    thesurfview.overlays.splice(k, 1);\n                                    break;\n                                }\n                            thesurfview.colors_mapped = undefined;\n                            thesurfview.update();\n\n                        }\n                        thesurfview.update();\n\n                        signalhandler.send("layoutHisto");\n                    }\n                    return;\n                    \n                }\n\n\n            }\n\n\n\n            that.nii = imageStruct.content;\n\n            that.prepViewer(imageStruct,params.intent);\n\n            niiOriginal = that.nii;\n\n            that.niiOriginal = niiOriginal;\n            histoManager.nii = that.nii;\n            histoManager.name = imageStruct.filename;\n            histoManager.setColorMapLims = setColorMapLims;\n\n            if (params.intent)\n            {\n                if (params.intent.gl & webgl_detect())\n                {\n                    if (!gl_enabled)\n                        toggle3D(undefined,function() {\n                            that.gl.setprops(params.intent.gl_props);\n                            if (that.viewport.onsetContent)\n                                that.viewport.onsetContent();\n                        });\n                }\n                else if (params.intent.gl == false)\n                {\n                    if (gl_enabled)\n                        toggle3D();\n                }\n            }\n\n            if (params.intent)\n            {\n                if (params.intent.slicing != undefined)\n                    slicingDimOfWorld = params.intent.slicing;\n                if (params.intent.isosurf)\n                     setTimeout(function(){  that.attachSurfaceRef(that,that.content,undefined,params.intent.isosurf);    });\n            }\n\n            if (params.mosaic)\n            {\n                that.mosaicview = $.extend(that.mosaicview,params.mosaic);\n                that.switchToMosaic()\n            }\n\n\n            quiver.clear();\n            if (interpretAsColoredVolume(that.nii,that))\n            {\n                that.addQuiver(histoManager);\n                that.toolbar.$quiver.show();\n            }\n\n            if(params.intent && params.intent.hideControls)\n                that.hideControls(params.intent.hideControls);\n            else\n                that.showControls();\n\n            toolbar.$dragdiv.off("dragstart");\n            toolbar.$dragdiv[0].ondragstart = dragstarter(function() {\n                if (that.currentFileID != undefined)\n                  return {\n                    type: \'file\',\n                    mime: \'nii\',\n                    filename: that.currentFilename,\n                    fileID: that.currentFileID,\n                    intent: {\n                        clim: that.histoManager.clim\n                    },\n                    close: that.close\n                }\n\n            })\n\n\n            var nii = that.nii;\n\n            // for single slice images, set slicing dim such that it becoms visible\n            if( nii.sizes[0] == 1 || nii.sizes[1] == 1 || nii.sizes[2] == 1)\n            {\n                applySlicingDimOfArray( nii.sizes.indexOf(1) )\n                worldLockedToMaster = false;\n            }\n            else\n                worldLockedToMaster = true;            \n\n\n            \n            that.showcolored = interpretAsColoredVolume(nii,that);\n                \n            if (params.intent)\n            {\n                if (params.intent.worldLockedToMaster != undefined)\n                    worldLockedToMaster = params.intent.worldLockedToMaster;\n                if (params.intent.showcolored != undefined)\n                    that.showcolored = params.intent.showcolored;\n                if (params.intent.showcolored_type != undefined)\n                    that.showcolored_type = params.intent.showcolored_type;\n            }\n\n\n            currentVoxel = math.matrix(nii.centerVoxel);\n\n            // remember center point as custom point \n            customPoint  = math.matrix(nii.centerWorld);\n\n            \n            // the new image might not become visible at once.\n            // so, set the current voxel and check if we are inside the view. Otherwise jump to center of this nifti.\n\n            var cpoint = getWorldPosition(); // if global coordinates off, this will return the local center, as it was set above with "customPoint"\n\n            if (cpoint == undefined || cpoint.reset)\n            {\n                setWorldPosition(customPoint)\n                var cpoint = getWorldPosition();\n            }\n\n            if (master.mainViewport !== -1)\n                    cpoint = math.multiply(math.inv(master.reorientationMatrix.matrix), cpoint);\n            \n            // check if image is outside: if yes set the global point to the center of this nifti\n            var curV_ = math.multiply(math.inv(nii.edges), cpoint)._data;\n            if(curV_[0]<-0.001 || curV_[1]<-0.001 || curV_[2]<-0.001 || curV_[0]>=nii.sizes[0]+0.001 || curV_[1]>=nii.sizes[1]+0.001 || curV_[2]>=nii.sizes[2]+0.001 )\n            {\n                if (!goOnAndloadasBackground)\n                {\n                    setWorldPosition(customPoint);\n                    signalhandler.send(\'positionChange\');\n                }\n            }\n            else\n            {\n\n            }\n\n            // remember viewcenter (old or new)\n            if (!goOnAndloadasBackground)\n            {\n                 // what is this\n                  master.viewcenter = math.multiply(nii.edges, currentVoxel);\n            }\n\n            resliceOnMaster();\n            setCanvasLayout();\n\n\n \n//             if (nii.intent_code > 0)\n//                     histoManager.setCmap(nii.intent_code);\n\n            if (nii.descrip.cmap > 0)\n                    histoManager.setCmap(nii.descrip.cmap);\n \n            if (params.intenet && params.intent.initialTimePoint != undefined)\n                that.nii.currentTimePoint.t = parseInt(params.intent.initialTimePoint);\n            else\n            {\n                if (that.nii.numTimePoints > KViewer.movie.currentTimePoint)\n                {\n                    that.nii.currentTimePoint.t = KViewer.movie.currentTimePoint;\n                    $timeinput.val( that.nii.currentTimePoint.t  );\n                    $timeCurrent.text(  that.nii.currentTimePoint.t );                    \n                }\n            }\n            if (params.intent)\n            {\n                if (params.intent.clim != undefined)\n                    var tempClim = params.intent.clim;\n                if (params.intent.cmap != undefined & !params.intent.overlay)\n                    histoManager.setCmap(params.intent.cmap);\n            }\n\n            if (tempClim) // intent had the clim set. now check if it was absolute or in percent for histogram, for auto windowing from histogram.\n            {\n                for (var z = 0; z < 2; z++)\n                {\n                    if (typeof (tempClim[z]) == "string") // is a string\n                    {\n                        if (tempClim[z].search("%") !== -1) // string an with percent --\x3e percantage of histos\n                        {\n                            var pp = parseFloat(tempClim[z]) / 100;\n                            if (z == 0)\n                                // lower bound\n                                histoManager.clim[z] = nii.histogram.min + pp * (nii.histogram.max - nii.histogram.min);\n                            else\n                                // upper\n                                histoManager.clim[z] = nii.histogram.max - pp * (nii.histogram.max - nii.histogram.min);\n                        }\n                    }\n                    else\n                        histoManager.clim[z] = parseFloat(tempClim[z]);\n                    // else, absolute values given\n                }\n\n            }\n            // default windowing might be set in nifti \n            else if(nii.cal_max && (nii.cal_max!=nii.cal_min))\n            {\n                histoManager.clim = [nii.datascaling.ie(nii.cal_min), nii.datascaling.ie(nii.cal_max)];\n            }\n            else // no clim set. Take standard auto windowing from histogram\n            {\n                if (nii.descrip.clim)\n                    histoManager.clim = [nii.descrip.clim[0],nii.descrip.clim[1]];\n                else\n                {\n                    var minPerc = 0;\n                    var maxPerc = 0.05;\n\n                    var lowerlim = nii.histogram.min + minPerc * (nii.histogram.max - nii.histogram.min);\n                    // set lowerlim always to zero ( account the intercept in nii)\n                    //if( nii.scl_inter < 0 && nii.scl_slope != 0)\n                    //    lowerlim = -nii.scl_inter/nii.scl_slope;\n                    //else\n                    //    lowerlim = 0;\n\n                    if (interpretAsColoredVolume(that.nii,that))\n                        lowerlim = 0;\n\n\n                    var upperlim = nii.histogram.max - maxPerc * (nii.histogram.max - nii.histogram.min);\n\n                    histoManager.clim = [lowerlim, upperlim];\n\n                                        \n                }\n            }\n\n            if (params.intent.transfactor != undefined)\n                that.transfactor = params.intent.transfactor;\n\n            setColorMapLims(histoManager.clim);\n\n            if (KViewer.roiTool && KViewer.roiTool.isinstance && KViewer.roiTool.roiPanel)\n                KViewer.roiTool.roiPanel.update();\n            drawHairCross();\n            updateInfoBar();\n\n\n            $timeinput.val( that.nii.currentTimePoint.t  );\n            $timeCurrent.text(  that.nii.currentTimePoint.t );\n\n\n\n            if (params.intent.zooms != undefined)\n            {\n                that.setZoomLims([params.intent.zooms[0], params.intent.zooms[1] * containerHeight(), params.intent.zooms[2] * containerWidth()],true);\n            }\n            else\n            {\n                if (master.zoomLims[slicingDimOfWorld] != undefined)\n                    that.setZoomLims(master.zoomLims[slicingDimOfWorld],true);\n            }\n\n\n        }// end of set content\n\n        function updateInfoBar()\n        {\n            if (master.showInfoBar)\n            {\n                if (that.nii)\n                {\n                    if (that.nii.type !== \'nii\')\n                        // do not update info bar for unnsupported types\n                        return;\n\n\n                    if (!master.showInfoBar)\n                    {\n                        txt = "";\n                    }\n                    else\n                    {\n                        var nii = that.nii;\n                        $infobar.on("dragstart",\n                        function(ev)\n                        {\n                            tempObjectInfo = [{\n                                type: \'file\',\n                                sid: \'\',\n                                piz: \'\',\n                                subfolder: \'\',\n                                tag: \'\',\n                                mime: \'nii\',\n                                filename: that.currentFilename,\n                                fileID: that.currentFileID,\n                                intent: {\n                                    clim: that.histoManager.clim,\n                                    viewport: that.viewport.viewPortID\n                                    }\n\n                            }];\n                            if (ev.originalEvent !== undefined)\n                                ev.originalEvent.dataTransfer.setData("fromfiletable", "yea");\n                            else\n                                ev.dataTransfer.setData("fromfiletable", "yea");\n                        });\n\n\n                        function mapVal(nii, val)\n                        {\n                            var value;\n                            if (val != undefined)\n                            {\n                                if (!(nii.datascaling.id()))\n                                {\n                                    value = (nii.datascaling.e(val)).toFixed(4);\n                                    value += " (" + val.toFixed(4) + ")";\n                                }\n                                else\n                                    value = val.toFixed(4);\n                                if (nii.descrip && nii.descrip.unit)\n                                    value += " " + nii.descrip.unti.slice(5);\n\n                            }\n                            else\n                                value = "undefined";\n                            return value;\n                        }\n\n                        var msz = "";\n                        msz = "matrix: " + nii.sizes[0].toFixed(0) + \'&nbsp;&nbsp;\' + nii.sizes[1].toFixed(0) + \'&nbsp;&nbsp;\' + nii.sizes[2].toFixed(0);\n                        if (nii.sizes.length > 3 && (nii.sizes[3] > 1 | nii.sizes[3] > 1))\n                            msz += \';&nbsp;\' + nii.sizes[3].toFixed(0);\n                        if (nii.sizes.length > 4 && nii.sizes[4] > 1)\n                            msz += \';&nbsp;\' + nii.sizes[4].toFixed(0);\n\n                        if (nii.currentTimePoint.t != 0)\n                            msz += "  (t:" + (nii.currentTimePoint.t + 1) + ")";\n\n\n\n                        if (that.currentFileinfo)\n                        {\n                            if (that.currentFileinfo.patients_id == undefined)\n                                var psid = "no associated patient";\n                            else\n                                var psid = that.currentFileinfo.patients_id + "_" + that.currentFileinfo.studies_id + "<br>";\n                        }\n                        else\n                            var psid = "localfile <br> ";\n                        if (userinfo.username == guestuser)\n                            psid = "";\n\n\n                        var value = mapVal(nii, currentValue);\n                        for (var k = 0; k < that.overlays.length; k++)\n                        {\n                            value += "; " + mapVal(that.overlays[k].nii, that.overlays[k].currentValue);\n                        }\n\n                        var txt = "<span style=\'font-size:11px;line-height:13px\'><b>";\n                        if (that.currentFileinfo.SubFolder != undefined && that.currentFileinfo.SubFolder !="")\n                             txt +=  that.currentFileinfo.SubFolder + \'/\' + that.currentFilename + \'<br>\'   ;\n                        else\n                             txt +=  that.currentFilename + \'<br>\'   ;\n                        \n                        txt += "</b>" + psid;\n\n                        // print the date nicely\n                        /*\n                        var sid = that.currentFileinfo.studies_id;\n                        if (sid != undefined)\n                        {\n                            var dd = sid.substring(7,9) + "." +sid.substring(5,7)+"."+sid.substring(1,5);\n                            txt += "</b>" + psid.split(\'_#\')[0] + " <b>" + dd + "</b>";\n                        }*/\n                    \n\n                        txt += "</span>";\n                        txt += "<span style=\'font-size:3px;line-height:3px\'><br></span>";\n\n\n                        txt +=  "voxsize: " + nii.voxSize[0].toFixed(2) + \'&nbsp;&nbsp;\' + nii.voxSize[1].toFixed(2) + \'&nbsp;&nbsp;\' + nii.voxSize[2].toFixed(2)\n                            + "<br>" + msz ;\n\n                        var p = getWorldPosition();\n                        txt += "<br>pos mm: " + p._data[0].toFixed(1) + \'&nbsp;&nbsp;\' + p._data[1].toFixed(1) + \'&nbsp;&nbsp;\' + p._data[2].toFixed(1) + \'\';\n                        txt += "<br>pos vx  : " + currentVoxel._data[0].toFixed(0) + \'&nbsp;&nbsp;\' + currentVoxel._data[1].toFixed(0) + \'&nbsp;&nbsp;\' + currentVoxel._data[2].toFixed(0) + \'\';\n\n                        txt += "<br> value: <b>" + value + "</b>";\n\n                    }\n                    $infobar.html(txt);\n\n                }\n                if ($infobar.hidden)\n                    $infobar.hide();\n                else\n                    $infobar.show();\n            }\n            else\n                $infobar.hide();\n        }\n\n\n        signalhandler.attach("updateInfoBar", updateInfoBar);\n\n\n        signalhandler.attach("climChange", function(event)\n        {\n            if (event.id == that.currentFileID)\n                setColorMapLims(event.val);\n        });\n\n\n        \n        function resetColorMapLims(lims)\n        {\n            if(lims == undefined)\n                lims = [\'auto\', \'auto\'];\n            \n            var mmin, mmax;\n\n            var nii = that.nii;\n\n            if (nii.isMask)\n            {\n                mmin = 0;\n                mmax = 1;\n                histoManager.clim = [0, 1];\n            }\n            else\n            {\n                if( lims[0]==\'auto\' )\n                    mmin = nii.histogram.min + 0.05 * (nii.histogram.max - nii.histogram.min);\n                else\n                    mmin = parseInt( nii.datascaling.ie( lims[0]) );\n                \n                if( lims[1]==\'auto\' )\n                    mmax = nii.histogram.max - 0.1 * (nii.histogram.max - nii.histogram.min);\n                else\n                    mmax = parseInt( nii.datascaling.ie( lims[1]) );\n\n\n            }\n            \n            histoManager.clim = [mmin, mmax];\n                                    \n            //setColorMapLims(clim);\n            signalhandler.send("climChange", {\n                id: that.currentFileID,\n                val: histoManager.clim\n            });\n\n        }\n        that.resetColorMapLims = resetColorMapLims;\n\n        function setColorMapLims(clim_in)\n        {\n            if (clim_in != undefined)\n                histoManager.clim = clim_in.slice(0);\n            histoManager.updateHistogramClim();\n            drawSlice({\n                noquiver: true,\n                mosaicdraw: true,\n                lazy:!that.viewport.hasMouse\n            });\n\n        }\n\n        function createTrace(obj)\n        {\n             var p = obj.getPoints();\n             if (p.length < 2)\n                return;\n\n                \n             var flines = "";\n             var quant = 10;\n             var col = [255,0,0];\n             var col2 = [0,255,0];\n                     var op = 0.3;\n\n              function addline(col,op,x0,y0,x1,y1)\n              {\n\t\t\t       flines += \'<line style="stroke-width:3px;stroke:rgba(\'+col[0]+\',\'+col[1]+\',\'+col[2]+\',\'+op+\')" x1="\' +x0 + \'" y1="\' + y0 + \'" x2="\' + x1 + \'" y2="\' + y1 + \'" />\';\n              }\n\n\n             var last  = that.getCanvasCoordinates(p[0].p.coords);\n             var cur = getCanvasCoordinates(getWorldPosition());\n             var cur_z = cur.z_mm;\n\n             for (var k = 1 ; k < p.length;k++)\n             {\n                 var c = that.getCanvasCoordinates(p[k%p.length].p.coords);\n\n\n                 if (Math.abs(c.z_mm - cur_z)<1 && Math.abs(last.z_mm - cur_z)<1) // (last.z_mm > cur_z && c.z_mm < cur_z) | (last.z_mm < cur_z && c.z_mm > cur_z))\n                 {    \n                  \n                     var x0 = last.x_pix ;\n                     var y0 = last.y_pix;;\n                     var x1 = c.x_pix;\n                     var y1 = c.y_pix;\n                    addline(col,1,x0,y0,x1,y1)\n                 }\n                 else\n                 {\n\n                     var dx = (c.x_pix - last.x_pix)/c.x_pixPerMM ;\n                     var dy = (c.y_pix - last.y_pix)/c.y_pixPerMM ;\n                     var dz = c.z_mm-last.z_mm\n                     var n = (1-Math.abs(dz)/Math.sqrt(dx*dx+dy*dy+dz*dz))*0.5;\n\n\n                     var x0 = last.x_pix ;\n                     var y0 = last.y_pix;\n                     var x1 = c.x_pix;\n                     var y1 = c.y_pix;\n                     var lam =  (cur_z-c.z_mm)/(last.z_mm-c.z_mm);\n\n                     var lam1 = lam+n;\n                     var lam2 = lam-n\n                     if (lam1 > 1) lam1 = 1;\n                     if (lam1 < 0) lam1 = 0;\n                     if (lam2 < 0) lam2 = 0;\n                     if (lam2 > 1) lam2 = 1;\n \n                     var xm1 =  last.x_pix*lam1 + c.x_pix*(1-lam1);\n                     var ym1 =  last.y_pix*lam1 + c.y_pix*(1-lam1);\n                     var xm2 =  last.x_pix*lam2 + c.x_pix*(1-lam2);\n                     var ym2 =  last.y_pix*lam2 + c.y_pix*(1-lam2);\n      \t\t\t\t if(!isNaN(xm1))\n      \t\t\t\t {\n\t\t\t\t\t\t addline(col,op,x0,y0,xm2,ym2);\n\t\t\t\t\t\t addline(col,op,xm1,ym1,x1,y1);\n\t\t\t\t\t\t addline(col,1,xm1,ym1,xm2,ym2);\n      \t\t\t\t }                  \n\n                 }\n              \n                 last = c;\n             }\n\n             var w = that.$canvascontainer.width();\n             var h = that.$canvascontainer.height();\n             var $lines = $("<svg  style=\'pointer-events:none;width:"+w+"px;height:"+h+"px;z-index:5;position:absolute;\'>" + flines + "</svg>");\n\t  \n             that.$canvascontainer.append($lines);\n\n\n             return $lines\n        }\n        that.createTrace = createTrace;\n\n\n\n        function drawSlice(params)\n        {\n                // do not draw on hidden viewports during zoom\n            if (master.zoomedViewport != -1 && master.zoomedViewport != that.viewport.viewPortID)\n                return;\n\n            if (that.nii == undefined)\n                return;\n\n            if (params && params.nosliceupdate != undefined && params.nosliceupdate == true)\n                return\n\n            if (params && params.point)\n                customPoint = params.point;\n\n\n            if (that.nii.type != undefined)\n                if (that.nii.type !== \'nii\')\n                {\n                    $infobar.html(("<div style=\'position:absolute; width:600px; left:100px;top:100px; font-size:20px;\'>Sorry, this Nifti Type is not yet fully supported: <br />" + that.nii.type + "</div>"));\n                    return;\n                }\n\n            var sliceChanged = setCurrentVoxel();\n            var respectSlCh = (params != undefined && params.respectSliceChange);\n\n            if (params && params.preferred == false)\n                params.lazy = true;\n\n\n\n\n            function getClipBox()\n            {\n\n                    var canvas_offs = that.$canvas.offset();\n                    var contai_offs = that.$container.offset();\n                    var canvas_wid = that.$canvas.width();\n                    var canvas_hei = that.$canvas.height();\n                    var contai_wid = that.$container.width();\n                    var contai_hei = that.$container.height();\n\n                    var clip = [0,0,1,1];\n\n                    var dw =  (canvas_offs.left-contai_offs.left );\n                    if (dw < 0)\n                        clip[0] = -dw / that.$canvas.width() ;\n                    dw = canvas_wid-contai_wid + dw;\n                    if (dw> 0)\n                       clip[2] = 1-dw/canvas_wid;\n\n                    var dh =  (canvas_offs.top-contai_offs.top );\n                    if (dh < 0)\n                        clip[1] = -dh / that.$canvas.height() ;\n                    dh = canvas_hei-contai_hei + dh\n                    if (dh> 0)\n                       clip[3] = 1-dh/canvas_hei;\n\n                    return clip;\n            }\n\n\n\n\n\n            function eagerDraw3D(arr,fun,done)\n            {\n                for (var k = 0; k < arr.length; k++)\n                        fun(k);\n                done();                \n            }\n\n\n            function lazyDraw3D(arr,fun,done)\n            {\n                for (var k = 0; k < arr.length; k++)\n                {\n                    if (arr[k].cid != undefined)\n                        clearTimeout(arr[k].cid);\n\n                    arr[k].cid = setTimeout(function(k) { return function() { \n                            fun(k); \n                            clearTimeout(arr[k].cid);\n                            arr[k].cid = undefined;\n                            \n                            for (var j = 0;j < arr.length;j++)\n                                if (arr[j].cid != undefined)\n                                    return;\n\n                            if (that.nii != undefined)\n                                done();\n\n                     }}(k),0\n                     );\n \n\n                }\n            }\n\n\n            function eagerDraw2D(fun)\n            {\n                fun()\n            }\n\n            function lazyDraw2D(fun)\n            {\n                  var t = 25;\n                  if (params && !params.preferred)\n                     t = master.static.lazydraw_timeout || 150;\n                  if (that.cid != undefined)\n                        clearTimeout(that.cid);\n                  that.cid = setTimeout(function() {\n                        if (that.nii != undefined)\n                            fun();\n                        clearTimeout(that.cid);\n                        that.cid = undefined;\n                    },t);\n            }\n            \n            if(master.static.lazydraw_timeout == 0 || typeof eagerDrawActive != "undefined" || (master.movie.isPlayed))\n            {\n                var draw3D = eagerDraw3D;\n                var draw2D = eagerDraw2D;\n            }\n            else\n            {\n                var draw3D = lazyDraw3D;\n                var draw2D = lazyDraw2D;\n            }\n\n\n            if (params && params.lazy == false)\n            {\n                draw2D = eagerDraw2D; \n            }\n            \n            if (gl_enabled)\n            {\n                var ctx3d = gl.getCtx();\n                var textures3d = gl.getTextures();\n                draw3D(textures3d,function(k) {\n                        if (that.nii == undefined)\n                            return;\n\n                        applySlicingDimOfWorld(k);\n                        textures3d[k].uOffset = 0;\n                        textures3d[k].vOffset = 1 - csy / gl.texSize;\n                        textures3d[k].uScale = csx / gl.texSize;\n                        textures3d[k].vScale = csy / gl.texSize;\n\n                        currentSlice = math.round(currentVoxel._data[slicingDimOfArray]);\n\n                        if (master.mainViewport !== -1)\n                        {\n                            sliceData = ctx3d[k].createImageData(csx, csy);\n                            drawSlice_interpolate();\n                            ctx3d[k].putImageData(sliceData, 0, 0);\n                        }\n                        else\n                        {\n                            if (!respectSlCh || textures3d[k].currentSlice != currentSlice)\n                            {\n                                sliceData = ctx3d[k].createImageData(csx, csy);\n                                if (!that.nii.dummy)\n                                    drawSlice_normal();\n                                else\n                                {\n                                    sliceData.data.fill(128+30*k);\n                                }\n                                ctx3d[k].putImageData(sliceData, 0, 0);\n                                textures3d[k].currentSlice = currentSlice;\n                            }\n\n                        }\n\n                },\n                function()\n                {\n                    gl.updatePlanes();\n                    gl.updateTexture();\n\n                });\n\n/*\n                var vr = gl.volrender;\n                for (var k = 0; k < vr.planes.length; k++)\n                {\n                    if (vr.planes[k] != undefined)\n                    {\n                        applySlicingDimOfWorld(vr.planes[k].sliceing);\n\n                        vr.textures[k].uOffset = 0;\n                        vr.textures[k].vOffset = 1 - csy / gl.texSize;\n                        vr.textures[k].uScale = csx / gl.texSize;\n                        vr.textures[k].vScale = csy / gl.texSize;\n                        sliceData = vr.ctx[k].createImageData(csx, csy);\n                        drawSlice_normal(math.round(vr.planes[k].arr_slicepos));\n                        vr.ctx[k].putImageData(sliceData, 0, 0);\n                    }\n                }\n                gl.updateVolume();\n                */\n\n            }\n            else\n            {\n\n                var sliceDrawer = drawSlice_normal;\n                if (master.mainViewport !== -1)\n                    sliceDrawer = drawSlice_interpolate;\n\n                if (that.mosaicview.active)\n                {\n                    if ((params && params.mosaicdraw) || that.atlas.length > 0)\n                        that.mosaicview.draw(sliceDrawer);\n\n\n                    renderOutlines("close")\n\n                }\n                else\n                {\n\n\n                    if (!respectSlCh || sliceChanged)\n                    {\n                     \n                        draw2D(function()\n                        {\n\n                            sliceData = ctx.createImageData(csx, csy);\n                            var clip;\n                            if (that.largeContent())\n                                clip = getClipBox();\n                            sliceDrawer(undefined,clip);\n                            ctx.putImageData(sliceData, 0, 0);\n\n                            renderOutlines("update",params)\n                        \n\n                        });\n\n                        \n\n\n\n                    }\n                }\n            }\n\n           // setCurrentVoxel();\n            drawHairCross();\n            updateInfoBar();\n\n            if (params && params.noquiver)\n                ;\n            else if (!respectSlCh || sliceChanged)\n                quiver.draw();\n\n        }\n\n\n\n        function renderOutlines(type,params)\n        {\n                if (params != undefined && params.frommove) // during roi-painting => do not update outlins\n                    return;\n\n                for (var k = 0; k < that.atlas.length;k++)\n                    if (that.atlas[k].outlines != undefined)\n                        that.atlas[k].outlines[type](that);\n                \n                if (that.outlines != undefined)\n                    that.outlines[type]();\n\n                for (var k = 0; k < that.overlays.length;k++)\n                    if (that.overlays[k].outlines != undefined)\n                        that.overlays[k].outlines[type](that);\n\n                for (var k = 0; k < that.objects3D.length;k++)\n                    if (that.objects3D[k].contour != undefined)\n                    {\n                        if (that.objects3D[k].outlines == undefined)\n                            that.objects3D[k].outlines = Outlines(that.objects3D[k])\n                        that.objects3D[k].outlines[type](that);\n                    }\n\n                \n                for (var k = 0; k < that.ROIs.length;k++)\n                    if (that.ROIs[k].outlines != undefined && that.ROIs[k].visible)\n                        that.ROIs[k].outlines[type](that);\n                    else if (!that.ROIs[k].visible && that.ROIs[k].outlines != undefined)\n                        that.ROIs[k].outlines[\'close\'](that);\n        }\n\n\n\n\n\n        var quiver = FiberQuiver(that);\n        that.quiver = quiver;\n\n\n        that.drawSlice = drawSlice;\n        that.positionChanger = signalhandler.attach("positionChange", drawSlice);\n        signalhandler.attach("drawSlices", drawSlice);\n\n\n        ///////////////////////// painting ///////////////////////////////////////////////\n        ///////////////////////// painting ///////////////////////////////////////////////\n\n\n        var niiOriginal;\n        function resliceOnMaster()\n        {\n            if (that.nii == undefined)\n                return;\n\n            // reset everything to normal first\n            that.nii = niiOriginal;\n\n            if (master.mainViewport !== -1)\n            {\n                var niin = master.viewports[master.mainViewport].medViewer.nii;\n                if (niin == undefined)\n                {\n                    master.toggleMainViewport(-1);\n                    //master.mainViewport = -1;\n                    return;\n                }\n\n                var sizes = [niin.sizes[0], niin.sizes[1],niin.sizes[2], niiOriginal.sizes[3]];\n                var voxsz = niin.voxSize;\n                var edges = niin.edges;\n\n                if (sizes[2] == 1 && that.viewport.viewPortID != master.mainViewport)\n                {\n                  var p0 = math.multiply(that.nii.edges,[0,0,0,1])._data;\n                  var p1 = math.multiply(that.nii.edges,[that.nii.sizes[0],that.nii.sizes[1],that.nii.sizes[2],1])._data;\n                  var n = [edges._data[0][2],edges._data[1][2],edges._data[2][2]];\n                  var d = math.floor(math.abs(((p0[0]-p1[0]) * n[0] + (p0[1]-p1[1]) * n[1] + (p0[2]-p1[2]) * n[2]) / math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2])));\n                  var vsz = voxsz[2];\n                  edges = math.multiply(edges, [ [1,0,0,0], [0,1,0,0], [0,0,vsz,-d/2],[0,0,0,1] ]);\n                  sizes[2] = (d/vsz);\n                  voxsz[2] = vsz;\n\n                 //   sizes[2] = that.nii.sizes\n                }\n\n\n\n\n\n                var centerVoxel = math.matrix([Math.floor(sizes[0] / 2),Math.floor(sizes[1] / 2),Math.floor(sizes[2] / 2),  1]);\n                var centerWorld = math.multiply(edges, centerVoxel);\n\n                that.nii = {\n                    edges: edges,\n                    voxSize: voxsz,\n                    sizes: sizes,\n                    edges_noscale: math.multiply(edges,math.diag([1/voxsz[0],1/voxsz[1],1/voxsz[2],1])),\n\n                    //  newsizes,\n                    permutationOrder: niin.permutationOrder,\n                    arrayReadDirection: niin.arrayReadDirection,\n                    detsign: niin.detsign,\n                    histogram: niiOriginal.histogram,\n                    currentTimePoint: niiOriginal.currentTimePoint,\n                    numTimePoints: niiOriginal.numTimePoints,\n\n                    centerVoxel:centerVoxel,\n                    centerWorld:centerWorld,\n\n                    widheidep: niin.widheidep,\n                    widhei: niin.widhei,\n                    wid: niin.wid,\n\n                    datascaling: niiOriginal.datascaling,\n                    type: \'nii\'\n                }\n\n            }\n\n\n            if (gl_enabled)\n                gl.updateObjects();\n\n            setSlicingDimOfWorld(slicingDimOfWorld);\n            setCurrentVoxel();\n            //drawSlice();\n        }\n\n        signalhandler.attach("reslice", resliceOnMaster);\n\n\n        ////////////////////////////////////\n\n        function drawSlice_interpolate(curSl,clipratio)\n        {\n\n            if (clipratio == undefined)\n                clipratio = 0;\n            //  console.log(\'in drawSlice_interpolate\');\n\n           // currentSlice = currentVoxel._data[slicingDimOfArray];\n\n            if (curSl != undefined)\n            {\n                currentSlice = curSl;                \n            }\n\n            var totsize = niiOriginal.sizes[0] * niiOriginal.sizes[1] * niiOriginal.sizes[2];\n\n            var tOffset = 0;\n            if (that.nii.currentTimePoint)\n                   tOffset = that.nii.currentTimePoint.t * totsize;\n            var tOffset_ovl = 0;\n\n            var R;\n            if (KViewer.navigationMode == 0 | KViewer.navigationMode == 2 )\n                R = math.diag([1, 1, 1, 1]);\n            else\n                R = getTiltMat(slicingDimOfArray);\n\n\n            // prep the overlays\n        /*    var overlay_visible = false;\n            for (var k = 0; k < that.overlays.length; k++)\n            {\n                var ovl = that.overlays[k];\n                ovl.tOffset_ovl = ovl.nii.currentTimePoint.t * ovl.nii.sizes[0] * ovl.nii.sizes[1] * ovl.nii.sizes[2];\n                var reorient = math.diag([1, 1, 1, 1]);\n                if (KViewer.navigationTool.isinstance && KViewer.navigationTool.movingObjs[ovl.currentFileID] != undefined & KViewer.navigationMode == 0)\n                    reorient = KViewer.reorientationMatrix.matrix;\n                ovl.A = (math.multiply(math.multiply(math.multiply(math.inv(ovl.nii.edges), reorient), that.nii.edges), R))._data;\n                overlay_visible = ovl.visible;\n  \n            }\n        */\n\n          // prep the overlays\n            prepOverlays(true);\n\n            var colVol = false;\n            var numCol = 0;\n            that.colVol_reorient = undefined;\n            if (niiOriginal.sizes[3]%3 == 0)\n            {\n                numCol = niiOriginal.sizes[3]/3\n                colVol = that.showcolored;\n\n                var n = that.nii;\n                var Order = KMedViewer.getPermutationOrder(); \n              \n                if (that.showcolored_type == "raw")\n                    that.colVol_reorient = math.diag([1,1,1,1])._data;\n                else\n                {\n                    var e2 = (math.multiply(n.edges,math.diag([1/n.voxSize[0],1/n.voxSize[1],1/n.voxSize[2],1])));\n                    e2 =  (math.multiply(math.inv(KViewer.reorientationMatrix.matrix),e2));\n\n\n                    e2 = colorPermutation(e2,that,niiOriginal);\n\n                    that.colVol_reorient = e2._data;\n                }\n\n            }\n         //   else\n           //     that.colVol_reorient = colorPermutation(math.diag([1,1,1,1]),that);\n\n\n\n            // prep the rois\n            while (that.ROIs_temp.length > 0) {\n                that.ROIs_temp.pop();\n            }\n            // empty the temp roi array for drawing;\n            for (var k = 0; k < that.ROIs.length; k++)\n            {\n                var reorient = math.diag([1, 1, 1, 1]);\n                if (KViewer.navigationTool.isinstance && \n                   ((KViewer.navigationTool.movingObjs[that.ROIs[k].roi.fileID] != undefined & KViewer.navigationMode == 0) | KViewer.navigationMode == 2 ) )\n                    reorient = KViewer.reorientationMatrix.matrix;\n                that.ROIs[k].A =(math.multiply(math.multiply(math.multiply(math.inv((that.ROIs[k].roi.content.edges)), reorient), that.nii.edges), R))._data;\n\n                if (that.ROIs[k].visible)\n                {\n                    that.ROIs_temp.push(that.ROIs[k]);\n                    that.ROIs[k].tOffset = that.ROIs[k].nii.currentTimePoint.t  * that.ROIs[k].roi.content.widheidep;\n\n                }\n            }\n            that.ROIs_temp.finalLength = that.ROIs_temp.length;\n\n\n            // prep the atlass\n            for (var k = 0; k < that.atlas.length; k++)\n                that.atlas[k].updateGetPixelFunction(that.nii, R);\n\n            var plotAtlas = that.atlas.length > 0;\n\n            // the(!) coordinate mapping\n            var reorient = math.diag([1, 1, 1, 1]);\n\n\n            if (KViewer.navigationTool.isinstance && \n                (( master.navigationTool.movingObjs[that.currentFileID] != undefined & KViewer.navigationMode == 0) | KViewer.navigationMode == 2 ) )\n                reorient = KViewer.reorientationMatrix.matrix;\n            R = math.multiply((math.multiply(math.inv(niiOriginal.edges), math.multiply(reorient, that.nii.edges))), R)._data;\n\n            function renderVal(k, px, py, pz)\n            {\n\n                var cval = trilinInterp(niiOriginal, px, py, pz, R, tOffset);\n\n                if (cval == undefined)\n                   cval = 0;\n\n                if (cval != undefined)\n                {\n\n\n                   for (var j = 0; j < that.overlays.length; j++)\n                        if (that.overlays[j].getPixel)\n                           that.overlays[j].val = that.overlays[j].getPixel(px,py,pz);\n\n                    if (colVol)\n                    {\n\n                        var e =  that.colVol_reorient ;\n                        var c = [0,0,0]\n                        var n = 1; //numCol\n                        for (var s = 0;s < n;s++)\n                        {\n                            var cVal = trilinInterp3_signcorrected(niiOriginal, px, py, pz, R,totsize,s*totsize*3); \n                            if (cVal == undefined)\n                                break;\n                            \n                            if (e)\n                            {\n                                c[0] +=  math.abs( e[0][0]*cVal[0] + e[0][1]*cVal[1] + e[0][2]*cVal[2]) \n                                c[1] +=  math.abs( e[1][0]*cVal[0] + e[1][1]*cVal[1] + e[1][2]*cVal[2]) \n                                c[2] +=  math.abs( e[2][0]*cVal[0] + e[2][1]*cVal[1] + e[2][2]*cVal[2])\n                            }\n                            else\n                            {\n                                c[0] += math.abs(cVal[0]);\n                                c[1] += math.abs(cVal[1]);\n                                c[2] += math.abs(cVal[2]);\n                            }\n\n                        }\n                        mapRGBval([c[0]/n,c[1]/n,c[2]/n],  k, rgbmapper,that.overlays.length,putVoxel);\n\n                    }\n                    else if (niiOriginal.datatype == \'rgb24\')\n                    {\n                           cval = trilinInterp_rgbnii(niiOriginal, px, py, pz, R, tOffset);\n                           if (cval != undefined)\n                            mapRGBval( cval, k, rgbmapper, that.overlays.length,putVoxel);\n                    }\n                    else\n                    {\n                        mapRGBval(cval, k, colmapper, that.overlays.length,putVoxel);\n                    }\n\n                }\n                if (that.ROIs_temp.finalLength > 0 |  plotAtlas) \n                    putRoiPixel(px, py, pz, k,undefined,putVoxel);\n\n            }\n\n            if (slicingDimOfArray == 0)\n            {\n                var sx_ =  that.nii.sizes[1];\n                var sy_ =  that.nii.sizes[2]; \n                var renderVal_ = function(k,a,b) { return renderVal(k,currentSlice,a,b); }\n            }\n            if (slicingDimOfArray == 1)\n            {\n                var sx_ =  that.nii.sizes[0];\n                var sy_ =  that.nii.sizes[2]; \n                var renderVal_ = function(k,a,b) { return renderVal(k,a,currentSlice,b); }\n            }\n            if (slicingDimOfArray == 2)\n            {\n                var sx_ =  that.nii.sizes[0];\n                var sy_ =  that.nii.sizes[1]; \n                var renderVal_ = function(k,a,b) { return renderVal(k,a,b,currentSlice); }\n            }\n                       \n            var cr = clipratio\n            if (swapXY)\n                cr = [clipratio[1],clipratio[0],clipratio[3],clipratio[2]];\n\n\n            if (clipratio.length == 4)\n            {\n                if (xflip != 0)\n                {\n                    var startx = Math.floor(sx_ * (1-cr[2]));\n                    var endx = Math.floor(sx_ * (1-cr[0]));\n                }\n                else\n                {\n                    var startx = Math.floor(sx_ * cr[0]);\n                    var endx = Math.floor(sx_ * cr[2]);\n                }\n\n                if (yflip != 0)\n                {\n                    var starty = Math.floor(sy_* (1-cr[3]));\n                    var endy = Math.floor(sy_ * (1-cr[1]));\n                }\n                else\n                {\n                    var starty = Math.floor(sy_* (cr[1]));\n                    var endy = Math.floor(sy_ * (cr[3]));\n                }\n\n                var sxclipped = Math.floor(sx);// *  (clipratio[2]-clipratio[0]));\n                var syclipped = sy; //Math.floor(sy *  (clipratio[2]-clipratio[0]));\n                var sx_clipped = Math.floor(sx_);//* (clipratio[2]-clipratio[0]));\n                var sy_clipped = sy_ //Math.floor(sy_* (clipratio[2]-clipratio[0]));\n                var offsx = 0;\n                var offsy = 0;\n\n            }\n            else\n            {\n\n\n                var startx = Math.floor(sx_ * clipratio / 2);\n                var starty = Math.floor(sy_ * clipratio / 2);\n                 var offsx = startx;\n                var offsy = starty;\n                var endx = sx_ - Math.floor(sx_ * clipratio / 2);\n                var endy = sy_ - Math.floor(sy_ * clipratio / 2);\n\n                var sxclipped = Math.floor(sx * (1 - clipratio))\n                var syclipped = Math.floor(sy * (1 - clipratio))\n                var sx_clipped = Math.floor(sx_ * (1 - clipratio))\n                var sy_clipped = Math.floor(sy_ * (1 - clipratio))\n            }\n\n            var lowres =  that.useLowres();\n            var putVoxel;\n            var delta = 1;\n            if (lowres)\n            {\n                delta = 2;\n                putVoxel = putQuad;\n            }\n            else\n                putVoxel = putSingle;\n\n            var k;\n            for (var x = startx; x < endx; x++)\n                for (var y = starty; y <endy; y++)\n                {   \n                    if (swapXY)\n                        k = ((sx_clipped * xflip + xdir * (x - offsx) - xflip) * syclipped + yflip * sy_clipped + ydir * (y - offsy) - yflip) * 4;\n                    else\n                        k = ((sy_clipped * yflip + ydir * (y - offsy) - yflip) * sxclipped + xflip * sx_clipped + xdir * (x - offsx) - xflip) * 4;\n\n                    if (lowres)\n                    {\n                        if (swapXY)\n                            k = [k,k+4,k+4+4*syclipped,k+4*sy_clipped];\n                        else\n                            k = [k,k+4,k+4+4*sxclipped,k+4*sx_clipped];\n                    }\n\n\n                   renderVal_(k, x,y);\n\n                }\n\n        }\n\n\n\n\n\n\n\n        function getTiltMat(slicing,nii)\n        {\n            if (nii == undefined)\n                nii = that.nii;\n\n            var sg = [];\n\n            var M = (permutationMat(nii))._data;\n            var perm = that.nii.permutationOrder;\n            var minors = function(a,b)\n            {\n                return [(a[1]*b[2] - a[2]*b[1]) ,\n                        (a[0]*b[2] - a[2]*b[0]) ,\n                        (a[0]*b[1] - a[1]*b[0])  ];\n            }        \n            var sg=[ minors(M[1],M[2])[perm[0]],\n                     minors(M[0],M[2])[perm[1]],\n                     minors(M[0],M[1])[perm[2]] ];\n\n            var R;\n            if (slicing == 0)\n                R = tiltMat(-sg[2] * master.currentTilts(2, 0).v, -sg[1] * master.currentTilts(1, 0).v, 0);\n            else if (slicing == 1)\n                R = tiltMat(sg[2] * master.currentTilts(2, 1).v, -sg[0] * master.currentTilts(0, 0).v, 1);\n            else\n                R = tiltMat(sg[0] * master.currentTilts(0, 1).v, sg[1] * master.currentTilts(1, 1).v, 2);\n               \n\n            return R;\n        }\n        that.getTiltMat = getTiltMat;\n \n        that.getSlicingTiltMat = function(nii)\n        {\n            return getTiltMat(slicingDimOfArray,nii);\n        }\n\n\n        function tiltMat(t1, t2, slicing)\n        {\n            var six = Math.sin(t1 / 180 * Math.PI);\n            var siy = Math.sin(t2 / 180 * Math.PI);\n            var sin2t = siy * siy + six * six + myeps;\n            var cost = Math.sqrt(1 - sin2t);\n            var a = (1 - cost) / sin2t;\n            var rotmat = math.matrix(\n            [[cost, six, siy, 0],\n            [-six, cost + a * siy * siy, -a * six * siy, 0],\n            [-siy, -a * six * siy, cost + a * six * six, 0],\n            [0, 0, 0, 1]]);\n            var Q;\n            if (slicing == 0)\n                Q = math.matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]);\n            else if (slicing == 1)\n                Q = math.matrix([[0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]);\n            else\n                Q = math.matrix([[0, 0, 1, 0], [0, 1, 0, 0], [1, 0, 0, 0], [0, 0, 0, 1]]);\n\n            var Trinv = math.multiply(Q, math.matrix([[that.nii.voxSize[0], 0, 0, -(currentVoxel._data[0]) * that.nii.voxSize[0]],\n            [0, that.nii.voxSize[1], 0, -(currentVoxel._data[1]) * that.nii.voxSize[1]],\n            [0, 0, that.nii.voxSize[2], -(currentVoxel._data[2]) * that.nii.voxSize[2]],\n            [0, 0, 0, 1]]));\n            var Tr = math.inv(Trinv);\n            A = math.multiply(Tr, math.multiply(rotmat, Trinv))._data;\n            return A;\n        }\n\n\n        var rgbmapper = function(cVal)\n        {\n            if (!isNaN(cVal[0]))\n            {\n                var rgba = histoManager.mapVal(cVal);\n                if (rgba[0] > 0 | rgba[1] > 0 | rgba[2] > 0)\n                    rgba[3] = 255;\n                else\n                    rgba[3] = 0;\n                return rgba;\n            }\n            else\n                return [0, 0, 0, 0];\n        }\n\n        var geo_rgbmapper = function(cVal)\n        {\n            if (!isNaN(cVal[0]))\n            {\n                var e =  that.colVol_reorient ;\n                if (e)\n                    cVal = [ math.abs( e[0][0]*cVal[0] + e[0][1]*cVal[1] + e[0][2]*cVal[2]) ,\n                             math.abs( e[1][0]*cVal[0] + e[1][1]*cVal[1] + e[1][2]*cVal[2]) ,\n                             math.abs( e[2][0]*cVal[0] + e[2][1]*cVal[1] + e[2][2]*cVal[2]) ];\n                else\n                    cVal = [ math.abs(cVal[0]),math.abs(cVal[1]),math.abs(cVal[2]) ];\n\n                var rgba = histoManager.mapVal(cVal);\n                if (rgba[0] > 0 | rgba[1] > 0 | rgba[2] > 0)\n                    rgba[3] = 255;\n                else\n                    rgba[3] = 0;\n                return rgba;\n            }\n            else\n                return [0, 0, 0, 0];\n        }\n\n\n\n        var colmapper = function(cVal)\n        {\n            if (!isNaN(cVal))\n            {\n                var currentVal = histoManager.mapVal(cVal);\n                return colormap.mapVal(currentVal, histoManager.cmapindex);\n            }\n            else\n                return [0, 0, 0, 0];\n        }\n\n\n\n\n        function mapRGBval(cVal, ktoplot, mapper, ovl_num,putVoxel)\n        {\n                var rgba = mapValtoRGBVol(cVal, mapper, ovl_num,ktoplot);\n                putVoxel(ktoplot,rgba);\n\n        }\n        function putSingle(k,rgba,f)\n        {\n             if (f == undefined)\n             {\n                sliceData.data[k + 0] = rgba[0];\n                sliceData.data[k + 1] = rgba[1];\n                sliceData.data[k + 2] = rgba[2];\n                sliceData.data[k + 3] = rgba[3];\n             }\n             else\n             {\n                sliceData.data[k + 0] = f(rgba[0],sliceData.data[k + 0]);\n                sliceData.data[k + 1] = f(rgba[1],sliceData.data[k + 1]);\n                sliceData.data[k + 2] = f(rgba[2],sliceData.data[k + 2]);\n                sliceData.data[k + 3] = rgba[3];\n\n             }\n        }\n\n        function putQuad(ktoplot,rgba,f)\n        {\n\n             if (f == undefined)\n             {\n                sliceData.data[ktoplot[0] + 0] = rgba[0];\n                sliceData.data[ktoplot[0] + 1] = rgba[1];\n                sliceData.data[ktoplot[0] + 2] = rgba[2];\n                sliceData.data[ktoplot[0] + 3] = rgba[3];\n\n                sliceData.data[ktoplot[1] + 0] = rgba[0];\n                sliceData.data[ktoplot[1] + 1] = rgba[1];\n                sliceData.data[ktoplot[1] + 2] = rgba[2];\n                sliceData.data[ktoplot[1] + 3] = rgba[3];\n\n                sliceData.data[ktoplot[2] + 0] = rgba[0];\n                sliceData.data[ktoplot[2] + 1] = rgba[1];\n                sliceData.data[ktoplot[2] + 2] = rgba[2];\n                sliceData.data[ktoplot[2] + 3] = rgba[3];\n\n                sliceData.data[ktoplot[3] + 0] = rgba[0];\n                sliceData.data[ktoplot[3] + 1] = rgba[1];\n                sliceData.data[ktoplot[3] + 2] = rgba[2];\n                sliceData.data[ktoplot[3] + 3] = rgba[3];\n             }\n             else\n             {\n                var a= f(rgba[0],sliceData.data[ktoplot[0] + 0]);\n                var b= f(rgba[1],sliceData.data[ktoplot[0] + 1]);\n                var c= f(rgba[2],sliceData.data[ktoplot[0] + 2]);\n\n                sliceData.data[ktoplot[0] + 0] = a\n                sliceData.data[ktoplot[0] + 1] = b\n                sliceData.data[ktoplot[0] + 2] = c\n                sliceData.data[ktoplot[0] + 3] = rgba[3];\n\n                sliceData.data[ktoplot[1] + 0] = a\n                sliceData.data[ktoplot[1] + 1] = b\n                sliceData.data[ktoplot[1] + 2] = c\n                sliceData.data[ktoplot[1] + 3] = rgba[3];\n\n                sliceData.data[ktoplot[2] + 0] = a\n                sliceData.data[ktoplot[2] + 1] = b\n                sliceData.data[ktoplot[2] + 2] = c\n                sliceData.data[ktoplot[2] + 3] = rgba[3];\n\n                sliceData.data[ktoplot[3] + 0] = a\n                sliceData.data[ktoplot[3] + 1] = b\n                sliceData.data[ktoplot[3] + 2] = c\n                sliceData.data[ktoplot[3] + 3] = rgba[3];\n\n             }\n        }\n\n\n        function mapValtoRGBVol(cVal, mapper, ovl_num,k)\n        {\n\n            var currentVal = 0;\n            var rgba = mapper(cVal, rgba);\n\n            if (ovl_num > 0)\n            {\n                var rgba_ovl = [0, 0, 0, 0];\n                for (var j = 0; j < ovl_num; j++)\n                {\n                    var ovl = that.overlays[j];\n                    if (ovl.visible)\n                    {\n                        var v = ovl.val;\n                        if (v[0] > 0 )\n                        {\n                            for (var i = 0; i < 4; i++)\n                                rgba_ovl[i] += v[i+1];\n                        }\n                    }\n                }\n\n                if (ovl.histoManager.blending)\n                {\n                    var fad = (rgba_ovl[0]+rgba_ovl[1]+rgba_ovl[2])/3/255;\n                    if (fad > 1) fad = 1;\n                    fad = Math.sqrt(fad)*that.transfactor;\n                    for (var i = 0; i < 4; i++)\n                        rgba[i] = rgba[i]*(1-fad) +that.transfactor*rgba_ovl[i];\n                }\n                else\n                {\n                    if (rgba_ovl[0]+rgba_ovl[1]+rgba_ovl[2] > 0)\n                        for (var i = 0; i < 4; i++)\n                            rgba[i] = rgba_ovl[i];\n\n                }\n\n/*\n                var rgba_ovl = [0, 0, 0, 0];\n                for (var j = 0; j < ovl_num; j++)\n                {\n                    var ovl = that.overlays[j];\n                    if (ovl.visible)\n                    {\n                        var v = ovl.val;\n                        if (v[0] > 0)\n                        {\n                            if (ovl.histoManager.blending)\n                            {\n                                var ovalcap = (v[0] > 1) ? 1 : v[0];\n                                for (var i = 0; i < 4; i++)\n                                {\n                                    rgba[i] *= (1 - ovalcap);\n                                    rgba[i] += v[i+1]*ovalcap;\n                                }\n                            }\n                            else\n                            {\n                                for (var i = 0; i < 4; i++)\n                                    rgba[i] = v[i+1];\n                            }\n                        }\n                    }\n                }\n*/\n              \n            }\n            return rgba;\n        }\n\n        function mapValtoRGBVol_old(cVal, k, mapper, ovl_num)\n        {\n\n            var currentVal = 0;\n            var rgba = mapper(cVal, rgba);\n\n            if (ovl_num > 0)\n            {\n                var rgba_ovl = [0, 0, 0, 0];\n                //var cnt = 0;\n                for (var j = 0; j < ovl_num; j++)\n                {\n                    var ovl = that.overlays[j];\n                    if (ovl.visible)\n                    {\n                        var v = ovl.val;\n//                        var oVal = ovl.histoManager.mapVal(ovl.val);\n//                        var c = colormap.mapValOvl(currentVal, histoManager.cmapindex, oVal, ovl.histoManager.cmapindex,   false);\n                        if (v[0] > 0)\n                        {\n                            if (ovl.histoManager.blending)\n                            {\n                                var ovalcap = (v[0] > 1) ? 1 : v[0];\n                                for (var i = 0; i < 4; i++)\n                                {\n                                    rgba[i] *= (1 - ovalcap);\n                                    rgba[i] += v[i+1]*ovalcap;\n                                    // this would be an alternative way to mix color. (dark background stays dark)\n                                    //rgba[i] *= v[i+1]/255;\n                                }\n                            }\n                            else\n                            {\n                                for (var i = 0; i < 4; i++)\n                                    rgba[i] = v[i+1];\n                            }\n                        }\n                    }\n                }\n              \n            }\n\n\n            sliceData.data[k + 0] = rgba[0];\n            sliceData.data[k + 1] = rgba[1];\n            sliceData.data[k + 2] = rgba[2];\n            sliceData.data[k + 3] = rgba[3];\n      \n            return k;\n        }\n\n\n\n\n        ////////////////////////////////\n\n        function putRoiPixel(px, py, pz, k,idx,putVoxel)\n        {\n    \n            var ison = false;\n            var len =  that.ROIs_temp.finalLength;\n            for (var r = 0; r < len; r++)\n            {\n                var roi = that.ROIs_temp[r].roi.content;\n                var v;\n                if (that.ROIs_temp[r].A == undefined)\n                {\n                    if (idx == undefined)\n                        idx = roi.widhei * pz + py * roi.wid + px;\n                    v = roi.data[idx + that.ROIs_temp[r].tOffset];\n                }\n                else\n                {\n                    v = trilinInterp(roi, px, py, pz, that.ROIs_temp[r].A, that.ROIs_temp[r].tOffset);\n                //    v = NNInterp(roi, px, py, pz, that.ROIs_temp[r].A, that.ROIs_temp[r].tOffset);\n                    \n                }\n                if (v > 0.5)\n                {\n                    var c = master.roiTool.colors[that.ROIs_temp[r].color];\n                    putVoxel(k, [c[0],c[1], c[2],255] ,  (a,b) => a*(1-state.viewer.roiTransparency) + b*state.viewer.roiTransparency );\n                    ison = true;\n                }\n              \n            }\n            if (1)\n            {\n                for (var r = 0; r < that.atlas.length; r++)\n                {\n                    var rgb = that.atlas[r].getPixel(px, py, pz);\n                    var alp = rgb[3]\n                    putVoxel(k, [rgb[0],rgb[1],rgb[2],255] ,  (a,b) => a * alp*that.atlas[r].atlas.content.alpha + b * (1-that.atlas[r].atlas.content.alpha*alp ) );                    \n                }\n            }\n        }\n\n        function prepOverlays(noNativeSlicing)\n        {\n            var nii = that.nii\n        \n            var R;\n            if (KViewer.navigationMode == 0 | KViewer.navigationMode == 2)\n                R = math.diag([1, 1, 1, 1]);\n            else\n                R = getTiltMat(slicingDimOfArray);\n\n           // prep the overlays\n            for (var k = 0; k < that.overlays.length; k++)\n            {\n                var ovl = that.overlays[k];\n                var totsz = ovl.nii.sizes[0] * ovl.nii.sizes[1] * ovl.nii.sizes[2];\n                ovl.tOffset_ovl = ovl.nii.currentTimePoint.t * totsz;\n                ovl.totsz = totsz;\n\n                var reorient = math.diag([1, 1, 1, 1]);\n                if (KViewer.navigationTool.isinstance && \n                       ((KViewer.navigationTool.movingObjs[ovl.currentFileID] != undefined & KViewer.navigationMode == 0) | (noNativeSlicing & KViewer.navigationMode == 2) ) )\n                    reorient = KViewer.reorientationMatrix.matrix;\n\n            \n                var ovledges = (ovl.nii.edges);\n                ovl.A = (math.multiply(math.multiply(math.multiply(math.inv(ovledges), reorient), that.nii.edges), R))._data;\n\n                if (ovl.visible)\n                {\n                    if (ovl.nii.sizes[3]%3 == 0 && ovl.showcolored)\n                    {\n\n\n                            var n = ovl.nii;\n                            var Order = KMedViewer.getPermutationOrder(); \n                            var e = (math.multiply(n.edges,math.diag([1/n.voxSize[0],1/n.voxSize[1],1/n.voxSize[2],1])));\n//                            e = math.multiply(math.inv(that.nii.edges),e)\n                            e = math.multiply((math.multiply(math.diag([n.voxSize[0],n.voxSize[1],n.voxSize[2],1]),math.inv(that.nii.edges))),e);\n                            e =  (math.multiply(math.inv(KViewer.reorientationMatrix.matrix),e));\n                            e = colorPermutation(e,ovl,ovl.nii);\n                            e = e._data;\n                            \n\n\n                            \n\n                           ovl.getPixel = function(px,py,pz) { \n                                var ovl = this;\n                                var c =  trilinInterp3_signcorrected(ovl.nii, px, py, pz, ovl.A,ovl.totsz); \n                                if (c != undefined)\n                                {\n                                    var q = [0,0,0];\n                                    q[0] = ovl.histoManager.mapVal(Math.abs(e[0][0]*c[0] + e[0][1]*c[1] + e[0][2]*c[2]));\n                                    q[1] = ovl.histoManager.mapVal(Math.abs(e[1][0]*c[0] + e[1][1]*c[1] + e[1][2]*c[2]));\n                                    q[2] = ovl.histoManager.mapVal(Math.abs(e[2][0]*c[0] + e[2][1]*c[1] + e[2][2]*c[2]));\n                                    var s = (q[0]+q[1]+q[2])/3;\n                                    return [s,q[0]*128,q[1]*128,q[2]*128,255];\n                                }\n                                else\n                                    return [0,0,0,0,0];\n                                };\n                    }\n                    else if (ovl.nii.datatype == "rgb24")\n                    {\n                        ovl.getPixel = function(px,py,pz) \n                        {\n                            var c =  trilinInterp_rgbnii(ovl.nii, px, py, pz, ovl.A, ovl.tOffset_ovl) || [0,0,0,0];\n                            var s = (c[0]+c[1]+c[2])/(3*255) *2 ;\n                            //s = .6;\n                            return [s, c[0], c[1], c[2], 255];\n                        } \n                    }\n                    else\n                    {\n                        var interpfun;\n                        var currentVal = 0; // an ancient remain ... \n                        if (!ovl.histoManager.blocky)\n                            ovl.interpfun = trilinInterp;\n                        else \n                            ovl.interpfun = NNInterp;\n                        ovl.getPixel = function(px,py,pz) { \n                                var ovl = this;\n                                var val =  ovl.interpfun(ovl.nii, px, py, pz, ovl.A, ovl.tOffset_ovl); \n                                if (isNaN(val))\n                                     return [0];\n                                if (!ovl.histoManager.posnegsym)\n                                {\n                                    var oVal = ovl.histoManager.mapVal(val);\n                                    if (oVal == undefined)\n                                        return [0];\n                                    var c = colormap.mapValOvl(currentVal, histoManager.cmapindex,oVal, ovl.histoManager.cmapindex,   false);\n                                    return [oVal,c[0],c[1],c[2],c[3]];\n                                }\n                                else\n                                {\n                                    if (val > 0)\n                                    {\n                                        var oVal = ovl.histoManager.mapVal(val);\n                                        if (oVal > 0)\n                                        {\n                                            oVal = oVal/2+0.5;\n                                            var c = colormap.mapValOvl(currentVal, histoManager.cmapindex,oVal, ovl.histoManager.cmapindex,   false);\n                                            return [oVal,c[0],c[1],c[2],c[3]];\n                                        }\n                                    }\n                                    else\n                                    {\n                                        var oVal = ovl.histoManager.mapVal(-val);\n                                        if (oVal > 0)\n                                        {\n                                            oVal = (1-oVal)*0.5;\n                                            if (oVal < 0.01) oVal = 0.01;\n                                            var c = colormap.mapValOvl(currentVal, histoManager.cmapindex, oVal, ovl.histoManager.cmapindex,   false);                                    \n                                            return [oVal,c[0],c[1],c[2],c[3]];\n                                        }\n                                    }\n                                    return [0];\n                                }\n                                };\n                    }\n                }  \n                else\n                    ovl.getPixel = undefined;\n\n            }\n        }\n\n\n        /*******************************************************************************************************************************************\n        * drawSlice_normal\n        *******************************************************************************************************************************************/\n\n     \n        function drawSlice_normal(curSl, clipratio, nanrender)\n        {\n            if (clipratio == undefined)\n                clipratio = 0;\n\n            var nii = that.nii;\n\n            if (nii.dummy)\n                return;\n         \n       //     currentSlice = math.round(currentVoxel._data[slicingDimOfArray]);\n\n            var this_colmapper = colmapper;\n\n            if (curSl != undefined)\n            {\n                currentSlice = curSl;\n\n                if (nanrender)\n                {\n                    this_colmapper = function(cVal)\n                    {\n                        if (!isNaN(cVal))\n                        {\n                            currentVal = histoManager.mapVal(cVal);\n                            var rgb = colormap.mapVal(currentVal, histoManager.cmapindex);\n                            rgb[3] = math.max(currentVal * 255, 0);\n\n                            return rgb;\n                        }\n                        else\n                            return [0, 0, 0, 0];\n                    }\n                }\n            }\n\n\n            var totsize = nii.sizes[0] * nii.sizes[1] * nii.sizes[2]\n            var tOffset = that.nii.currentTimePoint.t*totsize\n\n\n            // prep the overlays\n            prepOverlays(false);\n\n\n\n\n            // prep the rois\n\n            while (that.ROIs_temp.length > 0) {\n                that.ROIs_temp.pop();\n            }\n            // empty the temp roi array for drawing;\n            for (var k = 0; k < that.ROIs.length; k++)\n            {\n                if (nii.edges._data.toString() == that.ROIs[k].roi.content.edges._data.toString())\n                    that.ROIs[k].A = undefined;\n                else\n                   that.ROIs[k].A = ((math.multiply(math.inv((that.ROIs[k].roi.content.edges)), nii.edges)))._data;\n\n                if (that.ROIs[k].visible)\n                {\n                    that.ROIs_temp.push(that.ROIs[k]);\n                    that.ROIs[k].tOffset = that.ROIs[k].nii.currentTimePoint.t  * that.ROIs[k].roi.content.widheidep;\n                }\n            }\n            that.ROIs_temp.finalLength = that.ROIs_temp.length;\n\n\n            // prep the atlass\n            for (var k = 0; k < that.atlas.length; k++)\n                that.atlas[k].updateGetPixelFunction(nii);\n\n            var sx_, sy_;\n            if (slicingDimOfArray == 0)\n            {\n                sx_ = that.nii.sizes[1];\n                sy_ = that.nii.sizes[2];\n            }\n            if (slicingDimOfArray == 1)\n            {\n                sx_ = that.nii.sizes[0];\n                sy_ = that.nii.sizes[2];\n            }\n            if (slicingDimOfArray == 2)\n            {\n                sx_ = that.nii.sizes[0];\n                sy_ = that.nii.sizes[1];\n            }\n\n\n            var colVol = false;\n            var numCol = 0;\n            if (nii.sizes[3]%3 == 0)\n            {\n                numCol = nii.sizes[3]/3;\n                colVol = that.showcolored;\n                that.colVol_reorient =  colorPermutation(math.diag([1,1,1,1]),that,nii)._data;\n\n                if (nii.sizes[4] > 1)\n                {\n                    var tOffset0 = nii.sizes[0] * nii.sizes[1] * nii.sizes[2] * (0 + 3 * that.nii.currentTimePoint.t);\n                    var tOffset1 = nii.sizes[0] * nii.sizes[1] * nii.sizes[2] * (1 + 3 * that.nii.currentTimePoint.t);\n                    var tOffset2 = nii.sizes[0] * nii.sizes[1] * nii.sizes[2] * (2 + 3 * that.nii.currentTimePoint.t);\n                }\n                else\n                {\n                    var tOffset0 = nii.sizes[0] * nii.sizes[1] * nii.sizes[2] * ((0 + that.nii.currentTimePoint.t) % 3);\n                    var tOffset1 = nii.sizes[0] * nii.sizes[1] * nii.sizes[2] * ((1 + that.nii.currentTimePoint.t) % 3);\n                    var tOffset2 = nii.sizes[0] * nii.sizes[1] * nii.sizes[2] * ((2 + that.nii.currentTimePoint.t) % 3);\n                }\n            }\n\n            // THORAX XRAY PROJECT KOTTER\n            // special case: for a single slice (e.g. high res X-Ray), use an drawing optimized method \n            // one important factor is: looped operations are much faster when iterated consecutive!!\n           /* if (nii.singleSlice)\n            {\n                var data32 = new Uint32Array(sliceData.data.buffer);\n                var clim0 = that.histoManager.clim[0];\n                var clim1 = that.histoManager.clim[1];\n                var scslope = 255 / (clim1 - clim0);\n                var nVoxels = nii.sizes[0] * nii.sizes[1] * nii.sizes[2];\n\n                for (var i = 0; i < nVoxels; i++)\n                {\n                    var val = (nii.data[i] - clim0) * scslope;\n                    if (val > 255)\n                        val = 255;\n                    if (val < 0)\n                        val = 0;\n                    var j = 4 * i;\n                    sliceData.data[j + 0] = val\n                    sliceData.data[j + 1] = val;\n                    sliceData.data[j + 2] = val;\n                    sliceData.data[j + 3] = 255;\n\n                    //                    data32[i] = (255 << 24) | val << 16 | val << 8 | val;\n\n                }\n                sliceDrawUpdateNeeded = false;\n\n\n                return\n            }*/\n\n            // special single case case end\n\n\n            var lowres = (that.useLowres() && !that.isGLenabled());\n            var delta = 1;\n            var putVoxel;\n            \n            if (lowres)\n            {\n                delta = 2;\n                putVoxel = putQuad;\n            }\n            else\n                putVoxel = putSingle;\n\n\n            if (currentSlice < nii.sizes[slicingDimOfArray] & currentSlice >= 0)\n            {\n                var px, py, pz;\n                var ovl_num = that.overlays.length;\n                var cr = clipratio\n                if (swapXY)\n                    cr = [clipratio[1],clipratio[0],clipratio[3],clipratio[2]];\n\n                if (clipratio.length == 4)\n                {\n                    if (xflip != 0)\n                    {\n                        var startx = Math.floor(sx_ * (1-cr[2]));\n                        var endx = Math.floor(sx_ * (1-cr[0]));\n                    }\n                    else\n                    {\n                        var startx = Math.floor(sx_ * cr[0]);\n                        var endx = Math.floor(sx_ * cr[2]);\n                    }\n\n                    if (yflip != 0)\n                    {\n                        var starty = Math.floor(sy_* (1-cr[3]));\n                        var endy = Math.floor(sy_ * (1-cr[1]));\n                    }\n                    else\n                    {\n                        var starty = Math.floor(sy_* (cr[1]));\n                        var endy = Math.floor(sy_ * (cr[3]));\n                    }\n\n                    var sxclipped = sx;\n                    var syclipped = sy; \n                    var sx_clipped = sxclipped;\n                    var sy_clipped = syclipped;\n                    var offsx = 0;\n                    var offsy = 0;\n\n                }\n                else\n                {\n\n                    var startx = Math.floor(sx_ * clipratio / 2);\n                    var starty = Math.floor(sy_ * clipratio / 2);\n                    var offsx = startx;\n                    var offsy = starty;\n                    var endx = sx_ - Math.floor(sx_ * clipratio / 2);\n                    var endy = sy_ - Math.floor(sy_ * clipratio / 2);\n\n                    var sxclipped = Math.floor(sx * (1 - clipratio))\n                    var syclipped = Math.floor(sy * (1 - clipratio))\n                    var sx_clipped = Math.floor(sx_ * (1 - clipratio))\n                    var sy_clipped = Math.floor(sy_ * (1 - clipratio))\n                }\n\n                var deltak;\n                if (swapXY)\n                    deltak = 4*ydir*delta;\n                else\n                    deltak = 4*ydir*sxclipped*delta;\n\n                \n                for (var x = startx; x < endx; x+=delta)\n                {\n            \n                    if (swapXY)\n                        k = ((sx_clipped * xflip + xdir * (x - offsx) - xflip) * syclipped + yflip * sy_clipped + ydir * (starty - offsy) - yflip) * 4;\n                    else\n                        k = ((sy_clipped * yflip + ydir * (starty - offsy) - yflip) * sxclipped + xflip * sx_clipped + xdir * (x - offsx) - xflip) * 4;\n\n                    for (var y = starty; y < endy; y+=delta)\n                    {\n\n                        if (slicingDimOfArray == 0) {\n                            px = currentSlice;\n                            py = x;\n                            pz = y;\n                        }\n                        if (slicingDimOfArray == 1) {\n                            px = x;\n                            py = currentSlice;\n                            pz = y;\n                        }\n                        if (slicingDimOfArray == 2) {\n                            px = x;\n                            py = y;\n                            pz = currentSlice;\n                        }\n\n                         var ind = nii.widhei * pz + py * nii.wid + px;\n\n                        var v = nii.data[ind + tOffset];\n                        if (isNaN(v))\n                        {\n                            k+= deltak;                          \n                            continue;\n                        }\n\n\n\n                        for (var j = 0; j < ovl_num; j++)\n                            if (that.overlays[j].getPixel)\n                               that.overlays[j].val = that.overlays[j].getPixel(px,py,pz);\n\n                         var ktoplot = k;\n\n                         if (lowres)\n                         {\n                            if (swapXY)\n                               ktoplot = [k,k+4,k+4+4*syclipped,k+4*sy_clipped];\n                            else\n                               ktoplot = [k,k+4,k+4+4*sxclipped,k+4*sx_clipped];                               \n                         }\n\n\n                         if (that.nii.datatype == \'rgb24\')\n                         {\n                             // for rgb, data is stored as triplets, so we have to calc the indexing differently\n                               var ind = 3*( ind + tOffset);\n                               mapRGBval( [ nii.data[ind + 0], nii.data[ind+1], nii.data[ind+2]], ktoplot, rgbmapper, ovl_num ,putVoxel);\n                         }\n                         else if (colVol)\n                         {\n                                var c = [0,0,0]\n                                var e =  that.colVol_reorient ;   \n                                var n = 1; //numCol                             \n                                for (var s = 0;s <n;s++)\n                                {\n                                    var cVal = [ nii.data[ind + tOffset0 + totsize*s*3] , nii.data[ind + tOffset1+ totsize*s*3] , nii.data[ind + tOffset2 + totsize*s*3] ]\n\n                                    if (cVal == undefined)\n                                        break;\n\n                                    if (e)\n                                    {\n                                        c[0] +=  math.abs( e[0][0]*cVal[0] + e[0][1]*cVal[1] + e[0][2]*cVal[2]) \n                                        c[1] +=  math.abs( e[1][0]*cVal[0] + e[1][1]*cVal[1] + e[1][2]*cVal[2]) \n                                        c[2] +=  math.abs( e[2][0]*cVal[0] + e[2][1]*cVal[1] + e[2][2]*cVal[2])\n                                    }\n                                    else\n                                    {\n                                        c[0] += math.abs(cVal[0]);\n                                        c[1] += math.abs(cVal[1]);\n                                        c[2] += math.abs(cVal[2]);\n                                    }\n\n                                }\n                                mapRGBval([c[0]/n,c[1]/n,c[2]/n],ktoplot, rgbmapper, ovl_num ,putVoxel);\n                         }\n                         else\n                         {\n                            mapRGBval(v, \n                                        ktoplot, this_colmapper, ovl_num ,putVoxel);\n                         }\n\n\n                        putRoiPixel(px, py, pz, ktoplot,ind,putVoxel);\n\n                        k+= deltak;\n\n\n                    }\n                    //y\n                }\n                //x\n\n            }\n\n\n\n\n        }\n\n\n        /*******************************************************************************************************************************************\n        * end of         drawSlice_normal\n        *******************************************************************************************************************************************/\n\n\n        that.imageupdater = signalhandler.attach("updateImage",function(ev)\n        {\n            if (that.currentFileID == ev.id)\n            {\n                setSlicingDimOfWorld();\n                drawSlice(ev);\n             \n            }\n\n\n            for (var k = 0; k < that.atlas.length;k++)\n            {\n                 if (that.atlas[0].atlas.fileID == ev.id)\n                 {\n                     drawSlice(ev);\n                     return;\n                 }\n            }\n\n            for (var k = 0; k < that.ROIs.length;k++)\n            {\n                if (that.ROIs[k].roi.fileID == ev.id)\n                {\n                    drawSlice(ev);\n                    if (that.isGLenabled() && !ev.no3d)\n                        KViewer.roiTool.update3D(that.ROIs[k].roi);\n                    return;\n                }\n            }\n            for (var k = 0; k < that.overlays.length;k++)\n            {\n                if (that.overlays[k].currentFileID == ev.id)\n                {\n                    drawSlice(ev);\n                    return;\n                }\n            }\n\n            for (var k = 0; k < that.objects3D.length;k++)\n            {\n                if (that.objects3D[k].overlays)\n                {\n                    for (var j = 0; j < that.objects3D[k].overlays.length;j++)                    \n                    {\n                        var x = that.objects3D[k].overlays[j];\n                        if (x.surfacecolref)\n                        {\n                            x.surfacecolref.update();\n                        }\n                    }\n\n                }\n            }\n\n        });\n\n\n        signalhandler.attach("updateFilelink",function(ev)\n        {\n            function update()\n            {\n                that.$timediv.update()\n                applySlicingDimOfWorld(slicingDimOfWorld);        \n      //          setCanvasLayout();            \n                drawSlice();\n            }\n\n\n            for (var k = 0; k < that.quivers.length;k++)\n            {\n                if (that.quivers[k].parentviewbar.currentFileID  == ev.id)\n                {\n                    var fileObject = KViewer.dataManager.getFile(ev.id);                    \n                    var qp = that.quivers[k].nii.quiver_params\n                    that.quivers[k].nii = fileObject.content;\n                    that.quivers[k].nii.quiver_params = qp;\n                }\n            }\n\n\n            if (that.currentFileID == ev.id)\n            {\n                var fileObject = KViewer.dataManager.getFile(ev.id);\n                that.content = fileObject;\n                that.nii  = fileObject.content;\n                niiOriginal = that.nii;\n                that.niiOriginal = niiOriginal;\n                \n                update();\n                return;\n            }\n\n\n            for (var k = 0; k < that.ROIs.length;k++)\n            {\n                if (that.ROIs[k].roi.fileID == ev.id)\n                {\n                    var fileObject = KViewer.dataManager.getFile(ev.id);\n\n                    if(1)// must re-create the view, if 4D roi\n                    {\n                        var robj =that.ROIs[k];\n                        for (var r = 0; r < robj.divs.length; r++)\n                                robj.divs[r].remove();\n                        if (robj.outlines != undefined)\n                            robj.outlines.close();\n\n                        if (robj.refSurfView != undefined)\n                            robj.refSurfView.close();\n\n                        that.ROIs[k] = master.roiTool.createView(fileObject, that, {});\n                    }\n\n                    that.ROIs[k].nii = fileObject.content;\n                    KViewer.roiTool.update3D(that.ROIs[k].roi);\n\n                    update();\n                    return;\n                }\n            }\n            \n            for (var k = 0; k < that.overlays.length;k++)\n            {\n                if (that.overlays[k].currentFileID == ev.id)\n                {\n                    var fileObject = KViewer.dataManager.getFile(ev.id);\n                    that.overlays[k].nii = fileObject.content;\n                    KViewer.roiTool.update3D(that.overlays[k]);\n                    //if (that.overlays[k].quiver)\n                    //    that.quivernii.nii = fileObject.content;\n                    update();\n                    return;\n                }\n            }\n\n            for (var k = 0; k < that.objects3D.length;k++)\n            {\n                if (that.objects3D[k].fibers && that.objects3D[k].fibers.fileID == ev.id)\n                {\n                    var fileObject = KViewer.dataManager.getFile(ev.id);\n                    that.objects3D[k].fibers = fileObject;\n                     that.objects3D[k].updateFibers();\n                }\n                if (that.objects3D[k].overlays != undefined)\n                {\n                    for (var s = 0; s < that.objects3D[k].overlays.length;s++)\n                    {\n                        if (that.objects3D[k].overlays[s].currentFileID == ev.id)\n                        {\n                            var fileObject = KViewer.dataManager.getFile(ev.id);\n                            that.objects3D[k].overlays[s].nii = fileObject.content;\n                            that.objects3D[k].update();\n                            //KViewer.roiTool.update3D(that.objects3D[k].overlays[s]);\n                            update();\n\n                        }\n\n                    }\n                }\n            }            \n        });\n\n\n\n\n\n        function getCurrenVoxel()\n        {\n            return currentVoxel;\n        }\n        that.getCurrenVoxel = getCurrenVoxel;\n\n\n        function hasContent(type)\n        {\n            var c = [];\n            for (var k = 0; k < that.objects3D.length;k++)\n                if (that.objects3D[k][type] != undefined)\n                    c.push(that.objects3D[k]);\n            if (c.length > 0)\n                return c;\n            else\n                return undefined;\n\n        }\n        that.hasContent = hasContent;\n\n        // used in 3dviewer for info on ctrl hold\n        function getValueAtWorldPosition(point)\n        {\n              var tOffset = 0;\n              if (that.nii.currentTimePoint)\n                   tOffset = that.nii.currentTimePoint.t * niiOriginal.sizes[0] * niiOriginal.sizes[1] * niiOriginal.sizes[2];\n              \n              var val;\n              var whichnii;\n              if (!niiOriginal.dummy)\n                whichnii = niiOriginal\n              else\n                {\n\n                }\n                \n              if (whichnii != undefined)\n              {\n                  if (whichnii.sizes[3] == 3)\n                  {\n                     val =  Math.abs(NNInterp(whichnii, point._data[0], point._data[1], point._data[2], math.inv(whichnii.edges)._data, 0) )+ \n                            Math.abs(NNInterp(whichnii, point._data[0], point._data[1], point._data[2], math.inv(whichnii.edges)._data,  whichnii.sizes[0] * whichnii.sizes[1] * whichnii.sizes[2]) )+ \n                            Math.abs(NNInterp(whichnii, point._data[0], point._data[1], point._data[2], math.inv(whichnii.edges)._data,  whichnii.sizes[0] * whichnii.sizes[1] * whichnii.sizes[2]*2)) ;\n                  }\n                  else\n                     val =  NNInterp(niiOriginal, point._data[0], point._data[1], point._data[2], math.inv(that.niiOriginal.edges)._data, tOffset);\n              }\n              else\n                return 1;\n\n              if (val != undefined)\n              {\n                  var value;\n                  if (!(that.nii.datascaling.id()))\n                    {\n                        value = (that.nii.datascaling.e(val)).toFixed(4);\n                        value += " (" + val.toFixed(4) + ")";\n                    }\n                    else\n                        value = val.toFixed(4);\n                    that.currentValueAt3DWorldPick = value;\n              }\n              \n              that.currentCoordinateAt3DWorldPick = point._data;\n              val = math.abs(val)>that.histoManager.clim[0];\n              \n              return val;\n        }\n        that.getValueAtWorldPosition = getValueAtWorldPosition;\n\n\n\n        function setCurrentVoxel()\n        {\n\n            var sliceChanged = false;\n            if (that.nii) // && !that.nii.dummy)\n            {\n\n                var nii = that.nii;\n                var point = getWorldPosition();\n                if (master.mainViewport !== -1)\n                {\n                    point = math.multiply(math.inv(master.reorientationMatrix.matrix), point);\n                }\n                var curV = math.multiply(math.inv(nii.edges), point);\n\n                currentVoxel = curV;\n                \n                var totsz = niiOriginal.sizes[0] * niiOriginal.sizes[1] * niiOriginal.sizes[2]; \n\n                \n                var c = math.round(currentVoxel._data[slicingDimOfArray]+0.000001);\n\n                if (c != currentSlice)\n                    sliceChanged = true;\n\n                currentSlice = c;\n\n\n                var trafoMatrix = (math.multiply(math.inv(niiOriginal.edges), math.multiply(master.reorientationMatrix.matrix, that.nii.edges)));\n\n\n                var tOffset = 0;\n                if (nii.currentTimePoint)\n                   tOffset = nii.currentTimePoint.t * niiOriginal.sizes[0] * niiOriginal.sizes[1] * niiOriginal.sizes[2];\n                if (master.mainViewport !== -1)\n                    currentValue = trilinInterp(niiOriginal, point._data[0], point._data[1], point._data[2], math.multiply(trafoMatrix, math.inv(nii.edges))._data, tOffset);\n                else\n                {\n                    if (niiOriginal.data)\n                    {\n                        if (niiOriginal.sizes[3] == 3)\n                        {\n                            var px = NNInterp(niiOriginal, point._data[0], point._data[1], point._data[2], math.inv(nii.edges)._data, 0);\n                            var py = NNInterp(niiOriginal, point._data[0], point._data[1], point._data[2], math.inv(nii.edges)._data, totsz);\n                            var pz = NNInterp(niiOriginal, point._data[0], point._data[1], point._data[2], math.inv(nii.edges)._data, 2*totsz)\n                            currentValue = Math.sqrt(px*px+py*py+pz*pz);\n                        }\n                        else\n                            currentValue = NNInterp(niiOriginal, point._data[0], point._data[1], point._data[2], math.inv(nii.edges)._data, tOffset);\n                    }\n                }\n\n\n                for (var k = 0; k < that.overlays.length; k++)\n                {\n                    var ovl = that.overlays[k];\n                    if (ovl.A)\n                        ovl.currentValue = NNInterp(ovl.nii, currentVoxel._data[0], currentVoxel._data[1], currentVoxel._data[2], ovl.A, ovl.tOffset_ovl)\n\n                }\n\n            }\n            return sliceChanged;\n        }\n\n\n\n\n        function createTSeriesPinViewer(ev)\n        {\n            var tseriesdiv = $("#KseriesViewer");\n            var tseriesmax = $("#KseriesViewerMax");\n            var tseriesmin = $("#KseriesViewerMin");\n            var tseriescurrent = $("#KseriesViewerCurrent");\n\n            if (ev == \'close\')\n            {\n                $(tseriesdiv).remove();\n                return;\n            }\n\n            if (tseriesdiv.length == 0)\n            {\n                tseriesdiv = $("<div id=\'KseriesViewer\'> <svg height=180 width=400>" +\n                " <polygon points=\'\' style=\'fill:yellow;stroke:purple;stroke-width:1\' />sdkldk</svg></div>").appendTo($(document.body));\n                $(tseriesdiv).on("contextmenu", function(ev) {\n                    return false;\n                });\n                $("<div id=\'KseriesViewerMax\'> </div>").appendTo($(tseriesdiv));\n                $("<div id=\'KseriesViewerMin\'> </div>").appendTo($(tseriesdiv));\n                $("<div id=\'KseriesViewerCurrent\'> </div>").appendTo($(tseriesdiv));\n                tseriesdiv = $("#KseriesViewer");\n                tseriesmax = $("#KseriesViewerMax");\n                tseriesmin = $("#KseriesViewerMin");\n                tseriescurrent = $("#KseriesViewerCurrent");\n                $(tseriescurrent).css({\n                    left: niiOriginal.currentTimePoint.t / niiOriginal.sizes[3] * 200\n                });\n            }\n            tseriesdiv.css({\n                display: \'block\'\n            });\n            tseriesdiv.css({\n                left: ev.clientX,\n                top: ev.clientY\n            });\n\n            var tserheight = $(tseriesdiv).height();\n            var tserwidth = $(tseriesdiv).width();\n\n            var $poly = $(tseriesdiv).children().children();\n            var pstr = "";\n            var scfac = 0.1;\n            var tser = getCurrentTseries();\n            for (var i = 0; i < tser.data.length; i++)\n            {\n                var v = (tser.data[i] - tser.min) / (tser.max - tser.min);\n                if (v == NaN)\n                    v = 0;\n                pstr = pstr + (tserwidth * i / tser.data.length) + ","\n                + (tserheight - 1 * tserheight * v) + " ";\n            }\n            pstr = pstr + tserwidth + "," + tserheight + " 0," + tserheight;\n            $poly.attr("points", pstr);\n            $(tseriesmax).text("" + tser.max.toFixed(2));\n            $(tseriesmin).text("" + tser.min.toFixed(2));\n            $(tseriescurrent).css({\n                left: niiOriginal.currentTimePoint.t / niiOriginal.sizes[3] * 200\n            });\n        }\n\n        function getCurrentTseries()\n        {\n\n            var nii = that.nii;\n            var point = getWorldPosition();\n            //if (master.mainViewport !== -1)\n            //   point = math.multiply(math.inv(master.reorientationMatrix.matrix), point);\n            var curV = math.multiply(math.inv(niiOriginal.edges), point);\n\n            var max;\n            var min;\n            var tseries = [];\n            var vsz = niiOriginal.sizes[0] * niiOriginal.sizes[1] * niiOriginal.sizes[2];\n            for (var k = 0; k < niiOriginal.sizes[3]; k++)\n            {\n                var v;\n                v = trilinInterp(niiOriginal, curV._data[0], curV._data[1], curV._data[2], [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], k * vsz);\n                tseries.push(v);\n                if (max == undefined | v > max)\n                    max = v;\n                if (min == undefined | v < min)\n                    min = v;\n            }\n            return {\n                data: tseries,\n                max: max,\n                min: min\n            };\n        }\n        that.getCurrentTseries = getCurrentTseries;\n\n\n        that.getCurrentFiberView = function()\n        {\n            for (var k = 0; k < that.objects3D.length; k++)\n            {\n                if (that.objects3D[k].fibers != undefined)\n                    if (that.objects3D[k].isCurrent)\n                    {\n                        return that.objects3D[k];\n                    }\n            }\n\n            return;\n\n        }\n\n\n\n        return that;\n\n    }\n\n\n    // =======================  end of medviewer ===============================================================\n\n\n/********************************************************************\nbmpToNIFI\n********************************************************************/ \nfunction bmpToNIFTI(uint8buffer, callback)\n{\n    // prep canvas\n    var canvas = document.createElement(\'canvas\');\n    var ctx = canvas.getContext(\'2d\');\n\n    // create the image\n    var blob = new Blob( [ uint8buffer ], { type: "image" } );\n    var urlCreator = window.URL || window.webkitURL;\n    var strDataURI = urlCreator.createObjectURL( blob );   \n    var img = new Image;\n\n    img.onload = whenloaded;\n    img.src = strDataURI;\n\n    function whenloaded()\n    {\n        \n        canvas.width = img.width;     \n        canvas.height = img.height;\n        \n\n        ctx.drawImage(img,0,0);\n        var pixelData = ctx.getImageData(0, 0, img.width, img.height);\n\n        var niihdr = [92, 1, 0, 0, 117, 105, 110, 116, 49, 54, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 114, 0, 1, 0, 16, 0, 16, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 16, 0, 0, 0, 0, 0, 128, 191, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 111, 110, 101, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 191, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 128, 63, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 110, 105, 49, 0, 0, 0, 0, 0];\n        var hdrbuffer = (new Uint8Array(niihdr)).buffer;\n\n        var isrgb = true;\n        if(isrgb)\n        {\n            var type = 128;\n            var bitpix = 8*3;\n        }\n        else\n        {\n            var type = 2;\n            var bitpix = 8;\n        }\n\n        var sizes = [img.width,img.height,1];\n\n        var cumsize = sizes[0] * sizes[1] * sizes[2];\n\n        var thearray = new Uint8Array(hdrbuffer.byteLength + bitpix / 8 * cumsize );\n        var buffer = thearray.buffer;\n\n        var view = new DataView(buffer);\n        littleEndian = 1;\n        // sizes\n        view.setInt32(0, 348, littleEndian)\n        view.setInt16(40, 3, littleEndian)\n        view.setInt16(42, sizes[0], littleEndian)\n        view.setInt16(44, sizes[1], littleEndian)\n        view.setInt16(46, sizes[2], littleEndian)\n        view.setInt16(48, 1, littleEndian) // time dim\n        \n        // windowing\n        view.setFloat32(124, 255, littleEndian)\n        view.setFloat32(128, 0, littleEndian)\n\n        // edges\n        var pixsize = 1;\n        view.setFloat32(280 + 0 * 4, -pixsize, littleEndian);\n        view.setFloat32(280 + 1 * 4, 0, littleEndian);\n        view.setFloat32(280 + 2 * 4, 0, littleEndian);\n        view.setFloat32(280 + 3 * 4, 0, littleEndian);\n\n        view.setFloat32(280 + 4 * 4, 0, littleEndian);\n        view.setFloat32(280 + 5 * 4, -pixsize, littleEndian);\n        view.setFloat32(280 + 6 * 4, 0, littleEndian);\n        view.setFloat32(280 + 7 * 4, 0, littleEndian);\n\n        view.setFloat32(280 + 8 * 4, 0, littleEndian);\n        view.setFloat32(280 + 9 * 4, 0, littleEndian);\n        view.setFloat32(280 + 10 * 4, pixsize, littleEndian);\n        view.setFloat32(280 + 11 * 4, 0, littleEndian);\n\n        view.setInt16(252, 0, littleEndian)\n        //qform\n        view.setInt16(254, 1, littleEndian)\n        //sform\n\n\n        // ====== apply some other important stuff\n        // set the magic number to n+1\n        view.setInt32(344, 1848324352, !littleEndian)\n        // set vox offset to 352\n        view.setFloat32(108, 352, littleEndian)\n        view.setInt32(348, 0, littleEndian);\n        view.setInt16(70, type, littleEndian);\n        view.setInt16(72, bitpix, littleEndian);\n        if(isrgb)\n        {\n            for(var k=0; k < cumsize; k++)\n            {\n                view.setUint8(352 + k*3+0 , pixelData.data[k*4+0] , littleEndian);\n                view.setUint8(352 + k*3+1 , pixelData.data[k*4+1] , littleEndian);\n                view.setUint8(352 + k*3+2 , pixelData.data[k*4+2] , littleEndian);\n            }\n        }\n        else\n        {\n            for(var k=0; k < cumsize; k++)\n                view.setUint8(352 + k , pixelData.data[4*k] , littleEndian);\n\n        }\n        \n        if(callback)\n            callback(thearray);\n    }\n}\n\n\nfunction setSpace(nii,pref)\n{\n\n    if (pref == undefined)\n        pref = \'ras\'\n\n    function mapIt (space)\n    {\n        var t = space.toLowerCase()\n        var m ;\n        switch (t)\n        {\n            case \'ras\' :\n            case \'right-anterior-superior\' : m = [\'ras\', [1,1,1]]; break;\n            case \'las\' :\n            case \'left-anterior-superior\' : m = [\'las\', [-1,1,1]]; break;\n            case \'rps\' :\n            case \'right-posterior-superior\' : m = [\'rps\', [1,-1,1]]; break;\n            case \'lps\' :\n            case \'left-posterior-superior\' : m = [\'lps\', [-1,-1,1]]; break;\n            case \'rai\' :\n            case \'right-anterior-inferior\' : m = [\'ras\', [1,1,-1]]; break;\n            case \'lai\' :\n            case \'left-anterior-inferior\' : m = [\'las\', [-1,1,-1]]; break;\n            case \'rpi\' :\n            case \'right-posterior-inferior\' : m = [\'rpi\', [1,-1,-1]]; break;\n            case \'lpi\' :\n            case \'left-posterior-inferior\' : m = [\'lpi\', [-1,-1,-1]]; break;\n        }\n        return m;\n    }\n\n\n    var s = mapIt(nii.space);\n    if (s == undefined)\n    {\n        console.warn("no valid space definition found!");\n        return;\n    }\n    var p = mapIt(pref);\n\n    var flips = [s[1][0]*p[1][0],s[1][1]*p[1][1],s[1][2]*p[1][2]]\n\n\n    for (var k = 0; k < 3;k++)\n    {\n        if (flips[k] == -1)\n        {\n            nii.spaceOrigin[k] = -nii.spaceOrigin[k] ;\n            for (var j = 0; j < 3;j++)\n                nii.spaceDirections[j][k] = -nii.spaceDirections[j][k];\n\n        }\n    }\n    \n\n    nii.space = pref;\n}\n\n\n\n/********************************************************************\nprepareMedicalImageData\n********************************************************************/ \nfunction prepareMedicalImageData(nii_in, fobj, intent)\n{\n\n\n    var nii = nii_in;\n\n\n\n    nii.updateLimits = function(nii,fobj) {return function() { prepareMedicalImageData(nii, fobj ) } }(nii, fobj);\n\n\n    // this is spectrum data ...\n    if (nii.sizes.length == 1)\n        nii.type = \'nii/spectral\'\n    else\n        nii.type = \'nii\'\n\n    if (nii.sizes[0] === 1 || nii.sizes[1] === 1  || nii.sizes[2] === 1)\n         nii.singleSlice = true;\n    else\n         nii.singleSlice = false;\n\n\n    // workaround: in ill nifitis, there might be only zeros in matrix --\x3e everything goes wrong afterwards. Should not be here, since nifti remain the same (save rois ...)\n    if (math.sum(nii.spaceDirections[0]) == 0)\n        nii.spaceDirections[0] = [1, 0, 0];\n    if (math.sum(nii.spaceDirections[1]) == 0)\n        nii.spaceDirections[1] = [0, 1, 0];\n    if (math.sum(nii.spaceDirections[2]) == 0)\n        nii.spaceDirections[2] = [0, 0, 1];\n\n    \n    if (state.viewer.spacedef)\n    {\n        if (state.viewer.spacedef != "NO")\n        {\n           setSpace(nii,state.viewer.spacedef )\n     \n        }\n    }\n\n\n\n\n    // permutationOrder gives the order in which the real world is stored in the array\n\n    nii.applyReordering  = function(id)\n    {\n\n        var permutationOrder = [findIndexOfGreatest(nii.spaceDirections[0]), findIndexOfGreatest(nii.spaceDirections[1]), findIndexOfGreatest(nii.spaceDirections[2])];\n\n        if (permutationOrder[0] == permutationOrder[1] ||  permutationOrder[0] == permutationOrder[2] || permutationOrder[2] == permutationOrder[1])\n        {\n            console.warn(\'something went wrong with slice ordering , assuuming [0,1,2] by default\');\n            permutationOrder = [0,1,2];\n        }\n\n        if (0) // nii.singleSlice)\n        {\n            nii.arrayReadDirection = [1,1,1];\n            nii.permutationOrder = [0,1,2];\n            nii.reordering = \'\';\n\n        }\n        else\n        {\n\n            var arrayReadDirection = [nii.spaceDirections[0][permutationOrder[0]] < 0 ? -1 : 1, nii.spaceDirections[1][permutationOrder[1]] < 0 ? -1 : 1, nii.spaceDirections[2][permutationOrder[2]] < 0 ? -1 : 1, ];\n\n\n            nii.arrayReadDirection = arrayReadDirection;\n            nii.permutationOrder = permutationOrder;\n\n            // check and apply any reordering\n            var Order = KMedViewer.getPermutationOrder(id);\n            var perm = Order.perm;\n            var flips = Order.flips;\n            if (Order.fixed)\n            {\n                nii.permutationOrder = Order.perm.slice(0);\n                nii.arrayReadDirection = Order.flips.slice(0);\n\n            }\n            else\n            {\n                nii.permutationOrder = [perm[nii.permutationOrder[0]], perm[nii.permutationOrder[1]], perm[nii.permutationOrder[2]]];\n                nii.arrayReadDirection = [flips[nii.permutationOrder[0]] * nii.arrayReadDirection[0], flips[nii.permutationOrder[1]] * nii.arrayReadDirection[1], flips[nii.permutationOrder[2]] * nii.arrayReadDirection[2]];\n            }\n            nii.reordering = Order.id;\n\n            nii.invPermOrder = [];\n            nii.invPermOrder[nii.permutationOrder[0]] = 0;\n            nii.invPermOrder[nii.permutationOrder[1]] = 1;\n            nii.invPermOrder[nii.permutationOrder[2]] = 2;\n        }\n\n    }\n    nii.applyReordering();\n\n    nii.edges = math.eye(4);\n    nii.voxSize = [1, 1, 1];\n\n\n    // spaceDirections are stored column wise (column index first)\n    // multiplication in javascript is row-wise defined, therefore transpose at the end\n    nii.edges._data[0][0] = nii.spaceDirections[0][0];\n    nii.edges._data[0][1] = nii.spaceDirections[0][1];\n    nii.edges._data[0][2] = nii.spaceDirections[0][2];\n    nii.edges._data[1][0] = nii.spaceDirections[1][0];\n    nii.edges._data[1][1] = nii.spaceDirections[1][1];\n    nii.edges._data[1][2] = nii.spaceDirections[1][2];\n    nii.edges._data[2][0] = nii.spaceDirections[2][0];\n    nii.edges._data[2][1] = nii.spaceDirections[2][1];\n    nii.edges._data[2][2] = nii.spaceDirections[2][2];\n    nii.edges._data[3][0] = nii.spaceOrigin[0];\n    nii.edges._data[3][1] = nii.spaceOrigin[1];\n    nii.edges._data[3][2] = nii.spaceOrigin[2];\n    nii.edges = math.transpose(nii.edges);\n\n\n    nii.voxSize[0] = math.sqrt(nii.spaceDirections[0][0] * nii.spaceDirections[0][0] + nii.spaceDirections[0][1] * nii.spaceDirections[0][1] + nii.spaceDirections[0][2] * nii.spaceDirections[0][2]);\n    nii.voxSize[1] = math.sqrt(nii.spaceDirections[1][0] * nii.spaceDirections[1][0] + nii.spaceDirections[1][1] * nii.spaceDirections[1][1] + nii.spaceDirections[1][2] * nii.spaceDirections[1][2]);\n    nii.voxSize[2] = math.sqrt(nii.spaceDirections[2][0] * nii.spaceDirections[2][0] + nii.spaceDirections[2][1] * nii.spaceDirections[2][1] + nii.spaceDirections[2][2] * nii.spaceDirections[2][2]);\n\n\n    nii.edges_noscale = math.multiply(nii.edges,math.diag([1/nii.voxSize[0],1/nii.voxSize[1],1/nii.voxSize[2],1]))\n    var r0 = 0.98;\n    var r1 = 1.02;\n\n    //if (nii_in.pixdim[1].toFixed(1) != nii.voxSize[0].toFixed(1) | nii_in.pixdim[2].toFixed(1) != nii.voxSize[1].toFixed(1) | nii_in.pixdim[2].toFixed(1) != nii.voxSize[1].toFixed(1))\n    if (!(nii_in.pixdim[1]/nii.voxSize[0] > r0 & nii_in.pixdim[1]/nii.voxSize[0] < r1 & \n          nii_in.pixdim[2]/nii.voxSize[1] > r0 & nii_in.pixdim[2]/nii.voxSize[1] < r1 & \n          nii_in.pixdim[3]/nii.voxSize[2] > r0 & nii_in.pixdim[3]/nii.voxSize[2] < r1  \n    ))\n    {\n        console.warn(\'warning: nifti voxelsizes inconsistent,\' + nii_in.pixdim.toString());\n    }\n\n    if(fobj && fobj.fileinfo)\n    {\n        var psid = fobj.fileinfo.patients_id + fobj.fileinfo.studies_id;\n        var coreginfo = KViewer.dataManager.coregInfos[psid];\n        \n        if(coreginfo && coreginfo.matrix)\n        {\n            var coregmat = coreginfo.matrix;\n            nii.edges = math.multiply(math.matrix(coregmat), nii.edges );\n            console.log("Coregmat found, transforming " + coreginfo)\n        }\n    }\n\n\n\n    nii.detsign = math.sign(math.det(nii.edges));\n\n\n    nii.currentTimePoint = {\n        t: 0\n    };\n\n\n    if (nii.sizes.length < 3)\n        nii.sizes[2] = 1;\n    if (nii.sizes.length < 4)\n        nii.sizes[3] = 1;\n    if (nii.sizes.length < 5)\n        nii.sizes[4] = 1;\n\n    if (nii.sizes[4] == 1 | nii.sizes[4] == undefined)\n        nii.numTimePoints = nii.sizes[3] ;\n    else\n        nii.numTimePoints = nii.sizes[4] ;\n\n\n    nii.centerVoxel = math.matrix([Math.floor(nii.sizes[0] / 2),Math.floor(nii.sizes[1] / 2),Math.floor(nii.sizes[2] / 2),  1]);\n    nii.centerWorld = math.multiply(nii.edges, nii.centerVoxel);\n\n\n    //console.log(Date.now().toString().substr(8) + "  ========== NIFTI edges ====== detsign " + nii.detsign + " \\n" + print_matrix(nii.edges._data));\n\n\n    // --------- create a test image --------\n    if (0)\n    {\n        swapXY = 0;\n        nii.arrayReadDirection = [1, -1, 1];\n        slicingDimOfArray = 2;\n        var ssx = nii.sizes[0];\n        var ssy = nii.sizes[1];\n        var ssz = nii.sizes[2];\n        for (var z = 0; z < ssz - 10; z++)\n        {\n            for (var y = 0; y < ssy / 2; y++)\n            {\n                for (var x = 0; x < ssx; x++)\n                {\n                    nii.data[ssx * ssy * z + ssx * y + x] = x / ssx * 3;\n                }\n            }\n        }\n    }\n\n\n    nii.widheidep = nii.sizes[0] * nii.sizes[1] * nii.sizes[2];\n    nii.widhei = nii.sizes[0] * nii.sizes[1];\n    nii.wid = nii.sizes[0];\n\n\n\n    // calculate the mean of the image for auto colormap\n    nii.histogram = new Object\n    var numsamples = 50001;\n\n    var n = nii.sizes[0] * nii.sizes[1] * nii.sizes[2];\n    \n    // 4D data?\n    if( (nii.sizes.length) >= 4 )\n        n *= nii.sizes[3];\n\n    try { eval(\' nii.descrip = {\'+nii.descrip+\'}\'); } catch(err) {}\n\n    // get the max and min of the whole array.\n    {\n        var minmax = getMinMax(nii.data, n, numsamples);\n        var max = minmax.max;\n        var min = minmax.min;\n    }\n\n\n    // CT scan speciality:\n    if( nii.scl_inter == -1024)\n    {\n        var min = 1000;\n        var max = 1200;\n    }\n\n\n    var nbins = 1000;\n    // fine histo to compute quantiles\n    nii.histogram = comphisto(min, max, nbins, nii.data, n, numsamples)\n\n\n    var EPSILON = 0.01;\n\n    var i = 0;\n    var sum = 0;\n    while (sum <= 3)\n        sum += nii.histogram.accus[i++];\n    min = nii.histogram.min + (nii.histogram.max - nii.histogram.min) * (i - 1) / nbins;\n    sum = 0;\n\n    i = 0;\n    while (sum <= 97)\n        sum += nii.histogram.accus[i++];\n    max = nii.histogram.min + (nii.histogram.max - nii.histogram.min) * (i - 1) / nbins;\n\n    min = min - EPSILON;\n    // add -eps to max. important.\n    max = max + EPSILON;\n    // add eps to max. important.\n\n    if (nii.descrip.hlim)\n    {\n        min = nii.descrip.hlim[0];\n        max = nii.descrip.hlim[1];\n    }\n\n\n    var nbins_final = 30;\n\n    //numsamples_final = Math.min(math.round(max-min),nbins_final);\n\n    // compute final histo\n    nii.histogram = comphisto(min + 0.02 * (max - min), max + 0.1 * (max - min), nbins_final, nii.data, n, numsamples)\n\n\n    // can set the outer lims for the histogram manually as string parameter "a,b" for the auotloader\n    if (intent !== undefined)\n    {\n        if (intent.clim_outer !== undefined)\n        {\n            min = parseFloat(intent.clim_outer.split(\',\')[0]);\n            max = parseFloat(intent.clim_outer.split(\',\')[1]);\n            nii.histogram = comphisto(min, max, nbins_final, nii.data, n, numsamples)\n        }\n    }\n\n\n\n    return nii;\n}\n\n\n\n\n// ======================================================================================\n// ======================================================================================\n// == KColorMap\n// ======================================================================================\n// ======================================================================================\n\n/** Object to orgainze colormaps and map values to rgb indexed colors\n* @class  */\n\n\n\nfunction KColormap()\n{\n    n = 256;\n    var hot = [[], [], []];\n    //new Array();\n    // ------ hot\n    for (var k = 0; k < n; k++)\n    {\n        if (k < 95)\n        {\n            hot[0][k] = k / 94 * 255;\n            hot[1][k] = 0;\n            hot[2][k] = 0;\n        }\n        if (k >= 95 & k < 195)\n        {\n            hot[0][k] = n - 1;\n            hot[1][k] = (k - 95) / 95.0 * (n - 1);\n            hot[2][k] = 0;\n        }\n        if (k >= 195)\n        {\n            hot[0][k] = n - 1;\n            hot[1][k] = n - 1;\n            hot[2][k] = (k - 195) / 101.0 * (n - 1);\n        }\n\n    }\n\n\n    var cgray = [[], [], []];\n    var red = [[], [], []];\n    var green = [[], [], []];\n    var blue = [[], [], []];\n    for (var k = 0; k < n; k++)\n    {\n        cgray[0][k] = k;\n        cgray[1][k] = k;\n        cgray[2][k] = k;\n        red[0][k] = k;\n        red[1][k] = 0;\n        red[2][k] = 0;\n        green[0][k] = 0;\n        green[1][k] = k;\n        green[2][k] = 0;\n        blue[0][k] = 0;\n        blue[1][k] = 0;\n        blue[2][k] = k;\n    }\n\n    var jet  = KColormap.jet;\n    var cold = KColormap.cold;\n    var rsp  = KColormap.rsp;\n    var btr  = KColormap.btr;\n    /* MATLAB code to generate colormps\n    x = jet(256);\n\n    strr = \'[\'; strg = \'[\'; strb = \'[\';\n    for k = 1:256,\n        strr = [strr sprintf(\'%0.f,\',(x(k,1)*255))];\n        strg = [strg sprintf(\'%0.f,\',(x(k,2)*255))];\n        strb = [strb sprintf(\'%0.f,\',(x(k,3)*255))];\n    end;\n    fprintf([\'[\' strr(1:end-1) \'], \\n \' strg(1:end-1) \'], \\n \' strb(1:end-1) \']  ]\\n \'])\n    */\n\n    var that = {};\n    that.names = ["gray", "hot", "jet", "cold", "rsp", "btr", "unicolor","upperThres", "lowerThres"];\n    that.maps = [cgray, hot, jet, cold, rsp, btr];\n    that.mapVal = mapVal;\n    that.mapValOvl = mapValOvl;\n    that.numCmaps = that.names.length;\n\n\n    for (var j = 0; j < KColor.list.length;j++)\n    {\n        var c = KColor.list[j]\n        var cm =  [[], [], []];\n        for (var k = 0; k < n; k++)\n        {\n            cm[0][k] = Math.floor(k*c[0]/255);\n            cm[1][k] = Math.floor(k*c[1]/255);\n            cm[2][k] = Math.floor(k*c[2]/255);\n        }\n        that.maps[100+j] = cm;\n    }\n\n\n\n\n    function mapIndex(name)\n    {\n        for (var k = 0; k < that.numCmaps; k++)\n        {\n            if (that.names[k].search(name) != -1)\n                return k;\n        }\n        return -1;\n    }\n    that.mapIndex = mapIndex;\n\n\n    /** maps scalar value between 0 and 1 to color triple\n    * @param {number} val -  the value \n    * @param {number} i -  index of colomap\n    */\n    function mapVal(val, i)\n    {\n        var alpha = 255;\n        if (i >= that.numCmaps - 2  && i < 100)\n        {\n            return [255 * val, 0, 0, alpha];\n        }\n        else\n        {\n        \t\n        \tvar cmap = colormap.maps[i];\n        \tif(cmap==undefined)\n        \t\tcmap = colormap.maps[0];\n            var v = Math.floor(val * 255);\n            if (v < 0)\n                v = 0;\n            if (v > 255)\n                v = 255;\n            if (v == 0)\n                return [cmap[0][v], cmap[1][v], cmap[2][v], 0];\n            else\n                return [cmap[0][v], cmap[1][v], cmap[2][v], 255];\n        }\n    }\n\n\n    /** maps two scalar value between 0 and 1 to color triple\n    * @param {number} val -  background value \n    * @param {number} j -  index of colormap for background\n    * @param {number} oVal -  overlay value \n    * @param {number} i -  index of colormap of overlay\n    * @param {logical} blend - type of overlay\n    */\n    function mapValOvl(val, j, oVal, i, blend)\n    {\n        var rgba = mapVal(val, j);\n\n        if (i >= that.numCmaps - 2 && i < 100) // upper/lower threshold on overlay\n        {\n            if (blend)\n            {\n                if (val < 0)\n                    return [0, 0, 0, 255];\n                else\n                {\n                    var tc = (1 - oVal * 0.25);\n                    return [oVal * 255 + rgba[0] * (1 - oVal), rgba[1] * tc, rgba[2] * tc, 255];\n                }\n            }\n            else\n            {\n                if (oVal > 0.5 & val >= 0)\n                    return [255, 0, 0, 255];\n                else\n                    return rgba;\n            }\n        }\n        else\n        {\n            if (oVal < 0)\n                oVal = 0;\n            if (oVal > 1)\n                oVal = 1;\n            var oIdx = Math.round(oVal * 255);\n            if (oIdx < 0)\n                oIdx = 0;\n            if (oIdx > 255)\n                oIdx = 255;\n            if (blend)\n            {\n                var ic = (1 - val);\n                if (ic < 0)\n                    ic = 0;\n                ic = math.pow(ic, 0.5);\n                return [colormap.maps[i][0][oIdx] * ic + rgba[0],\n                colormap.maps[i][1][oIdx] * ic + rgba[1],\n                colormap.maps[i][2][oIdx] * ic + rgba[2], 255];\n            }\n            else\n            {\n                if (oVal == 0)\n                {\n                    return rgba;\n                }\n                else\n                {\n                    return [colormap.maps[i][0][oIdx],\n                    colormap.maps[i][1][oIdx],\n                    colormap.maps[i][2][oIdx], 255];\n                }\n            }\n        }\n    }\n\n    /** colorlim presets\n    */\n\n    // in pacs given as center / width\n    that.colorlimpresets = \n    [\n        {title: "Auto (from zero)",      min:    0,             max:\'auto\'},\n        {title: "Auto",                  min:  \'auto\',          max:\'auto\'},\n        {title: "CT Brain tissue",       min:   50 - 100/2,     max:50 + 100/2},\n        {title: "CT Bone",               min:  500 - 2000/2,    max:500 + 2000/2},\n        {title: "CT Soft tissue",        min:   50 - 350/2,     max:50 + 350/2},\n        {title: "CT Liver",              min:  100 - 200/2,     max:100 + 200/2},\n        {title: "CT Lung",               min: -500 - 1440/2,    max:-500 + 1440/2},\n    ]\n\n    return that;\n\n\n}\n\nKColormap.jet = [[0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 131, 135, 139, 143, 147, 151, 155, 159, 163, 167, 171, 175, 179, 183, 187, 191, 195, 199, 203, 207, 211, 215, 219, 223, 227, 231, 235, 239, 243, 247, 251, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 251, 247, 243, 239, 235, 231, 227, 223, 219, 215, 211, 207, 203, 199, 195, 191, 187, 183, 179, 175, 171, 167, 163, 159, 155, 151, 147, 143, 139, 135, 131, 128],\n    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 8, 12, 16, 20, 24, 28, 32, 36, 40, 44, 48, 52, 56, 60, 64, 68, 72, 76, 80, 84, 88, 92, 96, 100, 104, 108, 112, 116, 120, 124, 128, 131, 135, 139, 143, 147, 151, 155, 159, 163, 167, 171, 175, 179, 183, 187, 191, 195, 199, 203, 207, 211, 215, 219, 223, 227, 231, 235, 239, 243, 247, 251, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 251, 247, 243, 239, 235, 231, 227, 223, 219, 215, 211, 207, 203, 199, 195, 191, 187, 183, 179, 175, 171, 167, 163, 159, 155, 151, 147, 143, 139, 135, 131, 128, 124, 120, 116, 112, 108, 104, 100, 96, 92, 88, 84, 80, 76, 72, 68, 64, 60, 56, 52, 48, 44, 40, 36, 32, 28, 24, 20, 16, 12, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n    [0, 135, 139, 143, 147, 151, 155, 159, 163, 167, 171, 175, 179, 183, 187, 191, 195, 199, 203, 207, 211, 215, 219, 223, 227, 231, 235, 239, 243, 247, 251, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 255, 251, 247, 243, 239, 235, 231, 227, 223, 219, 215, 211, 207, 203, 199, 195, 191, 187, 183, 179, 175, 171, 167, 163, 159, 155, 151, 147, 143, 139, 135, 131, 128, 124, 120, 116, 112, 108, 104, 100, 96, 92, 88, 84, 80, 76, 72, 68, 64, 60, 56, 52, 48, 44, 40, 36, 32, 28, 24, 20, 16, 12, 8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]];\n\nKColormap.cold = [[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0], \n [254,253,252,251,250,249,248,247,246,245,244,243,242,241,240,239,238,237,236,235,234,233,232,231,230,229,228,227,226,225,224,223,222,221,220,219,218,217,216,215,214,213,212,211,210,209,208,207,206,205,204,203,202,201,200,199,198,197,196,195,194,193,192,191,190,189,188,187,186,185,184,183,182,181,180,179,178,177,176,175,174,173,172,171,170,169,168,167,166,165,164,163,162,161,160,159,158,157,156,155,154,153,152,151,150,149,148,147,146,145,144,143,142,141,140,139,138,137,136,135,134,133,132,131,130,129,128,128,127,126,125,124,123,122,121,120,119,118,117,116,115,114,113,112,111,110,109,108,107,106,105,104,103,102,101,100,99,98,97,96,95,94,93,92,91,90,89,88,87,86,85,84,83,82,81,80,79,78,77,76,75,74,73,72,71,70,69,68,67,66,65,64,63,62,61,60,59,58,57,56,55,54,53,52,51,50,49,48,47,46,45,44,43,42,41,40,39,38,37,36,35,34,33,32,31,30,29,28,27,26,25,24,23,22,21,20,19,18,17,16,15,14,13,12,11,10,9,8,7,6,5,4,3,2,1,0].reverse(), \n [255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255].reverse()  ]\n\n\nKColormap.rsp = [[59,60,62,63,64,65,67,68,69,70,72,73,74,75,77,78,79,80,82,83,84,86,87,88,89,91,92,93,94,96,97,98,99,101,102,103,104,106,107,108,110,111,112,113,115,116,117,118,120,121,122,123,125,126,127,128,130,131,132,134,135,136,137,139,140,142,143,144,145,147,148,149,151,152,153,154,156,157,158,159,161,162,163,164,166,167,168,169,171,172,173,175,176,177,178,180,181,182,183,185,186,187,188,190,191,192,193,195,196,197,199,200,201,202,204,205,206,207,209,210,211,212,214,215,216,217,219,220,220,220,219,219,219,218,218,218,217,217,217,217,216,216,216,215,215,215,214,214,214,213,213,213,212,212,212,212,211,211,211,210,210,210,209,209,209,208,208,208,207,207,207,207,206,206,206,205,205,205,204,204,204,203,203,203,202,202,202,201,201,201,201,200,200,199,199,199,199,198,198,198,197,197,197,196,196,196,195,195,195,194,194,194,193,193,193,193,192,192,192,191,191,191,190,190,190,189,189,189,188,188,188,188,187,187,187,186,186,186,185,185,185,184,184,184,183,183,183,183,182,182,182,181,181,181,180,180],\n [76,77,78,79,81,82,83,84,85,86,87,88,90,91,92,93,94,95,96,97,99,100,101,102,103,104,105,106,108,109,110,111,112,113,114,116,117,118,119,120,121,122,123,125,126,127,128,129,130,131,132,134,135,136,137,138,139,140,142,143,144,145,146,147,149,150,151,152,153,154,156,157,158,159,160,161,162,164,165,166,167,168,169,170,171,173,174,175,176,177,178,179,180,182,183,184,185,186,187,188,190,191,192,193,194,195,196,197,199,200,201,202,203,204,205,206,208,209,210,211,212,213,214,215,217,218,219,220,220,218,217,215,213,212,210,208,206,205,203,201,200,198,196,195,193,191,190,188,186,184,183,181,179,178,176,174,173,171,169,167,166,164,162,161,159,157,156,154,152,151,149,147,145,144,142,140,139,137,135,134,132,130,129,127,125,123,122,120,118,117,115,113,111,109,107,106,104,102,101,99,97,95,94,92,90,89,87,85,84,82,80,79,77,75,73,72,70,68,67,65,63,62,60,58,57,55,53,51,50,48,46,45,43,41,40,38,36,34,33,31,29,28,26,24,23,21,19,18,16,14,12,11,9,7,6,4],\n [192,192,192,193,193,193,193,194,194,194,194,194,195,195,195,195,196,196,196,196,196,197,197,197,197,197,198,198,198,198,199,199,199,199,199,200,200,200,200,201,201,201,201,201,202,202,202,202,203,203,203,203,203,204,204,204,204,205,205,205,205,205,206,206,206,206,207,207,207,207,207,208,208,208,208,209,209,209,209,209,210,210,210,210,211,211,211,211,211,212,212,212,212,213,213,213,213,213,214,214,214,214,215,215,215,215,215,216,216,216,216,216,217,217,217,217,218,218,218,218,218,219,219,219,219,220,220,220,220,219,217,216,214,213,211,210,209,207,206,204,203,201,200,199,197,196,194,193,191,190,189,187,186,184,183,181,180,179,177,176,174,173,171,170,169,167,166,164,163,161,160,159,157,156,154,153,151,150,149,147,146,144,143,141,140,139,137,136,134,133,131,130,128,127,125,124,122,121,119,118,117,115,114,112,111,109,108,107,105,104,102,101,99,98,97,95,94,92,91,89,88,87,85,84,82,81,79,78,77,75,74,72,71,69,68,67,65,64,62,61,59,58,57,55,54,52,51,49,48,47,45,44,42,41,39,38]];\n\nKColormap.btr = \n[[ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,4,5,6,8,9,9,10,11,11,11,11,11,11,11,10,10,9,8,8,7,6,5,5,4,3,2,2,1,1,0,0,0,0,0,1,1,2,3,5,6,8,10,12,15,18,21,24,28,32,36,41,46,51,56,62,67,73,80,86,93,100,107,114,120,125,131,136,141,147,152,157,162,167,171,176,180,185,189,193,197,200,204,208,211,214,217,220,222,225,227,230,232,234,236,237,239,241,242,243,244,246,247,247,248,249,250,250,251,251,252,252,253,253,253,254,254,254,254,254,254,254,255,255,255,255,255,255,251,247,243,239,235,231,227,223,219,215,211,207,203,199,195,191,187,183,179,175,171,167,163,159,155,151,147,143,139,135,131,127 ]\n,[ 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,8,12,16,20,24,28,32,36,40,44,48,52,55,59,63,67,71,75,79,82,86,90,93,97,101,104,107,111,114,117,120,123,126,129,132,134,136,139,141,143,144,146,147,148,149,150,150,151,151,150,150,149,148,147,146,144,142,140,137,135,132,129,125,120,114,109,103,98,92,86,81,76,70,65,60,55,50,46,41,37,32,29,25,21,18,15,12,10,7,5,4,2,1,1,0,0,0,1,1,2,4,5,7,10,12,15,18,21,25,29,32,37,41,46,50,55,60,65,70,76,81,86,92,98,103,109,114,118,121,124,127,130,133,135,137,139,141,142,143,144,144,145,145,144,144,144,143,142,140,139,137,136,134,131,129,127,124,122,119,116,113,110,106,103,100,96,93,89,86,82,78,75,71,67,63,59,55,51,48,44,40,36,32,28,24,20,16,12,8,4,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ]\n,[ 131,135,139,143,147,151,155,159,163,167,171,175,179,183,187,191,195,199,203,207,211,215,219,223,227,231,235,239,243,247,251,255,255,255,255,255,255,255,255,254,254,254,254,254,254,254,253,253,253,252,252,251,251,250,250,249,248,247,247,246,244,243,242,241,239,237,236,234,232,230,227,225,222,220,217,214,211,208,204,200,197,193,189,185,180,176,171,167,162,157,152,147,141,136,131,125,118,111,104,97,90,83,77,71,65,59,54,49,44,39,35,31,27,23,20,17,14,12,10,8,6,4,3,2,1,1,0,0,0,0,0,1,1,2,2,3,3,4,5,6,6,7,8,8,9,9,9,9,9,9,9,9,8,8,7,6,5,3,2,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0 ]]\n\n// ======================================================================================\n\n\n\n\n\n    function findIndexOfGreatest(array) {\n        var greatest;\n        var indexOfGreatest;\n        for (var i = 0; i < array.length; i++) {\n            if (!greatest || Math.abs(array[i]) > greatest) {\n                greatest = Math.abs(array[i]);\n                indexOfGreatest = i;\n            }\n        }\n        return indexOfGreatest;\n    }\n\n\n    var indexOf = function(needle) {\n        if (typeof Array.prototype.indexOf === \'function\') {\n            indexOf = Array.prototype.indexOf;\n        } else {\n            indexOf = function(needle) {\n                var i = -1\n                  , index = -1;\n\n                for (i = 0; i < this.length; i++) {\n                    if (this[i] === needle) {\n                        index = i;\n                        break;\n                    }\n                }\n\n                return index;\n            }\n            ;\n        }\n\n        return indexOf.call(this, needle);\n    }\n    ;\n\n\n\n    function mov(ev)\n    {\n        if (ev.originalEvent.mozMovementX !== undefined)\n            return {\n                X: ev.originalEvent.mozMovementX,\n                Y: ev.originalEvent.mozMovementY\n            };\n        else\n            return {\n                X: ev.originalEvent.movementX,\n                Y: ev.originalEvent.movementY\n            };\n    }\n\n  \n\n    function calcRotmatForVectors(e, v)\n    {\n        if (e.hasOwnProperty(\'_data\'))\n            e = e._data;\n        if (v.hasOwnProperty(\'_data\'))\n            v = v._data;\n\n        e = e.slice(0, 3);\n        v = v.slice(0, 3);\n        var vnorm = math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);\n        v[0]/=vnorm; v[2]/=vnorm; v[1]/=vnorm;\n        var w = math.cross(e, v);\n        if (w._data)\n            w = w._data;\n        var s = math.norm(w);\n        var c = math.sqrt(1 - s * s);\n        var a = 1 - c\n        w = math.multiply(w, 1 / s)._data;\n        var R =\n        [[c + a * w[0] * w[0], a * w[0] * w[1] - s * w[2], a * w[0] * w[2] + s * w[1], 0],\n        [a * w[1] * w[0] + s * w[2], c + a * w[1] * w[1], a * w[1] * w[2] - s * w[0], 0],\n        [a * w[2] * w[0] - s * w[1], a * w[2] * w[1] + s * w[0], c + a * w[2] * w[2], 0], [0, 0, 0, 1]];\n        return R;\n    }\n\n    function NNInterp(thenii, px, py, pz, A, offs)\n    {\n        var xs = A[0][0] * px + A[0][1] * py + A[0][2] * pz + A[0][3];\n        var ys = A[1][0] * px + A[1][1] * py + A[1][2] * pz + A[1][3];\n        var zs = A[2][0] * px + A[2][1] * py + A[2][2] * pz + A[2][3];\n        var xi = Math.round(xs);\n        var yi = Math.round(ys);\n        var zi = Math.round(zs);\n        if (zi < thenii.sizes[2] && zi >= 0 && yi < thenii.sizes[1] && yi >= 0 && xi < thenii.sizes[0] && xi >= 0)\n        {\n            var currentIndex000 = (thenii.widhei * zi + yi * thenii.wid + xi) % thenii.widheidep + offs;\n            return thenii.data[currentIndex000];\n        }\n\n        return undefined;\n\n    }\n\n\n    function trilinInterp_MAP(thenii, px, py, pz, A, offs, mapval)\n    {\n\n\n        var xs = A[0][0] * px + A[0][1] * py + A[0][2] * pz + A[0][3];\n        var ys = A[1][0] * px + A[1][1] * py + A[1][2] * pz + A[1][3];\n        var zs = A[2][0] * px + A[2][1] * py + A[2][2] * pz + A[2][3];\n        var xi = math.floor(xs);\n        var yi = math.floor(ys);\n        var zi = math.floor(zs);\n        var xf = xs - xi;\n        var yf = ys - yi;\n        var zf = zs - zi;\n        var currentVal = 0;\n        if (zi < thenii.sizes[2] - 1 && zi >= 0 && yi < thenii.sizes[1] - 1 && yi >= 0 && xi < thenii.sizes[0] - 1 && xi >= 0)\n        {\n            currentIndex000 = thenii.sizes[0] * thenii.sizes[1] * zi + yi * thenii.sizes[0] + xi + offs;\n            currentIndex100 = thenii.sizes[0] * thenii.sizes[1] * zi + (yi + 1) * thenii.sizes[0] + xi + offs;\n            currentIndex010 = thenii.sizes[0] * thenii.sizes[1] * (zi + 1) + yi * thenii.sizes[0] + xi + offs;\n            currentIndex001 = thenii.sizes[0] * thenii.sizes[1] * zi + yi * thenii.sizes[0] + (xi + 1) + offs;\n            currentIndex110 = thenii.sizes[0] * thenii.sizes[1] * (zi + 1) + (yi + 1) * thenii.sizes[0] + xi + offs;\n            currentIndex011 = thenii.sizes[0] * thenii.sizes[1] * (zi + 1) + yi * thenii.sizes[0] + (xi + 1) + offs;\n            currentIndex101 = thenii.sizes[0] * thenii.sizes[1] * zi + (yi + 1) * thenii.sizes[0] + (xi + 1) + offs;\n            currentIndex111 = thenii.sizes[0] * thenii.sizes[1] * (zi + 1) + (yi + 1) * thenii.sizes[0] + (xi + 1) + offs;\n            currentVal = (thenii.data[currentIndex000] == mapval) * (1 - xf) * (1 - yf) * (1 - zf) +\n            (thenii.data[currentIndex100] == mapval) * (1 - xf) * (yf) * (1 - zf) +\n            (thenii.data[currentIndex010] == mapval) * (1 - xf) * (1 - yf) * (zf) +\n            (thenii.data[currentIndex001] == mapval) * (xf) * (1 - yf) * (1 - zf) +\n            (thenii.data[currentIndex110] == mapval) * (1 - xf) * (yf) * (zf) +\n            (thenii.data[currentIndex011] == mapval) * (xf) * (1 - yf) * (zf) +\n            (thenii.data[currentIndex101] == mapval) * (xf) * (yf) * (1 - zf) +\n            (thenii.data[currentIndex111] == mapval) * (xf) * (yf) * (zf);\n        }\n\n        return currentVal;\n\n    }\n\n\n    function trilinInterp_atlas(thenii, px, py, pz, A, offs, labels)\n    {\n\n\n\n        var xs = A[0][0] * px + A[0][1] * py + A[0][2] * pz + A[0][3];\n        var ys = A[1][0] * px + A[1][1] * py + A[1][2] * pz + A[1][3];\n        var zs = A[2][0] * px + A[2][1] * py + A[2][2] * pz + A[2][3];\n        var xi = math.floor(xs);\n        var yi = math.floor(ys);\n        var zi = math.floor(zs);\n        var xf = xs - xi;\n        var yf = ys - yi;\n        var zf = zs - zi;\n        var currentVal = 0;\n        if (zi < thenii.sizes[2] - 1 && zi >= 0 && yi < thenii.sizes[1] - 1 && yi >= 0 && xi < thenii.sizes[0] - 1 && xi >= 0)\n        {\n            currentIndex000 = thenii.sizes[0] * thenii.sizes[1] * zi + yi * thenii.sizes[0] + xi + offs;\n            currentIndex100 = thenii.sizes[0] * thenii.sizes[1] * zi + (yi + 1) * thenii.sizes[0] + xi + offs;\n            currentIndex010 = thenii.sizes[0] * thenii.sizes[1] * (zi + 1) + yi * thenii.sizes[0] + xi + offs;\n            currentIndex001 = thenii.sizes[0] * thenii.sizes[1] * zi + yi * thenii.sizes[0] + (xi + 1) + offs;\n            currentIndex110 = thenii.sizes[0] * thenii.sizes[1] * (zi + 1) + (yi + 1) * thenii.sizes[0] + xi + offs;\n            currentIndex011 = thenii.sizes[0] * thenii.sizes[1] * (zi + 1) + yi * thenii.sizes[0] + (xi + 1) + offs;\n            currentIndex101 = thenii.sizes[0] * thenii.sizes[1] * zi + (yi + 1) * thenii.sizes[0] + (xi + 1) + offs;\n            currentIndex111 = thenii.sizes[0] * thenii.sizes[1] * (zi + 1) + (yi + 1) * thenii.sizes[0] + (xi + 1) + offs;\n\n        \n            var rgb = [0,0,0,0];\n            function acc(currentIndex,fac)\n            {\n                a = labels[thenii.data[currentIndex]];\n                if (a) {\n                     rgb[0] += fac*a.color[0];\n                     rgb[1] += fac*a.color[1];\n                     rgb[2] += fac*a.color[2];\n                     rgb[3] += fac;\n                }                    \n            }\n            acc(currentIndex000, (1 - xf) * (1 - yf) * (1 - zf));\n            acc(currentIndex100,(1 - xf) * (yf) * (1 - zf) );\n            acc(currentIndex010, (1 - xf) * (1 - yf) * (zf) );\n            acc(currentIndex001,(xf) * (1 - yf) * (1 - zf) );\n            acc(currentIndex110, (1 - xf) * (yf) * (zf) );\n            acc(currentIndex011,(xf) * (1 - yf) * (zf) );\n            acc(currentIndex101,(xf) * (yf) * (1 - zf) );\n            acc(currentIndex111, (xf) * (yf) * (zf) );\n           \n\n            return rgb;\n        }\n\n        return [0,0,0,0];\n\n    }\n\n\n    function trilinInterp_rgbnii(thenii, px, py, pz, A, offs)\n    {\n        var xs = A[0][0] * px + A[0][1] * py + A[0][2] * pz + A[0][3] ;\n        var ys = A[1][0] * px + A[1][1] * py + A[1][2] * pz + A[1][3] ;\n        var zs = A[2][0] * px + A[2][1] * py + A[2][2] * pz + A[2][3] ;\n        \n        var xi = math.floor(xs + 0.001);\n        var yi = math.floor(ys + 0.001);\n        var zi = math.floor(zs + 0.001);\n\n        if (zi < thenii.sizes[2] && zi >= 0 && yi < thenii.sizes[1] && yi >= 0 && xi < thenii.sizes[0] && xi >= 0)\n        {\n            var ind = 3*(thenii.widhei * zi + yi * thenii.wid + xi + offs);\n            var currentVal = [thenii.data[ind], thenii.data[ind+1], thenii.data[ind+2]];\n            return currentVal;\n        }\n\n    }\n\n\n    function trilinInterp(thenii, px, py, pz, A, offs)\n    {\n\n\n        var xs = A[0][0] * px + A[0][1] * py + A[0][2] * pz + A[0][3] ;\n        var ys = A[1][0] * px + A[1][1] * py + A[1][2] * pz + A[1][3] ;\n        var zs = (A[2][0] * px + A[2][1] * py + A[2][2] * pz + A[2][3] );\n     //   if (zs<0 & zs > -0.001)\n       //     zs = 0;\n        var xi = math.floor(xs + 0.0000001);\n        var yi = math.floor(ys + 0.0000001);\n        var zi = math.floor(zs + 0.0000001);\n\n        var xf = xs - xi;\n        var yf = ys - yi;\n        var zf = zs - zi; \n        var currentVal = undefined;\n        if (zi < thenii.sizes[2] && zi >= -1 && \n            yi < thenii.sizes[1] && yi >= -1 &&\n            xi < thenii.sizes[0] && xi >= -1)\n        {\n            xi = (xi == -1)?0:xi\n            yi = (yi == -1)?0:yi\n            var xi1 = (xi == thenii.sizes[0]-1)?xi:(xi+1)\n            var yi1 = (yi == thenii.sizes[1]-1)?yi:(yi+1)\n            //var zi1 = (zi == thenii.sizes[2]-1)?zi:(zi+1)                \n            var zi1 = zi+1;\n\n            if (zi == -1)\n            {\n                if (zf < 0.5)\n                    return undefined\n                zi = 0;\n            }\n            else if (zi == thenii.sizes[2]-1)\n            {\n                if (zf > 0.5)\n                    return undefined;\n                zi1 = zi;\n            }\n\n            var currentIndex000 = (thenii.widhei * zi + yi * thenii.wid + xi) % thenii.widheidep + offs; // 000\n            var currentIndex100 = (thenii.widhei * zi + yi1 * thenii.wid + xi) % thenii.widheidep + offs; // 010\n            var currentIndex010 = (thenii.widhei * zi1 + yi * thenii.wid + xi) % thenii.widheidep + offs; // 001\n            var currentIndex001 = (thenii.widhei * zi + yi * thenii.wid + xi1) % thenii.widheidep + offs; // 100\n            var currentIndex110 = (thenii.widhei * zi1 + yi1 * thenii.wid + xi) % thenii.widheidep + offs; // 011\n            var currentIndex011 = (thenii.widhei * zi1 + yi * thenii.wid + xi1) % thenii.widheidep + offs; // 101\n            var currentIndex101 = (thenii.widhei * zi + yi1 * thenii.wid + xi1) % thenii.widheidep + offs;  // 110\n            var currentIndex111 = (thenii.widhei * zi1 + yi1 * thenii.wid + xi1) % thenii.widheidep + offs; // 111\n            var currentVal = thenii.data[currentIndex000] * (1 - xf) * (1 - yf) * (1 - zf) +  // 000\n            thenii.data[currentIndex100] * (1 - xf) * (yf) * (1 - zf) +                      // 010 \n            thenii.data[currentIndex010] * (1 - xf) * (1 - yf) * (zf) +                     // 001\n            thenii.data[currentIndex001] * (xf) * (1 - yf) * (1 - zf) +                     // 100\n            thenii.data[currentIndex110] * (1 - xf) * (yf) * (zf) +                         // 011\n            thenii.data[currentIndex011] * (xf) * (1 - yf) * (zf) +                         // 101\n            thenii.data[currentIndex101] * (xf) * (yf) * (1 - zf) +                         // 110\n            thenii.data[currentIndex111] * (xf) * (yf) * (zf);                              // 111\n        }\n        else\n            return undefined;\n\n        return currentVal;\n\n    }\n\n    function trilinInterp3_signcorrected(thenii, px, py, pz, A, totsz,offset)\n    {\n\n        \n        if (offset == undefined)\n            offset = 0;\n\n        var xs = A[0][0] * px + A[0][1] * py + A[0][2] * pz + A[0][3];\n        var ys = A[1][0] * px + A[1][1] * py + A[1][2] * pz + A[1][3];\n        var zs = A[2][0] * px + A[2][1] * py + A[2][2] * pz + A[2][3];\n        var xi = math.floor(xs + 0.0000001);\n        var yi = math.floor(ys + 0.0000001);\n        var zi = math.floor(zs + 0.0000001);\n        var xf =  xs - xi;\n        var yf =  ys - yi;\n        var zf =  zs - zi;\n        var currentVal;\n        if (zi < thenii.sizes[2] && zi >= 0 && yi < thenii.sizes[1] && yi >= 0 && xi < thenii.sizes[0] && xi >= 0)\n        {\n\n            currentVal = [0, 0, 0];\n            var currentIndex000 = offset+ (thenii.widhei * zi + yi * thenii.wid + xi) % thenii.widheidep;\n            var currentIndex100 = offset+ (thenii.widhei * zi + (yi + 1) * thenii.wid + xi) % thenii.widheidep;\n            var currentIndex010 = offset+ (thenii.widhei * (zi + 1) + yi * thenii.wid + xi) % thenii.widheidep;\n            var currentIndex001 = offset+ (thenii.widhei * zi + yi * thenii.wid + (xi + 1)) % thenii.widheidep;\n            var currentIndex110 = offset+ (thenii.widhei * (zi + 1) + (yi + 1) * thenii.wid + xi) % thenii.widheidep;\n            var currentIndex011 = offset+ (thenii.widhei * (zi + 1) + yi * thenii.wid + (xi + 1)) % thenii.widheidep;\n            var currentIndex101 = offset+ (thenii.widhei * zi + (yi + 1) * thenii.wid + (xi + 1)) % thenii.widheidep;\n            var currentIndex111 = offset+ (thenii.widhei * (zi + 1) + (yi + 1) * thenii.wid + (xi + 1)) % thenii.widheidep;\n\n            var magX = math.abs(thenii.data[currentIndex000]) +\n            math.abs(thenii.data[currentIndex001]) +\n            math.abs(thenii.data[currentIndex010]) +\n            math.abs(thenii.data[currentIndex100]) +\n            math.abs(thenii.data[currentIndex110]) +\n            math.abs(thenii.data[currentIndex011]) +\n            math.abs(thenii.data[currentIndex101]) +\n            math.abs(thenii.data[currentIndex111]);\n            var magY = math.abs(thenii.data[currentIndex000 + totsz]) +\n            math.abs(thenii.data[currentIndex001 + totsz]) +\n            math.abs(thenii.data[currentIndex010 + totsz]) +\n            math.abs(thenii.data[currentIndex100 + totsz]) +\n            math.abs(thenii.data[currentIndex110 + totsz]) +\n            math.abs(thenii.data[currentIndex011 + totsz]) +\n            math.abs(thenii.data[currentIndex101 + totsz]) +\n            math.abs(thenii.data[currentIndex111 + totsz]);\n            var magZ = math.abs(thenii.data[currentIndex000 + 2 * totsz]) +\n            math.abs(thenii.data[currentIndex001 + 2 * totsz]) +\n            math.abs(thenii.data[currentIndex010 + 2 * totsz]) +\n            math.abs(thenii.data[currentIndex100 + 2 * totsz]) +\n            math.abs(thenii.data[currentIndex110 + 2 * totsz]) +\n            math.abs(thenii.data[currentIndex011 + 2 * totsz]) +\n            math.abs(thenii.data[currentIndex101 + 2 * totsz]) +\n            math.abs(thenii.data[currentIndex111 + 2 * totsz]);\n\n            var off = 0;\n            if (magZ > magY && magZ > magX)\n                off = 2 * totsz;\n            else if (magY > magZ && magY > magX)\n                off = totsz;\n\n\n            var sg000 = math.sign(thenii.data[currentIndex000 + off]);\n            var sg001 = math.sign(thenii.data[currentIndex001 + off]);\n            var sg010 = math.sign(thenii.data[currentIndex010 + off]);\n            var sg100 = math.sign(thenii.data[currentIndex100 + off]);\n            var sg110 = math.sign(thenii.data[currentIndex110 + off]);\n            var sg011 = math.sign(thenii.data[currentIndex011 + off]);\n            var sg101 = math.sign(thenii.data[currentIndex101 + off]);\n            var sg111 = math.sign(thenii.data[currentIndex111 + off]);\n\n            currentVal[0] = thenii.data[currentIndex000] * (1 - xf) * (1 - yf) * (1 - zf) * sg000 +\n            thenii.data[currentIndex100] * (1 - xf) * (yf) * (1 - zf) * sg100 +\n            thenii.data[currentIndex010] * (1 - xf) * (1 - yf) * (zf) * sg010 +\n            thenii.data[currentIndex001] * (xf) * (1 - yf) * (1 - zf) * sg001 +\n            thenii.data[currentIndex110] * (1 - xf) * (yf) * (zf) * sg110 +\n            thenii.data[currentIndex011] * (xf) * (1 - yf) * (zf) * sg011 +\n            thenii.data[currentIndex101] * (xf) * (yf) * (1 - zf) * sg101 +\n            thenii.data[currentIndex111] * (xf) * (yf) * (zf) * sg111;\n\n            currentVal[1] = thenii.data[currentIndex000 + totsz] * (1 - xf) * (1 - yf) * (1 - zf) * sg000 +\n            thenii.data[currentIndex100 + totsz] * (1 - xf) * (yf) * (1 - zf) * sg100 +\n            thenii.data[currentIndex010 + totsz] * (1 - xf) * (1 - yf) * (zf) * sg010 +\n            thenii.data[currentIndex001 + totsz] * (xf) * (1 - yf) * (1 - zf) * sg001 +\n            thenii.data[currentIndex110 + totsz] * (1 - xf) * (yf) * (zf) * sg110 +\n            thenii.data[currentIndex011 + totsz] * (xf) * (1 - yf) * (zf) * sg011 +\n            thenii.data[currentIndex101 + totsz] * (xf) * (yf) * (1 - zf) * sg101 +\n            thenii.data[currentIndex111 + totsz] * (xf) * (yf) * (zf) * sg111;\n\n            currentVal[2] = thenii.data[currentIndex000 + totsz * 2] * (1 - xf) * (1 - yf) * (1 - zf) * sg000 +\n            thenii.data[currentIndex100 + totsz * 2] * (1 - xf) * (yf) * (1 - zf) * sg100 +\n            thenii.data[currentIndex010 + totsz * 2] * (1 - xf) * (1 - yf) * (zf) * sg010 +\n            thenii.data[currentIndex001 + totsz * 2] * (xf) * (1 - yf) * (1 - zf) * sg001 +\n            thenii.data[currentIndex110 + totsz * 2] * (1 - xf) * (yf) * (zf) * sg110 +\n            thenii.data[currentIndex011 + totsz * 2] * (xf) * (1 - yf) * (zf) * sg011 +\n            thenii.data[currentIndex101 + totsz * 2] * (xf) * (yf) * (1 - zf) * sg101 +\n            thenii.data[currentIndex111 + totsz * 2] * (xf) * (yf) * (zf) * sg111;\n\n        }\n\n        return currentVal;\n\n    }\n\n\n    function NNInterp3_n(thenii, px, py, pz, A, totsz,offset,n)\n    {\n\n        \n        if (offset == undefined)\n            offset = 0;\n\n        var xs = A[0][0] * px + A[0][1] * py + A[0][2] * pz + A[0][3];\n        var ys = A[1][0] * px + A[1][1] * py + A[1][2] * pz + A[1][3];\n        var zs = A[2][0] * px + A[2][1] * py + A[2][2] * pz + A[2][3];\n        var xi = Math.round(xs + 0.0000001);\n        var yi = Math.round(ys + 0.0000001);\n        var zi = Math.round(zs + 0.0000001);\n        \n        if (zi < thenii.sizes[2] && zi >= 0 && yi < thenii.sizes[1] && yi >= 0 && xi < thenii.sizes[0] && xi >= 0)\n        {\n            var currentVal = [];\n            var currentIndex000 = (thenii.widhei * zi + yi * thenii.wid + xi) % thenii.widheidep + offset;\n            for (var k = 0; k < n; k++)\n                currentVal[k] =thenii.data[currentIndex000+totsz*k];\n\n            return currentVal\n        }\n\n        return currentVal;\n\n    }\n\n\n\nKMedViewer.getPermutationOrder = function(id)\n{\n    // human (default, radiological)\n    var perm = [0, 1, 2];\n    var flips = [1, 1, 1];\n    var fixed = false;\n\n    var porder = state.viewer.permOrder \n    if (id != undefined)\n        porder = id;\n    if (porder == undefined)\n        proder = \'human\';\n                \n\n\n    if (porder != undefined)\n    {\n        if (porder== \'mouse\')\n            perm = [0, 2, 1];\n        else if (porder == \'mouse_flipped\')\n        {\n            perm = [0, 2, 1];\n            flips = [-1, -1, -1];\n        }\n        else if (porder == \'human_flipped\')\n        {\n            perm = [0, 1, 2];\n            flips = [-1, 1, -1];\n        }\n        else if (porder== \'human_neuro\')\n        {\n            perm = [0, 1, 2];\n            flips = [-1, 1, 1];\n        }\n        else if (porder== \'sheep\')\n        {\n            perm = [2, 0, 1];\n            flips = [1, 1, -1];\n        }\n        else if (porder == \'fixed_heart\')\n        {\n            perm = [0, 1, 2];\n            flips = [-1, -1, 1];\n            fixed = true;\n        }\n\n    }\n    var mat = [[0, 0, 0,0], [0, 0, 0,0], [0, 0, 0,0],[0,0,0,1]];\n    mat[0][perm[0]] = flips[0];\n    mat[1][perm[1]] = flips[1];\n    mat[2][perm[2]] = flips[2];\n    var det = math.det(mat) ;\n\n    var invperm = [-1,-1,-1];\n    invperm[perm[0]] = 0;\n    invperm[perm[1]] = 1;\n    invperm[perm[2]] = 2;\n\n/*    mat[0][perm[0]] = 1;\n    mat[1][perm[1]] = 1;\n    mat[2][perm[2]] = 1;\n    var det = math.det(mat) * flips[0] * flips[1] * flips[2];*/\n    return {\n        perm: perm,\n        invperm:invperm,\n        flips: flips,\n        det: det,\n        mat:mat,\n        fixed: fixed,\n        id:porder\n    };\n}\n\n\n\nKMedViewer.createThumbnailImage = function(nii, slicingDimOfWorld)\n{\n\n    var nii = nii || KViewer.viewports[0].medViewer.nii;\n    var slicingDimOfWorld = slicingDimOfWorld || 2;\n\n\n    var slicingDimOfArray = nii.permutationOrder.indexOf(slicingDimOfWorld);\n    var tOffset = 0;\n\n    var swapXY, sy, sy, xdir, ydir, xflip, yflip, sliceAspectRatio, currentSlice;\n\n    if (slicingDimOfArray == 0) {\n        swapXY = (nii.permutationOrder[1] > nii.permutationOrder[2]) ? 1 : 0;\n        sx = nii.sizes[1];\n        sy = nii.sizes[2];\n        currentSlice = math.floor(nii.sizes[0] / 2);\n        xdir = -nii.arrayReadDirection[1];\n        ydir = -nii.arrayReadDirection[2];\n        sliceAspectRatio = sx / sy * nii.voxSize[1] / nii.voxSize[2];\n        var voxSizeX = nii.voxSize[1];\n        var voxSizeY = nii.voxSize[2];\n\n    }\n\n    if (slicingDimOfArray == 1) {\n        swapXY = (nii.permutationOrder[0] > nii.permutationOrder[2]) ? 1 : 0;\n        sx = nii.sizes[0];\n        sy = nii.sizes[2];\n        currentSlice = math.floor(nii.sizes[1] / 2);\n        xdir = -nii.arrayReadDirection[0];\n        ydir = -nii.arrayReadDirection[2];\n        sliceAspectRatio = sx / sy * nii.voxSize[0] / nii.voxSize[2];\n        var voxSizeX = nii.voxSize[0];\n        var voxSizeY = nii.voxSize[2];\n    }\n\n    if (slicingDimOfArray == 2) {\n        swapXY = (nii.permutationOrder[0] > nii.permutationOrder[1]) ? 1 : 0;\n        sx = nii.sizes[0];\n        sy = nii.sizes[1];\n        currentSlice = math.floor(nii.sizes[2] / 2);\n        xdir = -nii.arrayReadDirection[0];\n        ydir = -nii.arrayReadDirection[1];\n        sliceAspectRatio = sx / sy * nii.voxSize[0] / nii.voxSize[1];\n        var voxSizeX = nii.voxSize[0];\n        var voxSizeY = nii.voxSize[1];\n    }\n    xflip = xdir == 1 ? 0 : 1;\n    yflip = ydir == 1 ? 0 : 1;\n\n    var width = sx;\n    var height = sy;\n\n    var scale = nii.histogram.max;\n    var sliceData = new Uint8ClampedArray(width * height * 4);\n\n    for (var x = 0; x < sx; x++)\n    {\n        for (var y = 0; y < sy; y++)\n        {\n\n            if (slicingDimOfArray == 0) {\n                px = currentSlice;\n                py = x;\n                pz = y;\n            }\n            if (slicingDimOfArray == 1) {\n                px = x;\n                py = currentSlice;\n                pz = y;\n            }\n            if (slicingDimOfArray == 2) {\n                px = x;\n                py = y;\n                pz = currentSlice;\n            }\n\n            var k;\n            if (swapXY)\n                k = ((sx * xflip + xdir * (x) - xflip) * sy + yflip * sy + ydir * (y) - yflip) * 4;\n            else\n                k = ((sy * yflip + ydir * (y) - yflip) * sx + xflip * sx + xdir * (x) - xflip) * 4;\n\n            var rgba = nii.data[nii.sizes[0] * nii.sizes[1] * pz + py * nii.sizes[0] + px + +tOffset] / scale * 255;\n            ;\n            sliceData[k + 0] = rgba;\n            sliceData[k + 1] = rgba;\n            sliceData[k + 2] = rgba;\n            sliceData[k + 3] = 255;\n        }\n        //y\n    }\n    //x\n\n\n    var canvas = document.createElement(\'canvas\');\n    var ctx = canvas.getContext(\'2d\');\n\n    canvas.width = sx;\n    canvas.height = sy * sliceAspectRatio;\n\n    var idata = ctx.createImageData(width, height);\n    idata.data.set(sliceData);\n    ctx.putImageData(idata, 0, 0);\n    var dataUri = canvas.toDataURL()\n\n\n    var $img = $("<img />");\n    // set the data uri \n    $img.attr("src", dataUri);\n\n    //$img.get(0).style = ("position:absolute; width:200px; top:0; left: 0; height:200px; z-index:1000; border:1px solid red;")\n    //$img.appendTo(document.body);\n    return $img;\n\n}\n\n\n\n\n\n\n\n\n\nfunction FiberQuiver(that)\n{\n    var quiver = {}\n    var ctx = that.$canvas.get(0).getContext("2d");\n\n    function resetParams()\n    {\n        var params = default_quiver_params();\n        FiberQuiver.params = params;\n        ViewerSettings.quiver = params;\n        return params;\n    }\n\n    function default_quiver_params()\n    {\n        var params = {};\n        params.density = 1;\n        params.type = \'t\';\n        params.color = 0;\n        params.lengthfac = 1;\n        params.sign = 0;\n        params.visible = false;\n        \n        return params;\n    }\n\n\n    quiver.draw = function()\n    {\n        for (var k = 0;k < that.quivers.length;k++)\n        //    if (that.quivers[k].parentviewbar.visible)\n                quiver.draw_single(that.quivers[k]);\n\n    }\n\n    quiver.draw_single = function(quiver_source)\n    {\n\n        var nii = quiver_source.nii;\n        if (nii.quiver_params == undefined)\n            nii.quiver_params = default_quiver_params();\n        quiver_source.parentviewbar.quiverdiv.css("color","")\n\n\n        if (!nii.quiver_params.visible | that.mosaicview.active)\n        {\n            quiver.clear_this(quiver_source);\n            quiver_source.parentviewbar.quiverdiv.css("color","red")\n            return;\n        }\n\n        var quiver_params = nii.quiver_params;\n\n        var slicingDimOfWorld;\n\n        if (nii == undefined || nii.sizes[3]%3 != 0)\n            return;\n\n        \n        var n = that.nii;\n\n\n        var reorient = math.diag([1, 1, 1, 1]);\n        if (KViewer.navigationTool.isinstance && \n               \n        ((KViewer.navigationTool.movingObjs[quiver_source.parentviewbar.currentFileID] != undefined & KViewer.navigationMode == 0)| (KViewer.navigationMode == 2 & KViewer.mainViewport != -1)))\n        reorient = KViewer.reorientationMatrix.matrix;\n        // | (noNativeSlicing & KViewer.navigationMode == 2) ) )\n\n\n/*\n \n        var n = quiver_source.nii;\n        var Order = KMedViewer.getPermutationOrder(); \n\n        var qe = math.multiply(n.edges,math.diag([1/n.voxSize[0],1/n.voxSize[1],1/n.voxSize[2],1]));\n        qe = math.setTranslation(qe,[0,0,0]);\n\n        var be = math.multiply(that.nii.edges,math.diag([1/that.nii.voxSize[0],1/that.nii.voxSize[1],1/that.nii.voxSize[2],1]));\n        be = math.setTranslation(be,[0,0,0]);\n\n        var r2 = math.multiply(math.inv(Order.mat),(math.multiply(reorient,(Order.mat))));\n   \n        var e1 = math.multiply(math.inv(be),(qe));\n        var e2 = math.inv(permMat_noscale(that.nii));\n\n\n         e2 = math.multiply(e2,e1);\n\n        e2 =  (math.multiply(math.inv(reorient),e2));\n\n        e2 = math.multiply(e2,math.inv(Order.mat));\n*/\n\n   /*\n\n        var Order = KMedViewer.getPermutationOrder(); \n\n        var qe = math.multiply(n.edges,math.diag([1/n.voxSize[0],1/n.voxSize[1],1/n.voxSize[2],1]));\n        qe = math.setTranslation(qe,[0,0,0]);\n\n        var be = math.multiply(that.nii.edges,math.diag([1/that.nii.voxSize[0],1/that.nii.voxSize[1],1/that.nii.voxSize[2],1]));\n        be = math.setTranslation(be,[0,0,0]);\n        var e1 = math.multiply(math.inv(be),(qe));\n        var e2 = math.inv(permMat_noscale(that.nii));\n         e2 = math.multiply(e2,e1);\n        e2 =  (math.multiply(math.inv(reorient),e2));\n\n        e2 = math.multiply(Order.mat,e2);\n*/\n  \n\n\n\n\n\n        var e =  math.multiply(math.inv(that.nii.edges_noscale),(math.multiply(math.inv(reorient),quiver_source.nii.edges_noscale)));\n        var e2 =  math.multiply(math.inv(permMat_noscale(that.nii)),e);\n\n        var permCol = function(q) { return q }\n        if (quiver_source.parentviewbar && quiver_source.parentviewbar.showcolored_type)\n        {\n            var type = quiver_source.parentviewbar.showcolored_type;            \n            if (type == "GBR")\n               permCol = function(q) { return [q[1],q[2],q[0]] }\n            if (type == "GRB")\n               permCol = function(q) { return [q[0],q[2],q[1]] }\n            if (type == "BRG")\n               permCol = function(q) { return [q[2],q[0],q[1]] }\n            \n        }\n\n\n        var qs = quiver_source.nii\n        if (typeof qs.descrip == "string" && qs.descrip.substring(0,6).toLowerCase() == "mrtrix")\n        {\n            e2 = math.multiply(e2,math.multiply(math.diag([qs.voxSize[0],qs.voxSize[1],qs.voxSize[2],1]),math.inv(qs.edges)));                        \n            e2 = math.multiply(e2,math.diag([-qs.detsign,1,1,1]));                        \n          //  e2 = math.multiply(e2,math.diag([1,-1,1,1]));                        \n        }\n\n\n\n        var R = e2._data;\n\n\n\n        var offX = 0.5 / ctx.canvas.width / that.embedfac_width;\n        // 1/2 pixel correction\n        var offY = 0.5 / ctx.canvas.height / that.embedfac_height;\n        var cpos = that.$canvas.offset();\n        cpos.top -= that.$container.offset().top;\n        cpos.left -= that.$container.offset().left;\n        var facX = 1 / that.$canvas.width() / that.embedfac_width;\n        var facY = 1 / that.$canvas.height() / that.embedfac_height;\n        var volsz = nii.sizes[0] * nii.sizes[1] * nii.sizes[2];\n\n        var cwid = that.$container.width();\n        var chei = that.$container.height();\n        var invedges = math.inv(nii.edges);\n        var flines = "";\n\n\n        var pos_random = 1;\n        var len_random = 1.3;\n        var col_random = 100;\n        var swidth = 1;\n        var opacs = [1, 0.8, 0.3];\n        var stepquality = [8, 5, 3];\n\n        if (quiver_params.type == "q")\n        {\n            pos_random = 0;\n            len_random = 0;\n            col_random = 0;\n            swidth = 1.5;\n            opacs = [1, 1, 1];\n            stepquality = [14, 12, 10];\n        }\n\n        if (quiver_params.gamma == undefined)\n            quiver_params.gamma = 1;\n        if (quiver_params.sign == undefined)\n             quiver_params.sign = 0;\n\n\n        var cfac = 127 / quiver_source.clim[1];\n\n\n        var opac = opacs[quiver_params.density];\n\n        var step = stepquality[quiver_params.density];\n\n        //var scfac = 0.05*that.zoomFac;\n        var scfac = 4*quiver_params.lengthfac * math.sqrt(that.zoomFac) / nii.histogram.max;\n\n        var numchunks = 40;\n\n        var wnum = math.floor(cwid / step);\n        var hnum = math.floor(chei / step);\n        var numdirs = nii.sizes[3]/3;        \n        var totnum = wnum * hnum *numdirs;\n        var rperm = randperm(totnum);\n\n\n        var interp_type;\n        if (quiver_params.sign == 0)\n            interp_type = 0;\n        if (numdirs == 1)\n            interp_type = 1;\n        if (quiver_params.sign != 0)\n            interp_type = 2;\n\n\n        var chunksize = math.floor(totnum / numchunks);\n\n        if (quiver_source.tsid != -1)\n            clearTimeout(quiver_source.tsid);\n        if (quiver_source.iid != -1)\n            clearInterval(quiver_source.iid);\n\n        if (quiver_source.$fibercont != undefined)\n            quiver_source.$fibercont.remove();\n\n        var c = colors[quiver_params.color];\n        var s = [(c[0] > 128) ? -1 : 1, (c[1] > 128) ? -1 : 1, (c[2] > 128) ? -1 : 1];\n\n        quiver_source.$fibercont = $("<div class=\'KFiberQuiver\'> </div>").appendTo(that.$container);\n\n        quiver_source.tsid = setTimeout(function()\n        {\n            quiver_source.tsid = -1;\n            var f = 0;\n            quiver_source.iid = setInterval(function() {\n                 if (that.nii == undefined || f >= totnum || f / chunksize > numchunks)\n                {\n                    clearInterval(quiver_source.iid);\n                    quiver_source.iid = -1;\n                }\n                var flines = render(f, chunksize);\n                var r = math.floor(col_random * Math.random());\n                if (c == "dir")\n                    $("<svg  style=\'opacity:" + opac + ";position:absolute;stroke-width:" + swidth + "\'>" + flines + "</svg>").appendTo(quiver_source.$fibercont);\n                else\n                    $("<svg  style=\'opacity:" + opac + ";position:absolute;stroke:rgb(" + (c[0] + s[0] * r) + "," + (c[1] + s[1] * r) + "," + (c[2] + s[2] * r) + ");stroke-width:" + swidth + "\'>" + flines + "</svg>").appendTo(quiver_source.$fibercont);\n                f += chunksize;\n               \n            }, 0);\n        }, 50);\n\n        function mapDirections(n)\n        {\n\n            var t  = [R[0][0]*n[0] + R[0][1]*n[1] + R[0][2]*n[2], \n                    R[1][0]*n[0] + R[1][1]*n[1] + R[1][2]*n[2] ,\n                    R[2][0]*n[0] + R[2][1]*n[1] + R[2][2]*n[2] ];\n               \n            return t;\n\n            if (1)   \n            {\n                if (slicingDimOfWorld == 0)\n                    return [t[1],t[2],t[0]];\n                if (slicingDimOfWorld == 1)\n                    return [t[0],t[2],t[1]];\n                if (slicingDimOfWorld == 2)\n                    return [t[0],t[1],t[2]];\n\n            return;\n            }\n            else\n            {\n            if (slicingDimOfWorld == 0)\n            {\n                return [nii.arrayReadDirection[nii.invPermOrder[1]] * n[nii.invPermOrder[1]], nii.arrayReadDirection[nii.invPermOrder[2]] * n[nii.invPermOrder[2]]];\n            }\n            if (slicingDimOfWorld == 1)\n            {\n                return [nii.arrayReadDirection[nii.invPermOrder[0]] * n[nii.invPermOrder[0]], nii.arrayReadDirection[nii.invPermOrder[2]] * n[nii.invPermOrder[2]]];\n            }\n            if (slicingDimOfWorld == 2)\n            {\n                return [nii.arrayReadDirection[nii.invPermOrder[0]] * n[nii.invPermOrder[0]], nii.arrayReadDirection[nii.invPermOrder[1]] * n[nii.invPermOrder[1]]];\n            }\n            }\n        }\n\n\n        function render(offs, size)\n        {\n            var flines = "";\n            if (that.nii == undefined)\n                return "";\n\n            var xrand = (Math.random() - 0.5) * step * pos_random;\n            var yrand = (Math.random() - 0.5) * step * pos_random;\n            slicingDimOfWorld = that.getSlicingDimOfWorld();\n            var slicingDimOfArray = that.getSlicingDimOfArray();\n            var R = math.inv(that.getTiltMat(slicingDimOfArray));\n            var EI = math.multiply(reorient, math.multiply(that.nii.edges, R));\n\n            var c = colors[quiver_params.color];\n\n            var pos,neg;\n            if (quiver_params.sign == 0)\n            {\n                pos = 1;\n                neg = 1;\n            }\n            else  if (quiver_params.sign == -1)\n            {\n                pos = 0;\n                neg = 1;\n            } \n            else if (quiver_params.sign == 1)\n            {\n                pos = 1;\n                neg = 0;\n            }\n\n\n            var renderLineString;\n\n            if (c == "dir")\n                renderLineString = function(v, k, j)\n                {\n                    var q = mapDirections(v);\n                    var n;\n                    if (slicingDimOfWorld == 0)\n                        n = [q[1],q[2],q[0]];\n                    if (slicingDimOfWorld == 1)\n                        n = [q[0],q[2],q[1]];\n                    if (slicingDimOfWorld == 2)\n                        n = [q[0],q[1],q[2]];\n                    var q = permCol(q);\n\n                    var rf = 1 + len_random * (Math.random() - 0.5);\n//                    n[0] *= scfac*rf;\n  //                  n[1] *= scfac * rf;\n                    if (!isNaN(n[0]) && !isNaN(n[1]))\n                        return \'<line style="stroke:rgb(\' + math.floor(math.abs(q[0] * cfac)+10)\n                                                    + \',\' + math.floor(math.abs(q[1] * cfac)+10)\n                                                    + \',\' + math.floor(math.abs(q[2] * cfac)+10) + \')" x1="\' + (k + pos*n[0]*scfac*rf) + \'" y1="\' + (j + pos*n[1]*scfac*rf) + \'" x2="\' + (k - neg*n[0]*scfac*rf) + \'" y2="\' + (j - neg*n[1]*scfac*rf) + \'" />\';\n//                        return \'<line style="stroke:rgb(\' + math.floor(math.abs(v[0] * cfac + 10)) + \',\' + math.floor(math.abs(v[1] * cfac + 10)) + \',\' + math.floor(math.abs(v[2] * cfac + 10)) + \')" x1="\' + (k + pos*n[0]) + \'" y1="\' + (j + pos*n[1]) + \'" x2="\' + (k - neg*n[0]) + \'" y2="\' + (j - neg*n[1]) + \'" />\';\n                }\n            else\n                renderLineString = function(v, k, j)\n                {\n                    var n = mapDirections(v);\n                    if (slicingDimOfWorld == 0)\n                        n = [n[1],n[2],n[0]];\n                    if (slicingDimOfWorld == 1)\n                        n = [n[0],n[2],n[1]];\n                    if (slicingDimOfWorld == 2)\n                        n = [n[0],n[1],n[2]];\n\n                    var rf = 1 + len_random * (Math.random() - 0.5);\n                    n[0] *= scfac * rf;\n                    n[1] *= scfac * rf;\n                    if (!isNaN(n[0]) && !isNaN(n[1]))\n                        return \'<line x1="\' + (k + pos*n[0]) + \'" y1="\' + (j + pos*n[1]) + \'" x2="\' + (k - neg*n[0]) + \'" y2="\' + (j - neg*n[1]) + \'" />\';\n/*\n                    var n = mapDirections(v);\n                    var rf = scfac*(1 + len_random * (Math.random() - 0.5));\n                    n[0] *= rf;\n                    n[1] *= rf;\n                    var r_ = (Math.random()-0.5)*0;\n                    var p_ = pos*(1+r_);\n                    var n_ = neg*(1-r_);\n\n                    if (!isNaN(n[0]) && !isNaN(n[1]))\n                        return \'<line x1="\' + (k + p_*n[0]) + \'" y1="\' + (j + p_*n[1]) + \'" x2="\' + (k - n_*n[0]) + \'" y2="\' + (j - n_*n[1]) + \'" />\';\n  */                      \n                }\n\n\n\n            var voxelCoordinates = that.getCurrenVoxel()._data.slice(0);\n            var te_ = that.nii.edges._data;\n            if (KViewer.mainViewport !== -1)\n                te_ = EI._data;\n                \n            for (var i = offs; i < size + offs && i < totnum; i++)\n            {\n                var ir = rperm[i];\n                var k = (ir % wnum                 ) * step + xrand;\n                var j = (math.floor(ir / wnum) %hnum      ) * step +yrand;\n                var ndir = (math.floor(ir / (wnum*hnum)));\n\n                var X = k - cpos.left;\n                // position on canvas\n                var Y = j - cpos.top;\n                // position on canvas\n                var x_norm = X * facX;\n                // must add one half pixel\n                var y_norm = Y * facY;\n\n                if (that.swapXY)\n                {\n                    var tmp = x_norm;\n                    x_norm = y_norm;\n                    y_norm = tmp;\n                }\n\n                var pi;\n                if (slicingDimOfArray == 0)\n                    pi = [1, 2, 0];\n                else if (slicingDimOfArray == 1)\n                    pi = [0, 2, 1];\n                else\n                    pi = [0, 1, 2];\n\n                if (x_norm)\n                    voxelCoordinates[pi[0]] = (that.nii.arrayReadDirection[pi[0]] == 1) ? ((1 - x_norm - offX) * that.nii.sizes[pi[0]]) : ((x_norm - offX) * that.nii.sizes[pi[0]]);\n                if (y_norm)\n                    voxelCoordinates[pi[1]] = (that.nii.arrayReadDirection[pi[1]] == 1) ? ((1 - y_norm - offY) * that.nii.sizes[pi[1]]) : ((y_norm - offY) * that.nii.sizes[pi[1]]);\n\n                var realWorldCoordinates;\n                realWorldCoordinates =  [ te_[0][0]*voxelCoordinates[0] + te_[0][1]*voxelCoordinates[1] + te_[0][2]*voxelCoordinates[2] + te_[0][3],\n                                              te_[1][0]*voxelCoordinates[0] + te_[1][1]*voxelCoordinates[1] + te_[1][2]*voxelCoordinates[2] + te_[1][3],\n                                              te_[2][0]*voxelCoordinates[0] + te_[2][1]*voxelCoordinates[1] + te_[2][2]*voxelCoordinates[2] + te_[2][3],1];\n                \n\n                var point = realWorldCoordinates;\n                var v;\n                if (interp_type == 0)\n                   v = NNInterp3_n(nii, point[0], point[1], point[2], invedges._data, volsz,ndir*volsz*3,3);\n                else if (interp_type == 1)\n                   v = trilinInterp3_signcorrected(nii , point[0], point[1], point[2], invedges._data,volsz); \n                else \n                   v = [trilinInterp(nii, point[0], point[1], point[2], invedges._data, volsz*0),\n                         trilinInterp(nii, data[0], point[1], point[2], invedges._data, volsz*1),\n                         trilinInterp(nii, data[0], point[1], point[2], invedges._data, volsz*2)];\n                if (v)\n                {\n                    if (quiver_params.gamma != 1)\n                    {\n                        var norm = Math.pow(v[0]*v[0]+v[1]*v[1]+v[2]*v[2],-1/2+quiver_params.gamma/2)*(quiver_params.gamma);\n                        v[0] *= norm; v[1] *= norm; v[2] *= norm;\n                    }\n                    flines += renderLineString(v, k, j);\n                }\n\n            }\n            return flines;\n\n        }\n\n    }\n\n\n\n     quiver.menu = function(event,obj) {\n       KContextMenu(\n       function(e) {\n\n        var quiver_params;\n        if (obj.niiOriginal != undefined)\n            quiver_params = obj.niiOriginal.quiver_params;            \n        else\n            quiver_params = obj.nii.quiver_params;\n            \n        var $menu = $("<ul class=\'menu_context\'>");\n\n        $menu.append($("<hr width=\'100%\'> "));\n        $menu.append($("<span> &nbsp Quiver</span>"));\n        $menu.append($("<hr width=\'100%\'> "));\n        if (quiver_params.visible)\n        {\n            $menu.append($("<li onchoice=\'hide\'>  hide  </li>"));\n            $menu.append($("<li onchoice=\'color\'>  Color </li>"));\n            $menu.append($("<li onchoice=\'reset\'>  reset  </li>"));\n\n            var name = [\'low\', \'medium\', \'high\'];\n            $menu.append($("<hr width=\'100%\'> "));\n            $menu.append($("<span> &nbsp Density</span>"));\n            $menu.append($("<hr width=\'100%\'> "));\n\n            for (var k = 0; k < 3; k++)\n            {\n                var sel = "";\n                if (quiver_params.density == k)\n                    sel = \'dot-\';\n\n                $menu.append($("<li  onchoice=\'dens_" + k + "\' > " + name[k] + "  <i  onchoice=\'vis_" + k + "\' class=\'fa fa-" + sel + "circle-o\'></i> </li>"));\n            }\n            $menu.append($("<hr width=\'100%\'> "));\n            $menu.append($("<span> &nbsp Type </span>"));\n            $menu.append($("<hr width=\'100%\'> "));\n            $menu.append($("<li  onchoice=\'type_q\' > quiver  <i  onchoice=\'type_q\' class=\'fa fa-" + ((quiver_params.type == \'q\') ? "dot-" : "") + "circle-o\'></i> </li>"));\n            $menu.append($("<li  onchoice=\'type_t\' > texture  <i  onchoice=\'type_t\' class=\'fa fa-" + ((quiver_params.type == \'t\') ? "dot-" : "") + "circle-o\'></i> </li>"));\n            $menu.append($("<hr width=\'100%\'> "));\n\n\n            if (quiver_params.lengthfac == undefined)\n                quiver_params.lengthfac = 1;\n            var $lengthfac = $("<input onchoice=\'preventSelection\' type=\'number\' step=\'0.1\' min=\'0\' max=\'100\'>").val(quiver_params.lengthfac).\n                 on(\'change\', function(ev) {\n            var $input = $(ev.target);\n                quiver_params.lengthfac = parseFloat($input.val());\n                 signalhandler.send(\'drawQuiver\');               \n               });\n             $menu.append($("<li  onchoice=\'preventSelection\'> Length: </li>").append($lengthfac));\n        \n            var $gamma = $("<input onchoice=\'preventSelection\' type=\'number\' step=\'0.1\' min=\'0\' max=\'2\'>").val(quiver_params.gamma).\n                 on(\'change\', function(ev) {\n            var $input = $(ev.target);\n                quiver_params.gamma = parseFloat($input.val());\n                 signalhandler.send(\'drawQuiver\');               \n               });\n            $menu.append($("<li  onchoice=\'preventSelection\'> Gamma: </li>").append($gamma));\n             $menu.append($("<hr width=\'100%\'> "));\n\n\t        var signed = [\'positive\',\'no\',\'negative\'];\n            $menu.append($("<li  onchoice=\'sign\' > signed ("+signed[ quiver_params.sign+1]+") </li>"));\n\t\t\t\n\n\n\n        }\n        else\n            $menu.append($("<li onchoice=\'show\'>  show  </li>"));\n\n\n        return $menu;\n    },\n    function(str, ev)\n    {\n        if (str == undefined)\n            return;\n        var quiver_params;\n        if (obj.niiOriginal != undefined)\n            quiver_params = obj.niiOriginal.quiver_params;            \n        else\n            quiver_params = obj.nii.quiver_params;\n            \n        if (str.substr(0, 5) == \'dens_\')\n        {\n            quiver_params.density = str.substr(5);\n            signalhandler.send(\'drawQuiver\');\n        }\n        else if (str.substr(0, 5) == \'type_\')\n        {\n            quiver_params.type = str.substr(5);\n            signalhandler.send(\'drawQuiver\');\n        }\n        else if (str == \'reset\')\n        {\n            quiver_params = $.extend(quiver_params,default_quiver_params());\n            signalhandler.send(\'drawQuiver\');\n        }\n        else if (str == \'show\')\n        {\n            quiver_params.visible = true;\n            signalhandler.send(\'drawQuiver\');\n        }\n        else if (str == \'hide\')\n        {\n            quiver_params.visible = false;\n            signalhandler.send(\'drawQuiver\');\n        }\n        else if (str == \'sign\')\n        {\n            quiver_params.sign = (quiver_params.sign+2)%3-1;\n            signalhandler.send(\'drawQuiver\');\n        }\n        else\n        {\n\n\n            var $colselector = KColorSelector(colors, colencode,\n            function() {\n                signalhandler.send(\'drawQuiver\');\n            }, quiver_params  );\n            $colselector.addClass(\'KColorMenuItem\');\n\n            $colselector.themenu(ev);\n        }\n\n\n    })(event);  }\n\n\n    quiver.clear = function()\n    {\n       // if (quiver.$fibercont != undefined)\n       //     quiver.$fibercont.remove();\n\n        for (var k = 0;k < that.quivers.length;k++)\n        {\n            if (that.quivers[k].iid != -1)\n            {\n                clearInterval(that.quivers[k].iid);\n                that.quivers[k].iid = -1;\n            }\n            if (that.quivers[k].$fibercont != undefined)\n              that.quivers[k].$fibercont.remove();\n        }\n    }\n\n    quiver.clear_this = function(quiver_source)\n    {\n        if (quiver_source.$fibercont != undefined)\n            quiver_source.$fibercont.remove();\n\n        if (quiver_source.iid != -1)\n        {\n            clearInterval(quiver_source.iid);\n            quiver_source.iid = -1;\n        }\n    }\n\n    var colors = ["dir", [255, 0, 0], [0, 255, 0], [0, 0, 255], [255, 255, 0], [255, 0, 255], [0, 255, 255], [0, 0, 0], [255, 255, 255]];\n\n    function colencode(c) {\n        return "background:" + RGB2HTML(c[0], c[1], c[2]) + ";";\n    }\n\n    signalhandler.attach(\'drawQuiver\', quiver.draw);\n\n\n    return quiver;\n}\n\n\n    ovlcnt = 0;\n\n\nfunction KMosaicView(that)\n{\n    var mosaic = {};\n\n    mosaic = {\n        active: false,\n        nx: 8,\n        nx_cont: 8,\n        zoom: 1,\n        border: 0.2,\n        start: 0.2,\n        end: 0.8,\n        mosaic_direction: false,\n    };\n    mosaic.active = (that.viewport.viewPortID > 14 && that.viewport.viewPortID < 18) ? true : false;\n    mosaic.$sliderdiv = $("<div class=\'mosaicbar\'></div>")\n    mosaic.$window = $("<div class=\'mosaicslider\'></div>").appendTo(mosaic.$sliderdiv);\n    mosaic.$leftdrag = $("<div class=\'mosaicdragleft\'></div>").appendTo(mosaic.$window);\n    mosaic.$rightdrag = $("<div class=\'mosaicdragright\'></div>").appendTo(mosaic.$window);\n\n    function crop(v, l, u)\n    {\n        v = (v > u) ? u : v;\n        v = (v < l) ? l : v;\n        return v;\n    }\n\n    function setZWindowing()\n    {\n        mosaic.$window.css(\'left\', mosaic.start * 100 + \'%\');\n        mosaic.$window.css(\'width\', (mosaic.end - mosaic.start) * 100 + \'%\');\n    }\n\n    // \n    mosaic.showControls = function()\n    {\n        that.layoutbar.$moszoomin.show();\n        that.layoutbar.$moszoomout.show();\n        that.mosaicview.$sliderdiv.show()\n        //that.layoutbar.$slideslices.hide();\n    }\n    mosaic.hideControls = function()\n    {\n        that.layoutbar.$moszoomin.hide();\n        that.layoutbar.$moszoomout.hide();\n        that.mosaicview.$sliderdiv.hide();\n        that.$topRow.find(".mosaiclabels").remove();\n        //that.layoutbar.$slideslices.show();\n    }\n\n\n    setZWindowing();\n\n    signalhandler.attach("mosaic_changelayout",function(ev)\n    {\n        mosaic.start = ev.start;\n        mosaic.end = ev.end;\n        mosaic.nx = ev.nx;\n        mosaic.ny = ev.ny;\n        mosaic.zoom = ev.zoom;\n        that.setInnerLayout();\n        that.drawHairCross();\n    })\n\n    mosaic.$window.on("mousedown", function(e)\n    {\n        var mos = mosaic;\n        var wid = mos.$sliderdiv.width();\n        var ini_start = mos.start;\n        var ini_end = mos.end;\n        $(document.body).on("mouseup mouseleave", function(em) {\n            if (KViewer.mainViewport != -1)\n                signalhandler.send("mosaic_changelayout",mos);\n            else\n            { \n                that.setInnerLayout();\n                that.drawHairCross();\n            }\n            $(document.body).off("mouseup mouseleave mousemove");\n        });\n        $(document.body).on("mousemove", function(em)\n        {\n            var delta = (em.clientX - e.clientX) / wid;\n            mos.start = crop(ini_start + delta, 0, 1);\n            mos.end = crop(ini_end + delta, 0, 1);\n            setZWindowing();\n        });\n    });\n\n\n    mosaic.$leftdrag.on("mousedown", function(e)\n    {\n        var mos = mosaic;\n        var wid = mos.$sliderdiv.width();\n        var ini = mos.start;\n        e.preventDefault();\n        e.stopPropagation();\n        $(document.body).on("mouseup mouseleave", function(em) {\n            if (KViewer.mainViewport != -1)\n                signalhandler.send("mosaic_changelayout",mos);\n            else\n            { \n                that.setInnerLayout();\n                that.drawHairCross();\n            }          \n            $(document.body).off("mouseup mouseleave mousemove");\n        });\n        $(document.body).on("mousemove", function(em)\n        {\n            var delta = (em.clientX - e.clientX) / wid;\n            mos.start = crop(ini + delta, 0, 1);\n            setZWindowing();\n        });\n    });\n\n    mosaic.$rightdrag.on("mousedown", function(e)\n    {\n        var mos = mosaic;\n        var wid = mos.$sliderdiv.width();\n        var ini = mos.end;\n        e.preventDefault();\n        e.stopPropagation();\n        $(document.body).on("mouseup mouseleave", function(em) {\n            if (KViewer.mainViewport != -1)\n                signalhandler.send("mosaic_changelayout",mos);\n            else\n            { \n                that.setInnerLayout();\n                that.drawHairCross();\n            }                      $(document.body).off("mouseup mouseleave mousemove");\n        });\n        $(document.body).on("mousemove", function(em)\n        {\n            var delta = (em.clientX - e.clientX) / wid;\n            mos.end = crop(ini + delta, 0, 1);\n            setZWindowing();\n        });\n    });\n\n    return mosaic;\n\n}\n\n\n\n\nfunction KHaircross()\n{\n    var line = {}\n\n    line.$main = $("<div class = \'haircross_new\'></div>").appendTo(KViewer.viewports[0].$container);\n\n    line.$centerline = $("<div class = \'centerline rotator\'></div>").appendTo(line.$main );\n    line.$rot1 = $("<div class = \'grabberbg rotator\'><div class=\'\'></div><i class=\'fa fa-rotate-left\'></i></div>").appendTo(line.$main );\n    line.$rot1i = line.$rot1.find(\'i\');\n    line.$rot2 = $("<div class = \'grabberbg rotator\'><div class=\'\'></div><i class=\'fa fa-rotate-left\'></i></div>").appendTo(line.$main );\n    line.$rot2i = line.$rot2.find(\'i\');\n\n    line.setsizes = function(siz)\n    {\n        siz = math.round(siz/2/3);\n        line.$rot1.css({top: siz*0.5 - 1 + "px" });\n        line.$rot2.css({bottom: siz*0.5 - 1 + "px"});\n    }\n\n\n    line.hideRot = function()\n    {\n            line.$rot2.hide(); \n            line.$rot1.hide();\n            line.$rot2i.hide(); \n            line.$rot1i.hide();\n    }\n\n    line.showRot = function()\n    {\n            line.$rot2.show(); \n            line.$rot1.show();\n            line.$rot2i.show(); \n            line.$rot1i.show();\n    }\n\n\n    line.toggleControls = function(state)\n    {\n        if(!state)\n        {\n            line.$rot2.hide(); \n            line.$rot1.hide();\n        }\n        else\n        {\n            line.$rot2.show(); \n            line.$rot1.show();\n        }\n\n    }\n    return line;\n    \n\n}\n\n\nfunction Outlines(that)\n{\n     var outlines = {};\n     outlines.gen2DContour = function(viewer)  \n     {\n        var ras = true;\n        \n        var sg = 1;\n        if (ras)\n            sg = -1;\n\n\n        var conts = that.contour.content.Contours[that.select].ContourSequence.node    \n\n\n        var e;\n        if (KViewer.mainViewport !== -1)\n        {\n            var e = viewer.nii.edges;\n            e = math.multiply(KViewer.reorientationMatrix.matrix, e);\n            e = math.inv(e)._data;\n        }\n        else\n            e = math.inv(viewer.nii.edges)._data;\n\n            \n        var sz = viewer.nii.sizes;\n\n        var wp = viewer.getWorldPosition()._data\n        var s = viewer.getSlicingDimOfWorld()\n        var pos = wp[s];\n\n        var min = 9999.0;\n        var idx = -1;\n        for (var k = 0;k < conts.length;k++)\n        {\n            var d = math.abs(conts[k].ContourData[s]-pos)\n            if (d < 3 && d < min)\n            {\n                idx = k;\n                min = d;\n            }\n\n        }\n        if (idx == -1)\n        {\n            outlines.close();\n            return;\n        }\n\n        var c = conts[idx].ContourData;\n        var verts = [];\n        var lines = [];\n        \n        var d ;\n        if (s==0) { if (viewer.swapXY)  d = [2,1];  else  d = [1,2]; }\n        if (s==1) { if (viewer.swapXY)  d = [2,0];  else  d = [0,2]; }\n        if (s==2) { if (viewer.swapXY)  d = [1,0];  else  d = [0,1]; }\n\n        var rdirs = [viewer.nii.arrayReadDirection[d[0]],viewer.nii.arrayReadDirection[d[1]]]\n\n        var pushC = function(p) { \n                    var x = (p[d[0]]+0.5)/sz[d[0]];\n                    var y = (p[d[1]]+0.5)/sz[d[1]];\n                    if (rdirs[0] > 0) verts.push(1-x)\n                    else               verts.push(x )\n                    if (rdirs[1] > 0) verts.push(1-y)\n                    else               verts.push(y)\n           }\n\n        var nverts = c.length/3\n\n        for (var k = 0; k < nverts;k++)        \n        {\n            var p = [ sg*e[0][0]*c[3*k] + sg*e[0][1]*c[3*k+1] + e[0][2]*c[3*k+2] + e[0][3] ,\n                      sg*e[1][0]*c[3*k] + sg*e[1][1]*c[3*k+1] + e[1][2]*c[3*k+2] + e[1][3],\n                      sg*e[2][0]*c[3*k] + sg*e[2][1]*c[3*k+1] + e[2][2]*c[3*k+2] + e[2][3]     ];\n\n            pushC(p)\n\n            lines.push(k)\n            lines.push((k+1)%nverts)\n\n        }\n\n        return {lines:lines,verts:verts};\n\n\n     }\n\n     outlines.compOutline = function(viewer)  \n     {\n             if (viewer == undefined)\n                viewer = that;\n\n            var nii = that.nii;\n\n            var slicingDimOfArray = viewer.getSlicingDimOfArray()\n            var curSl = viewer.getCurrentSlice();\n\n            var data = nii.data;\n            var sizes = viewer.nii.sizes;\n            var label = nii.label;\n\n            var w = sizes[0];\n            var h = sizes[1];\n            var d = sizes[2];\n            var wh = sizes[0]*sizes[1];\n\n\n            var cnt = 0;\n            var vertsIDX = {};\n            function addVert(i)\n            {\n                if (vertsIDX[i] == undefined)\n                {\n                    vertsIDX[i] = cnt;\n                    cnt++;\n                    return cnt-1;\n                }\t\t\n                else\n                    return vertsIDX[i];\n            }\n            var lines = [];\n\n            var addLine = function( i0,i1)\n                    {\n                        lines.push(i0,i1)\n                    }\n\n            var label,thres;\n            if (that.atlas != undefined && that.atlas.content != undefined)\n            {              \n              label = that.atlas.currentLabel.key;\n            }\n            else\n            {\n               if (that.histoManager)\n                    thres =that.histoManager.clim[0];\n               else\n                    thres = 0.5;\n            }\n            var compfun = function(x) { return x>thres }\n            var negcompfun = function(x) { return x<=thres }\n            if (label)\n            {\n                if (label.threshold)\n                {\n                    compfun = function(x) {\n                        return x>label.threshold;\n                    }\n                    negcompfun = function(x) {\n                        return x<=label.threshold;\n                    }\n                }\n                else\n                {\n                    compfun = function(x) {\n                        return x==label;\n                    }\n                    negcompfun = function(x) {\n                        return x!=label;\n                    }\n                }\n            }\n\n        var idxfun,subst;\n        var lims;\n        var pi;\n\n        if (slicingDimOfArray == 0)\n            {\n                idxfun = function (a,b) { return curSl + a*w + b * wh };\n                subst = function(f) { return function(a,b) { return  f(curSl,a,b) }     };                \n                lims = [sizes[1],sizes[2]];\n                pi = [1,2]\n            }\n        else if (slicingDimOfArray == 1)\n            {\n                idxfun = function (a,b) { return a + curSl*w + b * wh };\n                subst = function(f) { return function(a,b) { return  f(a,curSl,b) }     };\n                lims = [sizes[0],sizes[2]];\n                pi = [0,2]\n            }\n        else if (slicingDimOfArray == 2)\n            {\n                idxfun = function (a,b) { return a + b*w + curSl * wh };\n                subst = function(f) { return function(a,b) { return  f(a,b,curSl) }     };\n                lims = [sizes[0],sizes[1]];\n                pi = [0,1]                \n            }\n\n        var flip;\n        var arrayReadDirection = viewer.nii.arrayReadDirection;\n        if (viewer.swapXY)\n             flip = function(x,y){\n                    x = x/lims[0]; y = y/lims[1];\n                    x = (arrayReadDirection[pi[0]]<0)?x:(1-x);\n                    y = (arrayReadDirection[pi[1]]<0)?y:(1-y);\n                    return [y,x];\n                }\n        else\n             flip = function(x,y){\n                    x = x/lims[0]; y = y/lims[1];\n                    x = (arrayReadDirection[pi[0]]<0)?x:(1-x);\n                    y = (arrayReadDirection[pi[1]]<0)?y:(1-y);\n                    return [x,y];\n                }\n        var getPixel;\n\n\n\n\n        var tOffset = 0;\n        if (nii.currentTimePoint)\n        {\n            tOffset = nii.currentTimePoint.t * nii.sizes[0]* nii.sizes[1]* nii.sizes[2];\n        }\n\n        if (viewer.nii.edges._data.toString() == that.nii.edges._data.toString() && KViewer.mainViewport == -1)\n            getPixel = function(x,y) { return data[ idxfun(x,y) + tOffset] }        \n        else\n        {\n            if (that.atlas)\n            {\n                var getPixel3d = KAtlasTool.updateGetPixelFun(that.atlas.content,viewer.nii,undefined,math.diag([1,1,1,1]),undefined);\n                getPixel = subst(getPixel3d);\n            }\n            else\n            {\n                var getPixel3d = function(x,y,z) { return  trilinInterp(that.nii, x, y, z, that.A, tOffset); }\n                getPixel = subst(getPixel3d);\n            }\n        }\n\n\n\n        for (var y = 1; y < lims[1]-1;y++)\n        for (var x = 1; x < lims[0]-1;x++)\n        {\n            var idx2 = x+lims[0]*y;\n            if (compfun(getPixel(x,y)))\n            {\n                var i0,i1;\n                if (negcompfun(getPixel(x-1,y) ))\n                {\n                    i0 = addVert(idx2);\n                    i1 = addVert(idx2+lims[0]);\n                    addLine(i0,i1);\n                } \n\n                if (negcompfun(getPixel(x+1,y) ))\n                {\n                    i0 = addVert(idx2+1);\n                    i1 = addVert(idx2+1+lims[0]);\n                    addLine(i0,i1);\n                }\n\n                if (negcompfun(getPixel(x,y-1)))\n                {\n                    i0 = addVert(idx2);\n                    i1 = addVert(idx2+1);\n                    addLine(i0,i1);\t\t\t    \n                } \n                if (negcompfun(getPixel(x,y+1)))\n                {\n                    i0 = addVert(idx2+lims[0]);\n                    i1 = addVert(idx2+1+lims[0]);\n                    addLine(i0,i1);\t\t\t    \n                }\n            }\n\n        }\n\n\n\n        var pts = Object.keys(vertsIDX);\n        var verts = new Float32Array(pts.length*2);\n        for (var k = 0; k < pts.length;k++)\n        {\n            var p = flip(pts[k]%lims[0], math.floor(pts[k]/lims[0]));\n            var i = vertsIDX[pts[k]];\n            verts[2*i] = p[0];\n            verts[2*i+1] = p[1];\n        }\n\n        smooth();\n        smooth();\n\n        function smooth()\n        {\n            var cnt = new Float32Array(pts.length);\n            var verts2 = new Float32Array(2*pts.length);\n            verts2.set(verts);\n            for (var k = 0 ; k < lines.length/2;k++)\n            {\n                  var p1_x = verts[2*lines[2*k]];\n                  var p1_y = verts[2*lines[2*k]+1];\n                  var p2_x = verts[2*lines[2*k+1]];\n                  var p2_y = verts[2*lines[2*k+1]+1];\n                  verts2[2*lines[2*k]] += p2_x;\n                  verts2[2*lines[2*k]+1] += p2_y;\n                  verts2[2*lines[2*k+1]] += p1_x;\n                  verts2[2*lines[2*k+1]+1] += p1_y;\n                  cnt[lines[2*k]]++\n                  cnt[lines[2*k+1]]++\n            }\n            for (var k=0;k < pts.length;k++)\n            {\n                verts[2*k] = verts2[2*k]/(1+cnt[k]);\n                verts[2*k+1] = verts2[2*k+1]/(1+cnt[k]);\n            }\n        }\n\n\n\n        return {lines:lines,verts:verts};\n\n\n\n\n\n\n\n\n     }\n\n     outlines.close = function()\n     {\n          if (outlines.$lines != undefined)\n          {\n                outlines.$lines.remove();\n                outlines.$lines = undefined;\n          }\n     }\n     \n     outlines.update= function(viewer)   \n     {\n        if (that.nii != undefined)\n            outlines.current = outlines.compOutline(viewer);\n        else if (that.contour != undefined)\n            outlines.current = outlines.gen2DContour(viewer);\n\n        outlines.draw(viewer);\n     }\n\n     outlines.draw = function(viewer)   \n     {\n         if (viewer == undefined)\n            viewer = that;\n         if (outlines.current != undefined)\n         {\n             var l = outlines.current \n             var pstr = "";\n             var fac_x = viewer.$canvas.width() * viewer.embedfac_width;\n             var fac_y = viewer.$canvas.height() * viewer.embedfac_height;\n             \n             if(that.color !=undefined)\n             {\n                var color = KColor.list[that.color];\n                color = "rgba("+ color.join(\',\') + "," + "1)"; \n             }\n             else\n                color = "rgba(255,0,0,1)"; \n\n             for (var k = 0 ; k < l.lines.length/2;k++)\n             {\n                  var p1_x = l.verts[2*l.lines[2*k]]*fac_x;\n                  var p1_y = l.verts[2*l.lines[2*k]+1]*fac_y;\n                  var p2_x = l.verts[2*l.lines[2*k+1]]*fac_x;\n                  var p2_y = l.verts[2*l.lines[2*k+1]+1]*fac_y;\n                  pstr += "M "+ p1_x + " " + p1_y + " L " + p2_x + " " + p2_y + " ";\n\n             }\n\n             // hmm this not the right solution, but w/h of canvas does not match\n             var w = 1000000; viewer.$canvascontainer.width();\n             var h = 1000000; viewer.$canvascontainer.height();\n\n\n             if (outlines.$lines == undefined)\n             {\n              \n                 outlines.$lines =  $("<svg  style=\'pointer-events:none;width:"+w+"px;height:"+h+"px;z-index:1;position:absolute;stroke-width:2px\'> " + \n                            "<path style=\'fill:none;stroke:red;stroke-width:2\' />  </svg>");\n                             viewer.$canvascontainer.append( outlines.$lines);\n             }\n             var path = outlines.$lines.find("path");\n             path.attr("d",pstr)\n             path.css(\'stroke\',color);\n\n\n             //outlines.$lines = $("<svg  style=\'pointer-events:none;width:"+w+"px;height:"+h+"px;z-index:1;position:absolute;stroke-width:2px\'>" + flines + "</svg>");\n\n         }\n     }\n\n\n     \n     return outlines;\n\n}\n\n\n\nfunction interpretAsColoredVolume(nii,that)\n{\n    var fname = that.currentFilename;\n    if (fname == undefined)\n        fname = that.filename\n    if (fname == undefined)\n        return false;\n\n\n    return (nii.sizes[3]%3 == 0 &&  ( \n       fname.match(/col/i)!=null \n    || fname.match(/fod/i)!=null \n    || fname.match(/rgb/i)!=null \n    || fname.match(/_mdir/i)!=null \n    || fname.match(/DBS[\\w\\ \\_]*current/i)!=null \n    ) ); \n}\n\n\n  function off(ev)\n    {\n        if (ev.offsetX !== undefined)\n            return {\n                X: ev.offsetX,\n                Y: ev.offsetY\n            };\n        else\n            return {\n                X: ev.originalEvent.layerX,\n                Y: ev.originalEvent.layerY\n            };\n    }\n\nfunction colorPermutation(e2,that,nii)\n{\n\n    if (that.showcolored_type)\n    {\n        var Order = KMedViewer.getPermutationOrder(nii.reordering); \n        var type = that.showcolored_type        \n        if (type != "raw")\n              e2 = math.multiply(math.inv(Order.mat),e2);\n            \n        if (type == "GBR")\n               e2 = math.multiply(math.matrix([[0, 1, 0, 0], [0, 0, 1, 0], [1, 0, 0, 0], [0, 0, 0, 1]]),e2);\n        if (type == "GRB")\n               e2 = math.multiply(math.matrix([[1, 0, 0, 0], [0, 0, 1, 0], [0, 1, 0, 0], [0, 0, 0, 1]]),e2);\n        if (type == "BRG")\n               e2 = math.multiply(math.matrix([[0, 0, 1, 0], [1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 0, 1]]),e2);\n        if (type == "raw")\n               e2 = math.matrix([[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]]);\n    }\n    return e2;\n}\n\n\nfunction showInfoContextNifti(that,ev)\n{\n          var info =   KContextMenu(\n                    function() {\n\n                var nii = that.nii;\n\n                var msz = "";\n                msz = "matrix: " + nii.sizes[0].toFixed(0) + \'&nbsp;&nbsp;\' + nii.sizes[1].toFixed(0) + \'&nbsp;&nbsp;\' + nii.sizes[2].toFixed(0);\n                if (nii.sizes.length > 3 && (nii.sizes[3] > 1 | nii.sizes[3] > 1))\n                    msz += \';&nbsp;\' + nii.sizes[3].toFixed(0);\n                if (nii.sizes.length > 4 && nii.sizes[4] > 1)\n                    msz += \';&nbsp;\' + nii.sizes[4].toFixed(0);\n\n                if (nii.currentTimePoint.t != 0)\n                    msz += "  (t:" + (nii.currentTimePoint.t + 1) + ")";\n\n\n\n                if (that.currentFileinfo)\n                {\n                    if (that.currentFileinfo.patients_id == undefined)\n                        var psid = "no associated patient";\n                    else\n                        var psid = that.currentFileinfo.patients_id + "_" + that.currentFileinfo.studies_id + "<br>";\n                }\n                else\n                    var psid = "localfile <br> ";\n                if (userinfo.username == guestuser)\n                    psid = "";\n\n                var txt = "<span style=\'font-size:12px;line-height:13px\'><b>";\n                if (that.currentFileinfo.SubFolder != undefined && that.currentFileinfo.SubFolder !="")\n                     txt +=  that.currentFileinfo.SubFolder + \'/\' + that.currentFilename + \'<br>\'   ;\n                else\n                     txt +=  that.currentFilename + \'<br>\'   ;\n\n                txt += "</b>" + psid;\n                txt += "</span>";\n                txt += "<span style=\'font-size:3px;line-height:3px\'><br></span>";\n                txt += "<br>";\n\n                txt +=  "voxsize: " + nii.voxSize[0].toFixed(2) + \'&nbsp;&nbsp;\' + nii.voxSize[1].toFixed(2) + \'&nbsp;&nbsp;\' + nii.voxSize[2].toFixed(2)\n                    + "<br> <span>" + msz  + "</span>";\n\n                txt += "<br> <br> sform_code: "+nii.sform_code+"  <span>";\n                txt += "<br>  qform_code: "+nii.qform_code+"   <span>";\n                txt += "<br> <br> edges ("+nii.form+"): <br> <span>";\n                for (var k = 0; k < 3;k++)\n                    txt += "&nbsp;&nbsp;" + nii.edges._data[k][0].toFixed(2) + "&nbsp;&nbsp;" +  \n                                            nii.edges._data[k][1].toFixed(2) + "&nbsp;&nbsp;" + \n                                            nii.edges._data[k][2].toFixed(2) + "&nbsp;&nbsp;" + \n                                            nii.edges._data[k][3].toFixed(2) + "&nbsp;&nbsp; <br> " ;\n\n                txt +=  "<br>value: y=" + nii.datascaling.slope.toFixed(2) + \'*x + \' +nii.datascaling.offset.toFixed(2) + "<br>";\n                txt +=  "datatype: " + nii.datatype + "<br>";\n                txt +=  "endian: " + nii.endian + "<br>";\n                txt +=  "encoding: " + nii.encoding + "<br>";\n                txt +=  "filetype: " + nii.filetype + "<br>";\n                txt +=  "space: " + nii.space + "<br>";\n\n                txt += "</span>";\n\n                        var $menu = $("<ul class=\'menu_context\'>").append($(txt));\n\n                        return $menu;\n\n                    },\n                    function(str, ev)\n                    {                \n\n\n                    },false,true);\n         info(ev);\n\n\n\n}\n'},function(t,n){t.exports='\n\nvar oldBablyonFlag = false;\n\n/** @class \n*/\nfunction KMedImg3D(medviewer,$canvas3D)\n{\n\t\n\n\n\n\t$canvas3D.show();\n\n  \n\tvar viewer = medviewer;\n\tvar engine = new BABYLON.Engine($canvas3D[0], true,{preserveDrawingBuffer: true}  );\n\n    setQuality();\n\tvar scene;\n\tvar camera;\n\tvar camera_picto;\n\tvar control;\n\tvar planes = [];\n\tvar grandParent ;\n\tvar posIndicator;\n\tvar flip;\n\n\tvar vol_planes = [];\n\tvar vol_textures = [];\n\tvar vol_materials = [];\n\tvar vol_ctxs = [];\n\t\n\tvar currentLayout;\n\tvar psz = [];\n\tvar textures = [];\n\tvar materials = [];\n\tvar pencil;\n\tvar ctxs = [];\n    var center;\n    var texSize = 1024;\n    var _this = this;\n    var planesVisibility = [true,true,true];\n\t\n\tfunction setPlanesVisibility(pp)\n\t{\n\t\tplanesVisibility = pp;\n\t\tupdateObjects();\n\t}\n\n\tfunction getPlanesVisibility()\n\t{\n\t\treturn planesVisibility;\n\t}\n\n\n    var fixedPlanarView = -1;\n\n\n    var helperMesh;\n\n\n\n\n\tfunction createCutSurfShader(obj)\n\t{\n\t\t\tvar shader = new BABYLON.ShaderMaterial("mySurfcolShader", scene, "mySurfcol", {\n\t\t\t\t\tattributes: [BABYLON.VertexBuffer.PositionKind,BABYLON.VertexBuffer.NormalKind,\'color\'],\n\t\t\t\t\tuniforms: ["worldViewProjection","planesPos","planesThres","planesCut","worldToVoxel"],\n\t\t\t\t\tneedAlphaBlending: (obj.alpha<1),\n\t\t\t\t\tneedAlphaTesting: (obj.alpha<1)\t\n\t\t\t\t});\t\t\n\n\t\t\tshader.shadersignal = signalhandler.attach(\'positionChange\', function() {\n\t\t\t\tvar pp = world2GL(viewer.getWorldPosition());\n\t\t\t\tvar planesPos = new BABYLON.Vector3(pp[0],pp[1],pp[2]);\n\t\t\t\tshader.setVector3("planesPos",planesPos);\n\t\t\t\tshader.updateTilts();\n\t\t\t});\n\t\t\tshader.alphaMode = obj.alphaMode;\n\t\t\tshader.wireframe = obj.wire;;\n\t\t\tshader.backFaceCulling = false;\n\t\t\tif (parseFloat(obj.beltwidth) > 0)\n                shader.setFloat("planesThres",parseFloat(obj.beltwidth));\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (obj.cuts != undefined && obj.cuts[0] == 0 && obj.cuts[1] == 0 && obj.cuts[2] == 0)\n\t\t\t\t\tshader.setFloat("planesThres",10000);\n\t\t\t\telse\n\t\t\t\t\tshader.setFloat("planesThres",0);\n\t\t\t}\n\t  \t\tvar perm = [viewer.nii.permutationOrder[1],viewer.nii.permutationOrder[2],viewer.nii.permutationOrder[0]];\n\n\t\t\tshader.setVector3("planesCut",new BABYLON.Vector3(obj.cuts[perm[0]],obj.cuts[perm[1]],obj.cuts[perm[2]]));\n\t\t\tshader.setFloat(\'alpha\',obj.alpha);\n\t\t\tshader.setFloat(\'vertexcoloring\',0)\n\n\n\n\t\t\treturn shader;\n\t}\n\n/*\n\t\t\t\t\tneedDepthPrePass: true\t,\n\t\t\t\t\tseparateCullingPass:true\t\t\t\n*/\n\n\tfunction createFiberShader()\n\t{\n\t\t    var needAlphaBlending =false;\n\t\t    if (state.viewer.fiberAlpha)\n\t\t    \tneedAlphaBlending = true;\n\t\t\t/////////// the fibershader instance\n\t\t\tvar fiberDirColor_shader = new BABYLON.ShaderMaterial("fiberColorShader", scene, "fiberColor", {\n\t\t\t\t\tattributes: [BABYLON.VertexBuffer.PositionKind,\'colors\'],\n\t\t\t\t\tuniforms: ["worldViewProjection","col"],\n\t\t\t\t\tneedAlphaBlending: needAlphaBlending,\n\t\t\t\t});\n\t\t\tfiberDirColor_shader.shadersignal = signalhandler.attach(\'positionChange\', function() {\n\t\t\t\tvar pp = world2GL(viewer.getWorldPosition());\n\t\t\t\tvar planesPos = new BABYLON.Vector3(pp[0],pp[1],pp[2]);\n\t\t\t\tfiberDirColor_shader.setVector3("planesPos",planesPos);\n\t\t\t});\n            fiberDirColor_shader.setFloat("planesNum",-1);\n            fiberDirColor_shader.setColor4("col",new BABYLON.Color4(0,0,0,0));\n\t\t\tfiberDirColor_shader.setFloat("planesThres",5);\n\t\t\tfiberDirColor_shader.setFloat("planesProj",1);\n\t\t\tfiberDirColor_shader.setFloat("hover",0);\n\t\t\n\t\t\treturn fiberDirColor_shader;\n\t}\n\n\tfunction detachShader(shader)\n\t{\n\t\tsignalhandler.detach(\'positionChange\',shader.shadersignal);\n\t}\n\n\n\tfunction animate3D(dir)\n\t{\n\t\tif (this.animation != undefined)\n\t\t{\n\t\t   clearInterval(this.animation);\n\t\t   this.animation = undefined;\n\t\t   return false;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar speed = 3;\n\t\t   this.animation = setInterval(function() \n\t\t   \t\t{ \n\t\t   \t\t  camera.inertialAlphaOffset = dir*0.002*speed; \n\t\t   \t\t  if (camera_picto)\n\t\t\t\t\t{\n\t\t\t\t\t\tcamera_picto.alpha= viewer.gl.camera.alpha;\n\t\t\t\t\t\tcamera_picto.beta= viewer.gl.camera.beta;\n\t\t\t\t\t\tcamera_picto.inertialAlphaOffset = viewer.gl.camera.inertialAlphaOffset;\n\t\t\t\t\t\tcamera_picto.inertialBetaOffset= viewer.gl.camera.inertialBetaOffset;\n\t\t\t\t\t}\n\t\t   \t\t  activateRenderLoop();\n\t\t   \t\t},100);\n\t\t   return true;\n\t\t}\n\t}\n\n\n/*\n\n\tBABYLON.Effect.ShadersStore.mycolorVertexShader = "precision highp float;"+\n\t"attribute vec3 position;"+\n\t"attribute vec4 colors;"+\n\t"varying vec4 vcolor;"+\n\t"uniform mat4 worldViewProjection;"+\n\t"void main(void) { vcolor = colors;"+\n\t"\tgl_Position = worldViewProjection * vec4(position, 1.0);"+\n\t"}";\n\n\tBABYLON.Effect.ShadersStore.mycolorPixelShader = "precision highp float;"+\n\t"varying vec4 vcolor;void main(void) {\tgl_FragColor = vcolor;}";\n\n\n*/\n\t\n\n\t\t // This begins the creation of a function that we will \'call\' just after it\'s built\n\tfunction createScene() {\n\t\tvar canvas = $canvas3D[0];\n\n\t\tscene = new BABYLON.Scene(engine);\n\t\t//scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.12);\n\n\t\t\n\n\t\tvar rgb = hexToRgb(ViewerSettings.background3D);\n\t\tif (rgb != null)\n\t\t\tscene.clearColor = new BABYLON.Color3(rgb.r/255,rgb.g/255,rgb.b/255);\n\t    else\n\t        scene.clearColor = new BABYLON.Color3(0.1, 0.1, 0.12);\n\t\t\n\t\t\n\t\tscene.ambientColor = new BABYLON.Color3(0,0,0);\n\n\t\tvar order = KMedViewer.getPermutationOrder();\n\n\n \n\t\tvar light = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(0, 0, 0), scene);\n\t\tlight.intensity = 2\n\n\t\tlight.specular = new BABYLON.Color3(0,0,0);\n\t\tlight.diffuse = new BABYLON.Color3(1,1,1);\n\t\tlight.ambient = new BABYLON.Color3(1,1,1);\n\t\tlight.range = 1;\n\t\t\n\n\t\t// create main camera\n\t\tcreateControlsCam();\n\n\n\t\tif (state.viewer.picto3D && state.viewer.picto3D != -1)\n\t\t{\n\n\t\t\tvar pictoModels = [{name:"BodyMesh.obj",offset:[0,0,0],zoom:7 , rotx:Math.PI/2},\n\t\t\t\t\t\t\t   {name:"LowPolyGirl.obj",offset:[-5,0,0],zoom:6, rotx:-Math.PI/2},\n\t\t\t\t\t\t\t   {name:"minion.obj",offset:[0,6,0],zoom:0.6 , rotx:Math.PI/2}, \n\t\t\t\t\t\t\t   {name:"Bust_Basemesh.obj",offset:[0,8,0],zoom:0.3 , rotx:-Math.PI/2} \n\t\t\t\t\t\t\t   ];\n\n\t\t\tvar theModel = pictoModels[state.viewer.picto3D];\n\t\t//\tif (theModel != undefined)\n\t\t\t{\n\n\t\t\t\t// camera of small pictogram \n\t\t\t\tcamera_picto = new BABYLON.ArcRotateCamera("Camera", -1.6 * Math.PI , Math.PI *0.2,50 , \n\n\t\t\t\tnew BABYLON.Vector3(100000+theModel.offset[0],theModel.offset[1],theModel.offset[2]) , scene);\n\t\t\t\tscene.activeCameras.push(camera);\n\t\t\t\tscene.activeCameras.push(camera_picto);\n\t\t\t\tcamera_picto.viewport = new BABYLON.Viewport(0.7, -0.05, 0.4, 0.4);\n\t\t\t\tcamera_picto.thepictomodel = [];\n\n\t\t//\t\tvar test = BABYLON.Mesh.CreateBox("thumb", 10, scene);\n\t\t//\t\ttest.position.x =100000;\n\t\t//\t\tlight.exgodzilla/cludedMeshes.push(test);\n\n\t\t\t\t\n\t\t\t\tvar loadmodel = function()\n\t\t\t\t{\n\t\t\t\t\tvar theModel = pictoModels[state.viewer.picto3D];\t\t\t\t\n\t\t\t\t\tif (theModel)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar loader = new BABYLON.AssetsManager(scene);\n\t\t\t\t\t\tvar task = loader.addMeshTask("A2", "", url_pref , "models3d/"+theModel.name);\n//\t\t\t\t\t\tvar task = loader.addMeshTask("A2", "", myownurl().replace("index.php","") , "models3d/"+theModel.name);\n\t\t\t\t\t\ttask.onSuccess =  function (m)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor (var k = 0; k < camera_picto.thepictomodel.length;k++)\n\t\t\t\t\t\t\t\t\tcamera_picto.thepictomodel[k].dispose();\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t    camera_picto.thepictomodel = [];\n\t\t\t\t\t\t\t\tm.loadedMeshes.forEach(function(b) {          \n\t\t\t\t\t\t\t\t\t\t\t\tb.position.x = 100000;\n\t\t\t\t\t\t\t\t\t\t\t\tb.position.z = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tb.position.y = 0;\n\t\t\t\t\t\t\t\t\t\t\t\tb.scaling.x = theModel.zoom;\n\t\t\t\t\t\t\t\t\t\t\t\tb.scaling.y = theModel.zoom;\n\t\t\t\t\t\t\t\t\t\t\t\tb.scaling.z = theModel.zoom;\n\t\t\t\t\t\t\t\t\t\t\t\tb.createNormals();\n\t\t\t\t\t\t\t\t\t\t\t\tb.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\t\t\t\t\t\t\t\t\t\tb.rotation.y = theModel.rotx ;\n\t\t\t\t\t\t\t\t\t\t\t\t//meshy.material.diffuseColor = new BABYLON.Color3(1,1,1);\n\t\t\t\t\t\t\t\t\t\t\t\t//meshy.material.emissiveColorColor = new BABYLON.Color3(1,0,1);\n\t\t\t\t\t\t\t\t\t\t\t\tlight.excludedMeshes.push(b);\n\t\t\t\t\t\t\t\t\t\t\t\tcamera_picto.thepictomodel.push(b);\n\t\t\t\t\t\t\t\t\t\t\t\tactivateRenderLoop();\n\t\t\t\t\t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\tloader.load();\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var k = 0; k < camera_picto.thepictomodel.length;k++)\n\t\t\t\t\t\t\tcamera_picto.thepictomodel[k].dispose();\t\t\t\t\t\t\t\n\t\t\t\t\t\tcamera_picto.thepictomodel = [];\n\t\t\t\t\t}\n\n\t\t\t\t};\n\n\t\t\t\tsignalhandler.attach("picto3dmodel_changed",function(cm) { return function()\n\t\t\t\t{\n\t\t\t\t\tloadmodel();\n\t\t\t\t} }(camera_picto));\n\n\t\t\t\tloadmodel();\n\n\t\t\t\tvar light_picto = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(1, 0.2, 0), scene);\n\t\t\t\tlight_picto.diffuse = new BABYLON.Color3(0.8,0.7,0.2);\n\t\t\t\tlight_picto.intensity = 1;\n\t\t\t\t var light_picto = new BABYLON.HemisphericLight("light1", new BABYLON.Vector3(-1, 0.2, 0), scene);\n\t\t\t\tlight_picto.diffuse = new BABYLON.Color3(0.8,0.7,0.2);\n\t\t\t\tlight_picto.intensity = 0.5;\n\t\t\t}\n\t\t}\n\n \t    grandParent = BABYLON.Mesh.CreateBox("grandParent", 10, scene);\n \t    grandParent.scaling = new BABYLON.Vector3(1, 1, -order.det);\n \t  //  grandParent.scalingDeterminant =  -order.det;\n \t    grandParent.visibility = false;\n \t    grandParent.isPickable = false;\n \t    flip = function(p) { return new BABYLON.Vector3(p.x, p.y, -order.det*p.z); }\n \t    \n       /* grandParent.setPivotMatrix(\n              BABYLON.Matrix.FromArray([-2,0,0,0,\n\t\t\t\t\t\t\t\t\t\t0,-1,0,0,\n\t\t\t\t\t\t\t\t\t\t0,0,-1,0,\n\t\t\t\t\t\t\t\t\t\t0,0,0,1 ]));*/\n\n\n\n\n    }\n\n\n\tfunction createControlsCam()\n\t{\n\t\tvar canvas = $canvas3D[0];\n\t\tif (camera != undefined)\n\t\t{\n\t\t\tcamera.dispose();\n\t\t\tcontrol.detachControl(canvas);\t\t\t\n\t\t}\n      \n        if (KViewer.defaultFOV_mm == "")\n        {\n\t\t//\tconsole.warn("we need here a defaultFOV calculation");\n\t\t\tif (viewer.content)\n\t\t\t{\n\t\t\t\tvar min = math.multiply(viewer.content.edges,[0,0,0,1])._data\n\t\t\t\tvar max = math.multiply(viewer.content.edges,[viewer.content.sizes[0],viewer.content.sizes[0],viewer.content.sizes[0],1])._data\n\n\t\t\t\tKViewer.defaultFOV_mm = Math.max(max[0]-min[0],max[1]-min[1],max[2]-min[2]);\n\t\t\t}\n\t    }\n\n \t    var canvas = $canvas3D[0];\n\n\t\tcamera = new BABYLON.ArcRotateCamera("Camera", -1.6 * Math.PI , Math.PI *0.2, KViewer.defaultFOV_mm*1.2 , BABYLON.Vector3.Zero(), scene);\n  \t    control = new ArcRotateCameraPointersInput(camera,viewer,_this);\n \t    control.attachControl(canvas,true);\n \t    if (gl)\n \t    {\n \t    \tgl.camera = camera;\n \t    \tgl.camera_picto = camera_picto;\n \t    }\n \t\t\t\n\t}\n\tsignalhandler.attach(\'webglresetcam\',function() {} ); //createControlsCam);\n\n\n\t\n\n\n    function dispose()\n    {\n\t//\twindow.removeEventListener("resize",engine.resize);\n\t\t\n    \t\n    \tvar canvas = $canvas3D[0];\n\t\tscene.dispose();\n\t\t//delete scene;\n\n\t\tengine.stopRenderLoop();\n\t\t//engine.dispose();\n\t\t//delete engine\n\t\t//engine = undefined;\n\n\t\tcamera.dispose();\n\t\tcontrol.detachControl(canvas);\n\n\t\tclearInterval(saveRender_id);\n\n    }\n\n\n \n\t/////////////////////////////////////////////////////////////////////////////////////////\n\t////////////////////////////////////////// all creates\n\t/////////////////////////////////////////////////////////////////////////////////////////\n\n    function createPlaneController(off,sz,parent)\n    {\n      var radius = 5;\n\t  for (var j = 0; j < 4;j++)\n\t  {\n\t\t  var controller = BABYLON.Mesh.CreateSphere("planecontroller", radius*2, 10, scene);\n\t      controller.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t  controller.material.specularColor  = new BABYLON.Color3(0,0,0);\n\t\t  controller.material.diffuseColor  = new BABYLON.Color3(0,0,0);\n\t\t  //controller.material.specularPower =0;\n\t\t  function clear(_this)\n\t\t  {\n\t\t\t\tif (_this.delay_id != undefined) {\n\t\t\t\t\tclearInterval(_this.delay_id)\n\t\t\t\t\tdelete _this.delay_id;\n\t\t\t\t}\n\t\t  }\n\t\t  controller.onmousedown = function(evt,pickResult,inputcontrol)\n\t\t  {\n\t\t\t\tvar _this = this;\n\t\t\t\tthis.delay_id = setInterval( function()\n\t\t\t\t{\n\t\t\t\t   var contextMenu = KContextMenu(\n\t\t\t\t\t\t\t  function() {\n\t\t\t\t\t\t\t  \tinputcontrol.draggedPlane = undefined;\n\t\t\t\t\t\t\t  \tvar $menu =  $("<ul class=\'menu_context\'>");\n\t\t\t\t\t\t\t  \tif (_this.parent.visibility)\n\t\t\t\t\t\t\t  \t\t$menu.append($("<li onchoice=\'hide\' > hide  </li>"));\n\t\t\t\t\t\t\t  \telse\n\t\t\t\t\t\t\t  \t\t$menu.append($("<li onchoice=\'show\' > show  </li>"));\n\t\t\t\t\t\t\t\treturn  $menu;\n\t\t\t\t\t\t\t  },\n\t\t\t\t\t\t\t  function(str,ev)\n\t\t\t\t\t\t\t  { if (str == "hide")\n\t\t\t\t\t\t\t    {\n\t\t\t\t\t\t\t  \t   _this.parent.visibility = false;\n\t\t\t\t\t\t\t  \t   _this.parent.isPickable = false;\n\t\t\t\t\t\t\t    }\n\t\t\t\t\t\t\t  \telse\n\t\t\t\t\t\t\t  \t{\n\t\t\t\t\t\t\t  \t   _this.parent.visibility = true;\n\t\t\t\t\t\t\t  \t   _this.parent.isPickable = true;\n\t\t\t\t\t\t\t  \t}\n\t\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t  } ,true);\n\t\t\t\t\tcontextMenu(evt);\n\n\n\t\t\t\t\tclear(_this);\n\n\t\t\t\t},500);\n\n\t\t  }\n\t\t  controller.onmousemove = function(evt)  { clear(this); }\n\t\t  controller.onmouseup = function(evt)  { clear(this); }\n\n\t\t  controller.onHoverEnter = function() {\n\t\t\t\tthis.material.diffuseColor  = new BABYLON.Color3(0.5,0.5,0.5);\n\t\t\t\tactivateRenderLoop();\n\t\t\t}\n\t\t  controller.onHoverLeave = function() {\n\t\t\t\tthis.material.diffuseColor  = new BABYLON.Color3(0,0,0);\n\t\t\t\tactivateRenderLoop();\n\t\t\t}\t\t\t      \n\t\t  controller.parent = parent;\n\t\t  controller.position[off[0]] = (sz[0]/2-radius)  * Math.sign((j%2)-0.5);\n\t\t  controller.position[off[1]] = (sz[1]/2-radius)  * Math.sign((Math.round(j/2-0.5)%2)-0.5);\n\t  }\n    }\n\n\n\n\tKViewer.getPlanes = function()\n\t{\n\t\treturn planes;\n\t}\n\tKViewer.getGP = function()\n\t{\n\t\treturn grandParent;\n\t}\n\n    function createPlanes()\n    {\n    \tvar nii = viewer.nii;\n\t\n//\t\tif (viewer.niiOriginal)\n//\t\t\tnii = viewer.niiOriginal;\n\n    \tif (nii)\n    \t{\n\t\t\tvar i= [[0,1,2]]; \n\t\t\ti[nii.permutationOrder[0]] = 0;  i[nii.permutationOrder[1]] = 1; i[nii.permutationOrder[2]] = 2;\n\t\t\t//i = nii.permutationOrder;\n\t\t\tpsz[0] = [ math.round(nii.sizes[i[1]]*nii.voxSize[i[1]]), math.round(nii.sizes[i[2]]*nii.voxSize[i[2]]) ];\n\t\t\tpsz[1] = [ math.round(nii.sizes[i[0]]*nii.voxSize[i[0]]), math.round(nii.sizes[i[2]]*nii.voxSize[i[2]]) ];\n\t\t\tpsz[2] = [ math.round(nii.sizes[i[0]]*nii.voxSize[i[0]]), math.round(nii.sizes[i[1]]*nii.voxSize[i[1]]) ];\n\n\n\t\t\tif (posIndicator != undefined)\n\t\t\t\tposIndicator.dispose();\n\n\t\t\tposIndicator = BABYLON.Mesh.CreateSphere("posIndicator", 50, viewer.computeMaxExtentFac()*0.01, scene);\n\t\t\tposIndicator.parent = grandParent;\n\t\t\tposIndicator.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\tposIndicator.material.alphaMode = BABYLON.Engine.ALPHA_SUBTRACT;\n\t\t\tposIndicator.material.alpha = 0.1;\t\n\t\t\tposIndicator.material.diffuseColor = new BABYLON.Color3(0.1,0.1,0.1);\n\n\n\n\t\t\tcontrol_offs = [[\'x\',\'y\'],[\'z\',\'y\'],[\'z\',\'x\']];\n\n\t\t\tfor (var k=0;k < 3;k++)\n\t\t\t{\n\t\t\t  planes[k] = BABYLON.Mesh.CreateGround("ground"+k, psz[k][0],psz[k][1],1,scene);\n\t\t\t//  planes[k].parent = grandParent;\n\n\t\t\t//  createPlaneController(control_offs[k],psz[k],planes[k]);\n\n\t\t\t  textures[k] = new BABYLON.DynamicTexture("dynamic texture", texSize, scene, true);\n\t\t\t  materials[k] = new BABYLON.StandardMaterial(\'mat\', scene);\n\t\t\t  materials[k].specularColor = new BABYLON.Color3(0, 0, 0);\n\t\t\t  materials[k].backFaceCulling = false;\n\t\t\t  materials[k].diffuseTexture = textures[k];\n\t\t\t  materials[k].diffuseTexture.hasAlpha = true;\n\t\t\t  planes[k].material = materials[k];\n\t\t\t  ctxs[k] = textures[k].getContext();\n\t\t\t}\n\n\t\t\tplanes[0].rotation.x = -Math.PI / 2;\n\t\t\tplanes[0].rotation.y = -Math.PI ;\n\t\t\tplanes[1].rotation.x = -Math.PI / 2 ;\n\t\t\tplanes[1].rotation.y = Math.PI / 2 ; \t       \n\t\t\tplanes[2].rotation.y = -Math.PI / 2 ;\n\t\t\tplanes[2].rotation.x = -Math.PI ;\n\t\t\tplanes[2].rotation.z = -Math.PI ;\n\t\t\tplanes[0].bakeCurrentTransformIntoVertices()\n\t\t\tplanes[1].bakeCurrentTransformIntoVertices()\n\t\t\tplanes[2].bakeCurrentTransformIntoVertices()\n\n\t\n\n\n\n\n\n\n\n\n\nif (0)\n{\n\t\t// saggital\n\t\t\tfor (var j=0;j < vol_planes.length;j++)\n\t\t\t{\n\t\t\t\tif (vol_planes[j] != undefined)\n\t\t\t\t\tvol_planes[j].dispose();\n\t\t\t}\n\t\t\t\n\t\tfor (var k = 0; k < 3 ; k++)\n\t\t{\n\t\t  //  var k = 0;\n\t\t\tvar sz = nii.sizes[i[k]];\n\t\t\tvar szmm = sz*nii.voxSize[i[k]];\n\t\t\tvar numPl = 25;\n\t\t\tfor (var m=0;m < numPl;m++)\n\t\t\t{\n\t\t\t  var j = k*numPl+m;\n\n\t\t\t  vol_planes[j] = BABYLON.Mesh.CreateGround("volground"+j, psz[k][0],psz[k][1],1,scene);\n\t\t\t  vol_planes[j].isPickable = false;\n\t\t\t  vol_textures[j] = new BABYLON.DynamicTexture("dynamic texture", texSize, scene, true);\n\t\t\t  vol_textures[j].getAlphaFromRGB = true;\n\t\t\t  vol_materials[j] = new BABYLON.StandardMaterial(\'mat\', scene);\n\t\t\t  vol_planes[j].material = vol_materials[j];\n\t\t\t  vol_materials[j].specularColor = new BABYLON.Color3(0, 0, 0);\n\t\t\t  vol_materials[j].diffuseTexture = vol_textures[j];\n\t\t\t  vol_materials[j].diffuseTexture.hasAlpha = true;\n\t\t\t  vol_materials[j].backFaceCulling = false;\n\t\t\t  vol_materials[j].useAlphaFromDiffuseTexture = true\n\t\t\t  vol_ctxs[j] = vol_textures[j].getContext();\n\t\n\t          vol_planes[j].hasVertexAlpha = true;\n\t\t\t  \n\t\t  \t  vol_planes[j].arr_slicepos = m/numPl*sz;\n\t\t  \t  vol_planes[j].sliceing = k;\n\t\t\t  var slpos = szmm*m/numPl - szmm/2;\n\t\t\t  if (k == 0)\n\t\t\t  {\n\t\t\t\t  vol_planes[j].rotation.x = -Math.PI / 2;\n\t\t\t\t  vol_planes[j].rotation.y = -Math.PI ;\n\t\t\t\t  vol_planes[j].position.z = slpos;\n\t\t\t  }\n\t\t\t  else if (k == 1)\n\t\t\t  {\n\t\t\t\t  vol_planes[j].rotation.x = -Math.PI / 2 ;\n\t\t\t      vol_planes[j].rotation.y = Math.PI / 2 ; \t       \n\t\t\t\t  vol_planes[j].position.x = slpos;\n\t\t\t  } else\n\t\t\t  { \n  \t\t\t\t  vol_planes[j].rotation.y = -Math.PI / 2 ;\n\t\t\t\t  vol_planes[j].rotation.x = -Math.PI ;\n\t\t\t\t  vol_planes[j].rotation.z = -Math.PI ;\n\t\t\t\t  vol_planes[j].position.y = slpos;\n\t\t\t  }\n\n\n\t\t\t}\n\n\t\t}\n\n\n}\n\n\n\n\n\n\n    \t}\n\t\t\t\n    }\n\n\n\n    function setSurfColor(obj)\n    {\n\t\tif (obj.gl == undefined)\n\t\t\treturn;\n\n\t\tif (obj.color.length == 3)\n\t\t\tvar col = [obj.color[0],obj.color[1],obj.color[2]];\n\t\telse\n\t\t{\n\t\t\tvar col = obj.colors[obj.color];\n\t\t\tcol = [col[0],col[1],col[2]];\n\t\t}\n\n\t\tvar of = 100;\n\t\tfor (var k = 0; k < 3;k++)\n\t\t\t{ col[k] += of; col[k] /= (255+of); }\n\n\t\tif (obj.shader != undefined)\n\t\t{\n\t\t\tobj.shader.setVector3("uniformcolor",new BABYLON.Vector3(col[0],col[1],col[2]));\n\t\t\tobj.shader.setFloat("alpha",parseFloat(obj.alpha));\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\tobj.gl.material.specularColor  = new BABYLON.Color3(col[0]*0.6,col[1]*0.6,col[2]*0.6);\n\t\t\t//obj.gl.material.emissiveColor  = new BABYLON.Color3(col[0]*0.4,col[1]*0.4,col[2]*0.4);\n\t\t\tobj.gl.material.diffuseColor  = new BABYLON.Color3(col[0]*0.4,col[1]*0.4,col[2]*0.4);\n\t\t\tobj.gl.material.ambientColor  = new BABYLON.Color3(col[0]*0.4,col[1]*0.4,col[2]*0.4);\n\t\t\tobj.alpha = parseFloat(obj.alpha);\n\t\t\tobj.gl.material.alpha = obj.alpha;\t\n\t\t\tobj.gl.material.backFaceCulling = false;\n\t\t\t//if (obj.alpha != 1)\n\t\t\t//\tobj.gl.material.backFaceCulling = obj.alpha != 1;\n\t\t}\n\t\tactivateRenderLoop()\n    }\n\n\n\n\tfunction createContour(obj,col)\n\t{\n\t\tif (obj.gl != undefined && obj.gl.dispose)\n\t\t\tobj.gl.dispose();\n\t\tobj.gl = [];\n\t\tobj.gl.dispose = function() { for (var k = 0 ; k < obj.gl.length;k++) \n\t\t\t\t\t\t\t\t\t\t\tobj.gl[k].dispose(); }\n\n        if (obj.fiberDirColor_shader == undefined)\n            obj.createShader()\n\n\n\t\tvar x = obj.contour.content.Contours[obj.select].ContourSequence.node;\n\n\t\tvar d = [];\n\t\tfor (var k = 0; k < x.length;k++)\n\t\t\td.push(new Float32Array(x[k].ContourData));\n\n\t\tvar rp = randperm(x.length);\n\t\tvar chunkSize = 16;\n\t\tvar cid = setInterval(function()\n\t\t{\n\t\t\tif (rp.length == 0 | obj.gl == undefined)\n\t\t\t{\n\t\t\t\tclearInterval(cid);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tobj.gl.push(createFiberBundle(d,rp.splice(0,chunkSize),\'wholebrain\',col,obj.fiberDirColor_shader,obj.contour.content,1))\n\t\t},25);\n\n\n//\t\tobj.gl = createFiberBundle(d,subset,\'wholebrain\',col,obj.fiberDirColor_shader,obj.contour.content)\n\n\t}\n\n\tfunction createConmat(obj)\n\t{\n\t\tif (obj.gl != undefined)\n\t\t{\n\t\t\tif (typeof obj.gl == \'object\')\n\t\t\t\tobj.gl.dispose();\n\t\t\tobj.gl = undefined;\n\t\t}\n\n\n\n\t\tobj.gl = BABYLON.Mesh.CreateSphere("sphere1", 10, 0, scene);\n\t\tvar centroids = obj.cmat.content.centroids;\n\t\tvar clim = obj.histoManager.clim;\n\t\tvar ac = obj.cmat.content.cc;\n\n\t\tfunction map(v,cmap,thres)\n\t\t{\n\t\t\tv = (v-clim[0])/(clim[1]-clim[0]);\n\t\t\tif (v<0) v = 0;\n\t\t\tif (v>1) v = 1;\n\t\t\treturn  colormap.mapVal(v,cmap);   \n\t\t}\n\n\t\tfunction mapRad(v,offset,thres)\n\t\t{\n\t\t\tv = (v-clim[0])/(clim[1]-clim[0]);\t\t\t\n\t\t\tif (v<0) v = 0;\n\t\t\tif (v>1) v = 1;\n\t\t\treturn  v*3+offset;\n\n\t\t\t\n\t\t}\n\n\n\n\n\t\tvar node_thres = 0;\n\t\tvar node_cmap = 2;\n\t\tvar conn_thres = 0;\n\t\tvar conn_cmap = 2;\n\n\t\tvar papa = BABYLON.Mesh.CreateSphere("sphere1", 10, 1, scene);\n\t\tpapa.parent = grandParent;\n\n\t\tvar myPath = [new BABYLON.Vector3(1,0,0),new BABYLON.Vector3(-1,0,0)];\n\t//\tvar tube_papa = BABYLON.MeshBuilder.CreateTube("tube", {path: myPath,radius:1}, scene);\n\n\t\tvar single = false;\n\t\tif (ac.length == 1)\n\t\t\tsingle = true;\n\n\t\tfor (var k = 0;k < centroids.length;k++)\n\t\t{\n\n\t\t\tvar val;\n\t\t\tif (!single)\n\t\t\t\tval = ac[k][k];\n\t\t\telse\n\t\t\t\tval = ac[0][k];\n\n\t\t\tvar offset = 0.5;\n\t\t\tvar radius = mapRad(val,offset,node_thres);\n\t\t\tif (radius > offset)\n\t\t\t{\n\t\t\t\tvar col = map(val,node_cmap,node_thres);\n\n\t\t\t\tvar c = world2GL([centroids[k][0],centroids[k][1],centroids[k][2],1]);\n\n\t\t\t\tvar a = papa.clone();\n\t\t\t\ta.hoverColor  = new BABYLON.Color3(1,1,1);\n\t\t\t\ta.color = new BABYLON.Color3(col[0]/255, col[1]/255, col[2]/255);\n\t\t\t\ta.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\t\ta.material.diffuseColor  = a.color;\n\t\t\t\ta.material.alpha = 0.6;\n\t\t\t\ta.name = obj.cmat.content.cc_labels[k];\n\n\t\t\t\ta.position.x = c[0];\n\t\t\t\ta.position.y = c[1];\n\t\t\t\ta.position.z = c[2];\n\t\t\t\ta.position = flip(a.position);\n\n\t\t\t\ta.scaling = {x:radius,y:radius,z:radius};\t\n\t\t\t\ta.parent = obj.gl;\n\t\t\t\ta.renderOutline = true;\n\n\t\t\t\ta.onHoverEnter = function(evt) {\n\t\t\t\t\tthis.material.diffuseColor = a.hoverColor;\n\t\t\t\t\tvar $anno = $("<div id=\'Kcmat_annotation\'>" + this.name + "</div>").appendTo($(document.body));\n\t\t\t\t\t$anno.css("top",evt.clientY);\n\t\t\t\t\t$anno.css("left",evt.clientX+10);\n\t\t\t\t    viewer.gl.activateRenderLoop();\n\t\t\t\t\t\n\n\t\t\t\t}\n\t\t\t\ta.onHoverLeave = function(evt) {\n\t\t\t\t\tthis.material.diffuseColor = this.color;\n\t\t\t\t\t$("#Kcmat_annotation").remove();\n\t\t\t\t}\n\t\t\t}\n\n\n\t\tif (!single | k==0 )\n\t\t\tfor (var j = k+1; j < centroids.length;j++)\n\t\t\t{\n\t\t\t\tvar n = (ac[k][j]-clim[0])/(clim[1]-clim[0]);\n\t\t\t\tif (n > conn_thres)\n\t\t\t\t{\n\n\t\t\t\t\tvar col = map(ac[k][j],conn_cmap,conn_thres);    \n\t\t\t\t\tvar rad = mapRad(ac[k][j],1,conn_thres)/2;    \n\t\t\t\t\tvar c1 = world2GL([centroids[k][0],centroids[k][1],centroids[k][2],1]);\n\t\t\t\t\tvar c2 = world2GL([centroids[j][0],centroids[j][1],centroids[j][2],1]);\n\t/*\n\t\t\t\t\tvar tube = tube_papa.clone();\n\t\t\t\t\ttube.parent = obj.gl;\n\t\t\t\t\ttube.name = obj.cmat.content.cc_labels[k] + "<br>" + obj.cmat.content.cc_labels[j];\n\t\t\t\t\ttube.color  = new BABYLON.Color3(col[0]/255, col[1]/255, col[2]/255);\n\t\t\t\t\ttube.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\t\t\ttube.material.diffuseColor  = tube.color;\n\t\t\t\t\n\t\t\t\t\ttube.position.x = (c1[0]+c2[0])*0.5;\n\t\t\t\t\ttube.position.y = (c1[1]+c2[1])*0.5;\n\t\t\t\t\ttube.position.z = (c1[2]+c2[2])*0.5;\n\t\t\t\t\ttube.scaling.x = radius;\n*/\n\n\t\t\t\t\tvar myPath = [flip(new BABYLON.Vector3(c1[0],c1[1],c1[2])),flip(new BABYLON.Vector3(c2[0],c2[1],c2[2]))];\n\t\t\t\t\tvar tube = BABYLON.MeshBuilder.CreateTube("tube", {path: myPath,radius:rad,tessellation:6}, scene);\n\t\t\t\t\ttube.parent = obj.gl;\n\t\t\t\t\ttube.name = obj.cmat.content.cc_labels[k] + "<br>" + obj.cmat.content.cc_labels[j];\n\t\t\t\t\ttube.color  = new BABYLON.Color3(col[0]/255, col[1]/255, col[2]/255);\n\t\t\t\t\ttube.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\t\t\ttube.material.diffuseColor  = tube.color;\n\t\t\t\t\ttube.material.alpha=0.6;\n\t\t\t\t\t\n\n\t\t\t\t\ttube.onHoverEnter = function(xx) { return function(evt) {\n\t\t\t\t\t\t\n\t\t\t\t\t\tthis.material.diffuseColor = a.hoverColor;\n\t\t\t\t\t\tvar $anno = $("<div id=\'Kcmat_annotation\'>" + this.name + "<br>" + xx + "</div>").appendTo($(document.body));\n\t\t\t\t\t\t$anno.css("top",evt.clientY);\n\t\t\t\t\t\t$anno.css("left",evt.clientX+10);\n\n\t\t\t\t\t} }(ac[k][j]);\n\t\t\t\t\ttube.onHoverLeave = function(evt) {\n\t\t\t\t\t\tthis.material.diffuseColor = this.color;\n\t\t\t\t\t\t$("#Kcmat_annotation").remove();\n\t\t\t\t\t}\n\n\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\n\n\n\n\n\n\n\n\t\t\n\n\t}\n\n\n\n\tfunction createSurf(obj,pos,trigs,normals,vals,cut)\n\t{\n\t\tif (pos == undefined)\n\t\t\treturn;\n\n\t\tif ((obj.overlays != undefined && obj.overlays.length>0) | vals != undefined )\n\t\t{\n\t\t\tif (obj.colors_mapped == undefined || obj.colors_mapped.length != pos.length/3*4)\n\t\t\t\tobj.colors_mapped = new Float32Array(pos.length/3*4);\n\t\t\tif (obj.overlays.length > 0)\n\t\t\t{\n\n\t\t\t\tvar colors = obj.colors_mapped;\n\t\t\t\tvar points = obj.surf.content.points;\n\n\t\t\t\tfor (var j = 0; j < points.length/3;j++)\n\t\t\t\t{\n\t\t\t\t\tcolors[4*j] =0; colors[4*j+1] =0; colors[4*j+2] =0; colors[4*j+3] =0; \n\t\t\t\t}\n\t\t\t\tfor (var k = 0; k < obj.overlays.length;k++)\n\t\t\t\t{\n\t\t\t\t\tif (obj.overlays[k].atlas)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar atl = obj.overlays[k].atlas\n\t\t\t\t\t\tvar labels;\n\t\t\t\t\t\tif (atl.panel) \n\t\t\t\t\t\t\tlabels = atl.panel.persistentLabels;\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tlabels = atl.content.labels;\n\n\n\t    \t\t\t    var getPixel = KAtlasTool.updateGetPixelFun(atl.content,undefined,labels,undefined,undefined,true);\n\n\n\t\t\t\t\t\tacc = function(k,v) {colors[4*k] += v[0]/255; colors[4*k+1] += v[1]/255; colors[4*k+2] += v[2]/255;}\n\t\t\t\t\t\tfor (var j = 0; j < points.length/3;j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t var val = getPixel(points[3*j],points[3*j+1],points[3*j+2]);\n\t\t\t\t\t\t\t acc(j,val);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (!obj.overlays[k].visible)\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\tvar ovl = obj.overlays[k];\t\t\t\t\n\t\t\t\t\t\tvar totsize = ovl.nii.sizes[0] * ovl.nii.sizes[1] * ovl.nii.sizes[2];\n\t\t\t\t\t\tvar offs = ovl.nii.currentTimePoint.t * totsize;\n\t\t\t\t\t\tvar A = math.inv(ovl.nii.edges)._data;\n\t\t\t\t\t\t/*if (k==0)\n\t\t\t\t\t\t\tacc = function(k,v) {\n\t\t\t\t\t\t\t\tvar cv = 0.9-(v[0]+v[1]+v[2])/255/3;\n\n\t\t\t\t\t\t\t\tcolors[4*k] = (cv) + v[0]/255; colors[4*k+1] = (cv) + (v[1]/255); colors[4*k+2] = (cv) + v[2]/255;}\n\t\t\t\t\t\telse*/\n\n\t\t\t\t\t\tvar acc = function(k,v) {colors[4*k] += v[0]/255; colors[4*k+1] += v[1]/255; colors[4*k+2] += v[2]/255; colors[4*k+3] += v[3]/255;}\n\t\t\t\t\t\tvar acc2 = function(k,v) {colors[4*k] += v[0]/255; colors[4*k+1] += v[1]/255; colors[4*k+2] += v[2]/255; colors[4*k+3] += v[3]/255;\n\t\t\t\t\t\t    var sum = colors[4*k]+colors[4*k+1]+colors[4*k+2];\n\t\t\t\t\t\t\tcolors[4*k] /= sum; colors[4*k+1] /= sum; colors[4*k+2] /= sum; colors[4*k+3] /= sum;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar colVol = ovl.nii.sizes[3]==3;\n\n\t\t\t\t\t\tif (!colVol)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (var j = 0; j < points.length/3;j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t var val = trilinInterp(ovl.nii, points[3*j],points[3*j+1],points[3*j+2], A, offs);\n\t\t\t\t\t\t\t\t if (val != undefined && !isNaN(val))\n\t\t\t\t\t\t\t\t {\t\t\t\t\t\t\t \t\n\t\t\t\t\t\t\t\t\t\tif (ovl.histoManager.posnegsym)\n\t\t\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\t\t\tif (val > 0)\t\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar oVal = ovl.histoManager.mapVal(val);\n\t\t\t\t\t\t\t\t\t\t\t\tif (oVal > 0) \n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\toVal = oVal/2+0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar v = colormap.mapVal(oVal, ovl.histoManager.cmapindex);\n\t\t\t\t\t\t\t\t\t\t\t\t\tacc(j,v);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar oVal = ovl.histoManager.mapVal(-val);\n\t\t\t\t\t\t\t\t\t\t\t\tif (oVal > 0)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\toVal = (1-oVal)*0.5;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (oVal < 0.01) oVal = 0.01;\n\t\t\t\t\t\t\t\t\t\t\t\t\tvar v = colormap.mapVal(oVal, ovl.histoManager.cmapindex);\n\t\t\t\t\t\t\t\t\t\t\t\t\tacc2(j,v);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t var oVal = ovl.histoManager.mapVal(val);\n\t\t\t\t\t\t\t\t\t\t\t var v = colormap.mapVal(oVal, ovl.histoManager.cmapindex);\n\t\t\t\t\t\t\t\t\t\t\t acc(j,v);\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tfor (var j = 0; j < points.length/3;j++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t var val = trilinInterp3_signcorrected(ovl.nii, points[3*j],points[3*j+1],points[3*j+2], A,totsize); \n\t\t\t\t\t\t\t\t val = ovl.histoManager.mapVal(val);\n\t\t\t\t\t\t\t\t if (val != undefined && !isNaN(val[0]))\n\t\t\t\t\t\t\t\t {\t\t\t\t\t\t\t \t\n \t\t\t\t\t\t\t\t\tacc(j,val);\n\n\n\t\t\t\t\t\t\t\t }\n\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tvar bgnd = 1;\n\t\t\t\tvar bgndcol = obj.colors[obj.color];\n\t\t\t\t\t\t\t\t\n\n\t\t\t\tfor (var j = 0; j < points.length/3;j++)\n\t\t\t\t{\n\t\t\t\t\t// var sum = (colors[4*j]+colors[4*j+1]+colors[4*j+2])/3 ;\n\t\t\t\t\t var max = math.max([colors[4*j],colors[4*j+1],colors[4*j+2]]);\n\t\t\t\t\t var f1 = 2+obj.exposure;\n\t\t\t\t\t var f2 = (1-max)/255;\n\t\t\t\t\t colors[4*j] = f1*colors[4*j] + bgndcol[0]*f2;\t\t\t\t\t\t \n\t\t\t\t\t colors[4*j+1] = f1*colors[4*j+1] + bgndcol[1]*f2;\t\t\t\t\t\t \n\t\t\t\t\t colors[4*j+2] = f1*colors[4*j+2] + bgndcol[2]*f2;\t\t\t\t\t\t \n\t\t\t\t\t \n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\telse if (vals != undefined)\n\t\t\t{\n\t\t\t\tvar colors = obj.colors_mapped;\n\t\t\t\tvar clim = obj.histoManager.clim;\n\t\t\t\tfor (var j = 0; j < vals.length;j++)\n\t\t\t\t{\n\t\t\t\t\tvar v = colormap.mapVal((vals[j]-clim[0])/(clim[1]-clim[0]), obj.histoManager.cmapindex);\n\t\t\t\t\tfor (var k = 0; k < 3; k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar i = 3*j+k;\n\t\t\t\t\t\tcolors[4*i] =v[0]/255; colors[4*i+1] =v[1]/255; colors[4*i+2] =v[2]/255;colors[4*i+3] =v[3]/255; \n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tvar dynMesh = new BABYLON.Mesh("dynMesh", scene);\n\t\n        var vertexData = new BABYLON.VertexData();\n        vertexData.positions = pos;\n        vertexData.indices = trigs;\n        vertexData.normals = normals;\n        vertexData.colors = obj.colors_mapped;\n        vertexData.applyToMesh(dynMesh, 1);\n\n\t\tif (0) //cut == 0 | cut == undefined)\n\t\t{\n\t\t\tobj.shader = undefined;\n\t\t\tdynMesh.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\tdynMesh.material.specularPower = 0;\n\t\t\tdynMesh.material.backFaceCulling = false;\n\t\t\tdynMesh.material.alphaMode =obj.alphaMode;\n\t\t\n\t\t//\tdynMesh.showBoundingBox = true;\n\t\t//dynMesh.renderOutline =true\n\t\t//\tconsole.log(obj.alphaMode);\n\n\t\t\tdynMesh.setPivotMatrix(world2GL_BJS_matrix(),oldBablyonFlag);\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (obj.shader != undefined)\n\t\t    \tdetachShader(obj.shader);\n\n\t\t\tvar shader = createCutSurfShader(obj);\n\n\t\t\tshader.updateTilts = function()\n\t\t\t{\n\t\t\t\tvar x = math.diag([1,1,1,1]);\n\t\t\t\tif (KViewer.mainViewport != -1)\n\t\t\t\t\tx = ((viewer.getReorientMat(undefined,viewer.getWorldPosition())));\n\t\t\t\tvar M = world2GL_BJS_matrix_M(x);\n\t\t\t\tshader.setMatrix("worldToVoxel",M);\n\t\t\t}\n\t\t\tshader.updateTilts();\n\t\t\tdynMesh.setPivotMatrix( world2GL_BJS_matrix(),oldBablyonFlag);\n\t\t\tdynMesh.material = shader;\n\n\n\t\t\tobj.shader = shader;\n\n\t\t\tvar pp = world2GL(viewer.getWorldPosition());\n\t\t\tvar planesPos = new BABYLON.Vector3(pp[0],pp[1],pp[2]);\n\t\t\tshader.setVector3("planesPos",planesPos);\n\n\t\t\tif (obj.overlays.length > 0 | vals != undefined )\n\t\t\t\tshader.setFloat(\'vertexcoloring\',1)\n\t\t\telse\n\t\t\t\tshader.setFloat(\'vertexcoloring\',0)\n\n\t\t\tshader.setFloat(\'gamma\',obj.gamma)\n\n\t\t}\n\n\t\tdynMesh.isPickable = obj.pickable;\n\t\tif (pos.length > 256000) \n\t\t{\n\t\t\tdynMesh.isPickable = false;\n\t\t\tdynMesh.largeMesh = true;\n\t\t}\n/*\n\t\tdynMesh.onHoverEnter = function(evt) {\n\t\t\tif (obj.$captiondiv == undefined)\n\t\t\t\treturn\n\t\t\tobj.$captiondiv.addClass("highlight");\n\t\t\tif (obj.refRoiView && obj.refRoiView.$captiondiv) \n\t\t\t\tobj.refRoiView.$captiondiv.addClass("highlight");\n\t\t}\n\t\tdynMesh.onHoverLeave = function(evt) {\n\t\t\tif (obj.$captiondiv == undefined)\n\t\t\t\treturn\n\t\t\tobj.$captiondiv.removeClass("highlight");\n\t\t\tif (obj.refRoiView && obj.refRoiView.$captiondiv) \n\t\t\t\tobj.refRoiView.$captiondiv.removeClass("highlight");\n\t\t}\n*/\n\n\n\t\tobj.gl = dynMesh;\n\n\t\tsetSurfColor(obj);\n\t    dynMesh.parent = grandParent;\n\t\tdynMesh.contextmenu = obj.contextmenu3D;\n\n\n\t}\n\n\n\tfunction createFreeSurf(that)\n\t{\n\n\t    var obj = {color:[255,0,0],alpha:1,cuts:[0,0,0],overlays:[]};\n\n\t\tvar papa = BABYLON.Mesh.CreateSphere("sphere1", 50, 0, scene);\n\t\tpapa.visibility = 0;\n\t\tpapa.parent = grandParent;\n\n\t\tcreateSurf(obj,that.points,that.indices,that.normals,undefined,0);\n\t\tif (obj.gl)\n\t\t{\n\t\t\tobj.gl.parent = papa; \n\t\t\t//obj.gl.enableEdgesRendering(.9999999999);\t\n\t\t\t//obj.gl.edgesWidth = 100.0;\n\t\t\tobj.gl.material.alpha =1\n\t\t\tobj.gl.edgesColor = new BABYLON.Color3(1,1,0.3);\n\t\t\t//obj.gl.alphaIndex = 1000;\n\t\t\tobj.gl.material.alphaMode = 3;\n\t\t\tobj.gl.material.alpha = 1;\n\n\t\t\tvar outline = createTrace(that,{width:1,closed:true});\n\t\t\tif (outline != undefined)\n\t\t\t\toutline.parent = papa;\n\n\t\t\tobj.gl = papa;\n\n\n\n\t\t\treturn obj.gl;\n\t\t}\n\t}\n\n\n\n\tfunction createSurface(obj)\n\t{\n\n\t\tif (obj.gl != undefined)\n\t\t{\n\t\t\tif (obj.gl.dispose)\n\t\t\t\tobj.gl.dispose();\n\t\t\tobj.gl = undefined;\n\t\t}\n\t\n\t\tif (!obj.visible)\n\t\t\treturn;\n\n\t\tvar gii = obj.surf.content;\n\n\t\tif (obj.visible == undefined || (obj.visible != undefined && obj.visible == true))\n\t\t\tcreateSurf(obj,gii.points,gii.indices,gii.normals,gii.vals,obj.cut)\n\n\t}\n\n\n\n\n/*\n\n\tfunction createSurface(obj)\n\t{\n\n\t\tif (obj.gl != undefined)\n\t\t{\n\t\t\tobj.gl.dispose();\n\t\t\tobj.gl = undefined;\n\t\t}\n\t\n\t\tif (!obj.visible)\n\t\t\treturn;\n\n\t\tvar gii = obj.surf.content;\n\n\t\tvar dynMesh = new BABYLON.Mesh("dynMesh", scene);\n\t\n\t\tif (obj.cut == 0)\n\t\t{\n\n\t\t\tdynMesh.material = new BABYLON.StandardMaterial("texture1", scene);\n\t//\t\tdynMesh.material.diffuseColor  = new BABYLON.Color3(col[0]*0.1,col[1]*0.1,col[2]*0.1);\n\t//\t\tdynMesh.material.specularColor  = new BABYLON.Color3(col[0]*0.4,col[1]*0.4,col[2]*0.4);\n\t\t\tdynMesh.material.specularPower = 2;\n\t\t\tdynMesh.material.backFaceCulling = false;\n\n\t\t\tdynMesh.setPivotMatrix(world2GL_BJS_matrix());\n\t\t}\n\t\telse\n\t\t{\n\t\t    if (obj.shader != undefined)setSurfColor\n\t\t    \tdetachShader(obj.shader);\n\n\t\t\tvar shader = createCutSurfShader();\n\t\t\tshader.setMatrix("worldToVoxel",world2GL_BJS_matrix());\n\t\t\tshader.backFaceCulling = false;\n\t\t\tdynMesh.setPivotMatrix(world2GL_BJS_matrix());\n\t\t\tdynMesh.isPickable = false;\n\t\t\tdynMesh.material = shader;\n\n\t\t\tobj.shader = shader;\n\n\t\t\tvar pp = world2GL(viewer.getWorldPosition());\n\t\t\tvar planesPos = new BABYLON.Vector3(pp[0],pp[1],pp[2]);\n\t\t\tshader.setVector3("planesPos",planesPos);\n\n\t\t}\n\n\n\n        var vertexData = new BABYLON.VertexData();\n        vertexData.positions = gii.points;\n        vertexData.indices = gii.indices;\n        vertexData.normals = gii.normals;      \n        vertexData.applyToMesh(dynMesh, 1);\n\n\t\tobj.gl = dynMesh;\n\n\t\tsetSurfColor(obj);\n\t    dynMesh.parent = grandParent;\n \n\t\tdynMesh.contextmenu = obj.contextmenu3D;\n\n\t}\n\n\n*/\n\n\n\tfunction createFiberBundle(lines,subset,name,color,shader,obj,ras)\n\t{\n\t\t\tvar sg = 1;\n\t\t\tif (ras)\n\t\t\t\tsg = -1;\n\n\n  \t\t\tvar indices = [];\n            var positions = [];\n            var colors = [];\n            var plens = [];\n            var fibers;\n            var idx = 0;\n            var subsetlen = subset.length;\n            for (var l = 0; l < subsetlen; l++) {\n            \tif (lines[subset[l]] == undefined)\n            \t{\n            \t\tconsole.error(\'bug in fiber indexing!\');\n            \t\tbreak;\n            \t}\n              //  var points =  Array.prototype.slice.call(lines[subset[l]]);\n\t\t\t\tvar points = [];\n\t\t\t\tvar pts = lines[subset[l]];\n\t\t\t\tvar plen = pts.length/3;\n\t\t\t\tvar osamp = 1;\n\t\t\t\tvar c = 0;\n\t\t\t\tfor (var k = 0 ; k < plen;k+=osamp)\n\t\t\t\t{\n\t\t\t\t\tpoints[3*c] = sg*pts[3*k];\n\t\t\t\t\tpoints[3*c+1] = sg*pts[3*k+1];\n\t\t\t\t\tpoints[3*c+2] = pts[3*k+2];\n\t\t\t\t\tc++;\n\t\t\t\t}\n\t\t\t\tplens.push(c)\n\t\t\t\t\n                positions = positions.concat(points);\n                var plen = points.length/3;\n                var rcol = Math.random();\n\n                for (var index = 0; index < plen; index++) {\n                    if (index > 0) {\n                        indices.push(idx - 1);\n                        indices.push(idx);\n\t\t\t\t\t\tvar r = Math.abs(points[3*index] - points[3*(index-1)]);\n\t\t\t\t\t\tvar g = Math.abs(points[3*index+1]-points[3*(index-1)+1]);\n\t\t\t\t\t\tvar b = Math.abs(points[3*index+2]-points[3*(index-1)+2]);\n\t\t\t\t\t\tr*=r; g*=g; b*=b;\n\t\t\t\t\t\tvar s = r+g+b;\n\t\t\t\t\t\tcolors.push(r/s,g/s,b/s,rcol);\n                    }\n                    idx++;\n                }\n\t\t\t\tcolors.push(r/s,g/s,b/s,1);\n            }\n            var vertexData = new BABYLON.VertexData();\n            vertexData.indices = new Uint32Array(indices);\n            vertexData.positions = new Float32Array(positions);\n\t\t\tvertexData.colors = new Float32Array(colors);\n\n\t\t\tfibers = new BABYLON.LinesMesh(name, scene);\n\n\t\t\tfibers.parent = grandParent;\n\t\t\tfibers.isPickable = false;\n\n\t\t\tfibers._colorShader = shader;\n\t\t\tvar pp = world2GL(viewer.getWorldPosition());\n\t\t\tvar planesPos = new BABYLON.Vector3(pp[0],pp[1],pp[2]);\n\t\t\tshader.setMatrix("worldToVoxel",world2GL_BJS_matrix())\n\t\t\tshader.setVector3("planesPos",planesPos);\n\n\t\t//\tfibers._positionBuffer[\'colors\'] = new BABYLON.VertexBuffer(scene.getEngine(),colors,\'color\',true)\t\t\n\n\t\t\tif (color == \'dir\')\n\t\t\t\tshader.setVector4("col",new BABYLON.Vector4(0,0,0,0));\n\t\t\telse\n\t\t\t\tshader.setVector4("col",new BABYLON.Vector4(color[0]/255,color[1]/255,color[2]/255,1));\n       \n            vertexData.applyToMesh(fibers, true);\n\n\t\t\tif (obj != undefined && obj.max != undefined)\n\t\t\t{\n\t\t\t\tvar vis = [(obj.max[0]-obj.min[0])/2,(obj.max[1]-obj.min[1])/2,(obj.max[2]-obj.min[2])/2];\n\t\t\t\tfibers._boundingInfo = new BABYLON.BoundingInfo(new BABYLON.Vector3(-vis[0], -vis[1], -vis[2]), new BABYLON.Vector3(vis[0], vis[1], vis[2]));\n\t\t\t}\n\n\t\t\t//fibers.positions = positions;\n\t\t\t//fibers.plens = plens;\n\n            return fibers;\n\t}\n\n\n\n\n\nfunction doDownload(filename) {\n\nvar filename = "test";\n\tvar mesh = grandParent;\n\n    var serializedMesh = BABYLON.SceneSerializer.SerializeMesh(mesh,false,true);\n\n    var strMesh = JSON.stringify(serializedMesh);\n\n    if (filename.toLowerCase().lastIndexOf(".babylon") !== filename.length - 8 || filename.length < 9){\n        filename += ".babylon";\n    }\n\n    var blob = new Blob ( [ strMesh ], { type : "octet/stream" } );\n\n    // turn blob into an object URL; saved as a member, so can be cleaned out later\n    objectUrl = (window.webkitURL || window.URL).createObjectURL(blob);\n\n    var link = window.document.createElement(\'a\');\n    link.href = objectUrl;\n    link.download = filename;\n    var click = document.createEvent("MouseEvents");\n    click.initEvent("click", true, false);\n    link.dispatchEvent(click);          \n}\n\n\n\n\n    var annomesh_cnt = 0;\n    /*\n\tfunction createAnnotationMesh(point,col,radius,dragcontroller,hoverenter,hoverleave)\n\t{\n\t\tif (!radius)\n\t\t\tradius = viewer.computeMaxExtentFac()*0.1;\n\t\tvar c = world2GL(point.coords);\n\t\tvar a = BABYLON.Mesh.CreateSphere("marker", 50, radius, scene);\n\t\tannomesh_cnt++;\n\t\ta.hoverColor  = new BABYLON.Color3(1,1,1);\n\t\ta.parent = grandParent;\n\t\ta.point = point;\n\t\ta.color = new BABYLON.Color3(col.r/255, col.g/255, col.b/255);\n\t\ta.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\ta.material.backFaceCulling = false;\n\t\ta.material.diffuseColor  = a.color;\n\t\ta.material.alpha = 0.5;\n\t\ta.name = \'marker\';\n\t\ta.isPickable = true;\n\t\ta.setPosition = function(point)\n\t\t{\n\t\t\tif (point == undefined)\n\t\t\t\tpoint = this.point;\n \t\t    var c = world2GL(point.coords);\n\t\t\tthis.position.x = c[0];\n\t\t\tthis.position.y = c[1];\n\t\t\tthis.position.z = c[2];\t\t\t\n\t\t}\n\t\ta.dragController = dragController(viewer,a, \n\t\t\tfunction(c,ev) {  \n\t\t\t\tvar p = GL2world([c.x,c.y,c.z]);\n\t\t\t\tpoint.coords = p._data;\n\t\t\t\tif (dragcontroller != undefined)\n\t\t\t\t\tdragcontroller();\n\t\t\t    else\n\t\t\t\t\tKViewer.annotationTool.updatepoint(point);\n\t\t\t\t//a.material.alpha = 1;\n\t\t\t\t//for (var k in0.59 point.onupdate)\n\t\t\t\t//\tpoint.onupdate[k](c,ev);\n\t\t\t\t\t\t},\n\t\t\tfunction (c,ev) {\n\t\t\t\tthis.material.diffuseColor = a.hoverColor;\n\t\t\t});\n\t\ta.onHoverEnter = function() {\n\t\t\tif (hoverenter == undefined)\n\t\t\t\tKViewer.annotationTool.onHoverEnter(point.uuid);\n\t\t\telse\n\t\t\t\thoverenter(point);\n\t\t\tthis.material.diffuseColor = a.hoverColor;\n\t\t}\n\t\ta.onHoverLeave = function() {\n\t\t\tif (hoverleave == undefined)\n\t\t\t\tKViewer.annotationTool.onHoverLeave(point.uuid);\n\t\t\telse\n\t\t\t\thoverleave(point);\n\t\t\tthis.material.diffuseColor = a.color;\n\t\t}\n\t\ta.setPosition(point);\n\t\treturn a;\n\t}\n\t*/\n \n \tfunction createTrace(markerset,params)\n\t{\n\t    viewer.gl.activateRenderLoop();\n\t\tvar ps = markerset.getPoints();\n\t\tif (ps.length < 2)\n\t\t\treturn;\n\t\t\t\n\t\tfunction createPath(i,j)\n\t\t{\n\t\t\tvar c1,c2;\n\t\t\tif (markerset.resorted)\n\t\t\t{\n\t\t\t\ti = markerset.resorted[i].i;\n\t\t\t\tj = markerset.resorted[j%ps.length].i;\n\t\t\t}\n\n\n\n\n\n\t\t\tc1 = (ps[i%ps.length].p.coords);\n\t\t\tvar s1 = ps[i%ps.length].p.size;\n\t\t\tc2 = (ps[j%ps.length].p.coords);\n\t\t\tvar s2 = ps[j%ps.length].p.size;\n\t\t\tvar dd = [c1[0]-c2[0],c1[1]-c2[1],c1[2]-c2[2]];\n\t\t\tvar dnorm = Math.sqrt(dd[0]*dd[0]+dd[1]*dd[1]+dd[2]*dd[2]);\n\t\t\t\n\t\t\tc1 = [c1[0]-dd[0]*s1/dnorm,c1[1]-dd[1]*s1/dnorm,c1[2]-dd[2]*s1/dnorm,1];\n\t\t\tc2 = [c2[0]+dd[0]*s2/dnorm,c2[1]+dd[1]*s2/dnorm,c2[2]+dd[2]*s2/dnorm,1];\n/*\n\n\n\n\t\t\tc1 = (ps[i%ps.length].p.coords);\n\t\t\tc2 = (ps[j%ps.length].p.coords);\n\n*/\n\n\t\t\tc1 = world2GL(c1);\n\t\t\tc2 = world2GL(c2);\n\t\t\tc1[0] += 0.00000001; // god (or google) knows why that\n\t\t\t\n\t\t\tvar col = new BABYLON.Color3(1,0,0);\n\t\t\tif (params.color) \n\t\t\t\tcol = params.color.getBabylon();\n\n\t\t\tvar myPath = [(new BABYLON.Vector3(c1[0],c1[1],c1[2])),(new BABYLON.Vector3(c2[0],c2[1],c2[2]))];\n\t\t\t\t\t\tvar tube = BABYLON.MeshBuilder.CreateTube("tube", {path: myPath,radius:params.width,tessellation:10}, scene);\n\t\t\t\t\t\ttube.parent = grandParent\n\t\t\t\t\t\ttube.name = markerset.name;\n\t\t\t\t\t\ttube.isPickable = true;\n\t\t\t\t\t\ttube.color  = col;\n\t\t\t\t\t\ttube.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\t\t\t\ttube.material.diffuseColor  = tube.color;\n\t\t\t\t\t\ttube.material.specularPower = 5\n\t\t\t\t\t\t//tube.material.wireframe = true;\n\t\t\t\t\t\ttube.material.specularColor = new BABYLON.Color3(0.8,0.8,0.8)\n\n\t\t\t\t\t\ttube.hoverColor = new BABYLON.Color3(1,1,1);\n\t\t\t\t\t\ttube.material.backFaceCulling = false;\n\n\t\t\t\t\t\tif (markerset.type == \'freeline\' || markerset.type == \'surface\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttube.after = ps[i%ps.length];\n\t\t\t\t\t\t\ttube.onHoverEnter = function() {\n\t\t\t\t\t\t\t\tthis.material.diffuseColor = tube.hoverColor;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\ttube.onHoverLeave = function() {\n\t\t\t\t\t\t\t\tthis.material.diffuseColor = tube.color;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\treturn tube;\n\t\t}\n\n\t\tvar papa = createPath(0,1);\n\t\tfor (var k = 1; k < ps.length-1 + (params.closed?1:0);k++)\n\t\t\t{\n\t\t\t\tvar path = createPath(k,k+1);\n\t\t\t\tpath.parent = papa;\n\t\t\t}\n\n\n\t\treturn papa;\n\t}\n\n\tfunction createElectrode(markerset,params)\n\t{\n\t    viewer.gl.activateRenderLoop();\n\t\tvar ps = markerset.getPoints();\n\t\tif (ps.length < 2)\n\t\t\treturn;\n\t\tvar end = ps[0].p.coords; \n\t\tvar tip = ps[1].p.coords; \n\n\t\tvar n = [tip[0]-end[0],tip[1]-end[1],tip[2]-end[2]];\n\t\tvar norm = Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);\n\t\tn[0] /= norm; n[1] /= norm; n[2] /= norm;\n\t\t\t\n\t\tfunction createPath(i,j)\n\t\t{\n\t\t\tvar c1 = world2GL(ps[i].p.coords);\n\t\t\tvar c2 = world2GL(ps[j].p.coords);\n\t\t\tc1[0] += 0.00000001; // god (or google) knows why that\n\t\t\tvar myPath = [(new BABYLON.Vector3(c1[0],c1[1],c1[2])),(new BABYLON.Vector3(c2[0],c2[1],c2[2]))];\n\t\t\t\t\t\tvar tube = BABYLON.MeshBuilder.CreateTube("tube", {path: myPath,radius:params.width,tessellation:20}, scene);\n\t\t\t\t\t\ttube.parent = grandParent\n\t\t\t\t\t\ttube.name = markerset.name;\n\t\t\t\t\t\t//tube.isPickable = false;\n\t\t\t\t\t\ttube.color  = new BABYLON.Color3(1,0,0);\n\t\t\t\t\t\ttube.hoverColor  = new BABYLON.Color3(1,0.7,0.7);\n\t\t\t\t\t\ttube.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\t\t\t\ttube.material.diffuseColor  = tube.color;\n\t\t\t\t\t\ttube.material.backFaceCulling = false;\n\t\t\treturn tube;\n\t\t}\n\n\t\tvar papa = createPath(0,1);\n\t\n\t\t\n\t\treturn papa;\n\t}\n\n\tfunction createMarkerMesh(point)\n\t{\n\t    viewer.gl.activateRenderLoop();\n\n\t\tvar c = world2GL(point.p.coords);\n\t\tvar vx = viewer.computeMaxExtentFac()*2/300;\n\n\t\tvar a = BABYLON.Mesh.CreateSphere("marker" , 50, 1, scene);\n\n\t\tcol = {r:255, g:255, b:255};\n\t\tannomesh_cnt++;\n\t\ta.hoverColor  = new BABYLON.Color3(1,1,1);\n\t\ta.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\ta.material.backFaceCulling = false;\n\t\ta.material.alpha= 0.5;\n\t\ta.point = point;\t\n\t\ta.parent = grandParent;\n\t\ta.renderOutline = true;\n\t\tif (point.pickable != undefined)\n\t\t\ta.isPickable = point.pickable ;\n\t\telse\n\t\t\ta.isPickable = true;\n\t\ta.setpoint = function(point)\n\t\t{\n  \t        viewer.gl.activateRenderLoop();\n\t\t\t\n\t\t\ta.color  = point.p.color.getBabylon();\n\t\t\tvar alpha = point.p.color.getAlpha();\n\t\t\t//if (alpha == 0 )\n\t\t\t    alpha = 0.5\n\t\t\ta.material.alpha = alpha\n\t\t\ta.material.diffuseColor = a.color;\n\t\t\ta.scaling.x = point.p.size*2;\n\t\t\ta.scaling.y = point.p.size*2;\n\t\t\ta.scaling.z = point.p.size*2;\n \t\t    var c = world2GL(point.p.coords);\n\t\t\tthis.position.x = c[0];\n\t\t\tthis.position.y = c[1];\n\t\t\tthis.position.z = c[2];\t\t\t\n\t\t}\n\t\ta.dragController = dragController(viewer,a, \n\t\t\tfunction(c,ev) \n\t\t\t{  \n\t\t\t\t\n\t\t\t\tif (point.isElectrodeEnd && ! ev.ctrlKey)\n\t\t\t\t{\n\t\t\t\t\tif (helperMesh == undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar p = point.p.coords; //GL2world([c.x,c.y,c.z])._data;\n\t\t\t\t\t\tpoint.movepoint(p);\n\t\t\t\t\t\tvar tip = point.isElectrodeEnd.p.coords;\n\t\t\t\t\t\tvar dif = [tip[0]-p[0],tip[1]-p[1],tip[2]-p[2]];\n\t\t\t\t\t\tvar dist = Math.sqrt(dif[0]*dif[0]+dif[1]*dif[1]+dif[2]*dif[2]);\n\t\t\t\t\t\tvar tipgl = world2GL(tip);\n\t\t\t\t\t\thelperMesh =  BABYLON.Mesh.CreateSphere("marker" , 20, 1, scene);\n\t\t\t\t\t\thelperMesh.position.x = tipgl[0];\n\t\t\t\t\t\thelperMesh.position.y = tipgl[1];\n\t\t\t\t\t\thelperMesh.position.z = tipgl[2];\n\t\t\t\t\t\thelperMesh.scaling.x = dist*2;\n\t\t\t\t\t\thelperMesh.scaling.y = dist*2;\n\t\t\t\t\t\thelperMesh.scaling.z = dist*2;\n\n\t\t\t\t\t\thelperMesh.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\t\t\t\thelperMesh.material.backFaceCulling = false;\n\t\t\t\t\t\thelperMesh.material.alpha= 0.1;\n\t\t\t\t\t\thelperMesh.material.wireframe = true;\n\t\t\t\t\t\thelperMesh.color  = new BABYLON.Color3(1,1,1);\n\t\t\t\t\t\thelperMesh.parent = grandParent;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar p = GL2world([c.x,c.y,c.z]);\n\t\t\t\t\t\tpoint.movepoint(p._data);\n\t\t\t\t\t\ta.material.alpha = point.p.color.getAlpha();\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (!point.locked)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar p = GL2world([c.x,c.y,c.z]);\n\t\t\t\t\t\tpoint.movepoint(p._data);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.movepoint(point.p.coords);\n\t\t\t\t\t}\t\n\t\t\t\t}\t\t\t\t\n\n\t\t\t\t\t\t\t\n\t\t\t\t//for (var k in point.onupdate)\n\t\t\t\t//\tpoint.onupdate[k](c,ev);\n\t\t\t},\n\t\t\tfunction (c,ev) {\n\t\t\t\ta.material.diffuseColor = a.hoverColor;\n\t\t\t\tif (helperMesh)\n\t\t\t\t{\n\t\t\t\t\thelperMesh.dispose();\n\t\t\t\t\thelperMesh = undefined;\n\t\t\t\t}\n\t\t\t});\n \t\ta.onHoverEnter = function(e) {\n \t\t\tpoint.onHoverEnter(e);\n \t\t\ta.currenthoverdiv = $("<div class=\'markerhover3d\'>" + point.p.name + "</div>" ).appendTo($(document.body));\n\t\t\ta.currenthoverdiv.css(\'left\',e.clientX);\n\t\t\ta.currenthoverdiv.css(\'top\',e.clientY);\n\n\n \t\t\tthis.material.diffuseColor = a.hoverColor;\n \t\t}\n \t\ta.onHoverLeave = function(e) {\n \t\t\tpoint.onHoverLeave(e);\n \t\t\tthis.material.diffuseColor = a.color;\n \t\t\tif (a.currenthoverdiv != undefined)\n \t\t\t{\n \t\t\t\ta.currenthoverdiv.remove()\n \t\t\t\ta.currenthoverdiv = undefined;\n \t\t\t}\n \t\t}\n\t\t\n\t\ta.setpoint(point);\n\t\treturn a;\n\t}\n\n\n\t//////////////////////////////////////////////////////////////////////////////////////////////\n\t//////////////////////// coordinate transformations\n\t/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n    function tiltMat(t1,t2,slicing)\n    {\n\t\tvar six = Math.sin(t1/180*Math.PI);\n        var siy = Math.sin(t2/180*Math.PI);\n\t\tvar rvec;\n\t\tif (slicing == 0)\n\t\t  rvec = [myeps, six, siy];\n\t\telse if (slicing == 1)\n\t\t  rvec = [six,myeps, siy];\t\t  \n\t\telse if (slicing == 2)\n\t\t  rvec = [siy,six,myeps];\n        var ang = Math.asin(Math.sqrt(rvec[0]*rvec[0]+rvec[1]*rvec[1]+rvec[2]*rvec[2]));\n       \n    \treturn BABYLON.Quaternion.RotationAxis(new BABYLON.Vector3(rvec[0]/ang,rvec[1]/ang,rvec[2]/ang),ang);\n    }\n\n\tfunction world2GL_matrix()\n\t{\n\t\tvar nii;\n\t\tif (viewer.nii)\n\t\t\tnii = viewer.nii;\n\t\t//if (viewer.niiOriginal)\n\t\t//\tnii = viewer.niiOriginal;\n\n\n\n\t\tif (nii != undefined)\n\t\t{\n\t\t\tvar i= [[0,1,2]]; i[nii.permutationOrder[0]] = 0;  i[nii.permutationOrder[1]] = 1; i[nii.permutationOrder[2]] = 2;\n\t\t\tvar m = [\n\t\t\t    nii.sizes[i[0]]* nii.voxSize[i[0]]/2,\n\t\t\t    nii.sizes[i[1]]* nii.voxSize[i[1]]/2,\n\t\t\t    nii.sizes[i[2]]* nii.voxSize[i[2]]/2 ];\n\t\t\tvar ee =  nii.edges;\n\t\t\tif (KViewer.mainViewport !== -1)\n\t\t\t\t ee = math.multiply(KViewer.reorientationMatrix.matrix, ee);\n\n\t\t\tvar q = math.matrix(math.diag([0,0,0,1]))._data;\n\t\t\tfor (var j = 0;j < 3;j++)\n\t\t\t{\n\t\t\t\tif ( nii.arrayReadDirection[j] == 1)\n\t\t\t\t{\n\t\t\t\t\tq[ nii.permutationOrder[j]][j] =  nii.voxSize[j];         //(c_[i[k]]+0.5)* nii.voxSize[i[k]]-m[k];\n\t\t\t\t\tq[ nii.permutationOrder[j]][3] = -m[ nii.permutationOrder[j]]+0.5* nii.voxSize[j];\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tq[ nii.permutationOrder[j]][j] = - nii.voxSize[j];                    //c[k] = m[k]-(c_[i[k]]+0.5)* nii.voxSize[i[k]];\n\t\t\t\t\tq[ nii.permutationOrder[j]][3] = m[ nii.permutationOrder[j]]- nii.voxSize[j]*0.5;\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar fac = 1;\n\t\t\tvar p = [[0,fac,0,0],[0,0,fac,0],[fac,0,0,0],[0,0,0,1]];\n\n\t\t\treturn math.multiply(p,math.multiply(q,math.inv(ee)));\n\t\t}\n\t\telse\n\t\t{\n\t\t\treturn math.matrix([[0,1,0,0],[0,0,1,0],[1,0,0,0],[0,0,0,1]]);\n\n\t\t}\n\n\t}\n\n\tfunction world2GL_BJS_matrix()\n\t{\n  \t\tvar m = math.transpose(world2GL_matrix())._data;\n  \t\treturn BABYLON.Matrix.FromArray([m[0][0],m[0][1],m[0][2],m[0][3], \n\t\t\t\t\t\t\t\t\t\tm[1][0],m[1][1],m[1][2],m[1][3], \n\t\t\t\t\t\t\t\t\t\tm[2][0],m[2][1],m[2][2],m[2][3], \n\t\t\t\t\t\t\t\t\t\tm[3][0],m[3][1],m[3][2],m[3][3] ]);\n\t}\n\n\tfunction world2GL_BJS_matrix_M(M)\n\t{\n  \t\tvar m = math.transpose(math.multiply(world2GL_matrix(),M))._data;\n  \t\treturn BABYLON.Matrix.FromArray([m[0][0],m[0][1],m[0][2],m[0][3], \n\t\t\t\t\t\t\t\t\t\tm[1][0],m[1][1],m[1][2],m[1][3], \n\t\t\t\t\t\t\t\t\t\tm[2][0],m[2][1],m[2][2],m[2][3], \n\t\t\t\t\t\t\t\t\t\tm[3][0],m[3][1],m[3][2],m[3][3] ]);\n\t}\n\n\tfunction world2GL(p)\n\t{\n\t\t  var m = world2GL_matrix();\n\t\t  var x = math.multiply(m,p);\n\t\t  if (x._data) x =x._data;\n\t\t  return [x[0],x[1],x[2]];\n\t}\n\tfunction GL2world(c)\n\t{\n\t\t  var m = math.inv(world2GL_matrix());\n\t\t  var x = math.multiply(m,[c[0],c[1],c[2],1]);\n\t\t  if (x._data) x =x._data;\n\t\t  return math.matrix([x[0],x[1],x[2],1]);\n\t}\n\n\tfunction GL2world_withflip(c)\n\t{\n\t\t  var pP = flip(c);\n\t\t  return GL2world([pP.x,pP.y,pP.z]);\t \t\t\t\t\t\t\n\t}\n\n\tthis.GL2world_withflip = GL2world_withflip;\n\tthis.GL2world = GL2world;\n\tthis.world2GL = world2GL;\n\n\t//////////////////////////////////////////////////////////////////////////////////////////////\n\t//////////////////////// updates\n\t/////////////////////////////////////////////////////////////////////////////////////////////\n\t\n \n    function updatePlanes()\n    {\n\t\tif (planes.length == 0)\n\t\t\treturn;\n\n\t    if (planes[0] == undefined)\t\t\t\n\t    \tupdateLayout()\n\n\t    viewer.gl.activateRenderLoop();\n  \t    var c = world2GL(viewer.getWorldPosition());\n\n\n\n\t\tposIndicator.position.x = c[0];\n\t\tposIndicator.position.y = c[1];\n\t\tposIndicator.position.z = c[2];\n\n        var sg0 =1;// viewer.nii.arrayReadDirection[0];\n        var sg1 =1;// viewer.nii.arrayReadDirection[1];      \n        var sg2 =1;// viewer.nii.arrayReadDirection[2];\n \n    /*    var sg0 = viewer.nii.arrayReadDirection[0];\n        var sg1 = viewer.nii.arrayReadDirection[1];      \n        var sg2 = viewer.nii.arrayReadDirection[2];\n   */\n\n\t\tvar idx = [0,1,2];\n   \t\tvar matrix,t;\n\n\t\t// coronal\t\t\n\t\tt = [-c[0],-c[1],-c[2]]; \n\t\t t[0] = 0; \n\t\tmatrix = BABYLON.Matrix.Translation(t[0],t[1],t[2]); \n\t\tplanes[1].setPivotMatrix(matrix,oldBablyonFlag);\n\t\tplanes[1].rotationQuaternion = tiltMat(sg2* KViewer.currentTilts_(2,1).v,sg0* KViewer.currentTilts_(0,0).v,0);\n\n\t\t// transversal\n\t\tt = [-c[0],-c[1],-c[2]]; \n\t\tt[1] = 0;\n\t\tmatrix = BABYLON.Matrix.Translation(t[0],t[1],t[2]); t[1] = 0;\n\t\tplanes[2].setPivotMatrix(matrix,oldBablyonFlag);\n\t\tplanes[2].rotationQuaternion =\ttiltMat(-sg1* KViewer.currentTilts_(1,1).v,sg0*KViewer.currentTilts_(0,1).v,1);\n\n\n\t\t// saggital\n\t\tt = [-c[0],-c[1],-c[2]]; \n\t\tt[2] = 0;\n\t\tmatrix = BABYLON.Matrix.Translation(t[0],t[1],t[2]); t[2] = 0;\n\t\tplanes[0].setPivotMatrix(matrix,oldBablyonFlag);\n\t\tplanes[0].rotationQuaternion =  tiltMat(sg2*KViewer.currentTilts_(2,0).v,-sg1* KViewer.currentTilts_(1,0).v,2);\n\n  \t \n\t   for (var k = 0;k < 3;k++)\n\t   {\n\t\t   planes[k].position.x = c[0];\n\t\t   planes[k].position.y = c[1];\n\t\t   planes[k].position.z = c[2];\n\t   }\n\n\n\t   for (var pl = 0; pl < 3; pl++)\n  \t      if (planesVisibility[pl])\n\t\t  {\n\t\t  \tplanesVisibility[pl] = true;\n\t\t\tplanes[pl].visibility = 1;\n\t\t\tplanes[pl].isPickable = true;\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t\tplanes[pl].visibility = -1;\n\t\t\tplanes[pl].isPickable = false;\n\t\t  }\n\n\t   for (var k = 0;k < 3;k++)\n\t     planes[k].parent = grandParent;\n\n    }\n\n\tfunction updateLayout()\n\t{\n\t\tsetQuality();\n\t\tif (viewer.nii == undefined || currentLayout != viewer.nii.edges._data.toString() || planes[0] == undefined)\n\t\t\t{\n\t\t\t\tdisposePlanes();\n\t\t\t\tcreatePlanes();\n\t\t\t\tupdateObjects();\n\t\t\t}\n\t\tif (viewer.nii != undefined )\n\t    \tcurrentLayout = viewer.nii.edges._data.toString();\n\t    \n\t}\n\n\tfunction setQuality()\n\t{\n\t\tif (camera)\n\t\t{\n\t\t\tvar r = camera.radius/viewer.computeMaxExtentFac();\n\t\t\tvar scaling = Math.min($(document.body).width(),$(document.body).height())\n\t\t\t\t\t\t /ViewerSettings.quality3D/r/200;\n\t\t\tif (scaling < 1) \n\t\t\t\tscaling = 1;\n\t\t\tengine.setHardwareScalingLevel(scaling);\n\t\t}\n\t}\n\n\n\tfunction updateObjects()\n\t{\n\t\tupdatePlanes();\n\t\tfor (var k = 0; k < viewer.objects3D.length;k++)\n\t\t\tviewer.objects3D[k].update();\n\t}\n\n    function disposePlanes()\n    {\n\t\tfor (var k = 0; k < 3;k++)\n\t\t{\n\t\t\tif (planes[k] != undefined)\n\t\t\t{\n\t\t\t\t//planes[k].parent = undefined;\n\t\t\t\tplanes[k].dispose();\n\t\t\t\tplanes[k] = undefined;\n\t\t\t}\n\t\t}\n    }\n\n\n\n\n\tfunction createPencil(type,pickable)\n\t{\n\t\tif (pencil == undefined)\n\t\t{\t\t\t\t\t\n\t\t    var vx = viewer.computeMaxExtentFac()*2/300;\n\t\t    var radius;\n\t\t    if (viewer.currentROI != undefined)\n\t\t    \tradius = KViewer.roiTool.pencil.radius*vx;\n\t\t   \telse\n\t\t    \tradius = viewer.gl.selectionRadius;\n\n\t\t\tif (type == undefined | type == \'plane\')\t\n\t\t\t{\n\t\t\t\tpencil = BABYLON.Mesh.CreateTorus("torus", radius, vx*0.3, 20, scene, false);\n\t\t\t\tpencil.parent = grandParent;\n\t\t\t\tpencil.type == \'plane\';\n\t\t\t}\n\t\t\telse\n\t\t\t{\n   \t  \t        pencil = BABYLON.Mesh.CreateSphere("pencilball", 20,radius, scene,false);\n   \t  \t        pencil.parent = grandParent;\n\t\t\t\tpencil.type == \'ball\';\t\t\t\t\n\t\t\t}\n\t\t\tpencil.material = new BABYLON.StandardMaterial("texture1", scene);\n\t\t\tcontrol;\n\t\t\tif (control._isAltPushed)\n\t\t\t\tpencil.material.diffuseColor  = new BABYLON.Color3(0,1,1);\n\t\t\telse if (control._isCtrlPushed)\n\t\t\t\tpencil.material.diffuseColor  = new BABYLON.Color3(0,1,0);\n\t\t\telse\n\t\t\t\tpencil.material.diffuseColor  = new BABYLON.Color3(1,1,0);\n\t\t\tpencil.material.backFaceCulling = false;\n\t\t\tpencil.material.alpha = 0.5;\n\t\t\tif (pickable != undefined)\n\t\t\t\tpencil.isPickable = pickable;\n\t\t\telse\n\t\t\t\tpencil.isPickable = false;\n \t\t    activateRenderLoop();\n\n\t\t}\n\t}\n\n\tfunction makePencilPickable()\n\t{\n\t\tif(pencil != undefined)\n\t\t\tpencil.isPickable = true;\n\t}\n\n\tfunction setPencilProps(pickResult)\n\t{\n\n\t\tif (pickResult.pickedMesh != null && pickResult.pickedMesh.name != \'marker\')// && pencil != undefined)\n\t\t{\n\n\t\t\tvar mat = BABYLON.Matrix.Identity();\n\t\t\tvar s = 1;\n\n\t\t\tif (viewer.currentROI != undefined  && pencil != undefined && !KViewer.roiTool.regionGrow)\t\n\t\t\t{\n\t\t\t\tvar sl = slice(pickResult,false);\n\t\t\t\tif (sl>=0 & sl <=2)\n\t\t\t\t{\n\t\t\t\t   if (pencil.type != \'plane\')\n\t\t\t\t   {\n\t\t\t\t\t   disposePencil();\n\t\t\t\t\t   createPencil(\'plane\');\n\t\t\t\t   }\t\t\t   \n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t   if (pencil.type != \'sphere\')\n\t\t\t\t   {\n\t\t\t\t\t   disposePencil();\n\t\t\t\t\t   createPencil(\'sphere\');\n\t\t\t\t   }\t\t\t   \n\n\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (viewer.getCurrentFiberView() != undefined)\n\t\t\t{\n\t\t\t    disposePencil();\n\t\t\t\tif (viewer.getCurrentFiberView().associated_annotation == -1)\n\t\t\t\t{\t\t\t\n\t\t\t\t   createPencil(\'sphere\');\n\t\t\t\t}\n\t\t\t\n\t\t\t}\n\t\t\telse\n\t\t\t  disposePencil();\n\t\t\t\n\t\t\tif (pencil != undefined)\n\t\t\t{\n\t\t\t\tpencil.position = flip(pickResult.pickedPoint);\n\n\t\t\t\tif (sl == 0)\n\t\t\t\t  mat = BABYLON.Matrix.FromArray([s,0,0,0, 0,0,-s,0, 0,s,0,0, 0,0,0,1]);\n\t\t\t\telse if (sl == 1)\n\t\t\t\t  mat = BABYLON.Matrix.FromArray([0,s,0,0, -s,0,0,0, 0,0,s,0, 0,0,0,1]);\n\t\t\t\telse if (sl == 2)\n\t\t\t\t  mat = BABYLON.Matrix.FromArray([s,0,0,0, 0,s,0,0, 0,0,s,0, 0,0,0,1]);\n\n\t\t\t\tpencil.setPivotMatrix(mat,oldBablyonFlag);\n\t\t\t}\n\t\t}\n\t\telse\n\t\t\tdisposePencil();\n\t}\n\n\n\tfunction disposePencil()\n\t{\n\t\tif (pencil != undefined)\n\t\t\t{\n\t\t\t\tpencil.dispose();\n\t\t\t\tpencil = undefined;\n\t\t\t}\n\t}\n\n\n\n\n\tfunction slice(pickResult,perm)\n\t{\n\t\tif (pickResult.pickedMesh != null)\n\t\t{\n\t\t\tvar i= [0,1,2]; \n\t\t\tif (perm)\n\t\t\t{\n\t\t\t\ti[viewer.nii.permutationOrder[0]] = 0;  i[viewer.nii.permutationOrder[1]] = 1; i[viewer.nii.permutationOrder[2]] = 2;\t\t\t\t\t\n\t\t\t}\n\t\t\tif (pickResult.pickedMesh.id == "ground0")\n\t\t\t\treturn i[0];\n\t\t\telse if (pickResult.pickedMesh.id == "ground1")\n\t\t\t\treturn i[1];\n\t\t\telse if (pickResult.pickedMesh.id == "ground2")\n\t\t\t\t\treturn i[2];\n\t\t}\n\t\treturn undefined;\n\t}\n\n\n\n\n\tfunction modifyFibersByPick(pickResult,_this,type,delta)\n\t{\n\t\tif (pickResult.pickedMesh)\n\t\t\t{\n\t\t\t\tfor (var k = 0; k < _this.viewer.objects3D.length;k++)\n\t\t\t\t{\n\t\t\t\t\tvar tck = _this.viewer.objects3D[k];\n\t\t\t\t\tif (tck.isCurrent)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (pickResult.pickedPoint == undefined)\n\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\tvar pP = _this.viewer.gl.flip(pickResult.pickedPoint);\n\t\t\t\t\t\tvar p = _this.viewer3D.GL2world([pP.x,pP.y,pP.z]);\t \t\t\t\t\t\t\n\t\t\t\t\t\tif (delta != undefined)\n\t\t\t\t\t\t\ttck.modifyByPick(p,type,delta);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttck.modifyByPick(p,type);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\t}\n\n\n\n\t var planesVisContextMenu = new KContextMenu(\n\t\t\t\t  function() { \n\t\t\t\t\t var $menu = $("<ul class=\'menu_context\'>");\n\t\t\t\t\t var name = [\'Saggital\',\'Coronal\',\'Transversal\'];\n\t\t\t\t\t $menu.append($("<hr width=\'100%\'> ")); \t\t\t\t\t \t\t\t\t\t\n\t\t\t\t\t $menu.append($("<span> &nbsp Planes visible</span>"));\n\t\t\t\t\t $menu.append($("<hr width=\'100%\'> ")); \t\t\n\t\t\t\t\t  var perm = [0,1,2]; //[viewer.nii.permutationOrder[0],viewer.nii.permutationOrder[1],viewer.nii.permutationOrder[2]];\n\t\t\t\t\t  perm[-1] = -1;\n\t\t\t\t\t for (var k = 0;k <3;k++)\n\t\t\t\t\t {\n\t\t\t\t\t \tvar sel = \'\';\n//\t\t\t\t\t \tif (planesVisibility[perm[k]])\n\t\t\t\t\t \tif (planesVisibility[k])\n\t\t\t\t\t \t  sel = \'check-\';\n\t\t\t\t\t\tvar $li = $("<li  onchoice=\'vis_"+k+"\' > "+name[k]+"<i  onchoice=\'vis_"+k+"\' class=\'fa fa-"+sel+"square-o\'></i> </li>");\n\n\t\t\t\t\t\tvar val = \'\';\n\t\t\t\t\t\tif (planes[k].material.alpha != 1)\n\t\t\t\t\t\t\tval = \'value="\'+planes[k].material.alpha +\'"\';\n\n\t\t\t\t\t\tvar $t = $(" <input placeholder=\'transparent\' class=\'alphaSlider\' onchoice=\'preventSelection\' type = \'number\' min=\'0\' max=\'1\' step=\'0.05\' "+val+" /> ");\n\t\t\t\t\t\t$t.on("change",function(k) { return function(ev)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tplanes[k].material.alpha = 1-$(ev.target).val();\n\t\t\t\t\t\t\tactivateRenderLoop();\n\n\t\t\t\t\t\t}}(k))\n\n \t\t\t\t\t \t$menu.append($li.append($t));\n\t\t\t\t\t }\n\t\t\t\t\t $menu.append($("<hr width=\'100%\'> ")); \t\t\t\t\t \t\t\t\t\t\n\t\t\t\t\t $menu.append($("<span> &nbsp Fixed planar view</span>"));\n\t\t\t\t\t $menu.append($("<hr width=\'100%\'> ")); \t\t\t\t\t \t\t\t\t\t\n\n\t\t\t\t\t name[-1] = \'free view\';\n\t\t\t\t\t for (var k = -1;k <3;k++)\n\t\t\t\t\t {\n\t\t\t\t\t \tvar sel = \'\';\n\t\t\t\t\t \tif (fixedPlanarView == perm[k])\n\t\t\t\t\t \t  sel = \'check-\';\n \t\t\t\t\t \t$menu.append($("<li  onchoice=\'pla_"+k+"\' > "+name[k]+"  <i  onchoice=\'pla_"+k+"\' class=\'fa fa-"+sel+"circle-o\'></i> </li>"));\n\t\t\t\t\t }\n\t\t\t\t\t $menu.append($("<hr width=\'100%\'> ")); \t\t\t\t\t \t\t\t\t\t\n\n\t\t\t\t\t var sel = \'\';\n\t\t\t\t\t if (ViewerSettings.sync3D)\n\t\t\t\t\t \t  sel = \'check-\';\n \t\t\t\t \t $menu.append($("<li  onchoice=\'sync\' > Synchronize 3D views<i  onchoice=\'sync\' class=\'fa fa-"+sel+"square-o\'></i>   </li>"));\n\n\t\t\t\t\treturn $menu; \n\t\t\t\t  }, function(str,ev)\n\t\t\t\t  {\n\t\t\t\t  \t  if (str == \'\' | str == undefined)\n\t\t\t\t  \t  \treturn;\n\t\t\t\t\t  var perm = [viewer.nii.permutationOrder[0],viewer.nii.permutationOrder[1],viewer.nii.permutationOrder[2]];\n\t\t\t\t\t  perm[-1] = -1;\n\n\n\t\t\t\t\t  activateRenderLoop();\n\t\t\t\t\t  \n\t\t\t\t\t  if (str == \'sync\')\n\t\t\t\t\t  {\n\t\t\t\t\t  \t if (ViewerSettings.sync3D)\n\t\t\t\t\t  \t \tViewerSettings.sync3D = false;\n\t\t\t\t\t  \t else\n\t\t\t\t\t  \t \tViewerSettings.sync3D = true;\n\n\t\t\t\t\t  }\n\t\t\t\t\t  else \t  if (str.search("vis") != -1)\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \t  str = str.substring(4);\n//\t\t\t\t\t\t  var pl = perm[parseInt(str)];\n\t\t\t\t\t\t  var pl = parseInt(str);\n\t\t\t\t\t\t  planesVisibility[pl] = !planesVisibility[pl];\n\t\t\t\t\t\t  if (planesVisibility[pl])\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\tplanes[pl].visibility = 1;\n\t\t\t\t\t\t\tplanes[pl].isPickable = true;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  else\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\tplanes[pl].visibility = -1;\n\t\t\t\t\t\t\tplanes[pl].isPickable = false;\n\t\t\t\t\t\t  }\n\t\t\t\t  \t  }\n\t\t\t\t  \t  else\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \t  str = str.substring(4);\n\t\t\t\t\t\t  fixedPlanarView = parseInt(str);\n\t\t\t\t\t\t  if (fixedPlanarView != -1)\n\t\t\t\t\t\t  {\n\t\t\t\t  \t  \t //     fixedPlanarView = perm[fixedPlanarView];\n\t\t\t\t\t\t\t  for (var pl = 0; pl < 3; pl++)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  \tplanesVisibility[pl] = false;\n\t\t\t\t\t\t\t\tplanes[pl].visibility = 0;\n\t\t\t\t\t\t\t\tplanes[pl].isPickable = false;\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t\t  planesVisibility[fixedPlanarView] = true;\n\t\t\t\t\t\t\t  planes[fixedPlanarView].visibility = 1;\n\t\t\t\t\t\t\t  planes[fixedPlanarView].isPickable = true;\n\t\t\t\t\t\t\t  if (fixedPlanarView == 1)\n\t\t\t\t\t\t\t  {\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// coronal\t\t\t\t\t\t  \n\t\t\t\t\t\t\t\tcamera.alpha = Math.PI;\n\t\t\t\t\t\t\t\tcamera.beta = Math.PI/2;\n\t\t\t\t\t\t\t  } \n\t\t\t\t\t\t\t  else if (fixedPlanarView == 0)\n\t\t\t\t\t\t\t  {\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// saggital\t\t\t\t\t  \n\t\t\t\t\t\t\t\tcamera.alpha = Math.PI/2;\n\t\t\t\t\t\t\t\tcamera.beta = Math.PI/2;\n\t\t\t\t\t\t\t  } \n\t\t\t\t\t\t\t  else if (fixedPlanarView == 2)\n\t\t\t\t\t\t\t  {\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t// transversal\t\t\t\t\t  \n\t\t\t\t\t\t\t\tcamera.alpha = Math.PI;\n\t\t\t\t\t\t\t\tcamera.beta = 0;\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  else\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  for (var pl = 0; pl < 3; pl++)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  \tplanesVisibility[pl] = true;\t\t\t\t\t\t\t  \t\n\t\t\t\t\t\t\t\tplanes[pl].visibility = 1;\n\t\t\t\t\t\t\t\tplanes[pl].isPickable = true;\n\t\t\t\t\t\t\t  }\t\t\t\t\t\t  \t\n\t\t\t\t\t\t  }\n\n\n\t\t\t\t  \t  }\n\t\t\t\t\t  \n\n   \t\t\t\t\t  for (var k = 0; k < viewer.objects3D.length;k++)\n\t\t\t\t\t  {\n\t\t\t\t\t\tif (viewer.objects3D[k].updateCut != undefined)\n\t\t\t\t\t\t\tviewer.objects3D[k].updateCut([ planes[viewer.nii.permutationOrder[1]].visibility,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tplanes[viewer.nii.permutationOrder[2]].visibility,\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tplanes[viewer.nii.permutationOrder[0]].visibility]);\n\t\t\t\t\t  }\t\t\n\n\n\t\t\t\t  },undefined,true);\n\n\n\n\n\n\n\tcreateScene();\n\n\n\n\tfunction sync3DViews(a,b,px,py,zoom)\n\t{\n\t\tif (camera_picto)\n\t\t{\n\t\t\tcamera_picto.alpha= viewer.gl.camera.alpha;\n\t\t\tcamera_picto.beta= viewer.gl.camera.beta;\n\t\t\tcamera_picto.inertialAlphaOffset = viewer.gl.camera.inertialAlphaOffset;\n\t\t\tcamera_picto.inertialBetaOffset= viewer.gl.camera.inertialBetaOffset;\n\t\t}\n\n\t\tif (ViewerSettings.sync3D && KViewer.zoomedViewport == -1)\n\t\t{\n\n\t\t\tKViewer.iterateMedViewers(function(m)\n\t\t\t{\n\t\t\t\tif (m.nii !=undefined)\n\t\t\t\t  if (m.isGLenabled())\n\t\t\t\t  {\n\t\t\t\t\t\tif (viewer.gl.camera != m.gl.camera)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tm.gl.camera.alpha = viewer.gl.camera.alpha;\n\t\t\t\t\t\t\tm.gl.camera.beta = viewer.gl.camera.beta;\n\t\t\t\t\t\t\tm.gl.camera.radius = viewer.gl.camera.radius;\n\t\t\t\t\t\t\tm.gl.camera.inertialAlphaOffset = a;\n\t\t\t\t\t\t\tm.gl.camera.inertialBetaOffset = b;\n\t\t\t\t\t\t\tm.gl.camera.inertialPanningX = px;\n\t\t\t\t\t\t\tm.gl.camera.inertialPanningY = py;\n\t\t\t\t\t\t\tm.gl.camera.inertialRadiusOffset = zoom;\n\t\t\t\t\t\t\tif (m.gl.camera_picto)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tm.gl.camera_picto.alpha= viewer.gl.camera.alpha;\n\t\t\t\t\t\t\t\tm.gl.camera_picto.beta= viewer.gl.camera.beta;\n\t\t\t\t\t\t\t\tm.gl.camera_picto.inertialAlphaOffset = viewer.gl.camera.inertialAlphaOffset;\n\t\t\t\t\t\t\t\tm.gl.camera_picto.inertialBetaOffset= viewer.gl.camera.inertialBetaOffset;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tm.gl.activateRenderLoop();\n\t\t\t\t\t\t}\n\t\t\t\t  }\n\n\t\t\t});\n\t\t}\n\t}\n\n\n\t function activateRenderLoop()\n\t {\n\t\tgl.lastRenderQuery = Date.now();\n\t\tgl.isidle = false;\n\t\t///console.log(\'activate render loop\');\n\t }\n\n\n     var saveRender_id = setInterval(function()\n     {\n     \tif (Date.now()-gl.lastRenderQuery > 5000)\n     \t\tgl.isidle = true;\n     },500);\n\n\tengine.runRenderLoop(function () {\n\t\tif (gl.isidle)\n\t\t\treturn;\n\t\telse\n\t\t\tscene.render();\n\t  });\n\n//\twindow.addEventListener("resize",engine.resize);\n\n\n\n\tfunction screenShot(cb) \n\t{\n\t\treturn BABYLON.Tools.CreateScreenshot(engine,camera,{precision:1},cb);\n\t}\n\n\n\tfunction getRealWorldCoordinateFromEvent(evt)\n\t{\n\t\tvar pickResult = scene.pick(evt.offsetX, evt.offsetY,undefined,undefined,gl.camera);\t\n\t    var pP = gl.flip(pickResult.pickedPoint);\n\t\tvar p = GL2world([pP.x,pP.y,pP.z]);\t \t\t\t\t\t\t\n\t\treturn p;\n\n\t\t\t\t\t\t\t\n\n\t}\n\n\n\tvar gl = {engine:engine, \n\t      volrender :{ctx:vol_ctxs,material:vol_materials,textures:vol_textures,planes:vol_planes},\n\t\t  getCtx:function() { return ctxs; }, \n\t\t  getTextures:function() { return textures; },\n\t\t  scene:scene,\n\t\t  texSize:texSize,\n\t\t  camera:camera,\n\t\t  getRealWorldCoordinateFromEvent:getRealWorldCoordinateFromEvent,\n\t\t  camera_picto:camera_picto,\n\t\t  planes:planes,\n\t\t  isidle:false,\n\t\t  lastRenderQuery:Date.now(),\n\t\t  screenShot:screenShot,\n\t\t  doDownload:doDownload,\n\t\t  activateRenderLoop:activateRenderLoop,\n\t\t  createMarkerMesh:createMarkerMesh,\n\t\t  createTrace:createTrace,\n\t\t  createElectrode:createElectrode,\n\t\t  updateLayout:updateLayout,\n\t\t  updateObjects:updateObjects,\n\t\t  updatePlanes:updatePlanes,\n\t\t  grandParent:grandParent,\n\t\t  sync3DViews:sync3DViews,\n\t\t  setPlanesVisibility: setPlanesVisibility,\n\t\t  getPlanesVisibility: getPlanesVisibility,\n\t\t  isFixed:function() {return fixedPlanarView!=-1},\n\t\t  createPencil:createPencil,\n\t\t  setPencilProps:setPencilProps,\n\t\t  makePencilPickable:makePencilPickable,\n\t\t  disposePencil:disposePencil,\n\t\t  disposePlanes:disposePlanes,\n\t\t  createPlanes:createPlanes,\n\t\t  animate3D:animate3D,\n\t\t  setSurfColor:setSurfColor,\n\t\t  createControlsCam:createControlsCam,\n\t\t  modifyFibersByPick:modifyFibersByPick,\n\t\t  createSurface:createSurface,\n\t\t  createFreeSurf:createFreeSurf,\n\t\t  createConmat:createConmat,\n\t\t  createContour:createContour,\n\t\t  createFiberBundle:createFiberBundle,\n\t\t  createFiberShader:createFiberShader,\n\t\t  flip:flip,\n\t\t  setQuality:setQuality,\n\t\t  detachShader:detachShader,\n\t\t  selectionRadius:viewer.computeMaxExtentFac()*0.05,\n\t\t  slice:slice,\n\t\t  dispose:dispose,\n\t\t  GL2world:GL2world,\n\t\t  GL2world_withflip:GL2world_withflip,\n\t\t  world2GL:world2GL,\n\t\t  world2GL_matrix:world2GL_matrix,\n\t\t  world2GL_BJS_matrix:world2GL_BJS_matrix,\n\n\t\t  planesVisContextMenu:planesVisContextMenu,\n\t\t  updateTexture:function()\n\t\t\t{\n\t\t\t\tfor (var k=0;k<textures.length;k++)\n\t\t\t\t textures[k].update();\n\t\t\t} ,\n\t\t  updateVolume:function()\n\t\t\t{\n\t\t\t\tfor (var k=0;k<vol_planes.length;k++)\n\t\t\t\t  if (vol_planes[k] != undefined)\n\t\t\t\t \tvol_textures[k].update();\n\t\t\t} ,\n\t\t  setprops:function(gl_props)\n\t\t  {\n\t\t\t\tif (gl_props)\n\t\t\t\t{\n\t\t\t\t\tif(gl_props.alpha != undefined)\n\t\t\t\t\t\tcamera.alpha =  gl_props.alpha; \n\t\t\t\t\tif(gl_props.beta != undefined)\n\t\t\t\t\t\tcamera.beta =   gl_props.beta; \n\t\t\t\t\tif(gl_props.radius != undefined)\n\t\t\t\t\t\tcamera.radius = gl_props.radius; \n\t\t\t\t\tif(gl_props.planesVisibility != undefined) \n\t\t\t\t\t\tsetPlanesVisibility(gl_props.planesVisibility);    \n\t\t\t\t}\n\t\t  \t\n\t\t  }\n\n\t};\n\n\treturn gl;\n\n}\n\n\n\n\n//////////////////////////////////////////////////////////////////////////////////////////////\n//////////////////////// Event Managers\n/////////////////////////////////////////////////////////////////////////////////////////////\n\n\n\n\n\nfunction ArcRotateCameraPointersInput(cam,viewer,viewer3D) {\n\tthis.angularSensibilityX = 1000.0;\n\tthis.angularSensibilityY = 1000.0;\n\tthis.pinchPrecision = 6.0;\n\tthis.panningSensibility = 50.0;\n\tthis._isRightClick = false;\n\tthis._isCtrlPushed = false;\n\tthis._isShiftPushed = false;\n\tthis._isAltPushed = false;\n\tthis.pinchInwards = true;\n\tthis.camera = cam;\n\tthis.scene = cam.getScene();\n\tthis.viewer = viewer;\n\tthis.viewer3D = viewer3D;\n\n}\n\n\nfunction dragController(viewer,obj,move,drop)\n{\n\tvar that = {};\n\tthat.dragStart = function()\n\t{\n\t\tif (dragController.controller == undefined)\n\t\t{\n\t\t\tobj.isPickable = false;\n\t\t\tdragController.controller = {dragMove:that.dragMove, dropUp:that.dropUp};\n\t\t}\n\t}\n\tthat.dragMove = function (evt,scene)\n\t{\n\t\tvar pickResult = scene.pick(evt.offsetX, evt.offsetY,undefined,undefined,viewer.gl.camera);\t\n\t\tif (pickResult.pickedMesh)\n\t\t{\n\t\t   obj.position = viewer.gl.flip(pickResult.pickedPoint);\n\t\t   if (move != undefined)\n\t\t   \t  move(obj.position ,evt);\n\t\t}\n\t}\n\tthat.dropUp = function (evt,scene)\n\t{\n\t\tobj.isPickable = true;\n\t\tdragController.controller = undefined;\n\t\tif (drop != undefined)\n\t\t\tdrop(obj.position,evt)\n\t}\n\n\treturn that;\n}\ndragController.controller = undefined;\n\n\n\nfunction HoverController(scene,_this)\n{\n\tvar that = {};\n\tthat.hoveredObj = undefined;\n\tthat.onMove = function(evt)\n\t{\n\t\tvar pickResult = scene.pick(evt.offsetX, evt.offsetY,undefined,undefined,_this.viewer.gl.camera);   \n\t\tif (pickResult.pickedMesh != that.hoveredObj)\n\t\t{\n\t\t\tif (that.hoveredObj != undefined)\n\t\t\t{\n\t\t\t\tif (that.hoveredObj.onHoverLeave != undefined)\n\t\t\t\t\tthat.hoveredObj.onHoverLeave(evt);\n\t\t\t}\n\t\t\tthat.hoveredObj = pickResult.pickedMesh;\n\t\t\tif (that.hoveredObj != undefined)\n\t\t\t{\n\t\t\t\tif (that.hoveredObj.onHoverEnter != undefined)\n\t\t\t\t\tthat.hoveredObj.onHoverEnter(evt);\t\t\t\t\n\t\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\treturn that;\n\n}\n\n\n\n\nArcRotateCameraPointersInput.prototype.attachControl = function (element, noPreventDefault) {\n\n\tvar _this = this;\n\tvar engine = this.camera.getEngine();\n\tvar cacheSoloPointer; // cache pointer object for better perf on camera rotation\n\tvar pointA, pointB;\n\tvar lastMousePos;\n\tvar lastPickedPoint;\n\tthis.draggedPlane = undefined;\n\tvar draggedPlaneStart;\n\tvar previousPinchDistance = 0;\n\tvar lastMove = false;\n\tvar hoverController = HoverController(_this.scene,_this);\n\n\t// ignore picks on non visible parts of the three main slices\n\tfunction pick_noTransparent(x,y)\n\t\t\t{\n\t\t\t\tif (_this.viewer.gl.planes[0] == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t_this.viewer.gl.planes[0].isPickable = true;\n\t\t\t\t_this.viewer.gl.planes[1].isPickable = true;\n\t\t\t\t_this.viewer.gl.planes[2].isPickable = true;\n\n\t\t\t\treturn pick_();\n\n\t\t\t\tfunction pick_()\n\t\t\t\t{\n\t\t\t\t\tvar pickResult = _this.scene.pick(x,y,undefined,undefined,_this.viewer.gl.camera);\n\t\t\t\t\tif (pickResult.pickedMesh == undefined)\n\t\t\t\t\t\treturn pickResult;\n\t\t\t\t\tif (pickResult.pickedMesh.id.substring(0,6) == \'ground\')\n\t\t\t\t\t{\n\t\t\t\t\t\tvar notTransparent = _this.viewer.getValueAtWorldPosition(_this.viewer.gl.GL2world_withflip(pickResult.pickedPoint));\t\t\t\t\t\t\n\t\t\t\t\t\tnotTransparent = notTransparent && pickResult.pickedMesh.visibility==1;\n\t\t\t\t\t\tif (!notTransparent)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpickResult.pickedMesh.isPickable = false;\n\t\t\t\t\t\t\treturn pick_();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\treturn pickResult;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\treturn pickResult;\n\t\t\t\t}\n\t\t\t}\n\n\n\t\tfunction updateInfo3D(pickResult,evt)\n\t\t{\n\t\t\tif (_this.viewer.info3D != undefined)\n\t\t\t{\n\t\t\t _this.viewer.info3D.remove();\n\t\t\t}\n\t\t\t\n\t\t\tif (pickResult.pickedMesh != undefined)\n\t\t\t{\n\t\t\t\tif(_this._isCtrlPushed  && !_this._isShiftPushed)\n\t\t\t\t{\n\t\t\t\t   var c_val = _this.viewer.currentValueAt3DWorldPick;\n\t\t\t\t   var c_point = _this.viewer.currentCoordinateAt3DWorldPick;\n\t\t\t\t   if (c_point == undefined)\n\t\t\t\t\t   return;\n\n\t\t\t\t   var $info3D =  $("<div class=\'Kinfo3D\'> "\n\t\t\t\t   +c_point[0].toFixed(1)+ "," \n\t\t\t\t   +c_point[1].toFixed(1)+ "," \n\t\t\t\t   +c_point[2].toFixed(1)+ " (mm) <br> " \n\t\t\t\t   + "value: " + c_val + "" \n\t\t\t\t   + "</div>").appendTo(_this.viewer.$container);\n\t\t\t\t   _this.viewer.info3D = $info3D;\n\t\t\t\t   $info3D.css(\'top\',evt.offsetY+10);\n\t\t\t\t   $info3D.css(\'left\',evt.offsetX+10);\n\t\t\t\t}\n\t\t\t\telse if (_this._isShiftPushed | \n\t\t\t\t    ( _this._isShiftPushed & _this._isCtrlPushed ) | ( _this._isAltPushed ) )\n\t\t\t\t{\n            \t\tvar fibs = _this.viewer.getCurrentFiberView();\n            \t\tif (fibs != undefined)\n            \t\t{\n\n            \t\t\t  var txt ;\n            \t\t\t  if (_this._isShiftPushed) \n            \t\t\t    txt = "select fibers"\n            \t\t\t  if ( _this._isShiftPushed & _this._isCtrlPushed )\n            \t\t\t    txt = "append fibers"\n            \t\t      if ( _this._isAltPushed )\n            \t\t\t    txt = "select from<br>subset"\n\n\t\t\t\t\t\t   var $info3D =  $("<div class=\'Kinfo3D\'> "+txt+" </div>").appendTo(_this.viewer.$container);\n\t\t\t\t\t\t   _this.viewer.info3D = $info3D;\n\t\t\t\t\t\t   $info3D.css(\'top\',evt.offsetY+10);\n\t\t\t\t\t\t   $info3D.css(\'left\',evt.offsetX+10);\n\n\n            \t\t}\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n         \n\n\n\n\n\tthis._pointerInput = (function (p, s) {\n\t\tvar evt = p.event;\n\t\tif (p.type === BABYLON.PointerEventTypes.POINTERDOWN) {\n\t\t\ttry {\n\t\t\t\tevt.srcElement.setPointerCapture(evt.pointerId);\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t}\n\n\t\t\t_this._isRightClick = evt.button === 2;\n\t\t\t\n\t\t\tfunction default_rotate()\n\t\t\t{                    \n\n\t\t\t\t_this.viewer.gl.activateRenderLoop();\n\t\n\t\t\t\t// Manage panning with right click\n\t\t\t\t_this._isRightClick = evt.button === 2;\n\t\t\t\t// manage pointerss\n\t\t\t\tcacheSoloPointer = { x: evt.clientX, y: evt.clientY, pointerId: evt.pointerId, type: evt.pointerType };\n\t\t\t\tif (pointA === undefined) {\n\t\t\t\t\tpointA = cacheSoloPointer;\n\t\t\t\t}\n\t\t\t\telse if (pointB === undefined) {\n\t\t\t\t\tpointB = cacheSoloPointer;\n\t\t\t\t}\n\t\t\t\tif (!noPreventDefault) {\n\t\t\t\t\tevt.preventDefault();\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t\n\t\t\tvar pickResult = pick_noTransparent(evt.offsetX, evt.offsetY);\n\t\t\tif (pickResult == undefined)\n\t\t\t\treturn;\n\n\n\t\t\tif (pickResult.pickedMesh != null)\n\t\t\t{\n\n\t\t\t\t var markerEditmode = markerProxy.currentSet != undefined \n\t\t\t\t \t\t\t\t\t\t  && KViewer.markerTool.enabled\n\t\t\t\t\t\t\t\t\t\t  && markerProxy.currentSet.state\n\t\t\t\t\t\t\t\t\t\t  && !markerProxy.currentSet.state.locked\n\t\t\t\t\t\t\t\t\t\t  && markerProxy.currentSet.state.createonclick\n\t\t\t\t\t\t\t\t\t\t  && markerProxy.currentSet.type != "electrode";\n\n\t\t\t\tif (pickResult.pickedMesh.onmousedown != undefined)\n\t\t\t\t{\n\t\t\t\t\tpickResult.pickedMesh.onmousedown(evt,pickResult,_this);\n\t\t\t\t}\n\n\t\t\t\tif (markerEditmode && pickResult !=undefined && pickResult.pickedMesh !=undefined&& pickResult.pickedMesh.after!=undefined)\n\t\t\t\t{\n\t\t\t\t\t\tvar p1 = _this.viewer.gl.flip(pickResult.pickedPoint);\n \t\t\t\t    \tp1 = _this.viewer3D.GL2world([p1.x,p1.y,p1.z]);\t\n \t\t\t\t    \tvar po = markerProxy.currentSet.insertpoint(p1._data,undefined,pickResult.pickedMesh.after,{size:markerProxy.currentSet.state.defaultradius});\n\t\t\t\t\t\tmarkerProxy.currentSet.updateLine();\n\t\t\t\t\t\tKViewer.markerTool.update()\n\t\t\t\t}\n\t\t\t\telse if (pickResult.pickedMesh.dragController != undefined && !_this._isRightClick\n\t\t\t\t\t\t&& (pickResult.pickedMesh.id!="marker" || !markerProxy.currentSet.state.locked)   )\n\t\t\t\t{\n\t\t\t\t\tpickResult.pickedMesh.dragController.dragStart();\n\t\t\t\t}\n\t\t\t\telse if (_this._isShiftPushed)\n\t\t\t\t{\n\t\t\t\t\tif (_this.viewer.currentROI != undefined)\n\t\t\t\t\t{\n\t\t\t            KViewer.roiTool.history.record(\'startRecording\', _this.viewer);   \t\t\n\t\t\t            var pP = _this.viewer.gl.flip(pickResult.pickedPoint);\n \t\t\t\t\t\tvar p = _this.viewer3D.GL2world([pP.x,pP.y,pP.z]);\t \t\t\t\t\t\t\n\t\t\t\t\t\tif (KViewer.roiTool.regionGrow |  KViewer.roiTool.regionGrowRestric)\n\t\t\t\t\t\t\tregionGrow.changedPoints = [];\n\t\t\t\t\t\tif (KViewer.roiTool.regionGrow)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tKViewer.roiTool.drawPen(evt,_this.viewer); \n\t\t\t\t\t\t\tKViewer.roiTool.$pencil.addClass(\'leftright busy\');\n\t\t\t\t\t\t\tregionGrow.helper.simscaling = 0; \t\t\t\t\t\t\n\t\t\t\t\t\t\tregionGrow.helper.p = p;\n\t\t\t\t\t\t\tregionGrow.helper.downev = evt;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tKViewer.roiTool.modifyRoiInternal(p,evt.button==0,_this.viewer.gl.slice(pickResult,true), _this.viewer,undefined,function(changedPoints) {\n\t\t\t\t\t\t\n\t\t\t\t\t\t\tif (KViewer.roiTool.regionGrow)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t_this.viewer.gl.disposePencil();\n\t\t\t\t\t\t\t\tKViewer.roiTool.$pencil.removeClass(\'busy\');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tKViewer.roiTool.history.add(changedPoints, evt.button==0);\n\n\t\t\t\t\t\t\tsignalhandler.send("positionChange");\n\t\t\t\t\t\t\tpointA = {};\n\t\t\t\t\t\t\t_this._roiPainted = true;\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\telse if (!_this._isRightClick && markerEditmode)\n \t\t\t\t    {\n\t\t\t\t\t\tvar p1 = _this.viewer.gl.flip(pickResult.pickedPoint);\n \t\t\t\t    \tp1 = _this.viewer3D.GL2world([p1.x,p1.y,p1.z]);\t\n \t\t\t\t    \tvar po;\n \t\t\t\t    \tif (pickResult.pickedMesh.after != undefined)\n \t\t\t\t    \t   po = markerProxy.currentSet.insertpoint(p1._data,undefined,pickResult.pickedMesh.after,{size:markerProxy.currentSet.state.defaultradius});\n \t\t\t\t    \telse\n\t\t\t\t\t\t   po = markerProxy.currentSet.addpoint(p1._data,undefined,{size:markerProxy.currentSet.state.defaultradius});\n\t\t\t\t\t\tKViewer.markerTool.update()\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if (_this._isRightClick && markerEditmode)\n \t\t\t\t    {\n\t\t\t\t\t\tif (pickResult &&  pickResult.pickedMesh && pickResult.pickedMesh.point)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpickResult.pickedMesh.point.deletepoint();\n\t\t\t\t\t\t\tKViewer.markerTool.update()\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlastPickedPoint=pickResult;\n\t\t\t\t\t\tif (_this._isAltPushed)\n\t\t\t\t\t\t    _this.viewer.gl.modifyFibersByPick(pickResult,_this,\'subselect\');\n\t\t\t\t\t\telse if (_this._isRightClick)\n\t\t\t\t\t\t\t_this.viewer.gl.modifyFibersByPick(pickResult,_this,\'delete\');\n\t\t\t\t\t\telse if (_this._isCtrlPushed)\n\t\t\t\t\t\t\t_this.viewer.gl.modifyFibersByPick(pickResult,_this,\'append\');\n\t\t\t\t\t\telse\t\t\t\t\t\t\n\t\t\t\t\t\t\t_this.viewer.gl.modifyFibersByPick(pickResult,_this,\'select\');\n\t\t\t\t\t\tpointA = {};\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (_this._isCtrlPushed | pickResult.pickedMesh.id == "planecontroller")\n\t\t\t\t{\n \t\t\t\t\tif (pickResult.pickedMesh.id == "planecontroller")\n \t\t\t\t\t\t_this.draggedPlane = pickResult.pickedMesh.parent; \t\t\t\t\t\n\t\t\t\t\telse\n \t\t\t\t\t\t_this.draggedPlane = pickResult.pickedMesh;\n \t\t\t\t\tvar v = _this.viewer.getCurrenVoxel();\n \t\t\t\t\tdraggedPlaneStart = [evt.offsetX,evt.offsetY,v._data[0],v._data[1],\tv._data[2]];\n\t\t\t\t}\n\t\t\t\telse if (_this._isRightClick & pickResult.pickedMesh.contextmenu != undefined)\n\t\t\t\t{\n\t\t\t\t\t\t \t\t\t\t\t\t\n\t\t\t\t\tpickResult.pickedMesh.contextmenu(evt,pickResult,_this);\n\t\t\t\t}\n\t\t\t\telse if (_this._isRightClick & pickResult.pickedMesh.id==\'marker\'\n \t\t\t\t\t\t  && markerProxy.currentSet != undefined \n\t\t\t\t\t\t  && markerProxy.currentSet.state\n\t\t\t\t\t\t  && !markerProxy.currentSet.state.locked\n\t\t\t\t\t\t  && markerProxy.currentSet.state.createonclick\n\t\t\t\t\t\t  && markerProxy.currentSet.type != "electrode")\n\t\t\t\t{\n\t\t\t\t\tpickResult.pickedMesh.point.deletepoint()\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tdefault_rotate();\n\t\t\t}\n\t\t\telse\t\n\t\t\t\tdefault_rotate();\t\t\t\n\n\n\n\t\t}\n\t\telse if (p.type === BABYLON.PointerEventTypes.POINTERUP) {\n\t\t\ttry {\n\t\t\t\tevt.srcElement.releasePointerCapture(evt.pointerId);\n\t\t\t}\n\t\t\tcatch (e) {\n\t\t\t}\n\t\t\t_this.draggedPlane = null;\n\t\t\tcacheSoloPointer = null;\n\t\t\tpreviousPinchDistance = 0;\n\t\t\t//would be better to use pointers.remove(evt.pointerId) for multitouch gestures, \n\t\t\t//but emptying completly pointers collection is required to fix a bug on iPhone : \n\t\t\t//when changing orientation while pinching camera, one pointer stay pressed forever if we don\'t release all pointers  \n\t\t\t//will be ok to put back pointers.remove(evt.pointerId); when iPhone bug corrected\n\t\t\tpointA = pointB = undefined;\n\t\t\tif (!noPreventDefault) {\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\n\t\t\tvar pickResult = _this.scene.pick(evt.offsetX, evt.offsetY,undefined,undefined,_this.viewer.gl.camera);\n\t\t\tif (pickResult.pickedMesh != undefined )\n\t\t\t\tif (pickResult.pickedMesh.onmouseup != undefined)\n\t\t\t\t\tpickResult.pickedMesh.onmouseup(evt,pickResult,_this);\n\n\t\t\tif (_this._roiPainted & _this.viewer.currentROI != undefined)\n\t\t\t{\n\n\t\t\t\t\tif (KViewer.roiTool.regionGrow)\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\tif (regionGrow.timeout != -1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tclearTimeout(regionGrow.timeout);\n\t\t\t\t\t\t\tregionGrow.timeout = -1;\n\t\t\t\t\t\t\talertify.error(\'region growing breaked to early, keep mouse down to produce full result\')\n\t\t\t\t\t\t}\t\t\t\t\t\t\t\n\t\t\t\t\t\tKViewer.roiTool.history.add(regionGrow.changedPoints,  evt.button==0);\n\t\t\t\t\t\tKViewer.roiTool.hidePen(_this.viewer);\n\t\t\t\t\t\tKViewer.roiTool.$pencil.removeClass(\'leftright \'); \n\t\t\t\t\t\tKViewer.roiTool.update3D(_this.viewer.currentROI)\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tKViewer.roiTool.update3D(_this.viewer.currentROI)\t\t\t\t\n\n\t\t\t}\n\t\t\n\n\t\t\tif (dragController.controller != undefined)\n\t\t\t{\t\t\t\n\t\t\t\tdragController.controller.dropUp(evt,_this.scene);\t\t\t\t\n\t\t\t}\n\t\t\t_this._roiPainted = false;\n\n\t\t    if (_this.viewer.info3D != undefined)\n\t\t      _this.viewer.info3D.remove();\n\n\n\n\t\t}\n\t\telse if (p.type === BABYLON.PointerEventTypes.POINTERMOVE) {\n\t\t\tif (!noPreventDefault) {\n\t\t\t\tevt.preventDefault();\n\t\t\t}\n\t\t  evt = $.extend({},evt);\n\n\t\t  var thehandler = function() {\n\t\t\thoverController.onMove(evt);\n\n\t\t\n\n\n\t\t\tvar pickResult = pick_noTransparent(evt.offsetX, evt.offsetY);\n\n\t\t\tif (pickResult == undefined)\n\t\t\t\treturn;\n\n\t\t\tif (pickResult.pickedMesh != undefined )\n\t\t\t\tif (pickResult.pickedMesh.onmousemove != undefined)\n\t\t\t\t\tpickResult.pickedMesh.onmousemove(evt,pickResult,_this);\n\t\n\n\t\t\tupdateInfo3D(pickResult,evt);\n\n\n\n\t        if (_this._isShiftPushed)\n\t        {\n\t\t\t    _this.viewer.gl.setPencilProps(pickResult);\n\t\t\t    if (KViewer.roiTool.regionGrow)\t\t\t\n\t\t\t   \t\tKViewer.roiTool.drawPen(evt,_this.viewer); \n\t        }\n\n\n\n\n\n\n\n\t\t\tlastMousePos = {x:evt.offsetX,y:evt.offsetY,cx:evt.clientX,cy:evt.clientY};\n\n\t\t\t// One button down\n\t\t\tif (dragController.controller != undefined)\n\t\t\t{\t\t\t\n\t\t\t\tdragController.controller.dragMove(evt,_this.scene);\n\t\t\t}\n\t\t\telse if (_this._isAltPushed )\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\tif (lastPickedPoint)\n\t\t\t\t{\n\t\t\t\t\t_this.viewer.gl.makePencilPickable();\n\t\t\t\t\tvar p1 = _this.viewer.gl.flip(pickResult.pickedPoint);\n\t\t\t\t\tvar p2 = _this.viewer.gl.flip(lastPickedPoint.pickedPoint);\n\t\t\t\t\tp1 = _this.viewer3D.GL2world([p1.x,p1.y,p1.z]);\t\n\t\t\t\t\tp2 = _this.viewer3D.GL2world([p2.x,p2.y,p2.z]);\t\n\n\t\t\t\t\tp1._data[0] -= p2._data[0];\n\t\t\t\t\tp1._data[1] -= p2._data[1];\n\t\t\t\t\tp1._data[2] -= p2._data[2];\n\n\t\t\t\t\t_this.viewer.gl.modifyFibersByPick(lastPickedPoint,_this,\'select\',p1);\n\t\t\t\t}*/\n\t\t\t}\n\t\t\telse if (_this._isShiftPushed && pointA && pointB === undefined)\n\t\t\t{\n\t\t\t\t\tif ( _this.viewer.currentROI != undefined && pickResult.pickedPoint != undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pP = _this.viewer.gl.flip(pickResult.pickedPoint);\n \t\t\t\t\t\tvar p = _this.viewer3D.GL2world([pP.x,pP.y,pP.z]);\t \t\t\t\t\t\t\n\n\t\t\t\t\t\tif (!KViewer.roiTool.regionGrow)\n\t\t\t\t\t\t{\n \t\t\t\t\t\t\tKViewer.roiTool.modifyRoiInternal(p,evt.buttons==1,_this.viewer.gl.slice(pickResult,true), _this.viewer,undefined,function(changedPoints)\n \t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tKViewer.roiTool.history.add(changedPoints, evt.buttons==1);\n\t\t \t\t\t\t\t\tsignalhandler.send("positionChange");\n\n \t\t\t\t\t\t\t});\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tregionGrow.helper.simscaling = evt.clientX-regionGrow.helper.downev.clientX;\n\t\t\t\t\t\t\tKViewer.roiTool.$pencil.addClass(\'leftright busy\');\n\t\t\t\t\t\t\tKViewer.roiTool.modifyRoiInternal(regionGrow.helper.p,evt.buttons==1,_this.viewer.gl.slice(pickResult,true), _this.viewer,undefined,function(changedPoints)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tKViewer.roiTool.drawPen(evt,_this.viewer); \n\t\t\t\t\t\t\t\tKViewer.roiTool.$pencil.removeClass(\'busy\');\n\t\t \t\t\t\t\t\tsignalhandler.send("positionChange");\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t} \t\t\t\t\t\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tlastPickedPoint=pickResult;\n\t\t\t\t\t\tif (_this._isCtrlPushed | _this._isRightClick)\n\t\t\t\t\t\t\t_this.viewer.gl.modifyFibersByPick(pickResult,_this,\'delete\');\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t_this.viewer.gl.modifyFibersByPick(pickResult,_this,\'select\');\n\t\t\t\t\t}\n\t\t\t}\n\t\t\telse if\t(_this.draggedPlane)\n\t\t\t{\n\t\t\t\tvar speed = 0.3;\n\t\t\t\tvar i= [0,1,2]; i[_this.viewer.nii.permutationOrder[0]] = 0;  i[_this.viewer.nii.permutationOrder[1]] = 1; i[_this.viewer.nii.permutationOrder[2]] = 2;\t\t\t\t\t\n\t\t\t\tvar s = _this.viewer.nii.arrayReadDirection;\n\t\t\t\tvar dif = [(-evt.offsetX+draggedPlaneStart[0]),(-evt.offsetY+draggedPlaneStart[1])];\n                var camdir = _this.camera.globalPosition;\n\t\t\t\tif (_this.draggedPlane.id == "ground0")\n\t\t\t\t\t_this.viewer.setSlicePos(i[0],speed*s[i[0]]*dif[0]*Math.sign(camdir.x)+draggedPlaneStart[i[0]+2]);\n\t\t\t\telse if (_this.draggedPlane.id == "ground1")\n\t\t\t\t\t_this.viewer.setSlicePos(i[1],speed*s[i[1]]*dif[0]*Math.sign(camdir.z) +draggedPlaneStart[i[1]+2]);\n\t\t\t\tif (_this.draggedPlane.id == "ground2")\n\t\t\t\t\t_this.viewer.setSlicePos(i[2],speed*s[i[2]]*dif[1]*Math.sign(camdir.y)  +draggedPlaneStart[i[2]+2]);\n\t\t\t}\n\t\t\telse if (pointA && pointB === undefined) {\n\t\t\t\tif (_this.panningSensibility !== 0 &&\n\t\t\t\t\t((_this._isCtrlPushed && _this.camera._useCtrlForPanning) ||\n\t\t\t\t\t\t(!_this.camera._useCtrlForPanning && _this._isRightClick))) {\n\t\t\t\t\t_this.camera.inertialPanningX += -(evt.clientX - cacheSoloPointer.x) / _this.panningSensibility;\n\t\t\t\t\t_this.camera.inertialPanningY += (evt.clientY - cacheSoloPointer.y) / _this.panningSensibility;\n\t\t\t\t\t_this.viewer.gl.sync3DViews(_this.camera.inertialAlphaOffset,_this.camera.inertialBetaOffset,\n\t\t\t\t\t\t\t\t\t\t\t\t\t_this.camera.inertialPanningX,_this.camera.inertialPanningY,_this.camera.inertialRadiusOffset );\n\t\t\t\t\t_this.viewer.gl.activateRenderLoop();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tif (cacheSoloPointer != undefined & !_this.viewer.gl.isFixed())\n\t\t\t\t\t{\n\t\t\t\t\t\tvar offsetX = evt.clientX - cacheSoloPointer.x;\n\t\t\t\t\t\tvar offsetY = evt.clientY - cacheSoloPointer.y;\n\t\t\t\t\t\t_this.camera.inertialAlphaOffset -= offsetX / _this.angularSensibilityX;\n\t\t\t\t\t\t_this.camera.inertialBetaOffset -= offsetY / _this.angularSensibilityY;\n\t\t\t\t\t\t_this.viewer.gl.activateRenderLoop();\n  \t\t\t\t\t    _this.viewer.gl.sync3DViews(_this.camera.inertialAlphaOffset,_this.camera.inertialBetaOffset,\n  \t\t\t\t\t    \t\t\t\t\t\t\t\t_this.camera.inertialPanningX,_this.camera.inertialPanningY,_this.camera.inertialRadiusOffset );\n\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif (cacheSoloPointer != null)\n\t\t\t\t{\n\t\t\t\t\tcacheSoloPointer.x = evt.clientX;\n\t\t\t\t\tcacheSoloPointer.y = evt.clientY;\n\t\t\t\t}\n\t\t\t}\n\t\t\telse if (pointA && pointB) {\n\t\t\t\t//if (noPreventDefault) { evt.preventDefault(); } //if pinch gesture, could be useful to force preventDefault to avoid html page scroll/zoom in some mobile browsers\n\t\t\t\tvar ed = (pointA.pointerId === evt.pointerId) ? pointA : pointB;\n\t\t\t\ted.x = evt.clientX;\n\t\t\t\ted.y = evt.clientY;\n\t\t\t\tvar direction = _this.pinchInwards ? 1 : -1;\n\t\t\t\tvar distX = pointA.x - pointB.x;\n\t\t\t\tvar distY = pointA.y - pointB.y;\n\t\t\t\tvar pinchSquaredDistance = (distX * distX) + (distY * distY);\n\t\t\t\tif (previousPinchDistance === 0) {\n\t\t\t\t\tpreviousPinchDistance = pinchSquaredDistance;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (pinchSquaredDistance !== previousPinchDistance) {\n\t\t\t\t\t_this.camera\n\t\t\t\t\t\t.inertialRadiusOffset += (pinchSquaredDistance - previousPinchDistance) /\n\t\t\t\t\t\t(_this.pinchPrecision *\n\t\t\t\t\t\t\t((_this.angularSensibilityX + _this.angularSensibilityY) / 2) *\n\t\t\t\t\t\t\tdirection);\n\t\t\t\t\tpreviousPinchDistance = pinchSquaredDistance;\n\t\t\t\t}\n\t\t\t}\n\t\t  }\n\n\t\t  if (!(/Firefox/i.test(navigator.userAgent)))\n\t\t\tthehandler()\n\t\t  else\n\t\t  {\n\t\t\t  setTimeout(thehandler,0);\n\t\t\t  lastMove=true;\n\t\t\t  setTimeout(function() { lastMove = false; },10);\n\t\t  }\n        \n\n\t\t}\n\t});\n\tthis._observer = this.camera.getScene().onPointerObservable.add(this._pointerInput, BABYLON.PointerEventTypes.POINTERDOWN | BABYLON.PointerEventTypes.POINTERUP | BABYLON.PointerEventTypes.POINTERMOVE);\n\tthis._onContextMenu = function (evt) {\n\t\tevt.preventDefault();\n\t};\n\tif (!this.camera._useCtrlForPanning) {\n\t\telement.addEventListener("contextmenu", this._onContextMenu, false);\n\t}\n\tthis._onLostFocus = function () {\n\t\t//this._keys = [];\n\t\tpointA = pointB = undefined;\n\t\tpreviousPinchDistance = 0;\n\t\tcacheSoloPointer = null;\n\t};\n\tthis._onKeyDown = function (evt) {\n\t\tif (!_this.viewer.isGLenabled())\n\t\t\treturn;\n\t\tif (!_this.mouseOnViewer)\n\t\t\treturn;\n\t\t\n\n\t\t_this._isCtrlPushed = evt.ctrlKey;\n\t\t_this._isShiftPushed = evt.shiftKey;\n\t\t_this._isAltPushed = evt.altKey;\n\t\tvar fibs = _this.viewer.getCurrentFiberView();\n\t\t\n\t\tif (_this._isShiftPushed & lastMousePos != undefined)\n\t\t{\n\t\t\t \n\t\t\tif (lastMousePos != undefined)\n\t\t\t{\n\t\t\t\tevt.clientX = lastMousePos.cx;\n\t\t\t\tevt.clientY = lastMousePos.cy;\n\t\t\t\tevt.offsetX = lastMousePos.x;\n\t\t\t\tevt.offsetY = lastMousePos.y;\n\t\t\t}\n\t\t\tif (KViewer.roiTool.regionGrow)\n\t\t\t\tKViewer.roiTool.drawPen(evt,_this.viewer); \t\t\t\n\n\t\t    var pickResult = _this.scene.pick(lastMousePos.x,lastMousePos.y,undefined,undefined,_this.viewer.gl.camera);\n\t\t\tif (pickResult.pickedMesh != null && (_this.viewer.currentROI != undefined | fibs != undefined))\n \t\t\t{\n\t\t\t\t_this.viewer.gl.createPencil()\n\t\t\t\tif (pickResult.pickedMesh.name != \'marker\')\n\t\t\t\t{\n\t\t\t\t\t_this.viewer.gl.createPencil()\n\t\t\t\t}\n\t\t\t\t_this.viewer.gl.setPencilProps(pickResult);\n\t\t\t\t\n \t\t\t}\n    \t\tupdateInfo3D(pickResult,evt);\n\n\t\t}\n\t\telse if (_this._isCtrlPushed)\n\t\t{\n            \n            for (var k=0;k <_this.viewer.objects3D.length;k++)\n            { \n                if (_this.viewer.objects3D[k].gl && _this.viewer.objects3D[k].gl.largeMesh)\n                    _this.viewer.objects3D[k].gl.isPickable = true;\n            }\n\n\t\t\tif (lastMousePos != undefined)\n\t\t\t{\n\t\t\t\tvar pickResult = _this.scene.pick(lastMousePos.x,lastMousePos.y,undefined,undefined,_this.viewer.gl.camera);\n\t\t\t\tevt.offsetX = lastMousePos.x\n\t\t\t\tevt.offsetY = lastMousePos.y\n\n\t\t\t\tupdateInfo3D(pickResult,evt);\n\t\t\t}\n\t\t}\n\n\t\t\n\t/*\telse if (_this._isAltPushed)\n\t\t{\n\t\n\t\t\tif (lastPickedPoint != undefined && lastPickedPoint.pickedMesh != null)\n \t\t\t{\n\t\t\t\t_this.viewer.gl.createPencil(undefined,true);\n\t\t\t\t//if (lastPickedPoint.pickedMesh.name != \'marker\')\n\t\t\t\t//\t\t_this.viewer.gl.setPencilProps(lastPickedPoint);\n\t\t\t\t\n \t\t\t}\n\t\t}\n\t\t*/\n\n\t};\n\tthis._onKeyUp = function (evt) {\n\t\tif (!_this.viewer.isGLenabled())\n\t\t\treturn;\n\t\n\t\tif (!_this.mouseOnViewer)\n\t\t\treturn;\n\t\t_this._isAltPushed = evt.altKey;\n\t\t_this._isCtrlPushed = evt.ctrlKey;\n\t\t_this._isShiftPushed = evt.shiftKey;\n\n\t\tif (_this.viewer.info3D != undefined)\n\t\t  _this.viewer.info3D.remove();\n\n\t\tKViewer.roiTool.hidePen(_this.viewer); \n\n        if  (evt.code == \'ControlLeft\')\n        {\n            for (var k=0;k <_this.viewer.objects3D.length;k++)\n            { \n                if (_this.viewer.objects3D[k].gl && _this.viewer.objects3D[k].gl.largeMesh)\n                    _this.viewer.objects3D[k].gl.isPickable = false;\n            }\n        }\n\n\t \n\t\tif (_this.viewer.gl )\n\t\t{\n\t\t\t_this.viewer.gl.disposePencil();\n\t\t\tif (!_this._isCtrlPushed & !_this._isShiftPushed)\n\t\t\t\t_this.viewer.gl.disposePencil();\n\t\t\telse\n\t\t\t{\n\t\t\t\t_this.viewer.gl.createPencil("sphere",true);\n\t\t\t\tif (lastMousePos)\n\t\t\t\t{\n\t\t\t\t\tvar pickResult = _this.scene.pick(lastMousePos.x,lastMousePos.y,undefined,undefined,_this.viewer.gl.camera);\n\t\t\t\t\t_this.viewer.gl.setPencilProps(pickResult);\t\t    \n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t};\n\tthis._onMouseMove = function (evt) {\n\t\t_this.mouseOnViewer = true;\n\t\tif (!engine.isPointerLock) {\n\t\t\treturn;\n\t\t}\n\t\tvar offsetX = evt.movementX || evt.mozMovementX || evt.webkitMovementX || evt.msMovementX || 0;\n\t\tvar offsetY = evt.movementY || evt.mozMovementY || evt.webkitMovementY || evt.msMovementY || 0;\n\t\t_this.camera.inertialAlphaOffset -= offsetX / _this.angularSensibilityX;\n\t\t_this.camera.inertialBetaOffset -= offsetY / _this.angularSensibilityY;\n\t\tif (!noPreventDefault) {\n\t\t\tevt.preventDefault();\n\t\t}\n\t};\n\tthis._onMouseLeave = function (evt) {\n\t\t_this.mouseOnViewer = false;\n\t\tif (!engine.isPointerLock) {\n\t//\t\treturn;\n\t\t}\n\t\tif (_this.viewer.info3D != undefined)\n\t\t  _this.viewer.info3D.remove();\n\n\t    pointA = pointB = undefined;\n\t\tpreviousPinchDistance = 0;\n\t\tcacheSoloPointer = null;\n\t\t_this._isCtrlPushed = false;\n\t\t_this._isShiftPushed = false;\n\t\tif (_this.viewer.gl != undefined)\n\t\t\t_this.viewer.gl.disposePencil();\n\n\t\tif (!noPreventDefault) {\n\t\t\tevt.preventDefault();\n\t\t}\n\t};\n\tthis._onGestureStart = function (e) {\n\t\tif (window.MSGesture === undefined) {\n\t\t\treturn;\n\t\t}\n\t\tif (!_this._MSGestureHandler) {\n\t\t\t_this._MSGestureHandler = new MSGesture();\n\t\t\t_this._MSGestureHandler.target = element;\n\t\t}\n\t\t_this._MSGestureHandler.addPointer(e.pointerId);\n\t};\n\tthis._onGesture = function (e) {\n\t\t_this.camera.radius *= e.scale;\n\t\tif (e.preventDefault) {\n\t\t\tif (!noPreventDefault) {\n\t\t\t\te.stopPropagation();\n\t\t\t\te.preventDefault();\n\t\t\t}\n\t\t}\n\t};\n\tthis._wheel = (function (event) {\n\n \t\tif (KViewer.zoomedViewport != -1 & !_this.viewer.viewport.isZoomed())\n            return;\n\n\n\t\t\n\t    event = window.event || event; // old MOZ support\n\t\t_this.viewer.gl.activateRenderLoop();\n  \t\n\t\tif (event.shiftKey)\n\t\t{\n\t\t\tfunction c(amount)\n\t\t\t{\n\t\t\t\tvar fac = 0.8;\n\t\t\t\tif (KViewer.defaultFOV_mm)\n\t\t\t\t\tfac = KViewer.defaultFOV_mm/100;\n\t\t\t\treturn fac*((amount>0)?1:-1);\n\t\t\t}\n\t\t\tvar amount = (event.wheelDelta || -event.detail);\t\t\t\t\t\t\t\n\t\t\tvar pickResult = _this.scene.pick(event.offsetX, event.offsetY,undefined,undefined,_this.viewer.gl.camera);\n\t\t\tif (pickResult.pickedMesh != undefined && pickResult.pickedMesh.point != undefined)\n\t\t\t{\n\t\t\t\tpickResult.pickedMesh.point.incsize(c(amount));\n\t\t\t}\n\t\t\telse if (_this.viewer.currentROI != undefined)\n\t\t\t{\n\t\t\t\tKViewer.roiTool.pensizechange({myScrollAmount:c(amount)}, "radius", _this.viewer);\n\t\t\t\t_this.viewer.gl.setPencilProps(pickResult);\n\t\t\t}\n\t\t\telse if (_this.viewer.getCurrentFiberView() != undefined)\n\t\t\t{\n\t\t\t\t\n\t\t\t\t_this.viewer.gl.selectionRadius += c(amount)* _this.viewer.computeMaxExtentFac()*0.002;\n\t\t\t\tif (_this.viewer.gl.selectionRadius < 0.1) \n\t\t\t\t\t_this.viewer.gl.selectionRadius = 0.1;\n\t\t\t\tif (pickResult.pickedMesh != undefined)\n\t\t\t\t\t_this.viewer.gl.setPencilProps(pickResult);\n\t\t\t\tif (pointA)\n\t\t\t\t{\n\t\t\t\t\tif (_this._isCtrlPushed)\n\t\t\t\t\t\t_this.viewer.gl.modifyFibersByPick(pickResult,_this,\'delete\');\t\t\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t\t_this.viewer.gl.modifyFibersByPick(pickResult,_this,\'select\');\t\t\t\t\t\n\t\t\t\t}\t\t\t\t\t\t    \n\t\t\n\t\t\t}\n\t\t//\tevent.preventDefault();\n\t\t//    event.stopPropagation();\n\n\t\t}\n\t\telse if (event.ctrlKey)\n\t\t{\n\t\t\tvar delta = 0;\n\t\t\tif (event.wheelDelta != undefined) {\n\t\t\t\tdelta = event.wheelDelta / (_this.camera.wheelPrecision * 40);\n\t\t\t}\n\t\t\telse if (event.detail != undefined) {\n\t\t\t\tdelta = -event.detail / _this.camera.wheelPrecision;\n\t\t\t}\n\t\t\tif (delta)\n\t\t\t{\n\t\t\t\t_this.camera.inertialRadiusOffset += delta*_this.viewer.getMinVoxSize();\t\t\t\t\n\t\t\t\t_this.viewer.gl.sync3DViews(_this.camera.inertialAlphaOffset,_this.camera.inertialBetaOffset,\n\t\t\t\t\t\t\t_this.camera.inertialPanningX,_this.camera.inertialPanningY,_this.camera.inertialRadiusOffset );\n\t\t\t}\n\t\t\t\n\t\t\tsetTimeout(_this.viewer.gl.setQuality,350);\n\t\t//\tevent.preventDefault();\n\t\t//\tevent.stopPropagation();\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar pickResult = _this.scene.pick(event.offsetX, event.offsetY,undefined,undefined,_this.viewer.gl.camera);\n\t\t\tif (pickResult.pickedMesh)\n\t\t\t{\n\t\t\t\tvar i= [[0,1,2]]; i[_this.viewer.nii.permutationOrder[0]] = 0;  i[_this.viewer.nii.permutationOrder[1]] = 1; i[_this.viewer.nii.permutationOrder[2]] = 2;\t\t\t\t\t\n\t\t\t\tvar amount = (event.wheelDelta || -event.detail)/800;\t\t\t\t\t\t\t\n\t\t\t\t_this.viewer.handleSliceChange(_this.viewer.gl.slice(pickResult,true),amount);\n\t\t\t//\tevent.preventDefault();\n\t\t\t//    event.stopPropagation();\n\t\t\t\n\t\t\t}\n\t\t\n\t\t}\n\t\tevent.returnValue = false;\n\t    return false;\n\t});\n\telement.addEventListener("mouseleave", this._onMouseLeave, false);\n//\telement.addEventListener("mousemove", moveUnlagger(this._onMouseMove,\'cloneEvent\'), false);\n\telement.addEventListener("mousemove", this._onMouseMove, false);\n\telement.addEventListener("MSPointerDown", this._onGestureStart, false);\n\telement.addEventListener("MSGestureChange", this._onGesture, false);\n\t\n\tif (/Firefox/i.test(navigator.userAgent))\n\t{\n\t\t this._wheel = moveUnlagger(this._wheel,\'cloneEvent\')\n\t\t element.addEventListener( "DOMMouseScroll", this._wheel);\t \n\t}\n\telse\n\t{\n         element.addEventListener( "mousewheel", this._wheel);\t\n\t}\n    //var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" //FF doesn\'t recognize mousewheel as of FF3.x\n\t//element.addEventListener(mousewheelevt, this._wheel);\n\n\n\tBABYLON.Tools.RegisterTopRootEvents([\n\t\t{ name: "keydown", handler: this._onKeyDown },\n\t\t{ name: "keyup", handler: this._onKeyUp },\n\t\t{ name: "blur", handler: this._onLostFocus }\n\t]);\n\n\treturn this;\n\n\n};\nArcRotateCameraPointersInput.prototype.detachControl = function (element) {\n\tif (element && this._observer) {\n\t\tthis.camera.getScene().onPointerObservable.remove(this._observer);\n\t\tthis._observer = null;\n\t\telement.removeEventListener("contextmenu", this._onContextMenu);\n\t\telement.removeEventListener("mousemove", this._onMouseMove);\n\t\telement.removeEventListener("mouseleave", this._onMouseLeave);\n\t\telement.removeEventListener("MSPointerDown", this._onGestureStart);\n\t\telement.removeEventListener("MSGestureChange", this._onGesture);\n\t\telement.removeEventListener("mousewheel", this._wheel, false);\n\n\t\tthis._isRightClick = false;\n\t\tthis._isCtrlPushed = false;\n\t\tthis.pinchInwards = true;\n\t\tthis._onKeyDown = null;\n\t\tthis._onKeyUp = null;\n\t\tthis._onMouseMove = null;\n\t\tthis._onGestureStart = null;\n\t\tthis._onGesture = null;\n\t\tthis._MSGestureHandler = null;\n\t\tthis._onLostFocus = null;\n\t\tthis._onContextMenu = null;\n\t}\n\tBABYLON.Tools.UnregisterTopRootEvents([\n\t\t{ name: "keydown", handler: this._onKeyDown },\n\t\t{ name: "keyup", handler: this._onKeyUp },\n\t\t{ name: "blur", handler: this._onLostFocus }\n\t]);\n};\nArcRotateCameraPointersInput.prototype.getTypeName = function () {\n\treturn "ArcRotateCameraPointersInput";\n};\nArcRotateCameraPointersInput.prototype.getSimpleName = function () {\n\treturn "pointers";\n};\n\n\n\n\n\n\n\nfunction initBabylon(onBabylon)\n{\n\n     scriptLoader.loadScript(\'babylon.js\', function() { \n\n     scriptLoader.loadScript(\'babylon.objFileLoader.js\', function() { \n\n\n\n\n\tBABYLON.Effect.ShadersStore.fiberColorVertexShader = "precision highp float;"+\n\t"attribute vec3 position;"+\n\t"attribute vec4 color;"+\n\t"varying vec4 vcolor;"+\n\t"varying vec4 ptmp;"+\n\t"uniform mat4 worldViewProjection;"+\n\t"uniform mat4 worldToVoxel;"+\n\t"uniform vec3 planesPos;" +\n\t"uniform float planesNum;" +\n\t"uniform float planesThres;" +\n\t"uniform float planesProj;" +\n\t"void main(void) { vcolor = color;"+\n\t"   ptmp = worldToVoxel * vec4(position,1.0);"+\n\t"   if (planesNum < 0.0) { " +\n\t\t"\t    gl_Position = worldViewProjection * ptmp; } "+\n\t"   else if (planesNum < 0.5) { " +\n\t\t"   if (sign(planesThres)*abs(ptmp[0]-planesPos[0]) <  planesThres) { "+\n\t\t"       if (planesProj > 0.0) ptmp[0] = planesPos[0]; " + \n\t\t"\t    gl_Position = worldViewProjection * ptmp; } "+\n\t\t"   else { " + \n\t\t"       gl_Position = vec4(0.0,0.0,1000000000000.0,0.0);  } } " + \n\t"   else if (planesNum < 1.5) { " +\n\t\t"   if (sign(planesThres)*abs(ptmp[1]-planesPos[1]) <  planesThres) { "+\n\t\t"       if (planesProj > 0.0) ptmp[1] = planesPos[1]; " + \n\t\t"\t    gl_Position = worldViewProjection * ptmp; } "+\n\t\t"   else { " + \n\t\t"       gl_Position = vec4(0.0,0.0,1000000000000.0,0.0);  } } " + \n\t"   else { " +\n\t\t"   if (sign(planesThres)*abs(ptmp[2]-planesPos[2]) <  planesThres) { "+\n\t\t"       if (planesProj > 0.0) ptmp[2] = planesPos[2]; " + \n\t\t"\t    gl_Position = worldViewProjection * ptmp; } "+\n\t\t"   else { " + \n\t\t"       gl_Position = vec4(0.0,0.0,1000000000000.0,0.0);  } } " + \n\t"}";\n\n\n\tBABYLON.Effect.ShadersStore.fiberColorPixelShader = "precision highp float;"+\n\t"varying vec4 vcolor; uniform vec4 col; uniform float alpha; uniform float hover; float tex; float tox=0.7; void main(void) {"+\n\t" if (col[3]==0.0) "+\n\t\t\t" { gl_FragColor = vcolor;  }  "+\n\t" else {gl_FragColor = col; tex = 0.3*(vcolor[3]-0.5);  "+\n\t\t\t "  gl_FragColor[0] = vcolor[0]*(1.0-tox)+gl_FragColor[0]*tox+tex; "+\n\t\t\t "  gl_FragColor[1] = vcolor[1]*(1.0-tox)+gl_FragColor[1]*tox+tex;  "+\n\t\t\t "  gl_FragColor[2] = vcolor[2]*(1.0-tox)+gl_FragColor[2]*tox+tex;}" +\n\t" gl_FragColor[0] += hover; gl_FragColor[1] += hover; gl_FragColor[2] += hover;  gl_FragColor[3]=alpha;  } ";\n\n\n\n\tBABYLON.Effect.ShadersStore.mySurfcolVertexShader = "precision highp float;"+\n\t"attribute vec3 position;"+\n\t"attribute vec3 normal;"+\n\t"attribute vec4 color;"+\n\t"uniform float alpha;" +\t\t\n\t"varying vec3 vNormal;"+\t\n\t"varying vec4 ptmp;"+\t\n\t"uniform mat4 worldViewProjection;"+\n\t"uniform mat4 worldToVoxel;"+\n\t"uniform vec3 planesPos;" +\n\t"uniform vec3 uniformcolor;" +\n\t"uniform float vertexcoloring;" +\n\t"varying vec4 col;"+\n\t"void main(void) { "+\t\n\t"   if (vertexcoloring > 0.5) "+\n\t"     { col[0] = color[0]; col[1] = color[1]; col[2] = color[2]; col[3] = color[3]; } " + \n\t"   else "+\n    "     { col[0] = uniformcolor[0]; col[1] = uniformcolor[1]; col[2] = uniformcolor[2]; col[3] = alpha; } " + \n//    "     { col[0] = 0.0; col[1] = 1.0; col[2] = 0.0; col[3] = 0.0; } " + \n\t"   gl_Position = worldViewProjection * vec4(position,1.0);"+\n\t"   ptmp = worldToVoxel * vec4(position,1.0) - vec4(planesPos,0.0);"+\t\n\t"   vNormal = normal; " +\n\t"}";\n\n\tBABYLON.Effect.ShadersStore.mySurfcolPixelShader = "precision highp float;"+\n\t"varying vec4 col;"+\n\t"varying vec3 vNormal;"+\t\n\t"varying vec4 ptmp;"+\t\n\t"float fac;"+\n\t"uniform mat4 worldViewProjection;"+\n\t"uniform float planesThres;" +\t\n\t"uniform float gamma;" +\t\n\t"uniform float alpha;" +\t\n\t"uniform vec3 planesCut;" +\n\t"void main(void) {"+\n\t"    if (planesThres != 0.0){ "+\n\t"    \tif((ptmp[0] >planesThres || ptmp[0] < -planesThres)  && "+\n\t"    \t   (ptmp[1] >planesThres || ptmp[1] < -planesThres)  && "+\n\t"          (ptmp[2] >planesThres || ptmp[2] < -planesThres) )   "+\n\t"           discard; } " +\n\t"    else "+\n\t"       if (    (ptmp[0]*planesCut[0] >= 0.5 || planesCut[0] == 0.0) "+\n\t"\t\t\t&&  (ptmp[1]*planesCut[1] >= 0.5 || planesCut[1] == 0.0) "+\n\t"\t\t\t && (ptmp[2]*planesCut[2] >= 0.5 || planesCut[2] == 0.0))"+\n    "        \tdiscard; "+\n\t"    vec3 vNormalW = normalize(vec3(worldViewProjection * vec4(vNormal, 0.0)));" +\n\t"    if (vNormalW[2] > 0.0 && alpha < 1.0) { discard; } " +\t\n\t"    fac = pow(abs(vNormalW[2]),gamma);"+\n\t"\t gl_FragColor[0] = fac*col[0];"+\n\t"\t gl_FragColor[1] = fac*col[1];"+\n\t"\t gl_FragColor[2] = fac*col[2];"+\n\t"\t gl_FragColor[3] = col[3];"+\n\t"}";\n\n\n\tonBabylon();\n\n\n     });\n     });\n\n\n}'},function(t,n){t.exports='\n// ======================================================================================\n// ======================================================================================\n// ============= KPrototypeViewer\n// ======================================================================================\n// ======================================================================================\n\n\n\nfunction KPrototypeViewer(viewport, master)\n{\n\t/**  @class \n\t   *  @alias KPrototypeViewer */\n    var that = new Object();\n\n    that.viewport = viewport;\n    that.$container = $("<div class=\'KViewPort_icontainer\'></div>");\n    that.$topRow    = $("<div class=\'KViewPort_topRow\'></div>").appendTo(that.$container);\n   \n\n\n    // ======================================================================================\n    /**  @class \n\t   *  @alias KToolbar */\n    \n    that.toolbar = {};\n    that.toolbar.$container = $("<div class=\'KViewPort_toolbar\'></div>").appendTo(that.$topRow).click(function(ev){return false;});\n\n    that.toolbar.$container.on("mousemove",function(e)\n    {\n\t\tif (!that.toolbar.issticky)\n\t\t{\n\n        \tvar $t = $(e.target);\n        \tfor (var k = 0; k < 3;k++)\n        \t{\n        \t    if ($t.hasClass("minimized"))\n        \t        return\n        \t    $t = $t.parent()\n        \t}\n\n\n\t\t\tif (that.toolbar.stdelay != undefined)\n\t\t\t\tclearTimeout(that.toolbar.stdelay)\n\t\t\tthat.toolbar.stdelay = setTimeout(function(){\n\t\t\t   that.toolbar.show_addons(e);\n\t\t\t   that.toolbar.stdelay = undefined\n\t\t\t},150);\n\n\t\t\tif (that.toolbar.id != undefined)\n\t\t\t\tclearTimeout(that.toolbar.id);\n\t\t\tthat.toolbar.id = setTimeout(function(){\n\t\t\t\tthat.toolbar.hide_addons();\n\t\t\t\tthat.toolbar.id = undefined;\n\t\t\t},2500);\n\t\t}\n    });\n    that.toolbar.$container.on("mouseleave",function()\n    {\n    \tif (that.toolbar.stdelay != undefined)\n    \t    clearTimeout(that.toolbar.stdelay)\n        \n    });\n\n    that.toolbar.$dragdiv = $("<div  class=\'KViewPort_tool draganddrop\'>  <i class=\'fa fa-fw fa-hand-paper-o fa-1x\'></i></div>").appendTo(that.toolbar.$container).appendTooltip("dragdropviewport")\n\tattachhandhover(that.toolbar.$dragdiv);\n    that.toolbar.$dragdiv.attr("draggable",\'true\');\n    that.toolbar.$dragdiv.on(\'mousedown\',function(e){e.stopPropagation()})\n\tthat.toolbar.$dragdiv[0].ondragstart = dragstarter(function() { \n       return { type:\'file\', mime: that.contentType, filename: that.currentFilename,  fileID: that.currentFileID}; } ) \n\n\n\n    that.toolbar.$zoom = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-expand fa-1x\'></i></div>")\n                     .click(function(e) {  e.stopPropagation(); viewport.zoomViewPort(); return false; })\n\t\t\t\t\t .on(\'mousedown\',function(e){e.stopPropagation()})\n                     .appendTo(that.toolbar.$container).appendTooltip("zoomviewport")\n    that.toolbar.$screenshot = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-camera fa-1x\'></i></div>")\n\t\t\t\t\t .on(\'mousedown\',function(e){e.stopPropagation()})\n                     .click(takeScreenshot).appendTo(that.toolbar.$container).appendTooltip("screenshot")\n\n\tif (KViewer.standalone)\n\t{\n\t\tthat.toolbar.$screenshot.hide();\n\t}\n\n    that.toolbar.$close = $("<div  class=\'KViewPort_tool KViewPort_tool_close\'>  <i class=\'fa fa-close fa-1x\'></i></div>")\n                     .click(function() { that.close(); }).appendTo(that.toolbar.$container)\n                     .mousedown(viewport.closeContextMenu()).appendTooltip("closeviewport")\n\t\n\n\tthat.toolbar.hide_mainview = function()\n\t{\n\t\t $(\t that.toolbar.$container.find(".KToolbarSep")[0]).prevAll().addClass("KTool_displaynone");\n\t}\n\tthat.toolbar.show_mainview = function()\n\t{\n\t\t $(\t that.toolbar.$container.find(".KToolbarSep")[0]).prevAll().removeClass("KTool_displaynone");\n\t}\n\tthat.toolbar.reset_mainview = function()\n\t{\n\t\t $(\t that.toolbar.$container.find(".KToolbarSep")[0]).prevAll().attr("style","")\n\t}\n\n\n\tthat.toolbar.get_addons = function(e)\n\t{\n\t\tif (e == undefined)\n\t\t    return that.toolbar.$container.find(".KToolbarSep").find(".KViewPort_tool").not("input, .persistent, .caption, .draganddrop, .KViewPort_tool_cmap, .KToolbar_sticky");\n\t\telse\n\t\t{\n\t\t\tif (e.target != undefined)\n\t\t\t{\n\t\t\t\tvar $t = $(e.target);\n\t\t\t\treturn $t.nextUntil("br").add($t.prevUntil("br"))\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\treturn $(e).find(".KViewPort_tool").not("input, .persistent, .caption, .draganddrop, .KViewPort_tool_cmap, .KToolbar_sticky");\n\t\t\t}\n\n\n\t\t}\n\t}\n\tthat.toolbar.hide_addons = function()\n\t{\n\t\tthat.toolbar.get_addons().addClass("KTool_hidden");\n\t\n\t\tsetTimeout(function(){ \n\t\t    that.toolbar.get_addons().addClass(\'KTool_displaynone\') \n\t        that.toolbar.$container.find(".KViewPort_tool.caption").addClass("equalwidth");\n\t\t},500);\n\t}\n\tthat.toolbar.show_addons = function(e)\n\t{\t\n\t    if (e == undefined || $(e.target).hasClass("KViewPort_tool"))\n\t    {\n\t\t\tvar $thesep = that.toolbar.get_addons(e);\n\t\t\tif ($thesep.length == 1)\n\t\t\t{\n\t\t\t\t$thesep.addClass(\'KTool_displaynone\');\n\t\t\t\treturn;\n\t\t\t}\n\t\t\t$thesep.removeClass("KTool_hidden KTool_displaynone");\n            $thesep.removeClass("equalwidth");\n\n\t\t\tif (!that.toolbar.issticky)\n\t\t\t{\n\t\t\t\tif (that.toolbar.id != undefined)\n\t\t\t\t\tclearTimeout(that.toolbar.id);\n\t\t\t\tthat.toolbar.id = setTimeout(function(){\n\t\t\t\t\tthat.toolbar.hide_addons();\n\t\t\t\t\tthat.toolbar.id = undefined;\n\t\t\t\t},2500);\n\t\t\t}\n\t    }\n\t}\n\n    that.toolbar.$stickydiv = $("<div  class=\'KViewPort_tool KToolbar_sticky\'>  <i class=\'fa fa-fw fa-circle-o fa-1x\'></i></div>");\n\tthat.toolbar.issticky = (ViewerSettings.stickytoolbar==undefined) || ViewerSettings.stickytoolbar;\n\tvar toggleSticky = function(){\n\t\tif (that.toolbar.id != undefined)\n\t\t\t\tclearTimeout(that.toolbar.id);\n\t\tthat.toolbar.issticky = !that.toolbar.issticky;\n\t\tViewerSettings.stickytoolbar = that.toolbar.issticky\n\t\tsignalhandler.send("stickychanged");\n\t}\n\n    function updateSticky()\n    {\n\t\tif (!that.toolbar.issticky)\n\t\t{\n            //that.toolbar.$container.find(".Kmintoolsep").show()\n\t\t\tthat.toolbar.$stickydiv.find("i").removeClass("fa-circle").addClass("fa-circle-o");\n\t\t\tthat.toolbar.hide_addons();\n\t\t}\n\t\telse\n\t\t{\n           // that.toolbar.$container.find(".Kmintoolsep").hide()\n\t\t\tthat.toolbar.$container.find(".KToolbarSep").removeClass("minimized");\n\t\t\tthat.toolbar.$container.find(".KViewPort_tool.caption").removeClass("equalwidth");\n\n\t\t\tthat.toolbar.$stickydiv.find("i").removeClass("fa-circle-o").addClass("fa-circle");\n            that.toolbar.show_addons()\n\n\t\t}\n\t}\n\n    signalhandler.attach("stickychanged",function()\n    {\n         that.toolbar.issticky = ViewerSettings.stickytoolbar\n\t\t updateSticky()\n\n    })\n\n\n\tif (that.toolbar.issticky)\n\t\t\tthat.toolbar.$stickydiv.find("i").removeClass("fa-circle-o").addClass("fa-circle");\n\tthat.toolbar.$stickydiv.click(toggleSticky);\n\n\tvar types = [\'overlay\',\'roi\',\'atlas\',\'fiber\',\'surface\',\'cmat\',\'sticky\'];\n\tfor (var k = 0; k < types.length;k++)\n\t{  \n    \tthat.toolbar[types[k]] = {};\n    \tthat.toolbar[types[k]].$div = $("<div class=\'KToolbarSep\'> </div>").appendTo(that.toolbar.$container);\n    \tif (types[k] != "sticky")\n    \t{\n    \t    that.toolbar[types[k]].$sep = $("<div class=\'Kmintoolsep\'> <i class=\'fa fa-minus-square-o\'></i></div>").appendTo(that.toolbar[types[k]].$div);\n    \t    that.toolbar[types[k]].$sep.hide();\n    \t    that.toolbar[types[k]].$sep.on("mousedown",function(t) { return function(){\n    \t    \tvar a = that.toolbar[t]\n    \t    \tif (!a.$div.hasClass("minimized"))\n    \t    \t{\n\t\t\t\t\ta.$div.addClass("minimized")\n\t\t\t\t\ta.$sep.find("i").removeClass("fa-minus-square-o").addClass("fa-plus-square-o")\n\t\t\t\t\tthat.toolbar.get_addons(a.$div).addClass("KTool_hidden").addClass(\'KTool_displaynone\') \n\t\t\t\t    that.toolbar.$container.find(".KViewPort_tool.caption").addClass("equalwidth");\n\n    \t    \t}\n    \t    \telse\n    \t    \t{\n\t\t\t\t\ta.$div.removeClass("minimized")\n\t\t\t\t\ta.$sep.find("i").addClass("fa-minus-square-o").removeClass("fa-plus-square-o")  \n\t\t\t\t\tif (that.toolbar.issticky)\n\t\t\t\t\t{\n \t  \t  \t \t\t    that.toolbar.get_addons(a.$div).removeClass("KTool_hidden").removeClass(\'KTool_displaynone\') \n\t\t\t\t\t    that.toolbar.$container.find(".KViewPort_tool.caption").removeClass("equalwidth");\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t    that.toolbar.$container.find(".KViewPort_tool.caption").addClass("equalwidth");\n  \t    \t\t\n    \t    \t}\n    \t    } }(types[k]) );\n    \t}\n\t}\n\n\n    that.toolbar.$info= $("<span class=\'KViewPort_title\'></span>").appendTo(that.$container);\n\n\tthat.toolbar.$info.attr("draggable",\'true\');\n\tthat.toolbar.$info.on(\'mousedown\',function(e){e.stopPropagation()})\n\t.on("dragstart", dragstarter(function() { \n    return { intent:{viewport:that.viewport.viewPortID}, type:\'file\', mime: that.contentType, filename: that.currentFilename,  fileID: that.currentFileID}; } ) );\t\n\n\tthat.toolbar.$info.click(function(ev){\n\t\t\n\t\tev.stopPropagation();\n\t\tev.preventDefault();\n        that.$container.off(\'mousemove\');\n\n   \t\tif (KViewer.zoomedViewport != -1)\n        {\n           if (!that.viewport.isZoomed())\n           {\n               KViewer.unZoomViewport();\n               that.viewport.zoomViewPort();\n           }\n           else\n                that.viewport.zoomViewPort();\n          \n        } });\n\n\n    /** @function */\n\tthat.toolbar.attachhandhover = attachhandhover;\n\tfunction attachhandhover($ddiv)\n\t{\n\t\t$ddiv.on(\'mouseenter\',function(){\n\t\t\t$ddiv.find("i").addClass(\'fa-hand-grab-o\');\n\t\t\t$ddiv.find("i").removeClass(\'fa-hand-paper-o\');\n\t\t});\n\t\t$ddiv.on(\'mouseleave\',function(){\n\t\t\t$ddiv.find("i").removeClass(\'fa-hand-grab-o\');\n\t\t\t$ddiv.find("i").addClass(\'fa-hand-paper-o\');\n\t\t});\n\n\t}\n\n\n    /** @function */\n\tthat.toolbar.attach = function($t)\n\t{\n\t\t$t.insertAfter(that.toolbar.$dragdiv);\n\n\t\treturn that.toolbar;\n\t}\n\n    /** @function */\n\n\tthat.toolbar.append = function(divs,type)\n\t{\n\t\tvar $where = that.toolbar[type].$div ;\t        \n\t\tfor (var k = divs.length-1; k >= 0; k--)\n\t\t\tdivs[k].appendTo($where);\n\t//\tif (that.toolbar.issticky)\n\t//\t   that.toolbar.show_addons();\n\t\tif (that.toolbar[type].$div.find("br").length >2)\n\t\t    that.toolbar[type].$sep.show();\n\n\t}\n\n\tthat.toolbar.update = function(type)\n\t{\n \t    if (type == undefined)\n \t       t = types;\n \t    else\n \t       t = [type];\n \t    for (var k = 0; k < t.length;k++)\n \t    {\n \t    \tif (that.toolbar[t[k]].$sep != undefined)\n \t    \t {\n\t\t\t\tif (that.toolbar[t[k]].$div.find("br").length >2)\n\t\t\t\t\tthat.toolbar[t[k]].$sep.show();\n\t\t\t\telse\n\t\t\t\t\tthat.toolbar[t[k]].$sep.hide();\n \t    \t }\n \t    }\n\t}\n\n\tthat.toolbar.appendAfter = function(divs,which)\n\t{\n\t\tvar $after = that.toolbar.$container.find(which.divs[0]);\n\t\tfor (var k = 0; k < divs.length; k++)\n\t\t\tdivs[k].insertAfter($after);\n\t\tif (that.toolbar.issticky)\n    \t\tthat.toolbar.show_addons();\n    \tif (which.type != undefined)\n\t\t\tif (that.toolbar[which.type].$div.find("br").length >2)\n\t\t\t\tthat.toolbar[which.type].$sep.show();\n\n\t}\n\n\n\n    /** @function */\n    that.toolbar.show = function()\n    {\n        that.toolbar.$container.show();\n        that.toolbar.show_mainview();\n\t\t\n        that.toolbar.$container.css(\'opacity\',1);\n        var divs = Object.keys(that.toolbar)\n\n\n    }\n     \n    /** @function */\n    that.toolbar.hide = function()\n    {\n        that.toolbar.$container.hide();\n    }\n\n\tthat.toolbar.append([that.toolbar.$stickydiv],\'sticky\');\n\n\n\n    // ======================================================================================\n\t/**  @class \n\t   *  @alias KLayoutBar */\n\n\tthat.layoutbar = {};\n\tthat.layoutbar.opacity = 0.3;\n\tthat.layoutbar.$container = $("<div class=\'KViewPort_layoutbar\'></div>").appendTo(that.$container).click(function(ev){return false;});\n\tthat.layoutbar.$container.on("mouseenter",function()\n\t{\n\t\t\tthat.layoutbar.$container.css(\'opacity\',1);\n\t});\n\tthat.layoutbar.$container.on("mouseleave",function()\n\t{\n\t\t\tthat.layoutbar.$container.css(\'opacity\',that.layoutbar.opacity);\n\t});\n\tthat.layoutbar.$zoomin = $("<div class=\'KViewPort_tool_layout\'><i class=\'fa fa-search-plus fa-1x\'></i></div>").appendTo(that.layoutbar.$container);\n\tthat.layoutbar.$zoomout = $("<div class=\'KViewPort_tool_layout\'><i class=\'fa fa-search-minus fa-1x\'></i></div>").appendTo(that.layoutbar.$container);\n\t/** @function */\n\tthat.layoutbar.attach = function($t)\n\t{\n\t\t\t$t.insertBefore(that.layoutbar.$zoomin);\n\t\t\treturn that.layoutbar;\n\t}\n\t/** @function */\t\n    that.layoutbar.show = function() {that.layoutbar.$container.show();}\n\t/** @function */    \n\tthat.layoutbar.hide = function() {that.layoutbar.$container.hide();}\n\n\tthat.layoutbar.$container.css(\'opacity\',that.layoutbar.opacity);\n\n\n    // ======================================================================================\n\n\n\t\n\tthat.statusbar = {};\n\tthat.statusbar.opacity = 0.3;\n\tthat.statusbar.$container = $("<div class=\'KViewPort_statusbar\'> good morning </div>").appendTo(that.$container).click(function(ev){return false;}).hide();\n\tthat.statusbar.report = function(string)\n\t{\n\t\tvar that = this;\t\t\n\t\tthat.$container.text(string);\n\t\tthat.$container.fadeIn(300);\n\t\tif (that.sid != -1)\n\t\t\tclearTimeout(that.sid);\n\t\tthat.sid = setTimeout(function(){\n\t\t\tthat.$container.fadeOut(500);\n\t\t\tthat.sid = -1;\t\t\t\n\t\t},2000);\n\n\t}\n\n    /** @function */\n    function takeScreenshot()\n    {\n\n\t  // find normal or 3D canvas, whichever is visible\n\t  var $C = that.$container.find(".KViewPort_canvas:visible, .KViewPort_canvas3D:visible");\n\t  if($C.length > 0)\n\t  {\n\n\t\t var blob = dataURItoBlob($C.get(0).toDataURL());\n\t\t var finfo = that.viewport.getCurrentViewer().currentFileinfo;\n\t\t saveScreenShot(blob,finfo);\t\t\n\t\t $(".KViewPort_container").removeClass(\'noBorder\');\n\t\t\n\t  }\n\t  else\n\t  {\n\t\t  KViewer.toggleElementsForScreenShot();\n\t\t  $(".KViewPort_container").addClass(\'noBorder\');\n\n\t\t  html2canvas(that.$container).then(function(canvas)\n\t\t  {\n\t\t\t var blob = dataURItoBlob(canvas.toDataURL());\n\t\t\t var finfo = that.viewport.getCurrentViewer().currentFileinfo;\n\t\t\t saveScreenShot(blob,finfo);\n\t\t\t KViewer.toggleElementsForScreenShot();\n\t\t\t $(".KViewPort_container").removeClass(\'noBorder\');\n\n\t\t  });   \n\t  }\n    }\n\n\tthat.getCanvas = function()\n\t{\n\t\t  var $C = that.$container.find(".KViewPort_canvas:visible, .KViewPort_canvas3D:visible");\n\t\t  if($C.length == 0)\n\t\t  {\n\t\t\tconsole.log("no canvas found.")\n\t\t\treturn false;\n\t\t  }\n\t\t  return $C;\n\t\t  //return dataURItoBlob($C.get(0).toDataURL())\n\n\t}\n\n\n    /** @function */\n    that.setInnerLayout = setInnerLayout;\n    that.setInnerLayout_parent = that.setInnerLayout;  \n    function setInnerLayout()\n    {\n        $ref = viewport.isZoomed()?master.$zoomedPortContainer:viewport.$container;\n        that.$container.width($ref.width());\n        that.$container.height($ref.height());\n    }\n\n    /** @function */    \n    that.detachContent = detachContent;\n    function detachContent()\n    {\n      that.$container.detach();\n    }\n\n    /** @function */\n    that.prepViewer = function (ev,params)\n    {\n        that.currentFilename = ev.filename;\n        that.currentFileinfo = ev.fileinfo;\n        that.currentFileID = ev.fileID;\n        that.contentType = ev.contentType;\n        that.content = ev;\n        \n        viewport.setCurrentViewer(that);\n    \tthat.toolbar.$info.html(ev.filename);\n\t\tif (params && params.hideControls)\n        \tthat.toolbar.hide();\n        else\n        \tthat.toolbar.show();\n        \t\n    }\n\n    /** @function */\n\tthat.showControls = function() { \n\t    that.toolbar.show(); that.layoutbar.show(); };\n    /** @function */\n\tthat.hideControls = function() { that.toolbar.hide(); that.layoutbar.hide(); };\n\n    /** @function */\n    that.close = close;\n    function close()\n    {\n    \tif (that.currentFileID != undefined)\n    \t{\n\t\t\tif (that.customClose != undefined)\n\t\t\t\tthat.customClose();\n\t\t\tthat.toolbar.hide();\n\t\t\tthat.currentFileID = undefined;\n\t\t\tviewport.close();\n    \t}\n\n    }\n \n\n    signalhandler.attach("close",function() { that.close() });\n\n    that.closeUnreferenced = function()\n    {\n  \t   var found = false;\n  \t   for (var k in KViewer.viewports)\n  \t   {\n  \t   \t   if (KViewer.viewports[k] != that.viewport)\n  \t   \t     if (KViewer.viewports[k].getCurrentViewer() != undefined\n  \t   \t       && KViewer.viewports[k].getCurrentViewer().currentFileID == that.currentFileID)\n  \t   \t       {\n  \t   \t       \t found = true;\n  \t   \t       }\n  \t   }\n  \t   if (!found)\n  \t   {\n  \t   \t    KViewer.dataManager.delFile(that.currentFileID);\n  \t   \t    KViewer.cacheManager.update();\n  \t   }\n    }\n\n\n    return that;\n\n}\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= VIERWERJS\n// ======================================================================================\n// ======================================================================================\n\nfunction KViewerJS(parent_viewport_, master_)\n{\n  var that = new Object();\n\n  that.viewerType = \'ViewerJS\';\n\n  var viewport = parent_viewport_;\n  var master = master_;\n\n  var $container = $("<div class=\'KViewPort_icontainer\'></div>");that.$container = $container;\n  var $topRow    = $("<div id=\'KViewPort_topRow\'></div>").appendTo($container);\n\n  var toolbar = new Object();\n  toolbar.$container = $("<div class=\'KViewPort_toolbar\'></div>").appendTo($topRow);\n  toolbar.$close = $("<div  class=\'KViewPort_tool KViewPort_tool_close\'>  <i class=\'fa fa-close fa-1x\'></i></div>").click(function() { close(); }).appendTo(toolbar.$container)\n                     .mousedown(viewport.closeContextMenu());\n\n  toolbar.$zoom = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-expand fa-1x\'></i></div>").click(function() { \n\n  viewport.zoomViewPort(); }).hide().appendTo(toolbar.$container);\n\n  that.toolbar = toolbar;\n\n  var $div =  $("<div class=\'KViewPort_ViewerJS\'></div>").appendTo($container);\n\n  var $viewer;\n\n\n\n  that.setContent = setContent;\n\n  function setContent(ev)\n  {\n    that.currentFileID = ev.fileID;\n    that.currentFilename = ev.filename;\n\n    viewport.setCurrentViewer(that);\n    var caller = \'/VEO/ViewerJS/#\' + myownurl + \'?fileID=\' + ev.fileID + "&asuser="+userinfo.username + "#" + ev.filename;\n\n    $viewer = $("<iframe id=\'viewerjs\' src = \'"+caller+"\' ></iframe>");\n\n\n    $div.append($viewer);\n    $div.show();\n\n    toolbar.$zoom.show();\n    toolbar.$close.show();\n\n    setImageLayout();\n\n  }\n\n  that.detachContent = detachContent;\n  function detachContent()\n  {\n    //$container.detach();\n  }\n\n  that.setInnerLayout = setImageLayout;\n  function setImageLayout()\n  {\n    $ref = viewport.isZoomed()?master.$zoomedPortContainer:viewport.$container;\n    $container.width($ref.width());\n    $container.height($ref.height());\n    if ($ref.find("#viewerjs").length == 0)\n        $container.appendTo($ref);\n\n    $viewer.width($container.width()*1);\n    $viewer.height($container.height()*1);\n\n  }\n\n   function close()\n    {\n    \tif (that.currentFileID != undefined)\n    \t{\n\t\t\ttoolbar.$close.hide();\n\t\t\ttoolbar.$zoom.hide();\n\n\t\t\tthat.currentFileID = undefined;\n\t\t\t$viewer.remove();\n\t\t\t$div.hide();\n\t\t\tviewport.close();\n    \t}\n\n    }\n    that.close = close;\n    signalhandler.attach("close",close);\n\n\n  return that;\n\n}\n\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= KJsonViewer\n// ======================================================================================\n// ======================================================================================\n\n\nfunction KJsonViewer(viewport,master)\n{\n  /**  @class \n    *  @alias KJsonViewer \n\t*  @augments KPrototypeViewer */\n  var that = KPrototypeViewer(viewport, master);\n\n  that.viewerType = \'jsonViewer\';\n\n  var toolbar = that.toolbar;\n  toolbar.$save = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-save fa-1x\'></i></div>")\n        .click(function() { \n\t\t\tvar myquery = [[]];\n\t\t\tif (that.currentFileID.substr(0,4) == \'meta\')\n\t\t\t{\n\t\t\t\tvar psid = that.currentFileID.substr(5).split(\'#\')\n\t\t\t\tif (psid.length <= 2)\n\t\t\t\t{\n\t\t\t\t\tvar sid = "%";\n\t\t\t\t\tvar obj = json_obj\n\t\t\t\t\tif (psid.length == 2)\n\t\t\t\t\t{\n\t\t\t\t\t\t sid = "#"+psid[1];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\t obj = json_obj[\'STUDIES\'];\n\n\n\t\t\t\t\tmyquery[0].push({command:\'save_patientinfo_studyinfo\' ,json:{piz:psid[0],sid:sid,content:obj }});\n\t\t\t\t\tajaxRequest( myquery, function(e) {\n\t\t\t\t\t\talertify.success("studyinfo saved");\n\n\t\t\t\t\t\t});\n\t\t\t\t}\n\n\n\n\n         \t}\n         \telse\n         \t{\n\n\t\t\t  uploadJSON(that.currentFileinfo.Filename,json_obj,{subfolder:that.currentFileinfo.SubFolder});  \t \n              that.content.content=JSON.stringify(json_obj)\n\n         \t}\n\n         \t });\n  toolbar.attach(toolbar.$save);\n  that.layoutbar.$container.hide()\n\n  var json_obj;\n\n  var $div =  $("<div class=\'KViewPort_jsonViewer\'></div>").appendTo(that.$container);\n\n  var $a = $("<ol class=\'csstree\'></ol>");\n  $div.append($a);\n\n\n   var editable = true;\n  that.setContent = setContent;\n\n  function setContent(params,ev)\n  {\n\n    if (ev && ev.intent && ev.intent.singleview)\n    {\n    \ttoolbar.$dragdiv.hide();\n    \ttoolbar.$screenshot.hide()\n    \ttoolbar.$close.hide();\n    \ttoolbar.$zoom.hide();\n    }\n\n    var str = params.content;\n\ttry { d = JSON.parse(str.replace(/\\n/g,"\\\\n")); } catch(e)\n\t\t{\n\t\t\ttry { eval(\'d=\'+str); } catch(e)\n\t\t\t{\n\t\t\t\t KViewer.dataManager.delFile(params.fileID);\n\t\t\t\t KViewer.cacheManager.update()\n\t\t\t\talertify.error(\'Error: The json in this file seems to be corrupt!\');\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\t\n\tif (d == undefined)\n\t{\n\t\t KViewer.dataManager.delFile(params.fileID);\n\t\t KViewer.cacheManager.update()\n\t\talertify.error(\'Error: The json in this file seems to be corrupt!\');\n\t\treturn false;\n\t\t\n\t}\n\t\t\n// this is for the reading form, just extract the formcontent\n\tif(d.formcontent != undefined)\n\t\t\td = d.formcontent;\n\n\tif (ev && ev.intent && ev.intent.editable != undefined && ev.intent.editable == false)\n\t\teditable = false;\n\n\tif (!editable)\n\t\ttoolbar.$save.css(\'display\',\'none\');\n\telse\n\t\ttoolbar.$save.css(\'display\',\'inline-block\');\n    \n\tif (ev != undefined && ev.intent != undefined && ev.intent.field != undefined)\n\t{\n\t\t// this is the fileinfo subselector intent\n\t\tvar keyseq = ev.intent.field.split(".");\n\t\tfor (var k = 0; k < keyseq.length-1;k++)\n\t\t{\n\t\t\tvar d_try = d[keyseq[k]];\n\t\t\tif (d_try == undefined)\n\t\t\t{\n\t\t\t\td  = d[keyseq[k].substring(keyseq[k].length-4)];  // this compatibility to old seriesnumber stuff\n\t\t\t\tif (d == undefined)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\telse\n\t\t    \td = d_try;\n\t\t}\n\t\tif (d == undefined)\n\t\t{\n\t\t\td = {Info: "No series information available"};\n\t\t}\t\n\t\telse\n\t\t{\n\t\t\td;\n\t\t}\n\t\tvar dspec = {}\n        var sers = Object.keys(d)\n        for (var k = 0; k <sers.length;k++)\n        {\n        \tvar pat = ev.intent.objinfo.more.Filename.replace("\\.nii","")\n        \t.replace("\\.gz","")\n        \t.replace("\\.bvec","")\n        \t.replace("\\.bval","")\n        \t.replace("\\.json","")\n        \tif (sers[k].search(pat) > -1)\n        \t{\n        \t\tdspec[sers[k]] = d[sers[k]];\n        \t}\n        }\n        if (Object.keys(dspec).length > 0)\n            d = dspec;\n\n\n\t\tparams.filename = ev.intent.objinfo.more.Filename;\t\t\n\t}\n\n\tif (ev.intent &&  ev.intent.objinfo)\n\t{\n \t  d = $.extend(d,ev.intent.objinfo.more);\n\t}\n\n  \tthat.prepViewer(params);\n\n    var id = that.viewport.viewPortID;\n    $a.children().remove();\n\n\taddChildren(undefined,$a,d,undefined,editable);\n\n\tjson_obj = d;\n\n\n\n\tvar contextmenu = KContextMenu(\n\tfunction(ev) {\n\t\tev.preventDefault();\n\t\tev.stopPropagation();\n\t   var $menu = $("<ul class=\'menu_context\'>")\n\t   var $subul = $("<ul >")\n\t   if (editable)\n\t   {\n\t\t   $menu.append($("<li onchoice=\'newkey\'>insert key</li>"));\n\t\t   $menu.append($("<li onchoice=\'delete\'>delete key</li>"));\n\t   }\n\t   $menu.append($("<li onchoice=\'add\'>Use as meta index </li>"));\n\n\n\t   return $menu;\n\t},\n\tfunction (str,ev,ev2)\n\t{\n\t   if (str)\n\t   {\n\t\t\tvar path = $(ev2.target).parent().attr("path");\t   \t\n\t\t\tif (str == \'newkey\')\n\t\t\t{\n\t\t\t  var def = path + ",";\n\t\t\t  alertify.prompt({msg:\'Please give a name\'},\n\t\t\t  function(e,val)\n\t\t\t\t\t{ \n\t\t\t\t\t   if (e)\n\t\t\t\t\t   {\n\t\t\t\t\t\tvar sobj = {};\n\t\t\t\t\t\tvar obj = sobj;\n\t\t\t\t\t\tindex = val.split(",");\n\t\t\t\t\t\tfor (var k = 0; k <index.length-1;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tobj[index[k]] = {};\n\t\t\t\t\t\t\tobj = obj[index[k]];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t   \tobj[index[index.length-1]] = "undefined";\n\t\t\t\t\t\t$.extend(true,json_obj,sobj);\n\n\n\t\t\t\t\t\t$a.children().remove();\n\t\t\t\t\t\taddChildren(undefined,$a,json_obj,undefined,editable);\n\t\t\t\t\t   }\n\t\t\t\t\t},def);\n\n\t\t\t}\n\t\t\tif (str == \'delete\')\n\t\t\t{\n \t\t\t\tif (path != undefined)\n \t\t\t\t{\n \t\t\t\t\tvar obj = json_obj;\n \t\t\t\t\tindex = path.split(",");\n \t\t\t\t\tfor (var k = 0; k <index.length-1;k++)\n \t\t\t\t\t\tobj = obj[index[k]];\n \t\t\t\t\tdelete obj[index[index.length-1]];\n\t\t\t\t\t$a.children().remove();\n\t\t\t\t\taddChildren(undefined,$a,json_obj,undefined,editable);\n\n \t\t\t\t\t\t\n \t\t\t\t}\n\t\t\t}\n\t\t\tif (str == \'add\')\n\t\t\t{\n\t\t\t\tvar $tr =getOnParentPath( $(ev2.target),function(x) { return x.attr(\'path\') != undefined; });\n\t\t\t\tvar r = getIndexAndLevel($tr.attr(\'path\'));\n\t\t\t\tvar index = r.index;\n\t\t\t\tvar level = r.level;\n\n\t\t\t  var def;\n\t\t\t  if (index.length>2)\n\t\t\t\tdef = index[index.length-2] + \'_\' + index[index.length-1];\n\t\t\t  else\n\t\t\t\tdef = index[index.length-1];\n\n\t\t\t  alertify.prompt({msg:\'Please give a name for the metaindex (no special chars).<br>Start with "/" to share with all users.\' + index.toString() ,opt:["FLOAT","INT","STRING","MEDIUMTEXT"], optMsg:"Datatype of Index"},\t\t\t\t  \n\t\t\t  function(e,val)\n\t\t\t\t\t{ \n\t\t\t\t\t   if (e)\n\t\t\t\t\t   {\n\t\t\t\t\t\t var name = val.str;\n\t\t\t\t\t\t var shared = false; if(name[0] == "/"){ shared = 1; name = name.substring(1)};\n\t\t\t\t\t\t   \t\n\t\t\t\t\t\t name = name.replace(/[^\\w\\s]/gi, \'_\').replace(/ /g,\'_\');\n\t\t\t\t\t\t var type = val.option;\n\t\t\t\t\t\t if (type == \'STRING\')\n\t\t\t\t\t\t\ttype = "CHAR(64)";\n\t\t\t\t\t\t createMetaIndex_local(name, index, type, level, shared);\n\t\t\t\t\t   }\n\t\t\t\t\t},def);\n\n\t\t\t\tfunction createMetaIndex_local(name,index,type,level, shared)\n\t\t\t\t{\t\t\t\t\t\n\n\n\t\t\t\t    var pbar = KProgressBar("updateing metaindex " + name,"fa-submit",undefined,true);\n\n\t\t\t\t\t\n\t\t\t\t\tvar jsonString = JSON.stringify({name:name,index:index,type:type,level:level, shared:shared});\n\t\t\t\t\tajaxRequest(\'command=addMetaIndex\'+\'&json=\' + jsonString , function(e) {\n\t\t\t\t\t\tstate.metaindices = e.metaindices; \n\t\t\t\t\t    pbar.done();\n\t\t\t\t\t\trefreshButton();\n\t\t\t\t\t});\n\t\t\t\t}\n\n\n\t\t\t}\n\n\t   }\n\t},true, false);\n\n\tfunction getIndexAndLevel(path)\n\t{\n\n\t\t\t\tvar index;\n                var level;\n                \n\t\t\t\tif (params.fileinfo.meta)\t\t\n\t\t\t\t{\t\t\n\t\t\t\t\tindex = path.split(",");\n\t\t\t\t\tlevel = params.fileinfo.type;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tindex = [params.filename.replace(\'.json\',\'\')];\n\t\t\t\t\tindex = index.concat(path.split(","));\n\t\t\t\t\tlevel = \'study\';\n\t\t\t\t}\n\t\t\t\t\t\n                var name = "test";\n                var type = "STRING";\n\t\t\t\tif (level == \'patient\' && index.length == 1)\n\t\t\t\t{\n\t\t\t\t\tname = index[0];\n\t\t\t\t\tindex = [\'PATIENT\',index[0]];\n\t\t\t\t}\n\t\t\t\telse if (index[0] == \'STUDIES\' && index.length == 3)\n\t\t\t\t{\n\t\t\t\t\tname = index[2];\n\t\t\t\t\tindex = [\'STUDY\', index[2]];\n\t\t\t\t}\n\t\t\t\telse if (level==\'study\' && index.length == 1)\n\t\t\t\t{\n\t\t\t\t\tname = index[0];\n\t\t\t\t\tindex = [\'STUDY\', index[0]];\n\t\t\t\t}\n\t\t\t\telse if (index[0] == \'STUDIES\')\n \t\t\t    {\n\t\t\t\t\t index = index.slice(2);\n\t\t\t\t\t level = \'study\';\n\t\t\t    }\n\n\t\t\t    return {index:index,level:level};\n\t}\n\n    function addChildren($parent, $currentNode, obj,attrarr,editable)\n    {\n    \n      if (attrarr == undefined)\n      \tattrarr = [];\n      var isarray = Array.isArray(obj);\n      var keys = Object.keys(obj);\n      keys.sort();\n      if (keys.length > 1000)\n      {\n      \t $currentNode.append($("<li class=\'file\'>max children number exceeded!!</li>"));\n      \t return $currentNode;\n      }\n      for (var  k = 0; k < keys.length; k++) {\n      \tvar property = keys[k];\n        if (obj.hasOwnProperty(property))\n     \t{\n            var subattr = attrarr.slice(0);\n            subattr.push(property);\n            if (typeof obj[property] == "object" && obj[property] != undefined)\n\t\t\t{\n\t\t\t  var children_editable = editable;\n\t\t\t  var children = obj[property];\n\t\t\t  if (property.substr(0,6) == "[FORM]" | property.substr(0,5) == "[SQL]" | property.substr(0,6) == "[META]")\n\t\t\t  {\n\t\t\t  \tchildren_editable = false;\n\t\t\t  \tobj[property] = undefined;\n\t\t\t  \tdelete obj[property];\n\n\t\t\t  }\n\n\t\t\t  var $newNode = $("<li><label class="+(children_editable?"\'jsoncontenteditable\'":"")+ " for=\'"+id+\'_\'+property+"\'>"+property+"</label><input type=\'checkbox\' id=\'"+id+\'_\'+property+"\' /></li>");\n\t\t\t  //$newNode.append( addChildren($("<ol/>"), obj[property],subattr));\n\t\t\t  setTimeout(function(a,b,c,d,e) { return function() {\n\t\t\t  \taddChildren(a,b,c,d,e);\n\t\t\t  } }($newNode,$("<ol/>"),children,subattr,children_editable) ,100);\n//\t\t\t  \taddChildren($newNode,$("<ol/>"), obj[property],subattr) \n\n\t\t\t  $newNode.on(\'contextmenu\',function(ev){ ev.preventDefault()});\n\t\t\t  $currentNode.append($newNode);\n\t\t\t}\n\t\t} \n\n\t  }\n      for (var  k = 0; k < keys.length; k++) {\n      \tvar property = keys[k];\n\t  \t\n      \t\n        if (obj.hasOwnProperty(property))\n     \t{\n            var subattr = attrarr.slice(0);\n            subattr.push(property);\n            if (typeof obj[property] != "object")\n            {\n              var val = obj[property] ;\n              if (val === "")\n              \tval ="&nbsp";\n              $currentNode. append($("<li  path=\'"+ subattr.toString() + "\' class=\'file\'> <span class=\'key\' >"+property +\n               "</span> : <span class="+(editable?"\'jsoncontenteditable\'":"")+ " contenteditable=\'"+(editable?"true":"false")+"\' >"+val+ "</span></li>")\n              .on(\'contextmenu\',function(e){contextmenu(e)})\n              .on(\'keyup\',function(e)\n              {\n              \tvar $txt =  $(e.target);\n              \tvar $tr =getOnParentPath( $txt,function(x) { return x.attr(\'path\') != undefined; });\n\t\t\t\tvar index = $tr.attr(\'path\').split(",");\n\t\t\t\tif (!$txt.hasClass("key"))\n\t\t\t\t{\n\t\t\t\t\tvar obj = json_obj;\n\t\t\t\t\tfor (var k = 0; k < index.length-1;k++)\n\t\t\t\t\t\tobj = obj[index[k]];\n\t\t\t\t\tobj[index[index.length-1]] = $txt.text().trim();\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\n\t\t\t\t}\n\n              }));\n            }\n\t\t}\n      \n     } \n\n     if ($parent != undefined)\n     \t$parent.append($currentNode);\n\n     return $currentNode; \n    }\n\n    $div.show();\n \n    setInnerLayout();\n  }\n\n  that.setInnerLayout = setInnerLayout;\n  function setInnerLayout()\n  {\n  \tthat.setInnerLayout_parent();\n    $div.appendTo(that.$container);\n  }\n\n  that.customClose = function()\n  {\n  \tthat.closeUnreferenced()\n  }\n\n\n  return that;\n\n}\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= KTXTViewer\n// ======================================================================================\n// ======================================================================================\n\n\nfunction KTXTViewer(viewport,master)\n{\n  /**  @class A small text editor\n\t   *  @alias KTXTViewer\n\t   *  @augments KPrototypeViewer */\n  var that = KPrototypeViewer(viewport, master);\n\n  that.viewerType = \'txtViewer\';\n  var toolbar = that.toolbar;\n\n  var $div =  $("<div contenteditable=\'true\' class=\'KViewPort_txtViewer\'></div>").appendTo(that.$container);\n\n  function getText()\n  {\n\t   var str = $div.html();\n  \n\t   str = str.replace(/<div>/g, "\\n");\n\t   str = str.replace(/<\\/div>/g, "");\n\t   str = str.replace(/<br>/g, "\\n");\n\t   return str;\n  }\n  $div.on(\'keydown\',function(e) {\n  \tif (e.ctrlKey)\n  \t    return;\n    that.toolbar.$save.addClass(\'notsaved\');\n  });\n  var toolbar = that.toolbar;\n  toolbar.$save = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-save fa-1x\'></i></div>")\n        .click(function() { \n           var fobj  = KViewer.dataManager.getFile(that.currentFileID);\n \t\t   fobj.content =  getText();\n \t\t   uploadBinary(fobj,{},function(){\n               that.toolbar.$save.removeClass(\'notsaved\');\n\n \t\t   },that.viewport.progressSpinner,false,"usenativePID");\n\t\t   \n\n         });\n  toolbar.attach(toolbar.$save);\n\n  function textFromObjectToDiv()\n  {\n     var fobj  = KViewer.dataManager.getFile(that.currentFileID);   \n     if (fobj != undefined)\n     \tfobj.content = getText();\n  }\n  function textFromDivToObject()\n  {\n  \n     var fobj  = KViewer.dataManager.getFile(that.currentFileID);   \n     $div[0].innerHTML = ((fobj.content)); \t\n  }\n\n  $div.on("blur",textFromObjectToDiv);\n  $div.on("focus",textFromDivToObject);\n\n  that.layoutbar.$container.hide();\n\n  that.setContent = setContent;\n  function setContent(ev,p)\n  {\n\n    if (p && p.intent && p.intent.singleview)\n    {\n    \ttoolbar.$dragdiv.hide();\n    \ttoolbar.$screenshot.hide()\n    \ttoolbar.$close.hide();\n    \ttoolbar.$zoom.hide();\n    }\n  \t\n  \tthat.prepViewer(ev);  \t\n    textFromDivToObject();\n    $div.appendTo(that.$container);\n    $div.show();\n    if (ev.modified == true)\n        that.toolbar.$save.addClass(\'notsaved\');\n    else\n        that.toolbar.$save.removeClass(\'notsaved\');\n\n    setInnerLayout();\n  }\n\n  that.setInnerLayout = setInnerLayout;\n  function setInnerLayout()\n  {\n  \tthat.setInnerLayout_parent();  \n  }\n\n  that.customClose = function()\n  {\n  \ttextFromObjectToDiv();\n  \tif (!that.toolbar.$save.hasClass("notsaved"))\n  \t{\n  \t    that.closeUnreferenced()\n  \t}\n  \telse\n  \t    that.content.modified = true;\n  }\n\n  return that;\n\n}\n\n\n\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= KBmpViewer\n// ======================================================================================\n// ======================================================================================\n\n\n\n\nfunction KBmpViewer(viewport, master)\n{ \n  /**  @class A simple Bitmap viewer work jpgs,bmps,pngs,etc..\n\t   *  @alias KBmpViewer \n\t   *  @augments KPrototypeViewer */\n  var that = KPrototypeViewer(viewport, master);\n  that.viewerType = \'bmpViewer\';\n\n  var layoutbar = that.layoutbar;\n  layoutbar.$zoomin.on("mousedown", function(e)\n   {\n\tzoom(1,5);\n\te.stopPropagation();\n\te.preventDefault();\n   })\n\n  layoutbar.$zoomout.on("mousedown", function(e)\n   {\n\tzoom(-1,5);\n\te.stopPropagation();\n\te.preventDefault();\n   })\n\n\t//************* better slidezoomer **********\n    layoutbar.$slidezoom   = $("<span class=\'KViewPort_tool_layout\'> <i class=\'fa fa-search fa-1x\'></i> </span>");\n    layoutbar.attach(layoutbar.$slidezoom)\n\tattachMouseSlider(layoutbar.$slidezoom, \n        {\n            mousedown: function(ev)\n            { \n            ev.stopPropagation();\n                return { startzoomFac: that.zoom} \n            }, \n            mousemove:function(ev,dx,dy,mousedownvar, lastdx, lastdy) \n            {\n            \tev.stopPropagation();\n\t\t\t\tthat.zoom  = mousedownvar.startzoomFac - dy;\n\t\t\t\tsetInnerLayout(1);\n                return  true;\n\n            }, \n            mouseup: function(){ } \n        });\n    layoutbar.$resetzoom  = $("<span class=\'KViewPort_tool_layout\'> <i class=\'fa fa-reply fa-1x\'></i> </span>");\n    layoutbar.$resetzoom.mousedown(function(ev){ that.zoom = 1; setInnerLayout();  ev.stopPropagation();    })\n    layoutbar.attach(layoutbar.$resetzoom);\n\tlayoutbar.$zoomin.hide();\n\tlayoutbar.$zoomout.hide();\n\n\n\n\n\n  var $img =  $("<img  class=\'KViewPort_img\'></img>").appendTo(that.$container);\n  $img.on(\'dragstart\',function(e) { \n  e.preventDefault() });\n  $img.click(function() {\n\n  \t \n  \tif (!that.moved)\n  \t{\n\t\tif (viewport.viewPortID != KViewer.zoomedViewport)\n  \t\t\tKViewer.unZoomViewport();\n\t\tviewport.zoomViewPort();  \t\t\n\n  \t\tthat.$container.off(\'mousemove mouseup\');\n  \t}\n\n  });\n\n  $img.on(\'load\', function()\n  {  \n   \t     \n    \t  setInnerLayout();\n          //$img.fadeIn(200);\n\t\t  $img.show();\n\n\t\t  var icontainer = that.$container[0];\n\t\t  if ( icontainer.addEventListener) {\n\t\t\t  icontainer.addEventListener("mousewheel", MouseWheelHandler, false);// Firefox\n\t\t\t  icontainer.addEventListener("DOMMouseScroll", MouseWheelHandler, false);    \n\t\t   }\n\t\t  else\n\t\t\t  icontainer.attachEvent("onmousewheel", MouseWheelHandler);\n\t\n\t\t  that.$container.on(\'mousedown\',MouseButtonHandler);\n  });\n\n  that.setContent = setContent;\n\n  function setContent(ev)\n  {\n    //$img.detach();\n \t$img.hide();\n\n\tthat.prepViewer(ev);\n\n    that.zoom = 1;\n    that.offX =0;\n    that.offY =0;\n\n\tif( ev.contentType == \'nii\')\n\t{\n\t\t// ************ convert a single slice RGB nifti to png using a canvas **********\n\t\tvar canvas = document.createElement(\'canvas\');\n\t\tvar ctx = canvas.getContext(\'2d\');\n\t\tvar imgData=ctx.createImageData(ev.content.sizes[0],ev.content.sizes[1]);\n\t\tcanvas.width = ev.content.sizes[0];\n\t\tcanvas.height = ev.content.sizes[1];\n\t\tfor (var k=0;k<ev.content.data.length/3;k++)\n\t\t{\n\t\t\timgData.data[4*k+0] =ev.content.data[3*k+0];\n\t\t\timgData.data[4*k+1] =ev.content.data[3*k+1];\n\t\t\timgData.data[4*k+2] =ev.content.data[3*k+2];\n\t\t\timgData.data[4*k+3] =255;\n\t\t}\n\t\tctx.putImageData(imgData,0,0);\n\t\tvar imageUrl = canvas.toDataURL();\n\t}\n\telse\n\t{\n\t    var blob = new Blob( [ ev.content ], { type: "image" } );\n    \tvar urlCreator = window.URL || window.webkitURL;\n    \tvar imageUrl = urlCreator.createObjectURL( blob );   \n\t}\n    \n \t\n    $img.attr(\'src\',imageUrl); \n\tthat.currentFileID = ev.fileID;\n\n  }\n\n  function zoom(amount,delta)\n  {\n  \t\tvar fac = 1;\n\t\tif (amount > 0)\n\t\t   fac +=0.01*delta;\n\t\telse\n\t\t   fac -=0.01*delta;\n\t\tthat.zoom *= fac;\n\t\tsetInnerLayout();\n\n  }\n\n\n  var MouseWheelHandler = function(e)\n  {\n\t  var amount = (e.wheelDelta || -e.detail);\n\t  if(e.ctrlKey)\n\t  {\n\t\te.preventDefault();\n\t\tzoom(amount,1);\n\t  }\n\n  }\n\n  var MouseButtonHandler = function(e)\n  {\n \t  var X = that.offX - e.clientX; \n \t  var Y = that.offY - e.clientY; \n      that.moved = false;\n  \t \n\t // if (e.ctrlKey)\n\t  {\n\t  \t e.preventDefault();\n\t\t that.$container.on(\'mousemove\', function(ev)\n\t\t {\n\t\t\t that.offX = X + ev.clientX; \n\t\t\t that.offY = Y + ev.clientY; \n\t\t\t that.moved = true;\n\t\t\t setInnerLayout();\n\t\t\t that.$container.on(\'mouseup\', function()\n\t\t\t {\n\t\t\t \tthat.$container.off(\'mousemove mouseup\');\n\t\t\t });\n\n\t\t });\n\n\n\t  }\t  \n\n\n  \t\n  }\n\n\n  that.setInnerLayout = setInnerLayout;\n  function setInnerLayout( force)\n  {\n  \t    that.setInnerLayout_parent();\n  \t\n\t\tif (that.currentFileID != undefined)\n\t\t{\n\t\n\n\t\t  var hei = $img.get(0).naturalHeight;\n\t\t  var wid = $img.get(0).naturalWidth;\n\t\t  //console.log(force);\n\t\t  \n\t\t  var   fac = that.$container[0].offsetWidth/wid*that.zoom;\n \t\t  if ( that.$container[0].offsetHeight - hei*fac <= 0)\n \t\t     fac = that.$container[0].offsetHeight/hei*that.zoom;\n\n\t\t  wid = wid *fac;\n\t\t  hei = hei * fac;\n\t\t  var widoffs = (that.$container[0].offsetWidth - wid)/2;\n\t\t  var heioffs = (that.$container[0].offsetHeight - hei)/2;\n\n\t\t  widoffs += that.offX;\n\t\t  heioffs += that.offY;\n\t\t  //console.log(widoffs);\n\t\t  $img.css({height: math.round(hei) -2 + \'px\', width:  math.round(wid)-2 + \'px\', top: math.round(heioffs) + \'px\', left:  math.round(widoffs) + \'px\'});\n\t\t  //$img.appendTo(that.$container);\n\t\t}\n  \t\n  }\n\n\n\tsignalhandler.attach("updateFilelink",function(ev)\n\t\t{\n\t\t\tif(ev.id == that.currentFileID)\n\t\t\t{\n\t\t\t\tvar tfile = KViewer.dataManager.getFile(ev.id);\n\t\t\t\tsetContent(tfile);\n\t\t\t}\n\t\t}\n\t);\n\n\n  return that;\n}\n\n\n\n\n\n$.fn.textWidth = function(text, font) {\n    if (!$.fn.textWidth.fakeEl) $.fn.textWidth.fakeEl = $(\'<span>\').hide().appendTo(document.body);\n    $.fn.textWidth.fakeEl.text(text || this.val() || this.text()).css(\'font\', font || this.css(\'font\'));\n    return $.fn.textWidth.fakeEl.width();\n};\n\n'},function(t,n){t.exports='\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= KTableViewer\n// ======================================================================================\n// ======================================================================================\n\n\nfunction LogGamma(Z) {\n\twith (Math) {\n\t\tvar S=1+76.18009173/Z-86.50532033/(Z+1)+24.01409822/(Z+2)-1.231739516/(Z+3)+.00120858003/(Z+4)-.00000536382/(Z+5);\n\t\tvar LG= (Z-.5)*log(Z+4.5)-(Z+4.5)+log(S*2.50662827465);\n\t}\n\treturn LG\n}\n\nfunction Betinc(X,A,B) {\n\tvar A0=0;\n\tvar B0=1;\n\tvar A1=1;\n\tvar B1=1;\n\tvar M9=0;\n\tvar A2=0;\n\tvar C9;\n\twhile (Math.abs((A1-A2)/A1)>.00001) {\n\t\tA2=A1;\n\t\tC9=-(A+M9)*(A+B+M9)*X/(A+2*M9)/(A+2*M9+1);\n\t\tA0=A1+C9*A0;\n\t\tB0=B1+C9*B0;\n\t\tM9=M9+1;\n\t\tC9=M9*(B-M9)*X/(A+2*M9-1)/(A+2*M9);\n\t\tA1=A0+C9*A1;\n\t\tB1=B0+C9*B1;\n\t\tA0=A0/B1;\n\t\tB0=B0/B1;\n\t\tA1=A1/B1;\n\t\tB1=1;\n\t}\n\treturn A1/A\n}\n\nfunction student_t(df,X) \n{\n    with (Math) {\n\t\tif (df<=0) {\n\n\t\t} else {\n\t\t\tA=df/2;\n\t\t\tS=A+.5;\n\t\t\tZ=df/(df+X*X);\n\t\t\tBT=exp(LogGamma(S)-LogGamma(.5)-LogGamma(A)+A*log(Z)+.5*log(1-Z));\n\t\t\tif (Z<(A+1)/(S+2)) {\n\t\t\t\tbetacdf=BT*Betinc(Z,A,.5)\n\t\t\t} else {\n\t\t\t\tbetacdf=1-BT*Betinc(1-Z,.5,A)\n\t\t\t}\n\t\t\tif (X<0) {\n\t\t\t\ttcdf=betacdf/2\n\t\t\t} else {\n\t\t\t\ttcdf=1-betacdf/2\n\t\t\t}\n\t\t}\n\t\ttcdf=round(tcdf*100000)/100000;\n\t}\n    return tcdf\n}\n\nfunction linRegression(M,idx)\n{\n\tvar A = []\n\tvar b = [];\n\tfor (var k = 0; k < M.length;k++)\n\t{\n\t\tif (k != idx)\n\t\t{\n    \t\tb.push(M[idx][k])\n\t\t\tvar a = []\n\t\t\tfor (var j = 0; j < M.length;j++)\n\t\t\t{\n                if ( j!= idx)\n\t\t\t\t    a.push(M[j][k])\n\t\t\t}\n\t\t\tA.push(a)\n\t\t}\n\t}\n\tvar res = math.mdiv(math.matrix(A),math.matrix(b));\n\tvar stats = {b:res._data[0],m:res._data[1]};\n\n\treturn stats;\n}\n\nfunction pstats(stats,data)\n{\n\tvar err2 = 0;\n\tvar cnt = 0;\n\tvar m_0=0;\n\tvar q_0=0;\n\tvar m_1=0;\n\tvar q_1=0;\n\tfor (var k = 0;k < data[0].length;k++)\n\t{\n\t\tif (!isNaN(data[0][k] && !isNaN(data[1][k])))\n\t\t{\n\t\t   var d = data[0][k]*stats.m + stats.b - data[1][k];\n\t\t   err2 += d*d\n\t\t   m_0 += data[0][k];\n\t\t   m_1 += data[1][k];\n\t\t   q_0 += data[0][k]*data[0][k];\n\t\t   q_1 += data[1][k]*data[1][k];\n\t\t   cnt++;\n\t\t}\n\t}\n\tm_0 /= cnt;\n\tm_1 /= cnt;\n\tvar s_0 = q_0/cnt - m_0*m_0;\n\tvar s_1 = q_1/cnt - m_1*m_1;\n\terr2 = err2 / cnt;\n    var expvar = 1-err2/s_1;\n    var StErr = Math.sqrt(err2/ s_0 /(cnt-2))\n    var t = stats.m/StErr\n\n    var stats = {sdev_x:math.sqrt(s_0),sdev_y:math.sqrt(s_1),error:math.sqrt(err2), expvar:expvar ,t:t  }\n    console.log(stats)\n    return stats\n\n\n}\n\n\nfunction computeCorrelationMatrix(data)\n{\n\t\tvar xy = []\n\t\tvar M = [];\n\t\tfor (var k = 0; k < data.length+1;k++)\n\t\t{\n\t\t    var m = [];\n\t\t\tfor (var j = 0; j < data.length+1;j++)\n\t\t\t    m.push(0);\n\t\t\tM.push(m);\n\t\t}\n\n\n\n\n\t\tvar x0=10000000;\t\t    \n\t\tvar x1=-10000000;\t\t   \n\t\tvar nans = 0; \n\t\tfor (var k = 0; k < data[0].length;k++)\n\t\t{\n\t\t\tvar valid = true;\n\t\t\tvar mean = 0;\n\t\t\tfor (var j = 0; j < data.length;j++)\n\t\t\t{\n\t\t\t    if (isNaN(data[j][k]))\t\t\t    \n\t\t\t        valid = false;\n\t\t\t}\n            if (!valid)\n            {\n                nans++;\n\t\t\t\tcontinue;\n            }\n\n\t\t\tfor (var j = 0; j < data.length+1;j++)\n    \t\t\tfor (var s = 0; s < data.length+1;s++)\n    \t\t\t{\n    \t\t\t\tif (s==0 && j==0)\n    \t\t\t\t    M[s][j]+=1.0;\n    \t\t\t\telse if (s==0)\n    \t\t\t\t    M[s][j] += data[j-1][k];\n    \t\t\t\telse if (j==0)\n    \t\t\t\t    M[s][j] += data[s-1][k]; \n    \t\t\t\telse\n    \t\t\t\t    M[s][j] += data[s-1][k]*data[j-1][k]    \t\t\t\t \n\n    \t\t\t}\n\t\t\t\n\t\t}\n\n   return {M:M,nans:nans}\n\n}\nfunction ChartPanel(sheet,title)\n{\n\n    Chart.defaults.global.defaultFontColor = \'black\';\n    var panel = KPanel($(document.body), "Scatter", "Chart");\n\tpanel.$container.width(700)\n    panel.$container.height(700)\n\n    var $options = $("<div class=\'KchartOptions\'>  </div>")\n    var $statinfo = $("<div class=\'Kchartstats visible\'>  </div>")\n    $statinfo.on("mouseleave",function() {  $statinfo.removeClass("visible")})\n\n    panel.$container.append($options)\n    panel.$container.append($statinfo)\n\n    panel.$container.addClass("Kchart")\n\taddCustomResizer(panel.$container, {});\n\n    var canvas = $(\'<canvas class="KChartCanvas" ></canvas>\')\n    canvas.appendTo(panel.$container);\n    var ctx = canvas[0].getContext("2d");\n\n    var data = sheet.data;\n    var colnames = sheet.columns;\n\n\n\n    function organizeData(sheet,sels,type)\n    {\n\n\t\tvar data = sheet.data;\n\t\tvar colnames = sheet.columns;\n\t\tvar deselected_rows = sheet.deselected_rows\n\n        var numerical_data = [];\n        var combinatorial_dataset = undefined;\n\n        for (var j = 0 ; j < sels.length;j++)\n        {\n\n\t\t\tvar min = 100000000000;\n\t\t\tvar max = -100000000000;\n            var mapkey = x => { if (x == "") return "empty"; else return x; }\n            if (colnames[sels[j]].substring(0,11) == \'PatientsSex\')\n            {\n                var tmp = mapkey;\n                mapkey = x => tmp(x).replace("W","F")\n            }\n\n        \tvar combinatorial = type[sels[j]]==2;\n\n\t\t\tvar d = []\n\t\t\tvar dn = []\n\t\t\tvar l = [];\n\t\t\tvar uniset = {}\n\t\t\tfor (var k = 0; k < data.length;k++)\n\t\t\t{\n                if (deselected_rows[k])\n                    continue;\t\n                l.push(data[k][0])\t\t\n\t\t\t\tvar v = data[k][sels[j]];\n\t\t\t\tif (combinatorial == true )\n\t\t\t\t{\n\t\t\t\t\tvar vk = mapkey(v)\n\t\t\t\t    if (uniset[vk] == undefined)\n\t\t\t\t    {\n\t\t\t\t\t\tuniset[vk] = true;\n\t\t\t\t\t\tif (Object.keys(uniset).length> 5)\n\t\t\t\t\t\t\tcombinatorial = false;\n\t\t\t\t    }\n\t\t\t\t    dn.push(vk);\n\t\t\t\t}\n\t\t\t\t    \n\t\t\t\tv = parseFloat(v)\n\t\t\t\td.push(v)\n\t\t\t    if (!isNaN(v) & v != Infinity & v != -Infinity)\n\t\t\t\t{\n\t\t\t\t\tif (min > v) min = v;\n\t\t\t\t\tif (max < v) max = v;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (combinatorial)\n\t\t\t    combinatorial_dataset = {data:dn,uniset:uniset,name:colnames[sels[j]],max:max,min:min};\n\t\t\telse\n\t\t\t    numerical_data.push({numerical_data:d,name:colnames[sels[j]],max:max,min:min,ids:l});\n        }\n\n        return {numerical_data:numerical_data,combinatorial_dataset:combinatorial_dataset  }\n    }\n\n    function addStatinfo(obj)\n    {\n        var x = "<div> <div> " +  obj.name ;\n        for (var k = 0; k < obj.length;k++)\n            x += " </div> <div> " + obj[k]\n        x += "</div></div>";\n        $statinfo.append($(x))\n    }\n\n\n\n    function initPlot(x)\n    {\n \t    $options.append(x.$options)\n        $statinfo.children().remove();\n    \t\n    }\n\n    function addOption(which,visname,id,def,type)\n    {\n    \twhich[id] = def;\n\t\tvar $par = $("<div>"+visname+" <input value=\'"+def+"\' id=\'"+id+"\' type=\'"+type+"\'> </div>")\n\t\tif (type == "checkbox" & def)\n\t\t    $par.find("input").attr("checked",1)\n\n\t\t$par.find("input").on("change",function(e)\n\t\t{\n\t\t\tif (type == "checkbox")\n               which[id] = e.target.checked;\n\t\t\telse\n\t\t\t   which[id] = e.target.value;\n            which.update(e)\n\t\t})\n\t\twhich.$options.append($par)\n\n    }\n\n\n\tfunction fix(x,order)\n\t{\n\t\tif (Math.abs(order) > 3)\n\t\t\treturn x.toFixed(1) + "e" + order;\n\t\telse\n\t\t{\n\t\t\tif (x==undefined)\n\t\t\t    return "undefined"\n\t\t\tif (order > 0)\n\t\t\t\treturn ""+ (x).toFixed(1);\n\t\t\telse\n\t\t\t\treturn ""+ (x).toFixed(-order+1);\n\t\t}\n\t}\n\n\n    /**************************************************************\n    * ScatterPlot\n    **************************************************************/\n\n\n    function scatterPlot(sels,type)\n    {\n\n        initPlot(scatterPlot)\n        scatterPlot.update = function(e)\n\t\t{\n\t\t    scatterPlot(sels,type)\n\t\t}\n\n\n        var {numerical_data,combinatorial_dataset} = organizeData(sheet,sels,type)\n\n        \n        var ndata = numerical_data.map((x) => x.numerical_data);\n        var {M,nans} = computeCorrelationMatrix(ndata)\n\n        var stat = linRegression(M,2)\n        console.log(stat)\n        \n        var pstat = pstats(stat,ndata)\n\n\n\t\tvar txt = [\'sdev(\'+numerical_data[0].name+\'): \' + pstat.sdev_x.toFixed(2),\n\t\t\t\t   \'sdev(\'+numerical_data[1].name+\'): \' + pstat.sdev_y.toFixed(2),\n\t\t\t\t   \'error:\'+pstat.error,\n\t\t\t\t   \'explained var.:\'+pstat.expvar,\n\t\t\t\t   \'t:\'+pstat.t \n\t\t\t\t   ]\n\t\ttxt.name = \'lin. regression\'\n\t\taddStatinfo(txt);\n\n\n\n\t\tvar xy = ndata[0].map(function(e, i) {\n\t\t  return {x:e, y:ndata[1][i]};\n\t\t});\n\n\t\tvar xlabel = numerical_data[0].name\n\t\tvar ylabel = numerical_data[1].name\n        var min = numerical_data[0].min;\n        var max = numerical_data[0].max;\n\n\n\t\tif (panel.currentChart != undefined)\n            panel.currentChart.destroy();\n\n\t\tpanel.currentChart = new Chart(ctx, {\n\t\t\tdata: {\n\t\t\t\tdatasets: [{\n\t\t\t\t\ttype:\'scatter\',\n\t\t\t\t\tlabel: title,\n\t\t\t\t\tpointBackgroundColor: \'rgba(0,0,0,255)\',\t\t\t\t\t\n\n\t\t\t\t\tdata: xy\n\t\t\t\t},{\n\t\t\t\t\ttype:\'line\',\n\t\t\t\t\tlabel: "linear fit",\n\t\t\t\t\tborderColor:"rgba(255,128,128,0.5)",\n\t\t\t\t\tpointColor: \'rgba(0,255,0,1)\',\t\t\t\t\t\n\t\t\t\t\tfill:false,\n\t\t\t\t\tdata: [{x:min,y:stat.m*min+stat.b},{x:max,y:stat.m*max+stat.b}],\n\t\t\t\t}\n\t\t\t\t]\n\t\t\t},\n\t\t\toptions: {\n\t\t\t\ttooltips: {\n\t\t\t\t\t\t callbacks: {\n\t\t\t\t\t\t\tlabel: function(tooltipItem, data) {\n\t\t\t\t\t\t\t   return "PSID: "+ numerical_data[0].ids[tooltipItem.index]\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t }\n\t\t\t\t\t  },\t\t\t\t\n\t\t\t\tmaintainAspectRatio:false,\n\t\t\t\tscales: {\n\t\t\t\t\txAxes: [{\n\t\t\t\t\t\ttype: \'linear\',\n\t\t\t\t\t\tposition: \'bottom\',\n\t\t\t\t\t\t  scaleLabel: {\n\t\t\t\t\t\t\tdisplay: true,\n\t\t\t\t\t\t\tlabelString: xlabel\n\t\t\t\t\t\t  }\n\t\t\t\t\t}],\n\t\t\t\t\tyAxes: [{\n\t\t\t\t\t\ttype: \'linear\',\n\t\t\t\t\t\tposition: \'left\',\n\t\t\t\t\t\t  scaleLabel: {\n\t\t\t\t\t\t\tdisplay: true,\n\t\t\t\t\t\t\tlabelString: ylabel\n\t\t\t\t\t\t  }\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t});\n    }\n    panel.scatterPlot = scatterPlot\n\n\n\n    /**************************************************************\n    * PRgraph\n    **************************************************************/\n\n\n    PRgraph.$options = $("<div>")\n    addOption(PRgraph,"ROC ","ROC",0,"checkbox")\n    function PRgraph(sels,type)\n    {\n        initPlot(PRgraph)\n        PRgraph.update = function(e)\n\t\t{\n\t\t    PRgraph(sels,type)\n\t\t}\n\n\n        var {numerical_data,combinatorial_dataset,max,min} = organizeData(sheet,sels,type)\n\n        var datasets = []\n        for (var k = 0; k < numerical_data.length;k++)\n        {\n            var ndata = numerical_data[k].numerical_data;\n            var cdata = combinatorial_dataset.data\n            var tup = []\n            for (var j = 0;j < ndata.length;j++)            \n            \ttup.push({n:ndata[j],c:parseInt(cdata[j])});\n            //\ttup.push({n:Math.random(),c:parseInt(cdata[j])});\n            tup = tup.sort(function(x,y) { return y.n-x.n })\n            var cumsum = tup.map((x) => x.c);\n            for (var j = 1; j < cumsum.length;j++)\n                cumsum[j] += cumsum[j-1];\n\n            var xy = [];\n            var N = cumsum.length\n            var toton = cumsum[N-1]\n            var acc_max = 0;\n            var max_th;\n            var acc_05 = 0;\n            var lastx = 0;\n            var AUC = 0;\n            var x,y;\n\t\t\tfor (var j = 0; j < N;j++)\n            {\n            \tif (PRgraph.ROC)\n            \t{\n            \t     x = (j+1-cumsum[j])/(N-toton);\n            \t     y = cumsum[j]/toton;\n            \t}\n            \telse\n            \t{\n            \t\tx = cumsum[j]/(j+1)\n            \t\ty = cumsum[j]/toton\n            \t}\n                xy.push({y:y,x:x})\n                AUC += y*(x-lastx);\n                lastx = x;\n\n\n\n                var acc = (cumsum[j] + (N-j)-(toton-cumsum[j]))/N\n                if (acc > acc_max)\n                {\n                \tacc_max = acc;\n                \tmax_th = tup[j].n;\n                }\n                if (tup[j].n > 0.5)\n                    acc_05 = acc;\n            }\n            AUC += (1-lastx)*y;\n\t\t\tif (PRgraph.ROC)            \n                xy.push({y:1,x:1})            \n            else\n            {\n                xy.push({y:1,x:0})            \n                AUC = 1-AUC;\n            }\n\n\n            var txt = [\'accuracy@50%: \' + acc_05.toFixed(2),\n                       \'accuracy(max): \' + acc_max.toFixed(2) + "@" + Math.round(100*max_th)+"%" ,\n                       \'balance: \' + (100-100*toton/N).toFixed(2) + "%",\n                       "AUC: " + AUC.toFixed(2)\n                       ]\n            txt.name = numerical_data[k].name;\n            addStatinfo(txt);\n\n            datasets.push(           \n             {\n\t\t\t\t\ttype:\'line\',\n\t\t\t\t\tlabel: numerical_data[k].name,\n\t\t\t\t\tborderColor:(new KColor(KColor.list[k])).getCSS(),\t\t\t\t\t\n\t\t\t\t\tfill:true,\n\t\t\t\t\tdata: xy\n\t\t\t\t});\n\n\n\n        }\n        datasets.push(        \n                {\n\t\t\t\t\ttype:\'line\',\n\t\t\t\t\tlabel: "baseline",\n\t\t\t\t\tborderColor:"rgba(0,0,128,0.5)",\n\t\t\t\t\tpointColor: \'rgba(0,0,0,0)\',\t\t\t\t\t\n\t\t\t\t\tfill:false,\n\t\t\t\t\tdata: PRgraph.ROC?[{x:0,y:0},{x:1,y:1}]:[{x:toton/N,y:0},{x:toton/N,y:1}]\n\t\t\t\t})\n\n\n\t\tif (panel.currentChart != undefined)\n            panel.currentChart.destroy();\n\n\t\tpanel.currentChart = new Chart(ctx, {\n\t\t\tdata: {\n\t\t\t\tdatasets: datasets\n\t\t\t},\n\t\t\toptions: {\n\t\t\t\tmaintainAspectRatio:false,\n\t\t\t\tscales: {\n\t\t\t\t\txAxes: [{\n\t\t\t\t\t\ttype: \'linear\',\n\t\t\t\t\t\tposition: \'bottom\',\n\t\t\t\t\t\t  scaleLabel: {\n\t\t\t\t\t\t\tdisplay: true,\n\t\t\t\t\t\t\tlabelString: PRgraph.ROC?"FP (1-specificity)":"precision (1-FP)"\n\t\t\t\t\t\t  }\n\t\t\t\t\t}],\n\t\t\t\t\tyAxes: [{\n\t\t\t\t\t\ttype: \'linear\',\n\t\t\t\t\t\tposition: \'left\',\n\t\t\t\t\t\t  scaleLabel: {\n\t\t\t\t\t\t\tdisplay: true,\n\t\t\t\t\t\t\tlabelString: PRgraph.ROC?"TP (sensitivity)":"recall (TP)"\n\t\t\t\t\t\t  }\n\t\t\t\t\t}]\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n    }\n    panel.PRgraph = PRgraph\n\n\n\n    /**************************************************************\n    * Histogram\n    **************************************************************/\n\n\n    histogram.$options = $("<div>")\n    addOption(histogram,"#bins:","numberofbins",20,"number")\n    addOption(histogram,"normalized:","normalized",1,"checkbox")\n\n    function histogram(sels,type)\n    {\n        initPlot(histogram)\n        histogram.update = function(e)\n\t\t{\n\t\t    histogram(sels,type)\n\t\t}\n\n\n        var {numerical_data,combinatorial_dataset} = organizeData(sheet,sels,type)\n\n        var max = math.max(numerical_data.map(x => x.max))\n        var min = math.min(numerical_data.map(x => x.min))\n\n        var n = histogram.numberofbins;\n        if (!(n>1 & n < 1000))\n            n = 20;\n        var datasets = []\n        var dset_tpm =  {\n        \tfill:false,\n        \tborderWidth:1,\n        }\n        var del = max-min;\n        min = min - 0.02 * del;\n        max = max + 0.02 * del;\n        var cols = []\n        var cnt = 0;\n        var sets = []\n        for (var j = 0 ; j < numerical_data.length;j++)\n        {\n           function addhisto(num_data,name,idx)\n           {\n\t\t\t   var histo = comphisto(min,max, n, num_data, num_data.length, num_data.length,histogram.normalized=="1")\n\t\t\t   datasets.push($.extend({\n\t\t\t\t\t label:name,\n\t\t\t\t\t data:histo.accus,\n\t\t\t\t\t backgroundColor:(new KColor(KColor.list[cnt])).getCSS()\n\t\t\t\t   },dset_tpm) ) \t   \n\t\t\t   cnt++;\n\n               var mean = 0\n               var nancnt = 0\n               for (var k =0;k < num_data.length;k++)\n               {    \n                    if (isNaN(num_data[k]) | num_data[k] == Infinity | num_data[k] == -Infinity)\n                        nancnt++;\n                    else\n                        mean += num_data[k];\n                        \n               }\n               mean /= (num_data.length-nancnt);\n               var sdev = 0;\n               for (var k =0;k < num_data.length;k++)\n                    if (!(isNaN(num_data[k]) | num_data[k] == Infinity | num_data[k] == -Infinity))\n                        sdev += (num_data[k]-mean)*(num_data[k]-mean);\n               sdev = Math.sqrt(sdev / (num_data.length-1-nancnt));\n\n               var sorted = num_data.sort();\n               var p50 = sorted[Math.round(num_data.length/2)];\n               var p95 = sorted[Math.round(num_data.length*0.95)];\n               var p05 = sorted[Math.round(num_data.length*0.05)];\n               var order = Math.floor(Math.log10(sdev*2));\n\n               var nanstr="</div> <div> #samples: " + num_data.length;\n               if (nancnt >0)\n                nanstr = nanstr + " nans/inf:"+nancnt;\n\n                sets.push({mean:mean,sdev:sdev,n:num_data.length,name:name })\n\n\n               $statinfo.append($("<div> <div> " +  name \n               +" </div> <div> mean: "+fix(mean,order)\n               +" </div> <div> sdev: "+fix(sdev,order) \n               +" </div> <div> p%(5,50,95): "+fix(p05,order)+", "+fix(p50,order)+", "+fix(p95,order)\n               +nanstr\n               +"</div></div>"))\n\n           }\n\n\n            \n\n\n           if (combinatorial_dataset != undefined)\n           {\n\t\t\t   var num_data = numerical_data[j].numerical_data;  \n\t\t\t   var cdata = combinatorial_dataset.data;         \t\n               for (var k in combinatorial_dataset.uniset)\n               {\n                    var ndata = []\n                    for (var s = 0; s < num_data.length;s++)\n                    {\n                    \tif (cdata[s] == k)\n                    \t{\n                    \t\tndata.push(num_data[s])\n                    \t}\n                    }\n\t\t\t\t    var num_data = numerical_data[j].numerical_data;\n\t\t\t\t    addhisto(ndata,"<" + combinatorial_dataset.name+"="+k + "> " + numerical_data[j].name)\n\n               }\n           }\n           else\n           {\n\t\t\t   var num_data = numerical_data[j].numerical_data;\n\t\t\t   addhisto(num_data,numerical_data[j].name)\n           }\n\n           if (sets.length == 2)\n           {\n               var a = sets[0];\n               var b = sets[1]\n               var s2 = Math.sqrt((a.sdev*a.sdev*(a.n-1) + b.sdev*b.sdev*(b.n-1))/(b.n+b.n-2))\n               var t = (a.mean - b.mean) / s2\n               t *= Math.sqrt(a.n*b.n/ (a.n+b.n))\n               var p = 1-student_t(a.n+b.n-2,Math.abs(t));\n               var res = ", p=" + p.toFixed(3);\n               $statinfo.append($("<div> <div> T-test: " +sets[0].name +" vs "+sets[1].name\n               +" </div> <div> t: "+t.toFixed(3)+res\n               +"</div></div>"))\n\n\n           }\n\n        }\n    \t\n\n        var order = Math.floor(Math.log10(max-min));\n\n        var yd = [];\n        for (var k = 0; k < n; k++ )\n        { \n           var v = min + (max-min)*((k+0.5)/n);\n           yd.push(fix(v,order))\n        }\n\n        if (panel.currentChart != undefined)\n            panel.currentChart.destroy();\n\n\t\tpanel.currentChart = new Chart(ctx,\n\t\t  {"type":"bar",\n           "data":{\n   \t                 "labels":yd,\n   \t                 "datasets":datasets },\n   \t        "options":{\n\t\t\t\t\tmaintainAspectRatio:false,\n   \t               \t"scales":{"yAxes":[{\n   \t               \t\t    ticks:{"beginAtZero":true},\n\t\t\t\t\t\t    scaleLabel: {\n\t\t\t\t\t\t\t   display: true,\n\t\t\t\t\t\t       labelString: histogram.normalized=="1"?("percent (%)"):"frequency/counts"\n\t\t\t\t\t\t     }\n\n   \t               \t\t    }\n   \t               \t\t    ]\n\n   \t               \t\t}}});\n    }\n    panel.histogram = histogram\n\n    return panel\n\n}\n\n\n\n\nfunction KTableViewer(viewport, master)\n{\n  /**  @class A table viewer for csv-files\n   *  @alias KTableViewer \n   *  @augments KPrototypeViewer */\n\n  var that = KPrototypeViewer(viewport, master);\n  that.viewerType = \'tableViewer\';\n  var toolbar = that.toolbar\n \n\n  var $div;\n  var $table;\n\n  var data;\n  var colnames;\n  var selections;\n  var sheet;\n  var fobj;\n  var deselected_rows;\n\n\n  that.setContent = setContent;\n  function setContent(ev)\n  {\n\n    fobj = ev\n\tif ($div != undefined)\n\t\t$div.remove();\n\n    data = []\n    colnames = [];\n    selections = {}\n\tdeselected_rows = {}\n\n    sheet = { data : data, columns : colnames, deselected_rows:deselected_rows}\n\n\n\n\n\t$div = $("<div class=\'KViewPort_tableViewer_outerDiv\'>").appendTo(that.$container);\n\t$table =  $("<table class=\'KViewPort_tableViewer\' ></table>").appendTo($div);\n\n\n  \tthat.viewport.progressSpinner("rendering table");\n\tthat.prepViewer(ev);\n\t$div.show();\n\t$table.children().remove();\n\n\tviewport.setCurrentViewer(that);\n\tvar str = ev.content;\n\n    if (str == undefined)\n    {\n    \tthat.viewport.progressSpinner(undefined)\n    \talertify.error("sorry, no content found in csv!!");\n    \tthat.viewport.kill();\n    \treturn;\n    }\n\n\tlines = str.split("\\n");\n\tvar $head = $("<thead>")\n\tvar $body = $("<tbody>")\n\tvar $colg = $("<colgroup>");\n\n\tvar header = true;\n\n\tvar nate = [];\n\tvar header_lines=0\n\n\n\tlines.chunk( function(line,k)\n\t\t{\n\t\t\tif (line == "")\n\t\t\t\treturn;\n\n\t\t\tvar entries = line.split(";");\n\t\t\tvar $row = $("<tr></tr>");\n\n\n\t\t\tif (k>0 & entries[0] != "")\n\t\t\t   header=false;\n\t\t\tif (header)\n\t\t\t{\n\t\t\t\theader_lines++;\n\t\t\t\t$row.appendTo($head);\n\t\t\t\t$row.on(\'click\',function(e)\n\t\t\t\t{\n\t\t\t\t\tvar col = $(e.target).parent().children().index($(e.target));\n\t\t\t\t\tvar c = $($colg.children()[col])\n\t\t\t\t\tif (col == 0)\n\t\t\t\t\t    return;\n\t\t\t\t\tif (e.shiftKey)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (c.hasClass("tabcolselected"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t    c.removeClass("tabcolselected")\n\t\t\t\t\t\t    c.removeClass("tabcolselectedALT")\t\t\t\t\t\t    \n\t\t\t\t\t\t    delete selections[col] \n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t    c.addClass("tabcolselected")\n\t\t\t\t\t\t    selections[col] = 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tif (e.ctrlKey)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (c.hasClass("tabcolselectedALT"))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t    c.removeClass("tabcolselected")\n\t\t\t\t\t\t    c.removeClass("tabcolselectedALT")\n\t\t\t\t\t\t    delete selections[col] \n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t    c.addClass("tabcolselectedALT")\n\t\t\t\t\t\t    selections[col] = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$row.attr("row",k-header_lines)\n\t\t\t\t$row.appendTo($body);\n\t\t\t\t$row.on(\'click\',function(e)\n\t\t\t\t{\n                    var $x = $(e.currentTarget);\n                    if (e.shiftKey)\n                    {\n\t\t\t\t\t\tvar i = $x.attr(\'row\');\n\t\t\t\t\t\tif (!deselected_rows[i])\n                            $x = $x.prevUntil(".excluded").add($x);\n                        else\n                            $x = $x.prevUntil(":not(.excluded)").add($x);\n                    }\n\n\t\t\t\t\tfor (var j = 0; j < $x.length;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar i = $($x[j]).attr(\'row\');\n\n\n\t\t\t\t\t\tif (deselected_rows[i])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdelete deselected_rows[i];\n\t\t\t\t\t\t\t$($x[j]).removeClass(\'excluded\')\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdeselected_rows[i] = true;\n\t\t\t\t\t\t\t$($x[j]).addClass(\'excluded\')\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\n\t\t\t\t});\n\n\t\t\t}\n\n            var r = [];\n            var last = "";\n\t\t\tfor (var j = 0; j < entries.length;j++)\n\t\t\t{\n\t\t\t\tif (k==0)\n\t\t\t\t{\n\t\t\t\t\t$colg.append($("<col>"));\n\t\t\t\t\tif (entries[j] == "")\n\t\t\t\t\t{\n\t\t\t\t\t    colnames[j] = last;\n\t\t\t\t\t    nate[j] = false\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{                        \n                        colnames[j] = entries[j];\n                        last = entries[j];\n\t\t\t\t\t    nate[j] = true\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse if (header)\n\t\t\t\t{\n\t\t\t\t\tif (entries[j] != "")\n\t\t\t\t\t{\n\t\t\t\t    \tlast = entries[j];\n    \t\t\t\t\tcolnames[j] += "." +  last\n\t\t\t\t    \tnate[j] = true;\n\t\t\t\t\t}\t\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t    if (!nate[j])\t\n\t\t\t\t\t\t\tcolnames[j] += "." +  last\n    \n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tif (!header)\n\t\t\t\t    r.push(entries[j])\n\n\n\t//\t\t\tvar $span = $("<span> "+entries[j]+"</span>");\n//\t\t\t\t$row.append($("<td></td>").append($span));\t\t    \n\t\t\t\t$row.append($("<td>"+entries[j]+"</td>"));\t\t    \n\t\t\t}\n\t\t\tif (r.length > 0)\n\t\t\t    data.push(r)\n\n\n\t\t},5,1,function(i) {\n\t\tthat.viewport.progressSpinner("rendering table " + Math.round(100*i/lines.length) + "%");} ,\n\t\tfunction() {\n\n\t\t\t$table.append($colg);\n\t\t\t$table.append($head);\n\t\t\t$table.append($body);\n\t\t\tattachTableOperator($div,undefined,true);\t\n\t\t\t$table.show();\n\t\t\tthat.setInnerLayout();\n\t\t\tthat.viewport.progressSpinner(undefined)} );\n\n\t\n  }\n\n\n\n  that.detachContent = detachContent;\n  var scrollTop = 0;\n  var scrollLeft = 0;\n  function detachContent()\n  {\n    scrollTop = $div.scrollTop();\n    scrollLeft = $div.scrollLeft();\n  }\n\n  function setInnerLayout()\n  {\n  \tthat.setInnerLayout_parent();\n\t$div.scrollTop(scrollTop);\n\t$div.scrollLeft(scrollLeft);\n  }\n  that.setInnerLayout = setInnerLayout;\n\n\n  toolbar.$histo = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-bar-chart fa-1x\'></i></div>")\n        .click(function() { \n            var cpanel = ChartPanel(sheet ,fobj.filename)\n\t\t\tcpanel.histogram(Object.keys(selections),selections);\n\n         });\n\n  toolbar.$scatter = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-area-chart fa-1x\'></i></div>")\n        .click(function() { \n            var cpanel = ChartPanel(sheet ,fobj.filename)\n\t\t\tcpanel.scatterPlot(Object.keys(selections),selections);\n\n         });\n  toolbar.$pr = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-1x\'>PR</i></div>")\n        .click(function() { \n            var cpanel = ChartPanel(sheet ,fobj.filename)\n\t\t\tcpanel.PRgraph(Object.keys(selections),selections);\n\n         });\n\n  toolbar.$download = $("<div class=\'KViewPort_tool\'><i class=\'fa fa-download fa-1x\'></i></div>")\n        .click(function() { \n        that;\n\t\t\tinitiateDownload(that.content.content, projectInfo.name + "_meta.csv");\t\t\n         });\n     \n\n\n  toolbar.attach(toolbar.$download);\n  toolbar.attach(toolbar.$histo);\n  toolbar.attach(toolbar.$scatter);\n  toolbar.attach(toolbar.$pr);\n\n\n\n\n\n  return that;\n\n}\n\n\n\n'},function(t,n){t.exports="\n\n\n\n\nfunction KMedImgCurve(medviewer)\n{\n\t/******************************************************************************\n\tspecifications\n\t*******************************************************************************/\n\t/* This tool is supposed to:\n\t\t- draw lines: spectra, cross sections, time series, ...\n\t\t- draw multiple lines: compare multiple images -> use \"overlay\" to draw multiple contrast.\n\t\t  allow to scale multi-contrast among each other\n\t\t- draw mean curves of ROIs: use \"drop as roi interface\"\n\t\t- scale x-axis: true time, common scale for multiple rois\n\t\t- scale y-axis: normalise to max, baselinelength-max, native units\n\n\t\t- log plot\n\n\n\t\t- correlation plot: correlate multiple contrasts / time series, (VSI GE / SE spirals ...) \n\n\n\n\t*/\n\n\n\n\t/******************************************************************************\n\tas a seperate tool?\n\t*******************************************************************************/\n\t// as a tool ?\n\tvar $menu = $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li></li>\"));\n    var $thetog = $(\"<div class='KView_tool '><i class='fa fa-pencil fa-1x'></i></div>\").append($menu);\n    var that = new KToolWindow(KViewer, $thetog);\n\n    that.$leftToolistDiv.remove();\n\n\tthat.resize = function(hei)\n\t  {\n      that.$container.height(hei);\n      $curvecontainer.height(hei-that.$container.find('.KToolsTopMenu').height());\n      \n \t }\n\tvar $target = that.$container;\n\n    that.tstate.target = -1;\n\n    that.name = 'CurveTool';\n \n\n\n\n\t/******************************************************************************\n\tThe differnet modi\n\t*******************************************************************************/\n\tvar $modesel = $(\"<ul></ul>\").appendTo( $(\"<li><a><i class='fa fa-list-ul'></i>Mode  </a></li>\").appendTo(that.$topRow)  );\n\t\t $(\"<li myid='tseries'><a>Time Series</a></li>\").appendTo($modesel).click( function(){  setstate('mode', 'tseries') })  ;\n\t\t $(\"<li myid='vsi'><a>VSI Spiral</a></li>\" ).appendTo($modesel).click( function(){  setstate('mode', 'vsi') })  ;\n\t\t $(\"<li myid='dce_patlak'><a>DCE Patlak</a></li>\" ).appendTo($modesel).click( function(){  setstate('mode', 'dce_patlak') })  ;\n\t\t $(\"<li myid='histogram'><a>Histograms</a></li>\" ).appendTo($modesel).click( function(){  setstate('mode', 'histogram') })  ;\n\t\n\tvar $normalise = $(\"<ul></ul>\").appendTo( $(\"<li><a><i class='fa fa-arrows-v'></i>Scaling </a></li>\").appendTo(that.$topRow)  );\n\t\t $(\"<li myid='noscaling'><a>No scaling</a></li>\" ).appendTo($normalise).click( function(){  setstate('normalise', 'noscaling') })  ;\n\t\t $(\"<li myid='individual_max'><a>Individually to min_max </a></li>\").appendTo($normalise).click( function(){  setstate('normalise', 'individual_max') })  ;\n\t\t $(\"<li myid='individual_area'><a>Individually to area</a></li>\").appendTo($normalise).click( function(){  setstate('normalise', 'individual_area') })  ;\n\t\t $(\"<li myid='individual_lastpoint'><a>Individually to last point</a></li>\").appendTo($normalise).click( function(){  setstate('normalise', 'individual_lastpoint') })  ;\n\t\t  $normalise.append($(\"<hr width='100%'> \")); \t\t\t\n\t var $yscaling = $(\"<li myid='yscaling'><a>Y-Scaling <input value='1'> </a></li>\").appendTo($normalise).change( function(e){\t\t \t \n\t\t \t state.yscaling = $yscaling.find('input').val();\n\t\t \t drawAllCurves();\n\t\t \t   })  ;\n\t var $xscaling = $(\"<li myid='yscaling'><a>X-Scaling <input value='1'> </a></li>\").appendTo($normalise).change( function(e){\t\t \t \n\t\t \t state.xscaling = $xscaling.find('input').val();\n\t\t \t drawAllCurves();\n\t\t \t   })  ;\n\t\n\tvar $baselinelength = $(\"<ul></ul>\").appendTo( $(\"<li><a><i class='fa fa-window-minimize'></i>Baseline </a></li>\").appendTo(that.$topRow)  );\n\t\t $(\"<li myid='off'><a>None</a></li>\" ).appendTo($baselinelength).click( function(){  setstate('baselinelength', 'off') })  ;\n\t\t $(\"<li myid='1'><a>First point</a></li>\" ).appendTo($baselinelength).click( function(){  setstate('baselinelength', 1) })  ;\n\t\t $(\"<li myid='8'><a>First 8 points</a></li>\").appendTo($baselinelength).click( function(){  setstate('baselinelength', 8) })  ;\n\n\n\t/*************************************\n\tdownload curves\n\t************************************/\n\tif(1)\n\t{\n\t\tvar $downloadcurves = $(\"<li><a> <i class='fa fa-copy'></i>Copy to clipboard</a></li>\").appendTo(that.$topRow);\n\t\t$downloadcurves.click( function(){downloadcurves()});\n\t}\t\n\n\t/*************************************\n\trebuild the tool, for development\n\t************************************/\n\tif(0)\n\t{\n\t\tvar $rebuild = $(\"<li><a> <i class='fa fa-wrench'></i> RebuildTool</a></li>\").appendTo(that.$topRow);\n\t\t$rebuild.mousedown( function(){\n\t\t\t//that.close();\n\t\t\tvar x = KToolWindow.findToolbyContainer(that.$container)\n\t\t\tktoolslist[7] = KViewer.curveTool = KMedImgCurve();\n\t\t\tthat.$container.remove();\n\t\t\tKViewer.curveTool.show();\n\n\t\t});\t\n\t}\n\n\t\n\n\tvar state = \n\t{\n\t\tnormalise: 'individual_max',\n\t\tbaselinelength: 0,\n\t\tmode: 'tseries',\n\t}\n\tvar $state = \n\t{\n\t\tnormalise: $normalise,\n\t\tbaselinelength: $baselinelength,\n\t\tmode: $modesel,\n\t}\n\t\n\tfunction setstate(which, value)\n\t{\n\t\tstate[which] = value;\n\t\t$state[which].children().css('font-weight', '');\n\t\t$state[which].find(\"[myid=\"+value+\"]\").css('font-weight', 'bold');\n\n\t\tif (which == \"mode\")\n\t\t\tupdateCurveListHandlers();\n\t    if (which == \"yscaling\")\n\t    \t$yscaling.find('input').val(value);\n\t    if (which == \"xscaling\")\n\t    \t$xscaling.find('input').val(value);\n\n\t\tdrawAllCurves();\n\t}\n\n\tthat.setState = function(st)\n\t{\n\t\tfor (var k in st)\n\t\t{\n\t\t\tstate[k] = st[k];\n\t\t\tif ($state[k] != undefined)\n\t\t\t{\n\t\t\t\t$state[k].children().css('font-weight', '');\n\t\t\t\t$state[k].find(\"[myid=\"+st[k]+\"]\").css('font-weight', 'bold');\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\tif (k == \"yscaling\")\n\t    \t\t$yscaling.find('input').val(st[k]);\n\t\t\tif (k == \"xscaling\")\n\t    \t\t$xscaling.find('input').val(st[k]);\n\t\t}\n\n\t\tupdateCurveListHandlers();\n\n\t\tdrawAllCurves();\n\t}\n\n\n\tfunction getState()\n    {\n       \n        return state;\n\n    }\n    that.getState = getState\n\n\n\t/******************************************************************************\n\tShow as viewer like medviewer?  not for now\n\t*******************************************************************************/\n\tif(0)\n\t{\n\t\tmedviewer = medviewer || KViewer.viewports[0].getCurrentViewer();\n\t\tif(medviewer==undefined)\n\t\t\treturn false;\n\n\t\tvar viewport = medviewer.viewport;\n\t\tvar that = new KPrototypeViewer( viewport, KViewer)\n\n\t\tviewport.setCurrentViewer(that);\n\n\t\tvar $target = viewport.$container;\n\t\t//  medviewer.curveviewer = that;\n\t\t// \tmedviewer.$container.find('.KViewPort_curvecontainer').remove();\n\t\t// \t$('.KViewPort_curvecontainer').remove();\n\t}\n\n\t\n\n\t/******************************************************************************\n\tThe main curve container\n\t*******************************************************************************/\n    var $curvecontainer = $(\"<div class='KViewPort_curvecontainer sbox_horz' style='height:100%;position:relative;' ></div>\" )\n\n\tvar $box = $(\"<div class='KViewPort_curvecontainer_list  sbox_resizable' ></div>\").appendTo($curvecontainer);\n\tsbox.appendResizer($box); \n\n    var $svgcontainer = $(\"<div class='KViewPort_curvecontainer KViewPort_svgcontainer sbox_resizable' style='display:flex;height:100%;width:100%;position:relative;' ></div>\" ).appendTo($curvecontainer);\n    var $isvgcontainer = $(\"<div class='' style='display:flex;height:100%;width:100%;position:relative;' ></div>\" ).appendTo($svgcontainer);\n    //var $axcontainer  = $(\"<div class='KViewPort_curvecontainer sbox_resizable' style='display:flex;height:100%;width:100%;position:relative;background:green;' ></div>\" ).appendTo($curvecontainer);\n   \n\n\t/******************************************************************************\n\tprep the svg\n\t*******************************************************************************/\n\t// values are in percent defined by viewbox\n\t// given as x0 y0 width height\n\t//var str  =  \"<svg  preserveAspectRatio='none' viewbox='-10 -10 120 120' style='transform: scaleY(-1);' class='sbox_resizable' __style='width:100%;' >\";\n\tvar str  =  \"<svg  preserveAspectRatio='none' viewbox='-0 0 100 100' style='transform: scaleY(-1);' class='sbox_resizable' >\";\n\t\n// \tstr += '<defs>';\n// \tstr += '<marker id=\"marker-circle\" markerWidth=\".03\" markerHeight=\"400\" refx=\".5\" refy=\".5\" viewBox=\"0 0 1 100\" preserveAspectRatio=\"xMinYMin\"><circle cx=\"1\" cy=\"1\" r=\"2\" class=\"marker\" fill=\"green\"/></marker>';\n// \tstr += '</defs>';\n\n\n\t/******************************************************************************\n\taxes \n\t*******************************************************************************/\n\tstr +=  \"<line x1=-0 y1=0 x2=100 y2=00 style='stroke:white;stroke-width:.2' />\";\n\tstr +=  \"<line x1=0 y1=0 x2=00 y2=100 style='stroke:white;stroke-width:.2' />\";\n\t\n\n    var $ylabel = $(\"<div class='' style='position:absolute;text-align:right; left:-60px; transform:rotate(-90deg); top:50%' >no ylabel</div>\").appendTo($isvgcontainer);\n    var $xlabel = $(\"<div class='' style='position:absolute;text-align:right; left:50%; bottom:-35px' >no xlabel</div>\").appendTo($isvgcontainer);\n\t/******************************************************************************\n\tgridlines\n\t*******************************************************************************/\n\tif(1)\n\t{\n\t\tvar xticklabels = [];\n\t\tvar yticklabels = [];\n\t\tstr +=  \"<g class='curveTool_grid_major' >\";\n\t\t// prepare some (20) curves. must be prepared ind advance, svg cannot be appended\n\t\tngridh = 26;\n\t\tngridv = 16;\n\t\tysize = 100;\n\t\txsize = 100;\n\n\t\tfor(var k=0; k<ngridh; k++)\n\t\t{\n\t\t\tvar cx = k/(ngridh-1)*xsize;\n\t\t\tstr +=   \"<line class='KViewPort_curvetool_gridline curveTool_grid_horzlines'  y1=\"+cx+ \" x1=0 y2=\"+cx+\" x2=\"+100+\"  />\";\n \t\t    var $text = $(\"<div class='' style='position:absolute;text-align:right; left:-5px; transform:translate(-100%,-60%); top:\"+(ysize-cx)+\"%' >\"+cx+\"</div>\").appendTo($isvgcontainer);\n \t\t    yticklabels.push($text);\n\t\t}\n\t\tfor(var k=0; k<ngridv; k++)\n\t\t{\n\t\t\tvar cx = k/(ngridv-1)*ysize ;\n\t\t\tstr +=   \"<line class='KViewPort_curvetool_gridline curveTool_grid_vertlines' x1=\"+cx+ \" y1=-0.5 x2=\"+cx+\" y2=\"+(ysize)+\" />\";\n \t\t    var $text = $(\"<div class='' style='position:absolute;text-align:right; bottom:-10px; transform:translate(-50%,50%); left:\"+(cx)+\"%' >\"+k+\"</div>\").appendTo($isvgcontainer);\n \t\t    xticklabels.push($text);\n\t\t}\n\t\tstr +=   \"<line class='KViewPort_curvetool_timeline ' x1=\"+0+ \" y1=0 x2=\"+0+\" y2=100 />\";\n\t\tstr +=  \"</g>\";\n\t}\n\n\n\t/******************************************************************************\n\tcurevgroup with lines\n\t*******************************************************************************/\n\tstr +=  \"<g class='curveTool_curvegroup_lines' >\";\n\tfor(var k=0; k<20; k++)\n\t{\n\t\tstr +=  \"<polyline points='0,0' style='fill:none;stroke:red;stroke-width:2;visibility:hidden' />\";\n\t}\n\tstr +=  \"</g>\";\n\tstr += \"</svg>\";\n\tvar $svg = $(str).appendTo($isvgcontainer);\n\n\t// xlims (zoom / pan)  can be applied to the whole curve group.\n\tvar $curvegroup = $svg.find('.curveTool_curvegroup_lines');\n\tvar $curves = $svg.find('polyline');\n\n\n\t// xlims (zoom / pan)  can be applied to the whole curve group.\n\tvar $gridgroup = $svg.find('.curveTool_grid_major');\n\tvar $gridlinesvert = $svg.find('.curveTool_grid_vertlines');\n\tvar $gridlineshorz = $svg.find('.curveTool_grid_horzlines');\n\n\tvar $currenttimeline   = $svg.find('.KViewPort_curvetool_timeline');\n\n\n\t/******************************************************************************\n\tmousedown\n\t*******************************************************************************/\n\t$svg.on('mousedown', svgmousedown)\n\tfunction svgmousedown(ev)\n\t{\n\t\tfunction svgmouseup(ev)\n\t\t{\n\t\t\t$body.off(\"mousemove mouseup mouseleave\")\n\t\t}\n\t\t$body.on('mousemove', svgmousemove)\n\t\t$body.on('mouseup mouseleave', svgmouseup)\n\t\tsvgmousemove(ev);\n\t}\n\t\n\tfunction svgmousemove(ev)\t\n\t{\n\t\tvar val = Math.round( (ev.clientX - $svg.offset().left)/$svg.width()*maxnumtimepoints);\n\t\tvar master = KViewer;\n\t\t\n \t\tif(master.movie.currentTimePoint == val)\n \t\t\treturn;\n\n\t\tmaster.movie.currentTimePoint = val;\n\t\tmaster.iterateMedViewers(function(m)\n\t\t{\n\t\t\tif (m.nii !=undefined && m.nii.numTimePoints > 1 & m.movieGlobalMode)\n\t\t\t{\n\t\t\t\tm.updateCurrentTimePoint(val);\n\t\t\t}\n\n\t\t});\n\n    }\n\n\t/******************************************************************************\n\tmouswheel\n\t*******************************************************************************/\n\tif ($svg.get(0).addEventListener) {\n        // Firefox\n        if (/Firefox/i.test(navigator.userAgent))\n            $svg.get(0).addEventListener(\"DOMMouseScroll\", moveUnlagger(MouseWheelHandler_), false);\n        else\n        // IE9+, Chrome, Safari, Opera\n            $svg.get(0).addEventListener(\"mousewheel\", MouseWheelHandler_, false);\n    }\n    else\n    {\n        // IE 6/7/8\n        $svg.get(0).attachEvent(\"onmousewheel\", MouseWheelHandler);\n    }\n\n\tfunction MouseWheelHandler_(ev)\n\t{\n        var amount = (ev.wheelDelta || -ev.detail) > 0 ?1:-1;\n        var val =  KViewer.movie.currentTimePoint + amount;\n\t\tKViewer.movie.currentTimePoint = val;\n\t\tKViewer.iterateMedViewers(function(m)\n\t\t{\n\t\t\tif (m.nii !=undefined && m.nii.numTimePoints > 1 & m.movieGlobalMode)\n\t\t\t{\n\t\t\t\tm.updateCurrentTimePoint(val);\n\t\t\t}\n\n\t\t});\n\t\n\t}\n\n\n\tvar masterimage;\n    \n\t/******************************************************************************\n\ta curve object\n\t*******************************************************************************/\n\tvar curves = {};\n\tfunction createCurve(props)\n\t{\n\t\tvar curve = new Object;\n\t\tcurve.xdata = [];\n\t\tcurve.ydata = [];\n\t\tcurve.ymax = 1;\n\t\tcurve.ymin = 0;\n\t\tcurve.color = 0;\n\t\tcurve.visible = true;\n\t\tcurve.linewidth = 2;\n\t\tcurve.pstr = \"\";\n\t\tcurve.type = 'singlevox';\n\t\tcurve.dasharray = \"none\";\n\n\t\t$.extend(true, curve, props)\n\n\t\treturn curve;\n\t}\n\t\n\n\n\t/******************************************************************************\n\tthe list of potential curves from the datamanager\n\t*******************************************************************************/\n\tvar mainList = {};\n\tvar roiList = {};\n\tvar colorcount = 0;\n\t// these structues will contain: \n\t//\t- filobj:    referenct to nii obj\n\t//\t- curveobj:  an object containing all the necessary curve data\n\n\tfunction updateCurveList_main()\n\t{\n\t\tvar tlist = KViewer.dataManager.getFileList();\n\t\t\n\t\t// remove deleted items first\n\t\tfor(var k in mainList)\n\t\t{\n\t\t\tif(tlist.indexOf(k) ==-1)\n\t\t\t{\n\t\t\t\tif(masterimage == mainList[k])\n\t\t\t\t{\n\t\t\t\t\tmasterimage = undefined;\n\t\t\t\t\tupdateCurveData_rois();\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t// reset curve data\n\t\t\t\tmainList[k].curveobj.xdata = [];\n\t\t\t\tmainList[k].curveobj.ydata = [];\n\t\t\t\tdelete mainList[k];\n\t\t\t}\n\t\t}\n\n\t\t// set master to first on initial\n\t\tif(masterimage == undefined &  Object.getOwnPropertyNames(mainList).length == 0  && tlist.length > 0)\n\t\t\tvar reinitMaster = true;\n\t\telse\n\t\t\tvar reinitMaster = false;\n\n\t\tvar newfound = false\n\t\tfor(var k=0; k<tlist.length; k++)\n\t\t{\n\t\t\tvar tfile = KViewer.dataManager.getFile( tlist[k] );\n\t\t\tif(tfile.contentType == \"nii\" && tfile.content!=undefined) // && tfile.content.numTimePoints>1)\n\t\t\t{\n \t\t\t\tvar fid = tfile.fileID;\n  \t\t\t\t// only add non-rois here\n  \t\t\t\tif(!(tfile.fileinfo.Tag && tfile.fileinfo.Tag.search('mask') >-1 ))\n \t\t\t\t{\n \t\t\t\t\tif(mainList[fid] == undefined)\n \t\t\t\t\t{\n \t\t\t\t\t\tnewfound = true;\n\t\t\t\t\t\tmainList[fid] = {\n\t\t\t\t\t\t\tfileobj:  tfile,\n\t\t\t\t\t\t\tisTSeries: tfile.content.numTimePoints>1,\n\t\t\t\t\t\t\tcurveobj: createCurve( {color: colorcount%KColor.list.length })\n\n\t\t\t\t\t\t\t};\n\t\t\t\t\t\tcolorcount++;\t\n \t\t\t\t\t}\n \t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(reinitMaster)\n\t\t\tsetMaster();\n\n\t\t// this is somewhat doubled, but we need to do this\n\t\t// list can change on pushROI, delROI, closeAll, ...\n\t\tif(newfound)\n\t\t{\n\t\t\tupdateCurveData_main();\n\t\t\tupdateCurveList_rois()\n\t\t}\n\n\n\t}\n\t\n\tfunction updateCurveList_rois()\n\t{\n\t\tif (KViewer.roiTool != undefined)\n\t\t{\n\t\t\tvar baselist = Object.getOwnPropertyNames( KViewer.roiTool.ROIs);\n\t\t\tfor(var k in roiList)\n\t\t\t{\n\t\t\t\tif(baselist.indexOf(k) ==-1)\n\t\t\t\t{\n\t\t\t\t\t// reset curve data\n\t\t\t\t\troiList[k].curveobj.xdata = [];\n\t\t\t\t\troiList[k].curveobj.ydata = [];\n\n\t\t\t\t\tdelete roiList[k];\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tfor(var k in KViewer.roiTool.ROIs)\n\t\t\t{\n\t\t\t\tvar tfile =  KViewer.roiTool.ROIs[k]\n\t\t\t\tif(roiList[k] == undefined)\n\t\t\t\t{\n\t\t\t\t\tKViewer.roiTool.ROIs[k]\n\t\t\t\t\troiList[k] = {\n\t\t\t\t\t\t\tfileobj:  tfile,\n\t\t\t\t\t\t\tcurveobj: createCurve({type: 'roi', _dasharray:'5,5', linewidth:'5',  color:tfile.color, visible:state.mode=='histogram'})\n\t\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t// the GUI handles to enable / disable curves ...\n\t\tupdateCurveListHandlers();\n\t\tdrawAllCurves();\n\t\t//updateCurveData_main();\n\t}\n\n\tthat.updateCurveList_main = updateCurveList_main;\n\tthat.updateCurveList_rois = updateCurveList_rois;\n\t\n\n\n\n\n\t/******************************************************************************\n\ta general switcher\n\t*******************************************************************************/\n\tfunction KSwitch(options_in)\n\t{\n\t\tvar that = {};\n\t\tthat.options = \n\t\t{\n\t\t\tcallback:undefined,\n\t\t\tsize:1\n\t\t}\n\t\t$.extend(true, that.options, options_in);\n\n\t\tthat.$div   = $(\"<div class='KSwitch'></div>\");\n\t\tthat.$button = $(\"<div class='KSwitch_button KSwitch_disabled'></div>\").appendTo(that.$div);\n\t\tthat.state = 0;\n\t\t\n\t\tthat.setState = function(state)\n\t\t{\n\t\t\tthat.state = state;\n\t\t\tif(that.state)\n\t\t\t\tthat.$button.addClass('KSwitch_enabled').removeClass('KSwitch_disabled');\n\t\t\telse\n\t\t\t\tthat.$button.removeClass('KSwitch_enabled').addClass('KSwitch_disabled');\n\t\t\t\n\t\t\treturn that;\n\t\t}\n\n\t\tthat.appendTo = function($target)\n\t\t{\n\t\t\tthat.$div.appendTo($target);\n\t\t\treturn that;\n\t\t}\n\n\t\tthat.switch = function(newstate)\n\t\t{\n\n\t\t\tthat.setState(newstate==undefined?!that.state:newstate);\n\t\t\tif(that.options.callback)\n\t\t\t{\n\t\t\t\tthat.options.callback(that);\n\t\t\t}\n\t\t}\n\n\t\tthat.$div.click( function()\n\t\t{\n\t\t\tthat.switch();\n// \t\t\tthat.setState(!that.state);\n// \t\t\tif(that.options.callback)\n// \t\t\t{\n// \t\t\t\tthat.options.callback(that);\n// \t\t\t}\n\t\t} );\n\n\t\tthat.setCallback = function(callback)\n\t\t{\n\t\t\tthat.options.callback = callback;\n\t\t\treturn that;\n\t\t}\n\n\t\treturn that;\n\t}\n\n\t/******************************************************************************\n\tthe GUI handlers\n\t*******************************************************************************/\n\n\tvar handlers = {};\n \thandlers.main = {};\n \thandlers.ROIs = {};\n\n\tthat.meanROIMasters = [];\n\t\n\n\tfunction updateCurveListHandlers()\n\t{\n\t\t$box.empty();\n\t\tvar $main  = $(\"<div class='' style =''></div>\").appendTo($box);\n\t\tif (state.mode != \"histogram\")\n\t\t{\n\t\t\tvar $srow_single = $(\"<div class='KViewPort_curvecontainer_listTitle'></div>\").appendTo($main);\n\t\t\tvar $title = $(\"<div class=''><b>Single voxel curves</b></div>\").appendTo($srow_single);\n\t\t\t$(\"<div class='flexspacer'></div>\").appendTo($srow_single);\n// \t\t\tvar tswitch = new KSwitch({callback: function(s){ toggle_singleVoxelCurve(\"all\", s.state)}  })\n// \t\t\t\t\t\t\t.$div.appendTo( $srow )\n\n\t\t\tvar $showhideall = $(\"<div class='KViewPort_curvecontainer_showHideAll'></div>\").appendTo($srow_single);\n\t\t\tvar $hideall = $(\"<div class='KViewPort_tool'><i class='fa fa-eye-slash'></i></div>\").appendTo($showhideall).click( function(ev){toggle_singleVoxelCurve(\"all\", 0)} );\n\t\t\tvar $showall = $(\"<div class='KViewPort_tool'><i class='fa fa-eye'></div>\").appendTo($showhideall).click( function(ev){toggle_singleVoxelCurve(\"all\", 1)} );\n\t\t}\n\t\tvar $rois  = $(\"<div class='' style =''></div>\").appendTo($box);\n\t\tvar $srow = $(\"<div class='KViewPort_curvecontainer_listTitle'></div>\").appendTo($rois);\n\n\t\tif (state.mode == 'histogram')\n\t\t\tvar $title = $(\"<div class=''><b>Histogram over</b></div>\").appendTo($srow);\n\t\telse\n\t\t\tvar $title = $(\"<div class=''><b>Mean curve over</b></div>\").appendTo($srow);\n\n\t\tvar $mastersel = $(\"<select class='flexspacer' style='margin-left:0px'></select>\").appendTo( $srow )\n\t\t//$mastersel.change(function(k,$e){return function(){ setMaster(k,$e) }}(k,$master)  );\n\t\t$mastersel.click(function(ev){ setMaster( $(this).val() )});\n\n\t\tvar $showhideall = $(\"<div class='KViewPort_curvecontainer_showHideAll'></div>\").appendTo($srow);\n\t\tvar $hideall = $(\"<div class='KViewPort_tool'><i class='fa fa-eye-slash'></i></div>\").appendTo($showhideall).click( function(ev){toggle_ROIMeanCurve(\"all\", 0)} );\n\t\tvar $showall = $(\"<div class='KViewPort_tool'><i class='fa fa-eye'></div>\").appendTo($showhideall).click( function(ev){toggle_ROIMeanCurve(\"all\", 1)} );\n\n\n//\t\tvar $histpar_bins = $(\"<div class='KViewPort_curvetoolinput'><div>#bins:</div>  <input/> </div>\").appendTo($srow);\n//\t\tvar $histpar_min = $(\"<div class='KViewPort_curvetoolinput'><div>min:</div> <input/> </div>\").appendTo($srow);\n//\t\tvar $histpar_max = $(\"<div class='KViewPort_curvetoolinput'><div>max:</div> <input/> </div>\").appendTo($srow);\n\n\n//KMouseSlider( $histpar_bins, {min:0, incrementPerPixel: .1 });\n//KMouseSlider( $histpar_min, {min:0, incrementPerPixel: .1 });\n\n\t\tfor(var k in mainList)\n\t\t{\n\t\t\tvar fobj = mainList[k].fileobj;\n\t\t\tvar ID = fobj.fileID;\n\t\t\t//var name = fobj.fileinfo.SubFolder + fobj.fileinfo.Filename;\n\t\t\t//var name = fobj.fileinfo.Filename;\n\t\t\tvar name = fobj.filename;\n\n\t\t\n\t\t\t$mastersel.append( $(\"<option value='\"+k+\"'>\"+ name+\" </option>\") )\n\n\t\t\tvar $row1  = $(\"<div class='KViewPort_curvecontainer_item'></div>\").appendTo($main);\n\n\t\t\tvar\t$colorselector = KColorSelectorSimple($(\"<div class='' style='width:18px'></div>\"),  setcolor(mainList[k]), mainList[k].curveobj).appendTo($row1);\n\t\t\tvar $div   = $(\"<div class=''>\"+name+ \"</div>\").appendTo($row1);\n\t\t\t$(\"<div class='flexspacer'></div>\").appendTo($row1);\n\n\n// \t\t\tvar tswitch = new KSwitch()\n// \t\t\t\t\t\t\t.setCallback( function(k){ return function(s){ toggle_singleVoxelCurve(k)  } }(k))\n// \t\t\t\t\t\t\t.setState(  mainList[k].curveobj.visible )\n// \t\t\t\t\t\t\t.appendTo( $row1 );\n\n\n\t\t\tvar $eye = $(\"<i class='fa'></i>\").appendTo( $row1 )\n\n\t\t\t$row1.click( function(k){ return function(ev){toggle_singleVoxelCurve(k)}}(k)  );\n\t\t\t\n\t\t\tif (state.mode == \"histogram\" | !mainList[k].isTSeries)\n\t\t\t\t$row1.hide();\n\t\t\t\n\n\n\t\t\tmainList[k].curveobj.handles = {\n\t\t\t\t$row:$row1,\n\t\t\t\t$eye: $eye,\n\t\t\t\t$namediv: $div,\n\t\t\t\t//tswitch:tswitch\n\t\t\t\t};\n\n\t\t\tsetCurveToggleState( mainList[k].curveobj )\n\n\t\t}\n\n    \tif(masterimage!=undefined)\n    \t{\n    \t\t$mastersel.val(masterimage.fileobj.fileID);\n    \t}\n    \telse\n    \t{\n\t\t\t$mastersel.val('deselect');\n    \t}\n\n\t\t/*******************************************/\n\n\t\tif (Object.keys(roiList).length == 0)\n\t\t{\n\t\t\t\tvar $row1  = $(\"<div class='KViewPort_curvecontainer_item' style =''></div>\").appendTo($rois);\n\n\t\t\t\tvar $div = $(\"<div class='KViewPort_curvecontainer_name'> no ROI defined </div>\").appendTo($row1);\n\n\n\t\t}\n\t\telse\n\t\t\tfor(var k in roiList)\n\t\t\t{\n\t\t\t\tvar fobj = roiList[k].fileobj;\n\t\t\t\tvar ID = fobj.fileID;\n\t\t\t\t//var name = fobj.fileinfo.SubFolder + fobj.fileinfo.Filename;\n\t\t\t\tvar name = fobj.filename;\n\t\t\t\tvar $row1  = $(\"<div class='KViewPort_curvecontainer_item' style =''></div>\").appendTo($rois);\n\t\t\t\tvar\t$colorselector = KColorSelectorSimple($(\"<div class='' style='width:18px;'></div>\"),  setcolor(roiList[k]), roiList[k].curveobj).appendTo($row1);\n\n\t\t\t\tvar $div = $(\"<div class='KViewPort_curvecontainer_name'>\"+name+ \"</div>\").appendTo($row1);\n\n\t\t\t\t$(\"<div class='flexspacer'></div>\").appendTo($row1);\n\t\t\t\tvar $eye = $(\"<i class='fa'></i>\").appendTo( $row1 );\n\n\t\t\t\t$row1.click( function(k){ return function(ev){toggle_ROIMeanCurve(k)}}(k)   );\n\n\t\t\t\troiList[k].curveobj.handles = {\n\t\t\t\t\t$row:$row1,\n\t\t\t\t\t$eye: $eye,\n\t\t\t\t\t$namediv: $div\n\t\t\t\t\t};\n\n\t\t\t\tsetCurveToggleState(roiList[k].curveobj)\n\t\t\t}\n\n\t\tupdateCurveData_rois();\t\t\n\t\tdrawAllCurves();\n\n\n\t}\n\n\t/******************************************************************************\n\tsetColor (closure function)\n\t*******************************************************************************/\n\tfunction setcolor(obj)\n\t{\n\t\treturn function(color)\n\t\t{\n\t\t\tKViewer.roiTool.setColorGlobal(obj.fileobj.fileID , color )\n\t\t\tvar c = color = KColor.findColorIndex(color.color);    \n\t\t\tobj.curveobj.color = c;\n\t\t\tdrawAllCurves();\n\t\t}\n\t}\n\n\t/******************************************************************************\n\ttoggleCurveVisibleState\n\t*******************************************************************************/\n\tfunction setCurveToggleState(curveobj)\n\t{\n\t\tif(!curveobj.visible)\n\t\t{\n\t\t\tcurveobj.handles.$eye.addClass('fa-eye-slash').removeClass('fa-eye').css('color', '');\n\t\t\tcurveobj.handles.$row.css('color', 'hsl(0,0%,60%)');\n\t\t}\n\t\telse\n\t\t{\n\t\t\tcurveobj.handles.$eye.addClass('fa-eye').removeClass('fa-eye-slash').css('color', '');\n\t\t\tcurveobj.handles.$row.css('color', '');\n\t\t}\n\t\n\t}\n\n\t/******************************************************************************\n\ttoggleSingleCurve\n\t*******************************************************************************/\n\tfunction toggle_singleVoxelCurve(id, state)\n\t{\n\t\tif(id==\"all\")\n\t\t{\n\t\t\tfor(var k in mainList)\n\t\t\t{\n\t\t\t\t//mainList[k].curveobj.handles.tswitch.switch(state);\n\t\t\t\ttoggle_singleVoxelCurve(k, state)\n\t\t\t}\n\t\t}\n\t\tif(mainList[id]==undefined)\n\t\t\treturn \n\n\t\tvar obj = mainList[id];\n\t\tobj.curveobj.visible =    state==undefined?!obj.curveobj.visible:state;\n\t\tsetCurveToggleState(obj.curveobj)\n\n\t\tif(obj.curveobj.visible)\n\t\t\tcalcCurveData(obj.curveobj, obj.fileobj.content);\n\t\telse\n\t\t\tdrawAllCurves();\n\t}\n\n\t/******************************************************************************\n\ttoggleSingleCurve\n\t*******************************************************************************/\n\tfunction toggle_ROIMeanCurve(id, state)\n\t{\n\t\tif(id==\"all\")\n\t\t{\n\t\t\tfor(var k in roiList)\n\t\t\t\ttoggle_ROIMeanCurve(k, state)\n\t\t}\n\t\tif(roiList[id]==undefined)\n\t\t\treturn \n\t\t\t\n\t\tvar obj = roiList[id];\n\t\tobj.curveobj.visible =    state==undefined?!obj.curveobj.visible:state;\n\t\tsetCurveToggleState(obj.curveobj)\n\n\t\tif(obj.curveobj.visible)\n\t\t\tif(masterimage!=undefined)\n\t\t\t{\n\t\t\t\tcalcCurveData(obj.curveobj, masterimage.fileobj.content, obj.fileobj);\n\t\t\t\tdrawAllCurves();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tobj.curveobj.xdata = [];\n\t\t\t\tobj.curveobj.ydata = [];\n\t\t\t}\n\n\t\telse\n\t\t\tdrawAllCurves();\n\t}\n\n\n\n\n\t/******************************************************************************\n\tthe master curve for the rois\n\t*******************************************************************************/\n\tfunction setMaster(id, $elem)\n\t{\n\t\tif(id == undefined)\n\t\t{\n\t\t\tvar t = Object.getOwnPropertyNames(mainList);\n\t\t\tif(t.length>0)\n\t\t\t\tid = t[0];\n\t\t\telse\n\t\t\t\treturn\n\n\t\t}\n\t\tmasterimage = mainList[ id ]\n\t\tupdateCurveData_rois();\n\t}\n\n\t/******************************************************************************\n\textract the data for the single voxel curves\n\t*******************************************************************************/\n\tfunction updateCurveData_main()\n\t{\n\t\tif (state.mode != 'histogram')\n\t\t{\n\t\t\tfor(var k in mainList)\n\t\t\t{\n\t\t\t\tvar obj = mainList[k];\n\t\t\t\tif (obj.isTSeries)\n\t\t\t\t    calcCurveData(obj.curveobj, obj.fileobj.content);\n\t\t\t}\n\n\t\t\tif(state.mode == 'vsi')\n\t\t\t{\n\t\t\t\tvar clist = Object.getOwnPropertyNames(mainList);\n\t\t\t\tfor(var c=0; c<clist.length; c+=2)\n\t\t\t\t{\n\t\t\t\t\tvar obj1 = mainList[clist[c]]\n\t\t\t\t\tvar obj2 = mainList[clist[c+1]]\n\t\t\t\t\tif(obj2 && obj2 )\n\t\t\t\t\t{\n\t\t\t\t\t\tvar obj1 = obj1.curveobj\n\t\t\t\t\t\tvar obj2 = obj2.curveobj\n\t\t\t\t\t\tfor(var k=0; k< obj1.xdata.length; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tobj1.xdata[k] = obj2.ydata[k]/obj2.ymax*600;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t//delete mainList[clist[c+1]];\n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t}\n\t\t\tdrawAllCurves();\n\t\t}\n\t}\n\tthat.updateCurveData_main = updateCurveData_main;\n\n\n\n\tthat.updaterois = -1;\n\t/******************************************************************************\n\textract the data for the ROI curves : this can be quite expensive, so it is an extra function\n\t*******************************************************************************/\n\tfunction updateCurveData_rois( roiid )\n\t{\n\n\t\t//if (that.updaterois != -1)\n\t\t//\tclearTimeout(that.updaterois);\n\t\t//that.updaterois = setTimeout(doit,150);\n\n\n\t\tvar keys = Object.keys(roiList);\n\t\t\n\t\tdoit();\n\n\t\tfunction doit()\n\t\t{\n\n\t\t\tvar k = keys.splice(0,1);\n\t\t\tif (k.length == 0)\n\t\t\t\treturn;\n\n\t\t\tvar obj = roiList[k];\n\t\t\tif(obj.curveobj.visible)\n\t\t\t{\n\t\t\t\tif(roiid == undefined || roiid.id == k)\n\t\t\t\tif(masterimage!=undefined)\n\t\t\t\t{\n\t\t\t\t\tcalcCurveData(obj.curveobj, masterimage.fileobj.content, obj.fileobj, function (){\n\t\t\t\t\t\tdrawAllCurves();\n\t\t\t\t\t\tdoit();\t\t\t\t\t\t\n\t\t\t\t\t});\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tobj.curveobj.xdata = [];\n\t\t\t\t\tobj.curveobj.ydata = [];\n\t\t\t\t}\n\n\t\t\t}\t\t\n\t\t\tdoit();\n\t\t}\n\n\t}\n\tthat.updateCurveData_rois = updateCurveData_rois;\n\tvar maxnumtimepoints = 0;\n   \tvar seqinfo;\n\t\n\t/******************************************************************************\n\tplot all curves for this medviewer\n\t*******************************************************************************/\n    function drawAllCurves()\n    {\n\n    \tfor (var k in mainList)\n    \t{\n\t\t\tif (mainList[k] && mainList[k].fileobj)\n\t\t\t{\n\t\t\t\tseqinfo = mainList[k].fileobj.seqinfo;\n\t\t\t\tbreak;\n\t\t\t}\n    \t}\n    \t    \n\t\tvar yscaling = parseFloatEval(state.yscaling,seqinfo);\n\t\tif (isNaN(yscaling))\n\t\t\tyscaling = 1;\n\t\tvar xscaling = parseFloatEval(state.xscaling,seqinfo);\n\t\tif (isNaN(xscaling))\n\t\t\txscaling = 1;\n\t\tif (typeof state.yscaling == \"string\")\n\t\t{\n\t\t\tvar labeling = state.yscaling.split(\" \");\n\t\t\tif (labeling[1] != undefined)\n\t\t\t\t$ylabel.text(labeling[1])\n\t\t}\n\t\tif (typeof state.xscaling == \"string\")\n\t\t{\n\t\t\tvar labeling = state.xscaling.split(\" \");\n\t\t\tif (labeling[1] != undefined)\n\t\t\t\t$xlabel.text(labeling[1])\n\t\t}\n\n\n\t\t// find the max / min off all curves\n\t\tvar ymaxtot = -10000000;\n\t\tvar ymintot =  10000000;\n\t\tvar minnumtimepoints = 100000000;\n\t\tmaxnumtimepoints = -100000000;\n\n\t\tif (state.mode != \"histogram\")\t\n\t\t{\n\t\t\tminnumtimepoints = 0;\n\t\t\tfor(var k in mainList )\n\t\t\t{\n\t\t\t\tvar obj = mainList[k].curveobj;\n\t\t\t\tif(!obj.visible)\n\t\t\t\t\tcontinue;\n\t\t\t\tif(obj.ymax !=undefined && obj.ymax > ymaxtot )\n\t\t\t\t\tymaxtot =obj.ymax;\n\t\t\t\tif(obj.ymin !=undefined && obj.ymin < ymintot)\n\t\t\t\t\tymintot = obj.ymin;\n\n\t\t\t\tif(obj.xdata.length > maxnumtimepoints)\n\t\t\t\t\tmaxnumtimepoints = obj.xdata.length\n\t\t\t}\n\n\t\t}\n\n\t\tfor(var k in roiList)\n\t\t{\n\t\t\tvar obj = roiList[k].curveobj;\n\t\t\tif(!obj.visible)\n\t\t\t\tcontinue;\n\t\t\tif(obj.ymax > ymaxtot)\n\t\t\t\tymaxtot =obj.ymax;\n\t\t\tif(obj.ymin < ymintot)\n\t\t\t\tymintot = obj.ymin;\n\n\n\t\t\tif (state.mode == \"histogram\")\n\t\t\t{\n\t\t\t\tminnumtimepoints = Math.min(obj.xdata[0],minnumtimepoints)\n\t\t\t\tmaxnumtimepoints = Math.max(obj.xdata[obj.xdata.length-1],maxnumtimepoints);\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(obj.xdata.length > maxnumtimepoints)\n\t\t\t\t\tmaxnumtimepoints = obj.xdata.length\n\n\t\t\t}\n\n\t\t}\n\n\n\n\n\n\n\n\n\t// we have to clean all svg curves first ... not so nice but necessary\n \t\t$curves.attr(\"points\", \"\");\t\t\n\n   \t\t$curvecontainer.find(\".Kcurveinfo\").remove();\n\t\tvar cnt =1;\n\t\tvar top = 10+ 25*cnt++;\n\t\tif (state.mode == \"histogram\")\n\t\t{\n\t\t\t$curvecontainer.append($(\"<div class='Kcurveinfo' style='top:\"+top+\"px;'>\"\n\t\t\t\t +\"mean/ sd / #vox </div> \"));\t\t\t\n\t\t}\n\t\telse\n\t\t\t$curvecontainer.append($(\"<div class='Kcurveinfo' style='top:\"+top+\"px;'>\"\n\t\t\t\t +\"min/ max/ AUC </div> \"));\t\t\t\n\n\t\tvar curveindex = 0;\n\t\t\n\t\t//******** main\n\t\tif (state.mode != \"histogram\")\n\t\t\tfor(var k in mainList)\n\t\t\t{\n\t\t\t\tdrawcurve(curveindex++,  mainList[k].curveobj);\n\t\t\t\tif (mainList[k].curveobj.visible && mainList[k].isTSeries)\n\t\t\t\t{\n\t\t\t\t\tvar csscol = (new KColor( KColor.list[mainList[k].curveobj.color] )).getCSS();\n\t\t\t\t\tvar top = 10+ 25*cnt++;\n\n\t\t\t\t\tif (mainList[k].curveobj.ymin != undefined)\t\t\t\n\t\t\t\t\t\t$curvecontainer.append($(\"<div class='Kcurveinfo' style='top:\"+top+\"px;border-color:\" +csscol+ \"'>\"\n\t\t\t\t\t\t +(yscaling*mainList[k].curveobj.ymin).toFixed(2) + \"/ \"+(yscaling*mainList[k].curveobj.ymax).toFixed(2) +\n\t\t\t\t\t\t \"/ \"+(yscaling*xscaling*mainList[k].curveobj.auc).toFixed(2) +\n\t\t\t\t\t\t\t \" </div> \"));\n\n\t\t\t\t}\t\t\t\t\n\t\t\t}\n\n\t\t//******** ROIs\n\n\t\tfor(var k in roiList)\n\t\t{\n\t\t\tdrawcurve(curveindex++,  roiList[k].curveobj, [minnumtimepoints,maxnumtimepoints]);\n\n\t\t\tif (roiList[k].curveobj.visible)\n\t\t\t{\n\t\t\t\tvar csscol = (new KColor( KColor.list[roiList[k].curveobj.color] )).getCSS();\n\t\t\t\tvar top = 10+ 25*cnt++;\n\t\t\t\tif (state.mode == \"histogram\")\n\t\t\t\t{\n\t\t\t\t\tif (roiList[k].curveobj.mean != undefined)\t\t\t\n\t\t\t\t\t\t$curvecontainer.append($(\"<div class='Kcurveinfo' style='top:\"+top+\"px;border-color:\" +csscol+ \"'>\"\n\t\t\t\t\t\t +roiList[k].curveobj.mean.toFixed(2) + \"/ \"+roiList[k].curveobj.stddev.toFixed(2) +\n\t\t\t\t\t\t \"/ \"+roiList[k].curveobj.count +\n\t\t\t\t\t\t\t \" </div> \"));\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tif (roiList[k].curveobj.ymin != undefined)\t\t\t\n\t\t\t\t\t\t$curvecontainer.append($(\"<div class='Kcurveinfo' style='top:\"+top+\"px;border-color:\" +csscol+ \"'>\"\n\t\t\t\t\t\t +(yscaling*roiList[k].curveobj.ymin).toFixed(2) + \"/ \"+(yscaling*roiList[k].curveobj.ymax).toFixed(2) +\n\t\t\t\t\t\t \"/ \"+(yscaling*xscaling*roiList[k].curveobj.auc).toFixed(2) +\n\t\t\t\t\t\t\t \" </div> \"));\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\n        ymaxtot *= yscaling;\n        ymintot *= yscaling;\n\n\t\t//******** adjust the x / y lims\n\t\t// viewbox reference size is 100, 100\n\t\tif(1)\n\t\t{\n\n\t\t\tif (ymaxtot==ymintot)\n\t\t\t\treturn;\n\n\n\n\t\t\tvar t = getTicks(ymaxtot, ymintot);\n\t\t\tvar yscale = 1/(ymaxtot - ymintot) *100;\n\t\t\tvar yshift = -ymintot\n\t\t\tvar yshift = -t.position[0];\n\n\t\t\tvar dy1 = ( parseFloat(t.position[t.ticks.length-1]) - t.position[0] );\n\t\t\tvar dy2 = ( ymaxtot - t.ticks[0] );\n\t\t\t\n\t\t\tvar yscale = 1/(dy1+1e-15 )*100;\n\n\t        $curvegroup.attr('transform',\" scale(100, \" + yscale + \") translate(0, \" + yshift + \") \");\n\n\t        for(var k=0; k<$gridlineshorz.length; k++)\n\t        {\n\n\t        \tif(k < t.ticks.length)\n\t        \t{\n\t        \t\tvar yy = k/(t.ticks.length-1)*dy1/dy1*100;// +  (ymintot - t.ticks[0])/dy2;\n\t        \t\tif(yy==Infinity)\n\t        \t\t\tyy = k/(t.ticks.length-1)*100;\n\t\t\t\t\t$($gridlineshorz[k]).attr('y1', yy).attr('y2', yy);\n\t\t\t\t\tyticklabels[k].text( t.ticks[k]).css('top', (100-yy)+\"%\");\n\t        \t}\n\t        \telse\n\t        \t{\n\t\t\t\t\t$($gridlineshorz[k]).attr('y1', -1).attr('y2', -1);\n\t\t\t\t\tyticklabels[k].text(\"\");\n\t        \t}\n\t        }\n\n\t\t\tvar xscaling = parseFloatEval(state.xscaling,seqinfo);\n\t\t\tif (isNaN(xscaling))\n\t\t\t\txscaling = 1;\n\t\t\t\n\t\t\tvar t = getTicks(minnumtimepoints*xscaling, maxnumtimepoints*xscaling);\n\t        for(var k=0; k<$gridlinesvert.length; k++)\n\t        {\n\n\t        \tif(k < t.ticks.length)\n\t        \t{\n\t        \t\tvar yy = k/(t.ticks.length-1)*100;\n\t        \t\tif(yy==Infinity)\n\t        \t\t\tyy = k/(t.ticks.length-1)*100;\n\t\t\t\t\t$($gridlinesvert[k]).attr('x1', yy).attr('x2', yy);\n\t\t\t\t\txticklabels[k].text( t.ticks[k]).css('left', (yy)+\"%\");\n\t\t\t\t\txticklabels[k].css('font-size',9);\n\t        \t}\n\t        \telse\n\t        \t{\n\t\t\t\t\t$($gridlinesvert[k]).attr('x1', -1).attr('x2', -1);\n\t\t\t\t\txticklabels[k].text(\"\");\n\t        \t}\n\t        }\n\t\t}\n    }\n\n\n\t/******************************************************************************\n\tdownloadcurves\n\t*******************************************************************************/\n\tfunction downloadcurves()\n\t{\n\n    \tfor (var k in mainList)\n    \t{\n\t\t\tif (mainList[k] && mainList[k].fileobj)\n\t\t\t{\n\t\t\t\tseqinfo = mainList[k].fileobj.seqinfo;\n\t\t\t\tbreak;\n\t\t\t}\n    \t}\n    \t  \n\n\t\tvar yscaling = parseFloatEval(state.yscaling,seqinfo);\n\t\tif (isNaN(yscaling))\n\t\t\tyscaling = 1;\n\t\tvar xscaling = parseFloatEval(state.xscaling,seqinfo);\n\t\tif (isNaN(xscaling))\n\t\t\txscaling = 1;\n        var xlabel = \"no unit\";\n        var ylabel = \"no unit\";\n\n\t\tif (typeof state.yscaling == \"string\")\n\t\t{\n\t\t\tvar labeling = state.yscaling.split(\" \");\n\t\t\tif (labeling[1] != undefined)\n\t\t\t\t ylabel =  (labeling[1])\n\t\t}\n\t\tif (typeof state.xscaling == \"string\")\n\t\t{\n\t\t\tvar labeling = state.xscaling.split(\" \");\n\t\t\tif (labeling[1] != undefined)\n\t\t\t\t xlabel = (labeling[1])\n\t\t}\n\n\t\tvar tcurves = [];\n\n\t\tvar coltp = [];\n\t\ttcurves.push(coltp);\n\t\tcoltp.push(\"index(\"+ xlabel +\")\");\t\t\t\t\n\t\tfor(var t=0; t<maxnumtimepoints ; t++)\n\t\t\tcoltp.push((t*xscaling).toString());\n\n\n\n\t\tfor(var k in mainList )\n\t\t{\t\n\t\t\tvar obj = mainList[k].curveobj;\n\t\t\tif(!obj.visible)\n\t\t\t\tcontinue;\n\t\t\tvar col = [];\n\t\t\ttcurves.push(col);\n\t\t\tvar descrip = mainList[k].fileobj.fileinfo.SubFolder + \"_\" + mainList[k].fileobj.filename\n\t\t\tcol.push(descrip + \"(\" + ylabel + \")\");\t\t\t\t\n\t\t\tfor(var t=0; t<obj.ydata.length; t++)\n\t\t\t{\t\n\t\t\t\tcol.push((obj.ydata[t]*yscaling).toString());\n\t\t\t}\n\t\t}\n\t\tfor(var k in roiList)\n\t\t{\n\t\t\tvar obj = roiList[k].curveobj;\n\t\t\tif(!obj.visible)\n\t\t\t\tcontinue;\n\t\t\tvar col = [];\n\t\t\ttcurves.push(col);\n\t\t\t//var descrip = roiList[k].fileobj.fileinfo.SubFolder + \"_\" + roiList[k].fileobj.filename\n\t\t\tvar descrip = \"\" + roiList[k].fileobj.filename  + \"_OVER_\" + masterimage.fileobj.fileinfo.SubFolder + \"_\" + masterimage.fileobj.filename\t\n\t\t\tcol.push(descrip);\t\t\t\t\n\t\t\tfor(var t=0; t<obj.ydata.length; t++)\n\t\t\t{\t\n\t\t\t\tcol.push((obj.ydata[t]*yscaling).toString());\n\t\t\t}\n\t\t}\n\n\tvar str = \"\";\n\tfor(var t=0; t<coltp.length; t++)\n\t{\n\t\tfor(var k=0; k<tcurves.length; k++)\n\t\t{\n\t\t\tif(t < tcurves[k].length)\n\t\t\t\tvar val = tcurves[k][t];\n\t\t\telse\n\t\t\t\tvar val = \"\";\n\t\t\tstr += val + \"\\t\";\n\t\t}\n\t\tstr += \"\\n\";\n\t}\n\n\t\n\tvar $temp = $(\"<textarea style='position:absolute; display:block;z-index:99999;top:0px'>\"+str+\"</textarea>\").appendTo($body).select();\n\tvar successful = document.execCommand('Copy');\n\t$.notify(\" Copied \"+  (tcurves.length-1) + \" visible timeseries copied to clipboard\",\"success\");\n\t$temp.remove();\n\tconsole.log(str);\n\n\n\t}\n\n\n\t/******************************************************************************\n\tupdateCurrentTimePoint\n\t*******************************************************************************/\n\tthat.updateCurrentTimePoint = function(val)\n\t{\n\t\tif (state.mode != \"histogram\")\n\t\t{\n\t\t\t$currenttimeline.attr('x1', val/maxnumtimepoints*100);\n\t\t\t$currenttimeline.attr('x2', val/maxnumtimepoints*100);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tupdateCurveData_rois();\n\t\t\tdrawAllCurves();\t\n\t\t}\n\t}\n\n\t/******************************************************************************\n\tdrawcurve\n\t*******************************************************************************/\n    function drawcurve(curveindex, obj,lims)\n    {\n\t\t/* \n\t\tMODES  \n\t\t\tNormal\n\t\t\tVSI\n\t\t\tDiffusion\n\t\t\tPerf neg logplot\n\t\t\n\t\tSWITCHTES\n\t\t\tbaselinelength subtraction\n\t\t\tScale to min / max of all curves\n\t\t\tLogplot\n\t\t\tMinus\n\n    \t*/\n    \t\n\t\tvar $curve = $($curves.get(curveindex));\n\n\t\tif(!obj.visible)\n\t\t{\n\t\t\t$curve.css('visibility','hidden');\n\t\t\treturn;\n\t\t}\n\n        var pstr = \"\";\n\t\tvar color =  obj.color==undefined?curveindex:obj.color;\n\t\tcolor = KColor.list[color];\n\n\t\t//********* baselinelength\n\t\tif(state.baselinelength > 0)\n\t\t{\n\t\t\tvar m = 0;\n\t\t\tvar blength = state.baselinelength<obj.ydata.length?state.baselinelength:obj.ydata.length;\n\t\t\tfor (var k = 0; k < blength; k++)\n\t\t\t{\n\t\t\t\tm += obj.ydata[k];\n\t\t\t}\n\t\t\tm = m/state.baselinelength; \n\t\t}\n\t\telse\n\t\t{\n\t\t\tm = 0;\n\t\t}\n\n\t\tvar yscaling = parseFloatEval(state.yscaling,seqinfo);\n\t\tif (isNaN(yscaling))\n\t\t\tyscaling = 1;\n\n\t\tvar vx = 0;\n\t\tvar vy = 0;\n\t\tvar max;\n\t\tvar min;\n\t\tvar ysum = 0;\n\t\tvar n = obj.ydata.length;\n\n\t\tfor (var i = 0; i < obj.ydata.length; i++)\n\t\t{\n\n\t\t\tif(state.baselinelength > 0)\n\t\t\t\tvy = (obj.ydata[i] - m ) ;\n\t\t\telse\n\t\t\t\tvy\t= obj.ydata[i] ;\n\n\t\t\tif ( isNaN(vy) )\n\t\t\t\tvy = 0;\n\t\t\t\n\t\t\tvy *= yscaling;\n\n\t\t\tif(state.mode == 'tseries' | state.mode == 'dce_test')\n\t\t\t{\n\t\t\t\tvx = ( i / (obj.ydata.length));\n\t\t\t}\n\t\t\telse if(state.mode == 'vsi')\n\t\t\t{\n\t\t\t\tvx = (obj.xdata[i]/1000);\n\t\t\t}\n\t\t\telse if (state.mode == 'histogram')\n\t\t\t{\n\t\t\t\tvx = (obj.xdata[i]- lims[0]) /(lims[1] - lims[0]);\n\t\t\t}\n\n\t\t\n\t\t\tif (max == undefined | vy > max)\n\t\t\t\tmax = vy;\n\t\t\tif (min == undefined | vy < min)\n\t\t\t\tmin = vy;\n\n\t\t\t\t// vsi speciality, remove first points\n\t\t\t\tif(state.mode == 'vsi' && i < 4)\n\t\t\t\t{\n\t\t\t\t\tvx = 0;\n\t\t\t\t\tvy = 0;\n\t\t\t\t}\n\t\t\t\n\t\t\tysum += (vy/n);\n\t\t\tpstr += vx + \",\";\n\t\t\tpstr += (vy) + \" \";\n\n\t\t}\n\n\n\t\t// if baseline corrected, must take min is already 0\n\t\tif(state.baselinelength > 0)\n\t\t{\t\t\t\n\t\t\t//max = max -min;\n\t\t\t//min = 0;\n\t\t}\n\n\t\tif(max == min)\t\n\t\t\tmax = min + 0.00000001;\n\n\t\t\t\n        if(state.normalise == 'noscaling')\n\t\t{\n\t\t\t$curve.attr('transform',\" scale(1,1 ) translate(0,0) \");\n\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tif(state.normalise == 'individual_max')\n\t\t\t\tvar yscale = 1/(max - min);\n\t\t\telse if(state.normalise == 'individual_area')\n\t\t\t\tvar yscale = 1/(ysum)/5;\n\t\t\telse if(state.normalise == 'individual_lastpoint')\n\t\t\t\tvar yscale = 1/vy/5; // last point\n\n\n\t\t\tvar yshift = -min\n\n\t\t\tif(isNaN(yscale))\n\t\t\t\tyscale = 1;\n\t\t\tif(isNaN(yshift))\n\t\t\t\tyshift = 0;\n\t\t\txscale = 1;\n\n// \t\t\tif(state.mode == 'vsi')\n// \t\t\t\txscale = 1/max/5;\n\n\t\t\t$curve.attr('transform',\" scale(\"+xscale+\", \" + yscale + \") translate(0, \"+ yshift + \") \");\n\t\t\tobj.ymax\t= 1;\n\t\t\tobj.ymin\t= 0;\n\t\t\t\n\t\t}\n\n        $curve.attr(\"points\", pstr);\n        $curve.css(\"stroke\", 'rgb('+ color.join(',') +')');\n        $curve.css('stroke-width','' + obj.linewidth);\n        $curve.css('stroke-dasharray', obj.dasharray);\n        $curve.css('visibility','visible');\n\n\n        \n    }\n    that.drawcurve = drawcurve;\n    \n\n\n\t/******************************************************************************\n\textract the curve data from nii / roi\n\t*******************************************************************************/\n\tfunction calcCurveData(curveobj, niiOriginal, roiobj,callback)\n\t{\n\n\t\t\n\t\tif(niiOriginal == undefined)\n\t\t{\n\t\t\tcurveobj.xdata = [];\n\t\t\tcurveobj.ydata = [];\n\t\t}\n\n\t\t// either a single point, or mean over a roi\n\t\tvar sizeroi;\n\t\tvar point_vox = [];\n\n\t\tif(roiobj == undefined)\n\t\t{\n\t\t\tvar point  = KViewer.currentPoint;\t\n\t\t\t// in non-global coordinate mode, points can be different ...\n\t\t\tif( KViewer.globalCoordinates == false )\n\t\t\t{\n\t\t\t\tKViewer.iterateMedViewers(function(m)\n            \t{\n\t\t\t\t\tif (m.nii !=undefined &&  m.niiOriginal == niiOriginal)\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint = m.getWorldPosition();\n\t\t\t\t\t}\n\t\t\t\t\n    \t\t\t});\n\n\n\t\t\t}\n\n\t\t\tpoint_vox.push( math.multiply(math.inv(niiOriginal.edges), point) );\n\t\t\tsizeroi = 0;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar roi = roiobj.content;\n\t\t\tif (roi == undefined)\n\t\t\t\treturn;\n\n\t\t\t//var roi = roiobj.nii;\n\t\t\tsizeroi = roi.sizes[0] * roi.sizes[1] * roi.sizes[2];\n\n\t\t\tif (niiOriginal.edges._data.toString() == roi.edges._data.toString())\n\t\t\t\tvar A = undefined;\n\t\t\telse\n\t\t\t\tvar A = (math.multiply(math.inv(roi.edges), niiOriginal.edges))._data;\n\n\t\t}\n\n\t\t\n\t\t//if (master.mainViewport !== -1)\n\t\t//   point = math.multiply(math.inv(master.reorientationMatrix.matrix), point);\n\n\t\tvar xdata = [];\n\t\tvar ydata = [];\n\t\tvar vsz = niiOriginal.sizes[0] * niiOriginal.sizes[1] * niiOriginal.sizes[2];\n\n\n\t\t//updateProgress(1);\n\t\t//setTimeout(findVoxels, 0);\n\t\tfindVoxels();\n\n\n\t\t\n\n\n\t\t//******* functions *******\n\t\tfunction updateProgress(perc)\n\t\t{\n\t\t\tif(roiobj!=undefined && curveobj.handles != undefined && curveobj.handles.$namediv != undefined)\n\t\t\t{\n\t\t\t\tif(perc > 0)\n\t\t\t\t{\n\t\t\t\t\tcurveobj.handles.$namediv.css('background', 'red');\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tcurveobj.handles.$namediv.css('background', '');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tfunction findVoxels()\n\t\t{\n\t\t\t// this is a roi. Find all indices and sum up for each timepoint (below)\n\t\t\tif(sizeroi > 0 )\n\t\t\t{\n\t\t\t\tvar sz = roi.sizes;\n\t\t\t\tif (roi.onVoxels == undefined)\n\t\t\t\t{\n\t\t\t\t\troi.onVoxels = KViewer.roiTool.history.initOnVoxels(roi);\n\t\t\t\t}\n\t\t\t\tvar keys = Object.keys(roi.onVoxels);\n\t\t\t\t// slicing of roi and contrast identical\n\t\t\t\tif (A == undefined)\n\t\t\t\t{\n\t\t\t\t\tfor (var k = 0; k < keys.length;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar idx = keys[k];\n\t\t\t\t\t\tif (roi.onVoxels[idx] == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar x = idx%sz[0];\n\t\t\t\t\t\t\tvar y = Math.floor(idx/sz[0])%sz[1];\n\t\t\t\t\t\t\tvar z = Math.floor(idx/(sz[0]*sz[1]));\n\t\t\t\t\t\t\tpoint_vox.push( math.matrix([x,y,z])) ;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\telse // slicing of roi and contrast different\n\t\t\t\t{\n\n\t\t\t\t\tvar maxx=0,maxy=0,maxz=0;\n\t\t\t\t\tvar minx=niiOriginal.sizes[0],miny=niiOriginal.sizes[1],minz=niiOriginal.sizes[2];\n\n\t\t\t\t\t// find bbox\n\t\t\t\t\tvar invA = math.inv(A)._data;\n\t\t\t\t\tfor (var k = 0; k < keys.length;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar idx = keys[k];\n\t\t\t\t\t\tif (roi.onVoxels[idx])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar x = idx%sz[0];\n\t\t\t\t\t\t\tvar y = Math.floor(idx/sz[0])%sz[1];\n\t\t\t\t\t\t\tvar z = Math.floor(idx/(sz[0]*sz[1]));\n\t\t\t\t\t\t\tvar wx = invA[0][0]*x+invA[0][1]*y+invA[0][2]*z + invA[0][3];\n\t\t\t\t\t\t\tvar wy = invA[1][0]*x+invA[1][1]*y+invA[1][2]*z + invA[1][3];\n\t\t\t\t\t\t\tvar wz = invA[2][0]*x+invA[2][1]*y+invA[2][2]*z + invA[2][3];\n\t\t\t\t\t\t\tif (wx > maxx) maxx = wx;\n\t\t\t\t\t\t\tif (wy > maxy) maxy = wy;\n\t\t\t\t\t\t\tif (wz > maxz) maxz = wz;\n\t\t\t\t\t\t\tif (wx < minx) minx = wx;\n\t\t\t\t\t\t\tif (wy < miny) miny = wy;\n\t\t\t\t\t\t\tif (wz < minz) minz = wz;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\tfor (var pz = minz; pz < maxz; pz++)\n\t\t\t\t\t{\n\t\t\t\t\t\tfor (var py = miny; py < maxy; py++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (var px = minx; px < maxx; px++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar rv = trilinInterp(roi, px, py, pz, A, 0);\n\t\t\t\t\t\t\t\tif (rv > 0.5)\n\t\t\t\t\t\t\t\t\tpoint_vox.push( math.matrix([px,py,pz])  );\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tupdateProgress(2);\n\t\t\t\t\n\t\t\t\n\t\t\t//setTimeout(calcSeries, 0);\n\t\t\tcalcSeries();\n\n\t\t\tif (callback)\n\t\t\t\tcallback();\n\n\t\t}\n\n\t\tfunction calcSeries()\n\t\t{\n\n\n\t\t\tupdateProgress(2);\n\n\t\t\tvar count = point_vox.length;\n\n\t\t\tif (state.mode == \"histogram\")\t\t\t\n\t\t\t{\n\t\t\t\tvar vals = [];\t\t\t\n\t\t\t\tvar min = 99999999;\t\n\t\t\t\tvar max = -99999999;\t\n\t\t\t\tvar m=0;\n\t\t\t\tvar m2=0;\n\t\t\t\tvar cnt = 0;\n\t\t\t\tfor(var p=0; p < count; p++)\n\t\t\t\t{\n\n\t\t\t\t\tvar pv = point_vox[p];\n\t\t\t\t\tvar vv = NNInterp(niiOriginal, pv._data[0], pv._data[1], pv._data[2], [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], niiOriginal.currentTimePoint.t*niiOriginal.sizes[0]*niiOriginal.sizes[1]*niiOriginal.sizes[2]);\n\t\t\t\t\tvv = niiOriginal.datascaling.e(vv);\n\t\t\t\t\tif( !isNaN(vv) && vv != undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tvals.push(vv);\n\t\t\t\t\t\tif (min > vv)\n\t\t\t\t\t\t\tmin = vv;\n\t\t\t\t\t\tif (max < vv)\n\t\t\t\t\t\t\tmax = vv;\n\t\t\t\t\t    m+=vv;\n\t\t\t\t\t    m2+=vv*vv;\n\t\t\t\t\t    cnt++;\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif (min==max)\n\t\t\t\t\treturn;\n\n\n//\t\t\t    var nbins = 1000;\n\t\t\t\t// fine histo to compute quantiles\n//\t\t\t\tvar histogram = comphisto(min, max, nbins, vals, vals.length, 500)\n\n\t\t\t\tvar nbins = 30;\n\n\t\t\t\tvar nsamps = vals.length;\n\t\t\t\tif (nsamps > 20000)\n\t\t\t\t\tnsamps = 20000;\n\n\t\t\t    var histogram = comphisto(min ,max, nbins, vals,  vals.length,  nsamps);\n\n\n\t\t\t\tcurveobj.xdata = [];\n\n\t\t\t\tfor ( var k = 0 ; k < nbins; k++)\n\t\t\t\t\tcurveobj.xdata.push(k *(max-min)/nbins+min);\n\n\t\t\t\tcurveobj.ymax = histogram.accus.maxfreq\n\t\t\t\tcurveobj.mean = m/cnt;\n\t\t\t\tcurveobj.stddev = Math.sqrt(m2/cnt-(m/cnt)*(m/cnt));\n\t\t\t\tcurveobj.count = cnt;\n\t\t\t\tcurveobj.ydata = histogram.accus;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\n\t\t\t    var ymax = -100000000;\n\t\t\t    var ymin = 100000000;\n\t\t\t\tvar auc = 0;\n\t\t\t\t// run over timepoints\n\t\t\t\tfor (var k = 0; k < niiOriginal.sizes[3]; k++)\n\t\t\t\t\tchunkStep();\n\n\t\t\t\tfunction chunkStep()\n\t\t\t\t{\n\t\t\t\t\tvar v = 0;\n\t\t\t\t\t// run over roi points\n\t\t\t\t\tfor(var p=0; p < count; p++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar pv = point_vox[p];\n\t\t\t\t\t\tvar vv = NNInterp(niiOriginal, pv._data[0], pv._data[1], pv._data[2], [[1, 0, 0, 0], [0, 1, 0, 0], [0, 0, 1, 0], [0, 0, 0, 1]], k * vsz);\n\t\t\t\t\t\tvv = niiOriginal.datascaling.e(vv);\n\t\t\t\t\t\tif( !isNaN(vv) && vv != undefined)\n\t\t\t\t\t\t\t\tv += vv;\n\t\t\t\t\t}\n\t\t\t\t\tv = v/count;\n\t\t\t\t\tydata.push(v);\n\t\t\t\t\txdata.push(k);\n\t\t\t\t\tif (v > ymax)\n\t\t\t\t\t    ymax = v;\n\t\t\t\t\tif (v < ymin)\n\t\t\t\t\t    ymin = v;\n\t\t\t\t\tauc += Math.abs(v);\n\n\t\t\t\t}\n\n\t\t\t\tcurveobj.xdata\t= xdata;\n\t\t\t\tcurveobj.ydata\t= ydata;\n\t\t\t\tcurveobj.ymin = ymin;\n\t\t\t\tcurveobj.ymax = ymax;\n\t\t\t\tcurveobj.auc = auc;\n\n\t\t\t}\n\n\n\t\t\tupdateProgress(0);\n\t\t\t\t\n\n\t\t}\n\n\t\n\t}\n\n\n\n\t/******************************************************************************\n\tsignal handlers\n\t*******************************************************************************/\n\tvar shandlers = {};\n\t/* \n\t\tdrawSlices: undefined,\n\t\tupdateImage: undefined,\n\t\tpositionChane: undefined\n\t*/\n\n\tfunction enable()\n\t{\n\t    // on pos change, only update single point curves\n\t    if(shandlers.posChange == undefined)\n\t\t\tshandlers.posChange   =  signalhandler.attach(\"positionChange\", updateCurveData_main);\n\t    if(shandlers.drawSlices == undefined)\n\t\t\tshandlers.drawSlices  =  signalhandler.attach(\"drawSlices\", \tupdateCurveData_main);\n\t    if(shandlers.updateImage == undefined)\n \t\t\tshandlers.updateImage =  signalhandler.attach(\"updateImage\", \tupdateCurveData_rois );\n\t    if(shandlers.cacheManagerUpdate == undefined)\n \t\t\tshandlers.cacheManagerUpdate =  signalhandler.attach(\"cacheManagerUpdate\",  updateCurveList_main );\n\t    if(shandlers.roiListUpdate == undefined)\n \t\t\tshandlers.roiListUpdate =  signalhandler.attach(\"roiListUpdate\",  updateCurveList_rois );\n\t    \n\t    $curvecontainer.appendTo( $target ) ;\n\n\t}\n\t\n\tfunction disable()\n\t{\n\t\tsignalhandler.detachByIdList( [shandlers.posChange, shandlers.drawSlices, shandlers.updateImage,shandlers.cacheManagerUpdate,shandlers.roiListUpdate]);\n\t\tshandlers = {};\n\t    //$curvecontainer.detach();\n\t}\n\n\tfunction close()\n\t{\n\t\tdisable();\n\t\tthat.$container.remove();\n\t}\n\n\t\n\n\n\n\t// initial run on tool creation\n\n\tupdateCurveList_main();\n\tupdateCurveList_rois();\n\tsetMaster();\n\n\n\tupdateCurveData_main();\n\tupdateCurveData_rois();\n\n\tenable();\n\n\n\tsetstate('normalise', 'noscaling')\n\tsetstate('baselinelength', 'off')\n\tsetstate('mode', 'tseries')\n\n//\tthat.customToggle = close;\n\treturn that;\n\n\n\tfunction parseFloatEval(str,i)\n\t{\n\t\t\t\t\n\t\tif (str == undefined)\n\t\t\treturn NaN;\n\t\ttry {\t\n\t\t\tvar s = str.split(\" \");\n\t    \ts = s[0].replace(/\\$/g,\"i.\");\n\t\t\tvar x = eval(s);\n\t\t\treturn x;\n\t\t}\n\t\tcatch(err)\n\t\t{\n\t\t\treturn NaN\n\t\t}\n\t}\n\n}"},function(t,n){t.exports='//"use strict"\n//var assert = require(\'assert\')\n\n// good explanation\n// https://brainder.org/2012/09/23/the-nifti-file-format/\n\n//alert(1);\n\nvar systemEndianness = (function() {\n    var buf = new ArrayBuffer(4),\n        intArr = new Uint32Array(buf),\n        byteArr = new Uint8Array(buf)\n    intArr[0] = 0x01020304\n    if (byteArr[0]==1 && byteArr[1]==2 && byteArr[2]==3 && byteArr[3]==4) {\n        return \'big\'\n    } else if (byteArr[0]==4 && byteArr[1]==3 && byteArr[2]==2 && byteArr[3]==1) {\n        return \'little\'\n    }\n    console.warn("Unrecognized system endianness!")\n    return undefined\n})()\n\n/** converts utf-16 encoded ArrayBuffer to String \n * @function */\nfunction ab2str(buf) {\n    var chars = new Uint16Array(buf);\n    var s = "";\n    var l = chars.length;\n    for (var i = 0; i < l; i++)\n    {\n        if (chars[i] == 0)\n            break;\n        if (chars[i] == 239)\n        {\n            i+=2\n            continue;\n        }\n        s += String.fromCharCode(chars[i]);\n    }\n    return s;\n    //return String.fromCharCode.apply(null, new Uint16Array(buf));\n}\n\n\n\n// This expects an ArrayBuffer or (Node.js) Buffer\nparse = function (buffer_org) {\n  /////////////////////////////////////////\n  // Parse header\n \n  var buf8 = new Uint8Array(buffer_org)\n  var buffer = buf8.buffer // Make sure we have an ArrayBuffer\n  var view = new DataView(buffer)\n  if (buffer.byteLength<348) {\n\n    throw new Error("The NIFTI buffer size was " +buffer.byteLength +". This is not even large enough to contain a header!")\n  }\n\n  if (view.getInt16(0, true) == 540 | view.getInt16(0, false) == 540 ) // nifti-2\n  {\n      var magic = String.fromCharCode.apply(null, buf8.subarray(4, 8))\n\n      var littleEndian = true\n\n      var dim = new Array(8)\n      dim[0] = parseInt(view.getBigInt64(16, littleEndian))\n      if (1>dim[0] || dim[0]>7) {\n        littleEndian = !littleEndian\n        dim[0] = parseInt(view.getBigInt64(16, littleEndian))\n      }\n      if (1>dim[0] || dim[0]>7) {\n        console.warn("dim[0] is out-of-range, we\'ll simply try continuing to read the file, but this will most likely fail horribly.")\n      }\n      dim.length = 1+Math.min(7, dim[0])\n      for(var i=1; i<dim.length; i++) {\n        dim[i] = parseInt(view.getBigInt64(16+8*i, littleEndian))\n        if (dim[i]<=0) {\n          console.warn("dim[0] was probably wrong or corrupt")\n          dim.length = i\n        }\n      }\n      if (dim.length === 1) throw new Error("No valid dimensions!")\n\n      var intent_p1 = view.getFloat64(80, littleEndian)\n      var intent_p2 = view.getFloat64(88, littleEndian)\n      var intent_p3 = view.getFloat64(98, littleEndian)\n      //var intent_code = view.getInt16(68, littleEndian)\n\n      var datatype = decodeNIfTIDataType(view.getInt16(12, littleEndian))\n      var bitpix = view.getInt16(14, littleEndian)\n   //   var slice_start = view.getInt16(74, littleEndian)\n\n      var pixdim = new Array(dim.length)\n      for(var i=0; i<pixdim.length; i++) {\n        pixdim[i] = view.getFloat64(104+8*i, littleEndian)\n      }\n\n      var vox_offset = parseInt(view.getBigInt64(168, littleEndian))\n      var scl_slope = view.getFloat32(176, littleEndian)\n      var scl_inter = view.getFloat32(184, littleEndian)\n\n      var slice_start = parseInt(view.getBigInt64(224, littleEndian))\n      var slice_end = parseInt(view.getBigInt64(232, littleEndian))\n      var slice_code = view.getInt32(496)\n\n      var xyzt_units = decodeNIfTIUnits(view.getInt32(500))\n      var cal_max = view.getFloat64(192, littleEndian)\n      var cal_min = view.getFloat64(200, littleEndian)\n      var slice_duration = view.getFloat64(208, littleEndian)\n      var toffset = view.getFloat32(216, littleEndian)\n\n      var descrip = ab2str(buf8.subarray(240, 240+80))\n      var aux_file = String.fromCharCode.apply(null, buf8.subarray(320, 320+24))\n\n      var qform_code = view.getInt32(344, littleEndian)\n      var sform_code = view.getInt32(348, littleEndian)\n\n      var quatern_b = view.getFloat64(352, littleEndian)\n      var quatern_c = view.getFloat64(352+8, littleEndian)\n      var quatern_d = view.getFloat64(352+8*2, littleEndian)\n      var qoffset_x = view.getFloat64(352+8*3, littleEndian)\n      var qoffset_y = view.getFloat64(352+8*4, littleEndian)\n      var qoffset_z = view.getFloat64(352+8*5, littleEndian)\n\n      var srow = new Float32Array(12)\n      for(var i=0; i<12; i++) {\n        srow[i] = view.getFloat64(400+8*i, littleEndian)\n      }\n\n      var intent_name = String.fromCharCode.apply(null, buf8.subarray(508, 508+16))\n      var extension = 0;\n\n  }\n  else\n  {\n\n      // First read dim[0], to determine byte order\n      var littleEndian = true\n      var dim = new Array(8)\n      dim[0] = view.getInt16(40, littleEndian)\n      if (1>dim[0] || dim[0]>7) {\n        littleEndian = !littleEndian\n        dim[0] = view.getInt16(40, littleEndian)\n      }\n      if (1>dim[0] || dim[0]>7) {\n        // Even if there were other /byte/ orders, we wouldn\'t be able to detect them using a short (16 bits, so only two bytes).\n        console.warn("dim[0] is out-of-range, we\'ll simply try continuing to read the file, but this will most likely fail horribly.")\n      }\n\n      // Now check header size and magic\n       var sizeof_hdr = view.getInt32(0, littleEndian)\n      if (sizeof_hdr !== 348 && (1>dim[0] || dim[0]>7)) {\n        // Try to recover from weird dim info\n        littleEndian = !littleEndian\n        dim[0] = view.getInt16(40, littleEndian)\n        sizeof_hdr = view.getInt32(0, littleEndian)\n        if (sizeof_hdr !== 348) {\n          throw new Error("I\'m sorry, but I really cannot determine the byte order of the (NIfTI) file at all.")\n        }\n      } else if (sizeof_hdr < 348) {\n        throw new Error("Header of file is smaller than expected, I cannot deal with this.")\n      } else if (sizeof_hdr !== 348) {\n        console.warn("Size of NIfTI header different from what I expect, but I\'ll try to do my best anyway (might cause trouble).")\n      }\n      var magic = String.fromCharCode.apply(null, buf8.subarray(344, 348))\n      if (magic !== "ni1\\0" && magic !== "n+1\\0") {\n        throw new Error("Sorry, magic number wrong:" +  magic)\n      }\n\n      // Continue reading actual header fields\n      var dim_info = view.getInt8(39)\n      dim.length = 1+Math.min(7, dim[0])\n      for(var i=1; i<dim.length; i++) {\n        dim[i] = view.getInt16(40+2*i, littleEndian)\n        if (dim[i]<=0) {\n          console.warn("dim[0] was probably wrong or corrupt")\n          dim.length = i\n        }\n      }\n      if (dim.length === 1) throw new Error("No valid dimensions!")\n\n      var intent_p1 = view.getFloat32(56, littleEndian)\n      var intent_p2 = view.getFloat32(56, littleEndian)\n      var intent_p3 = view.getFloat32(56, littleEndian)\n      var intent_code = view.getInt16(68, littleEndian)\n\n      var datatype = decodeNIfTIDataType(view.getInt16(70, littleEndian))\n      var bitpix = view.getInt16(72, littleEndian)\n      var slice_start = view.getInt16(74, littleEndian)\n\n      var pixdim = new Array(dim.length)\n      for(var i=0; i<pixdim.length; i++) {\n        pixdim[i] = view.getFloat32(76+4*i, littleEndian)\n      }\n\n      var vox_offset = view.getFloat32(108, littleEndian)\n      var scl_slope = view.getFloat32(112, littleEndian)\n      var scl_inter = view.getFloat32(116, littleEndian)\n      var slice_end = view.getInt16(120, littleEndian)\n      var slice_code = view.getInt8(122)\n      var xyzt_units = decodeNIfTIUnits(view.getInt8(123))\n      var cal_max = view.getFloat32(124, littleEndian)\n      var cal_min = view.getFloat32(128, littleEndian)\n      var slice_duration = view.getFloat32(132, littleEndian)\n      var toffset = view.getFloat32(136, littleEndian)\n\n      var descrip = ab2str(buf8.subarray(148, 228))\n      var aux_file = String.fromCharCode.apply(null, buf8.subarray(228, 252))\n\n      var qform_code = view.getInt16(252, littleEndian)\n      var sform_code = view.getInt16(254, littleEndian)\n\n      var quatern_b = view.getFloat32(256, littleEndian)\n      var quatern_c = view.getFloat32(260, littleEndian)\n      var quatern_d = view.getFloat32(264, littleEndian)\n      var qoffset_x = view.getFloat32(268, littleEndian)\n      var qoffset_y = view.getFloat32(272, littleEndian)\n      var qoffset_z = view.getFloat32(276, littleEndian)\n\n      var srow = new Float32Array(12)\n      var sum = 0;\n      for(var i=0; i<12; i++) {\n        srow[i] = view.getFloat32(280+4*i, littleEndian)\n        sum+=Math.abs(srow[i])\n      }\n      if (sum < 0.000000001)\n        sform_code = -1\n\n\n      var intent_name = String.fromCharCode.apply(null, buf8.subarray(328, 344))\n\n      var extension = view.getInt32(348, littleEndian) // Actually a different format, but this suffices for checking === zero\n    \n  }\n\n  var ret = {};\n\n  if (vox_offset > 352)\n  {\n      if (extension != 0) {\n        var offs = 352;\n        var ext = {};\n        ext.size = view.getInt32(offs, littleEndian);\n        ext.code = view.getInt32(offs + 4, littleEndian);\n        ext.content = "";\n        for (var k = 0; k < ext.size-10; k++)\n        {\n            var c = view.getUint8(offs + 8 + k);\n            if (c != 0)\n              ext.content += String.fromCharCode(c);\n        }\n        ret.extension = ext;\n        if (ext.content.substring(0,10).search("xml")>-1)\n        {\n          try\n          {\n            ext.content = $.parseXML(ext.content);\n             console.log(\'extended nifti header contains XML\');\n          }\n          catch(err)\n          {\n            console.warn("Looks like there is a corrupt XML within the nifti header.")\n          }\n        }\n      }\n  }\n\n\n\n  ret.sform_code = sform_code;\n  ret.qform_code = qform_code;\n\n\n  // Check bitpix\n\n  // "Normalize" datatype (so that rgb/complex become several normal floats rather than compound types, possibly also do something about bits)\n  // Note that there is actually both an rgb datatype and an rgb intent... (My guess is that the datatype corresponds to sizes = [3,dim[0],...], while the intent might correspond to sizes = [dim[0],...,dim[5]=3].)\n\n  // Convert to NRRD-compatible structure\n  ret.dimension = dim[0]\n  ret.datatype = datatype // TODO: Check that we do not feed anything incompatible?\n  ret.encoding = \'raw\'\n  ret.endian = littleEndian ? \'little\' : \'big\'\n  ret.sizes = dim.slice(1) // Note that both NRRD and NIfTI use the convention that the fastest axis comes first!\n\n  if (scl_slope == 0) scl_slope = 1;\n\n  ret.cal_max = cal_max;\n  ret.cal_min = cal_min;\n  ret.scl_inter = scl_inter;\n  ret.scl_slope = scl_slope;\n\n  ret.descrip = descrip;\n  ret.intent_code = intent_code;\n  ret.intent_name = intent_name;\n\n\n  // this is for convenience use\n  ret.datascaling = \n  {\n    slope:scl_slope,\n    offset:scl_inter,\n    id: function() {return (this.slope==1 & this.offset==0) },\n    e: function(v) { return v*this.slope+this.offset },\n    ie: function (v) { return (v-this.offset)/this.slope }\n  };\n  \n  \n\n  if (xyzt_units !== undefined) {\n    ret.spaceUnits = xyzt_units\n    while(ret.spaceUnits.length < ret.dimension) { // Pad if necessary\n      ret.spaceUnits.push("")\n    }\n    ret.spaceUnits.length = ret.dimension // Shrink if necessary\n  }\n\n  ret.pixdim = pixdim;\n\n\n\n  if (qform_code === 0) { // "method 1"\n    ret.spacings = pixdim.slice(1)\n    while(ret.spacings.length < ret.dimension) {\n      ret.spacings.push(NaN)\n    }\n    ret.spaceDimension = Math.min(ret.dimension, 3) // There might be non-3D data sets? (Although the NIfTI format does seem /heavily/ reliant on assuming a 3D space.)\n  } else if (qform_code > 0) { // "method 2"\n    // TODO: Figure out exactly what to do with the different qform codes.\n    ret.space = "right-anterior-superior" // Any method for orientation (except for "method 1") uses this, apparently.\n    var qfac = pixdim[0] === 0.0 ? 1 : pixdim[0]\n    var a = Math.sqrt(Math.max(0.0,1.0-(quatern_b*quatern_b+quatern_c*quatern_c+quatern_d*quatern_d)))\n    var b = quatern_b\n    var c = quatern_c\n    var d = quatern_d\n    ret.spaceDirections = [\n      [pixdim[1]*(a*a+b*b-c*c-d*d),pixdim[1]*(2*b*c+2*a*d),pixdim[1]*(2*b*d-2*a*c)],\n      [pixdim[2]*(2*b*c-2*a*d),pixdim[2]*(a*a+c*c-b*b-d*d),pixdim[2]*(2*c*d+2*a*b)],\n      [qfac*pixdim[3]*(2*b*d+2*a*c),qfac*pixdim[3]*(2*c*d-2*a*b),qfac*pixdim[3]*(a*a+d*d-c*c-b*b)]]\n    ret.spaceOrigin = [qoffset_x,qoffset_y,qoffset_z]\n    ret.form = \'qform\';\n  } else {\n    console.warn("Invalid qform_code: " + qform_code + ", orientation is probably messed up.")\n  }\n  // TODO: Here we run into trouble, because in NRRD we cannot expose two DIFFERENT (not complementary, different!) transformations. Even more frustrating is that sform transformations are actually more compatible with NRRD than the qform methods.\n  //console.warn("sform " + sform_code);\n    // RGB niftis from dcm2nii have sform_code 0, but still have the srow ... so this should always be tried ...? \n\n  var prefq = false;\n  if (typeof ViewerSettings != "undefined" && ViewerSettings != undefined && ViewerSettings.preferqform != undefined)\n     prefq = ViewerSettings.preferqform;\n\n  if (qform_code == 0 && prefq)\n  {\n      prefq = false;\n      console.warn("qform prefered, but qform_code=0, switching back to sform")      \n  }\n  prefq = prefq & qform_code!=0;\n\n\n  if ((sform_code != 0 && !prefq) || ret.spaceDirections == undefined)\n  { // "method 3"\n    ret.space = "right-anterior-superior" // Any method for orientation (except for "method 1") uses this, apparently.\n    ret.form = \'sform\';\n    \n    // Nifit format convention is: row-wise storage of matric (x,x,x offsx,   y,y,y, offsy, z,z,z,offsz)\n    // Therefore, must transpose for column wise storage.\n    // However, in javascipt array multiplicaton assums row-wise storage. Therefore, edges are created as transposed in MedImageViewer prepare data\n    ret.spaceDirections = [\n      [srow[0*4 + 0],srow[1*4 + 0],srow[2*4 + 0]],\n      [srow[0*4 + 1],srow[1*4 + 1],srow[2*4 + 1]],\n      [srow[0*4 + 2],srow[1*4 + 2],srow[2*4 + 2]]]\n    ret.spaceOrigin = [srow[0*4 + 3],srow[1*4 + 3],srow[2*4 + 3]]\n    //print_matrix(ret.spaceDirections);\n  }\n\n\n\n  if (magic === "n+2\\0") { // nifti2\n    ret.hdroffset = Math.floor(vox_offset);\n    ret.buffer = buffer;\n    if (datatype !== 0) {\n      ret.data = parseNIfTIRawData(ret.buffer, datatype, dim, {endianFlag: littleEndian},Math.floor(vox_offset))\n    }\n  }\n  else\n  if (magic === "n+1\\0") { // nifti1 analysze75\n    ret.hdroffset = Math.floor(vox_offset);\n    ret.buffer = buffer;\n    if (datatype !== 0) {\n      // TODO: It MIGHT make sense to equate DT_UNKNOWN (0) to \'block\', with bitpix giving the block size in bits\n      ret.data = parseNIfTIRawData(ret.buffer, datatype, dim, {endianFlag: littleEndian},Math.floor(vox_offset))\n    }\n  }\n\n  ret.filetype=\'nifti\';\n\n\n  return ret\n}\n\n/****************************************************************\n* transform the nifti coordinate system in BUFFER directly\n*  currently unused function, went to prepareMedicalImageData\n*****************************************************************/\nfunction transform_nifti(buffer_org, coregmat)\n{\n\n\n    var buffer = (new Uint8Array(buffer_org)).buffer\n\n    var littleEndian = true;\n\n    var view = new DataView(buffer)\n    var srow = new Float32Array(12)\n    \n    for(var i=0; i<12; i++) \n    {\n      srow[i] = view.getFloat32(280+4*i, littleEndian)\n    }\n    \n    // extract affine matrix and apply transform\n    var edges = \n    [\n      [srow[0*4 + 0],srow[1*4 + 0],srow[2*4 + 0], 0],\n      [srow[0*4 + 1],srow[1*4 + 1],srow[2*4 + 1], 0],\n      [srow[0*4 + 2],srow[1*4 + 2],srow[2*4 + 2], 0],\n      [srow[0*4 + 3],srow[1*4 + 3],srow[2*4 + 3], 1]\n    ]\n\n    edges = math.transpose(edges);\n    edges = math.multiply(math.matrix(coregmat), edges );\n \n    // write back to buffer\n    var k=0;\n    for(var i=0; i<3; i++) \n    {\n      for(var j=0; j<4; j++) \n      {\n        val = edges._data[i][j];\n        // verify\n        //console.log(srow[k].toFixed(2) + "  " + val.toFixed(2));\n        view.setFloat32(280+4*k, val, littleEndian)\n        k++;\n      }\n    }\n    return buffer;\n}\n\n\n\n\n\n\nfunction parseNIfTIRawData(buffer, type, dim, options,hdroffs) {\n  var i, arr, view, totalLen = 1, endianFlag = options.endianFlag, endianness = endianFlag ? \'little\' : \'big\'\n  for(i=1; i<dim.length; i++) {\n    totalLen *= dim[i]\n  }\n  if (type == \'block\') {\n    // Don\'t do anything special, just return the slice containing all blocks.\n    return buffer.slice(hdroffs,totalLen*options.blockSize)\n  } else if (type == \'int8\' || type == \'uint8\' || endianness == systemEndianness) {\n    switch(type) {\n    case "int8":\n      checkSize(1)\n      return new Int8Array(buffer,hdroffs);\n    case "uint8":\n      checkSize(1)\n      return new Uint8Array(buffer,hdroffs);\n    case "int16":\n      checkSize(2)\n      return new Int16Array(buffer,hdroffs);\n    case "uint16":\n      checkSize(2)\n      if (totalLen > buffer.byteLength)\n        return new Uint16Array(buffer,hdroffs);\n      else\n        return new Uint16Array(buffer,hdroffs,totalLen);\n    case "int32":\n      checkSize(4)\n      return new Int32Array(buffer,hdroffs);\n    case "uint32":\n      checkSize(4)\n      return new Uint32Array(buffer,hdroffs);\n    //case "int64":\n    //  checkSize(8)\n    //  return new Int64Array(buffer.slice(0,totalLen*8))\n    //case "uint64":\n    //  checkSize(8)\n    //  return new Uint64Array(buffer.slice(0,totalLen*8))\n    case "float":\n      checkSize(4)\n      return new Float32Array(buffer,hdroffs);\n    case "double":\n      checkSize(8)\n      return new Float64Array(buffer,hdroffs);\n    case "rgb24":\n      return new Uint8Array(buffer,hdroffs);\n    default:\n      console.warn("Unsupported NIfTI type: " + type)\n      return undefined\n    }\n  } else {\n    view = new DataView(buffer)\n    switch(type) {\n    case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.\n      arr = new Int8Array(totalLen)\n      for(i=0; i<totalLen; i++) {\n        arr[i] = view.getInt8(hdroffs + i)\n      }\n      return arr\n    case "uint8":\n      arr = new Uint8Array(totalLen)\n      for(i=0; i<totalLen; i++) {\n        arr[i] = view.getUint8(hdroffs + i)\n      }\n      return arr\n    case "int16":\n      arr = new Int16Array(totalLen)\n      for(i=0; i<totalLen; i++) {\n        arr[i] = view.getInt16(hdroffs + i*2)\n      }\n      return arr\n    case "uint16":\n      arr = new Uint16Array(totalLen)\n      for(i=0; i<totalLen; i++) {\n        arr[i] = view.getUint16(hdroffs + i*2)\n      }\n      return arr\n    case "int32":\n      arr = new Int32Array(totalLen)\n      for(i=0; i<totalLen; i++) {\n        arr[i] = view.getInt32(hdroffs + i*4)\n      }\n      return arr\n    case "uint32":\n      arr = new Uint32Array(totalLen)\n      for(i=0; i<totalLen; i++) {\n        arr[i] = view.getUint32(hdroffs + i*4)\n      }\n      return arr\n    //case "int64":\n    //  arr = new Int64Array(totalLen)\n    //  for(i=0; i<totalLen; i++) {\n    //    arr[i] = view.getInt64(i*8)\n    //  }\n    // return arr\n    //case "uint64":\n    //  arr = new Uint64Array(totalLen)\n    //  for(i=0; i<totalLen; i++) {\n    //    arr[i] = view.getUint64(i*8)\n    //  }\n    //  return arr\n    case "float":\n      arr = new Float32Array(totalLen)\n      for(i=0; i<totalLen; i++) {\n        arr[i] = view.getFloat32(hdroffs+i*4)\n      }\n      return arr\n    case "double":\n      arr = new Float64Array(totalLen)\n      for(i=0; i<totalLen; i++) {\n        arr[i] = view.getFloat64(hdroffs+i*8)\n      }\n      return arr\n    default:\n      console.warn("Unsupported NRRD type: " + type)\n      return undefined\n    }\n  }\n  function checkSize(sizeOfType) \n  {\n    if (buffer.byteLength<totalLen*sizeOfType) \n      //throw new Error("NIfTI file does not contain enough data!")\n      console.log("NIfTI file does not contain enough data!");\n  }\n}\n\n\n\n\n\n\nfunction decodeNIfTIDataType(datatype) {\n  switch(datatype) {\n  case 1:\n    return \'bit\'\n  case 2:\n    return \'uint8\'\n  case 4:\n    return \'int16\'\n  case 8:\n    return \'int32\'\n  case 16:\n    return \'float\'\n  case 32:\n    return \'complex64\'\n  case 64:\n    return \'double\'\n  case 128:\n    return \'rgb24\'\n  case 256:\n    return \'int8\'\n  case 512:\n    return \'uint16\'\n  case 768:\n    return \'uint32\'\n  case 1024:\n    return \'int64\'\n  case 1280:\n    return \'uint64\'\n  case 1536:\n    return \'float128\'\n  case 1792:\n    return \'complex128\'\n  case 2048:\n    return \'complex256\'\n  case 2304:\n    return \'rgba32\'\n  default:\n    console.warn("Unrecognized NIfTI data type: " + datatype)\n    return datatype\n  }\n}\n\nfunction decodeNIfTIUnits(units) {\n  var space, time\n  switch(units & 7) {\n  case 0:\n    space = ""\n    break\n  case 1:\n    space = "m"\n    break\n  case 2:\n    space = "mm"\n    break\n  case 3:\n    space = "um"\n    break\n  default:\n    console.warn("Unrecognized NIfTI unit: " + (units&7))\n    space = ""\n  }\n  switch(units & 56) {\n  case 0:\n    time = ""\n    break\n  case 8:\n    time = "s"\n    break\n  case 16:\n    time = "ms"\n    break\n  case 24:\n    time = "us"\n    break\n  case 32:\n    time = "Hz"\n    break\n  case 40:\n    time = "ppm"\n    break\n  case 48:\n    time = "rad/s"\n    break\n  default:\n    console.warn("Unrecognized NIfTI unit: " + (units&56))\n    time = ""\n  }\n  return (space === "" && time === "") ? undefined : [space, space, space, time]\n}\n\n\n\n\n/** parses a mgh imaging file (freesurfer)\n * @param {ArrayBuffer} buffer - the binary to be parsed\n * @return {nifti} the nifti object\n */\nfunction parse_mgh(buffer)\n{\n\n    var view = new DataView(buffer);\n    var nifti = {\n        filetype: \'mgh\'\n    };\n\n    nifti.sizes = [view.getInt32(4), view.getInt32(8), view.getInt32(12), view.getInt32(16)];\n    nifti.type = ({\n        "0": "UCHAR",\n        "4": "SHORT",\n        "1": "INT",\n        "3": "FLOAT"\n    })[view.getInt32(20)];\n\n    var i = 42;\n    nifti.voxSize = [view.getFloat32(30), view.getFloat32(34), view.getFloat32(38)];\n    var d = nifti.voxSize;\n    nifti.spaceDirections = [[view.getFloat32(i) * d[0], view.getFloat32(i + 4) * d[0], view.getFloat32(i + 8) * d[0]],\n    [view.getFloat32(i + 12) * d[1], view.getFloat32(i + 16) * d[1], view.getFloat32(i + 20) * d[1]],\n    [view.getFloat32(i + 24) * d[2], view.getFloat32(i + 28) * d[2], view.getFloat32(i + 32) * d[2]]];\n    var M = nifti.spaceDirections;\n    nifti.spaceOrigin = [\n    view.getFloat32(i + 36) - (M[0][0] * nifti.sizes[0] + M[1][0] * nifti.sizes[1] + M[2][0] * nifti.sizes[2]) / 2,\n    view.getFloat32(i + 40) - (M[0][1] * nifti.sizes[0] + M[1][1] * nifti.sizes[1] + M[2][1] * nifti.sizes[2]) / 2,\n    view.getFloat32(i + 44) - (M[0][2] * nifti.sizes[0] + M[1][2] * nifti.sizes[1] + M[2][2] * nifti.sizes[2]) / 2];\n\n\n\n    nifti.buffer = buffer;\n\n    //xxx = nifti\n    //xxx.spaceOrigin = [-30, -30, 13]\n    var hdroffs = 284;\n    var imgsiz = nifti.sizes[0] * nifti.sizes[1] * nifti.sizes[2] * nifti.sizes[3];\n\n\n\n\n\n    nifti.nbyte = 1;\n    var view = new DataView(buffer,hdroffs);\n\n\n    if (nifti.type == \'UCHAR\')\n    {\n        nifti.nbyte = 1;\n        nifti.data = new Uint8Array(buffer,hdroffs,imgsiz);\n        for (var k = 0; k < imgsiz; k++)\n            nifti.data[k] = view.getUint8(k * nifti.nbyte);\n    }\n    else if (nifti.type == \'SHORT\')\n    {\n        nifti.nbyte = 2;\n        nifti.data = new Uint16Array(buffer,hdroffs,imgsiz);\n        for (var k = 0; k < imgsiz; k++)\n            nifti.data[k] = view.getUint16(k * nifti.nbyte);\n    }\n    else if (nifti.type == \'INT\')\n    {\n        nifti.nbyte = 4;\n        nifti.data = new Int32Array(buffer,hdroffs,imgsiz);\n        for (var k = 0; k < imgsiz; k++)\n            nifti.data[k] = view.getInt32(k * nifti.nbyte);\n    }\n    else if (nifti.type == \'FLOAT\')\n    {\n        nifti.nbyte = 4;\n        nifti.data = new Float32Array(buffer,hdroffs,imgsiz);\n        for (var k = 0; k < imgsiz; k++)\n            nifti.data[k] = view.getFloat32(k * nifti.nbyte);\n    }\n\n    nifti.mgh_extension = ab2str(new Uint8Array(buffer,hdroffs + imgsiz * nifti.nbyte));\n\n    var scl_slope = 1;\n    var scl_inter = 0;\n\n    nifti.datascaling = {\n        slope: scl_slope,\n        offset: scl_inter,\n        id: function() {\n            return ( scl_slope == 1 & scl_inter == 0)\n        },\n        e: function(v) {\n            return v * scl_slope + scl_inter\n        },\n        ie: function(v) {\n            return (v - scl_inter) / scl_slope\n        }\n    };\n\n    nifti.pixdim = [nifti.sizes.length]\n    nifti.pixdim = nifti.pixdim.concat(nifti.sizes);\n\n\n\n    return nifti;\n\n\n\n}\n\n\n\n\n\n\nfunction NRRD()\n{\n   var nrrd = {};\n\n\nvar lineSeparatorRE = /[ \\f\\t\\v]*\\r?\\n/;\nvar NRRDMagicRE = /^NRRD\\d{4}$/;\nvar lineRE = /^([^:]*)(:[ =])(.*)$/;\nvar dataFileListRE = /^LIST(?: (\\d+))?$/;\n\n// The minimal object this accepts is formed like this:\n//   {data: SomeTypedArray, sizes: [...]}\n// On the other hand, if data is not given it must have a form like this:\n//   {buffer: SomeArrayBuffer, type: ..., endian: ..., sizes: [...]}\n// Of course, if \'type\' is an 8-bit type, endian is not needed, and if \'type\' equals \'block\', \'blockSize\' should be set instead of \'endian\'. In this case, no interpretation of buffer is done (at all, it is written serialized directly to the buffer).\n// TODO: For now this only supports serializing "inline" files, or files for which you have already prepared the data.\nnrrd.serialize = function (nrrdOrg) {\n    var i, buffer, arr, totalLen = 1, nrrd = {}, prop, nativeType, nativeSize, bufferData, arrData, line, lines = [], header;\n    \n    // Copy nrrdOrg to nrrd to allow modifications without altering the original\n    for(prop in nrrdOrg) {\n        nrrd[prop] = nrrdOrg[prop];\n    }\n    \n    // For saving files we allow inferring certain information if it is not explicitly given.\n    // Also we normalize some fields to make our own lives easier.\n    if (nrrd.sizes===undefined) { // \'sizes\' should ALWAYS be given\n        throw new Error("Sizes missing from NRRD file!");\n    } else if (nrrd.dimension===undefined) {\n        nrrd.dimension = nrrd.sizes.length;\n    }\n    if (nrrd.data instanceof Int8Array) {\n        nativeType = "int8";\n    } else if (nrrd.data instanceof Uint8Array) {\n        nativeType = "uint8";\n    } else if (nrrd.data instanceof Int16Array) {\n        nativeType = "int16";\n    } else if (nrrd.data instanceof Uint16Array) {\n        nativeType = "uint16";\n    } else if (nrrd.data instanceof Int32Array) {\n        nativeType = "int32";\n    } else if (nrrd.data instanceof Uint32Array) {\n        nativeType = "uint32";\n    //} else if (nrrd.data instanceof Int64Array) {\n    //    nativeType = "int64";\n    //} else if (nrrd.data instanceof Uint64Array) {\n    //    nativeType = "uint64";\n    } else if (nrrd.data instanceof Float32Array) {\n        nativeType = "float";\n    } else if (nrrd.data instanceof Float64Array) {\n        nativeType = "double";\n    }\n    if (nrrd.type===undefined && nativeType!==undefined) {\n        nrrd.type = nativeType;\n    } else if (nrrd.type===undefined) {\n        throw new Error("Type of data is not given and cannot be inferred!");\n    } else if ((typeof nrrd.type) == "string" || nrrd.type instanceof String) {\n        nrrd.type = parseNRRDType(nrrd.type);\n    }\n    if (nrrd.encoding===undefined) {\n        nrrd.encoding = "raw";\n    } else if ((typeof nrrd.encoding) == "string" || nrrd.encoding instanceof String) {\n        nrrd.encoding = parseNRRDEncoding(nrrd.encoding);\n    }\n    if (nrrd.data && nrrd.type != \'block\' && nrrd.type != \'int8\' && nrrd.type != \'uint8\' && nrrd.encoding != \'ascii\') {\n        nrrd.endian = systemEndianness;\n    } else if (nrrd.type == \'block\' || nrrd.type == \'int8\' || nrrd.type == \'uint8\' || nrrd.encoding == \'ascii\') {\n        nrrd.endian = undefined;\n    } else if ((typeof nrrd.endian) == "string" || nrrd.endian instanceof String) {\n        nrrd.endian = parseNRRDEndian(nrrd.endian);\n    }\n    \n    // Try to infer spatial dimension\n    var spaceDimension = undefined;\n    if (nrrd.spaceDimension!==undefined) {\n        spaceDimension = nrrd.spaceDimension;\n    } else if (nrrd.space!==undefined) {\n        switch(nrrd.space) {\n        case "right-anterior-superior":\n        case "RAS":\n            spaceDimension = 3;\n            break;\n        case "left-anterior-superior":\n        case "LAS":\n            spaceDimension = 3;\n            break;\n        case "left-posterior-superior":\n        case "LPS":\n            spaceDimension = 3;\n            break;\n     \t  case "right-anterior-superior-time":\n     \t  case "RAST":\n     \t      spaceDimension = 4;\n     \t      break;\n        case "left-anterior-superior-time":\n        case "LAST":\n            spaceDimension = 4;\n            break;\n        case "left-posterior-superior-time":\n        case "LPST":\n            spaceDimension = 4;\n            break;\n        case "scanner-xyz":\n            spaceDimension = 3;\n            break;\n        case "scanner-xyz-time":\n            spaceDimension = 4;\n            break;\n        case "3D-right-handed":\n            spaceDimension = 3;\n            break;\n        case "3D-left-handed":\n            spaceDimension = 3;\n            break;\n        case "3D-right-handed-time":\n            spaceDimension = 4;\n            break;\n        case "3D-left-handed-time":\n            spaceDimension = 4;\n            break;\n        default:\n            console.warn("Unrecognized space: " + nrrd.space);\n        }\n    }\n    \n    // Now check that we have a valid nrrd structure.\n    checkNRRD(nrrd);\n\n    // Determine number of elements and check that we have enough data (if possible)\n    for(i=0; i<nrrd.sizes.length; i++) {\n        if (nrrd.sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");\n        totalLen *= nrrd.sizes[i];\n    }\n    if (nrrd.data) {\n        if (nrrd.data.length < totalLen) {\n            throw new Error("Missing data to serialize!");\n        }\n    } else if (nrrd.buffer) {\n        if (nrrd.encoding == "raw") {\n            if (nrrd.type=="block" && nrrd.blockSize!==undefined) {\n                nativeSize = nrrd.blockSize;\n            } else {\n                nativeSize = getNRRDTypeSize(nrrd.type);\n            }\n            if (nrrd.buffer.byteLength < totalLen*nativeSize) {\n                throw new Error("Missing data to serialize!");\n            }\n        }\n    } else if (nrrd.dataFile) {\n        // Okay, if you have your data ready, we\'ll just write a header.\n    } else {\n        throw new Error("Will not serialize an empty NRRD file!");\n    }\n    \n    // Make sure we have the correct buffer in bufferData.\n    if (nrrd.data) {\n        switch(nrrd.encoding) {\n        case \'raw\':\n            if (nrrd.type == nativeType && nrrd.endian == systemEndianness) {\n                bufferData = nrrd.data.buffer.slice(nrrd.data.byteOffset, nrrd.data.byteOffset+nrrd.data.byteLength);\n            } else if (nrrd.endian == systemEndianness) {\n                bufferData = castTypedArray(nrrd.data, nrrd.type);\n                bufferData = bufferData.buffer.slice(bufferData.byteOffset, bufferData.byteOffset+bufferData.byteLength);\n            } else {\n                bufferData = serializeToBuffer(nrrd.data, nrrd.type, nrrd.endian);\n            }\n            break;\n        case \'ascii\':\n            if (nrrd.type == nativeType) {\n                bufferData = serializeToTextBuffer(nrrd.data);\n            } else {\n                bufferData = serializeToTextBuffer(castTypedArray(nrrd.data, nrrd.type));\n            }\n            break;\n        default:\n            throw new Error("Unsupported NRRD encoding: " + nrrd.encoding);\n        }\n    } else if (nrrd.buffer) {\n        bufferData = nrrd.buffer;\n    }\n    \n    // Start header\n    lines.push("NRRD0005"); // TODO: Adjust version based on features that are actually used and/or the version specified by the user (if any).\n    lines.push("# Generated by nrrd-js");\n    \n    // Put in dimension and space dimension (the NRRD spec requires that these are present before any lists whose length depends on them)\n    var firstProps = [\'dimension\', \'spaceDimension\', \'space\'];\n    for(i=0; i<firstProps.length; i++) {\n        prop = firstProps[i];\n        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.\n        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);\n        if (line!==undefined) lines.push(line);\n    }\n    \n    // Put in field specifications\n    for(prop in nrrd) {\n        if (nrrd[prop] === undefined) continue; // Skip things we explicitly set to undefined.\n        if (firstProps.indexOf(prop)>=0) continue; // Skip the fields we already output.\n        line = serializeField(prop, nrrd[prop], nrrd.dimension, spaceDimension);\n        if (line!==undefined) lines.push(line);\n    }\n    \n    // Put in keys (if any)\n    if (nrrd.keys) for(prop in nrrd.keys) {\n        if (prop.indexOf(":=")>=0) throw new Error("The combination \':=\' is not allowed in an NRRD key!");\n        lines.push(prop + ":=" + escapeValue(nrrd[prop]));\n    }\n    \n    // Put in data file list (if any)\n    if (nrrd.dataFile && nrrd.dataFile.length) {\n        lines.push("data file: LIST");\n        Array.prototype.push.apply(lines, nrrd.dataFile);\n    } else if (nrrd.dataFile && nrrd.dataFile.files && \'subdim\' in nrrd.dataFile) {\n        lines.push("data file: LIST " + nrrd.dataFile.subdim);\n        Array.prototype.push.apply(lines, nrrd.dataFile.files);\n    }\n    \n    // Put in empty line and inline data (if we have inline data) and convert lines to buffer\n    if (bufferData && !(\'dataFile\' in nrrd)) {\n        lines.push("");\n        lines.push(""); // We actually need an extra blank line to make sure the previous is terminated.\n        header = lines.join("\\n");\n        buffer = new ArrayBuffer(header.length + bufferData.byteLength);\n        arr = new Uint8Array(buffer);\n        for(i=0; i<header.length; i++) {\n            arr[i] = header.charCodeAt(i);\n        }\n        arrData = new Uint8Array(bufferData);\n        arr.set(arrData, header.length);\n    } else {\n        lines.push(""); // Blank line to at least terminate the last line.\n        header = lines.join("\\n");\n        buffer = new ArrayBuffer(header.length);\n        arr = new Uint8Array(buffer);\n        for(i=0; i<header.length; i++) {\n            arr[i] = header.charCodeAt(i);\n        }\n    }\n    \n    return buffer;\n};\n\n// This expects an ArrayBuffer.\nnrrd.parse = function (buffer) {\n    var i, header, dataStart, ret = {data: undefined/* parsed data */, buffer: undefined/* raw buffer holding data */, keys: {}, version: undefined},\n        lines, match, match2,\n        buf8 = new Uint8Array(buffer);\n\n    // A work-around for incompatibilities between Node\'s Buffer and ArrayBuffer.\n    if (buf8.buffer !== buffer) buffer = buf8.buffer;\n\n    // First find the separation between the header and the data (if there is one)\n    // Note that we need to deal with with LF and CRLF as possible line endings.\n    // Luckily this means the line always ends with LF, so we only need to consider\n    // LFLF and LFCRLF as patterns for the separating empty line.\n    i=2; // It is safe to start at position 2 (in fact, we could start even later), as the file HAS to start with a magic word.\n    while(i<buf8.length) {\n        if (buf8[i] == 10) { // We hit an LF\n            if (buf8[i-1] == 10 || (buf8[i-1] == 13 && buf8[i-2] == 10)) { // Safe because we start at position 2 and never move backwards\n                dataStart = i+1;\n                break;\n            } else {\n                i++; // Move forward just once\n            }\n        } else if (buf8[i] == 13) { // We hit a CR\n            i++; // Move forward just once\n        } else {\n            i += 2; // Move forward two places, \n        }\n    }\n    \n    // Now split up the header and data\n    if (dataStart === undefined) {\n        header = String.fromCharCode.apply(null, buf8);\n    } else {\n        header = String.fromCharCode.apply(null, buf8.subarray(0,dataStart));\n        ret.buffer = buffer.slice(dataStart);\n    }\n    \n    // Split header into lines, remove comments (and blank lines) and check magic.\n    // All remaining lines except the first should be field specifications or key/value pairs.\n    // TODO: This explicitly removes any whitespace at the end of lines, however, I am not sure that this is actually desired behaviour for all kinds of lines.\n    lines = header.split(lineSeparatorRE);\n    lines = lines.filter(function (l) { return l.length>0 && l[0] != \'#\'; }); // Remove comment lines\n    if (!NRRDMagicRE.test(lines[0])) {\n        throw new Error("File is not an NRRD file!");\n    }\n    ret.version = parseInt(lines[0].substring(4, 8), 10);\n    if (ret.version>5) {\n        console.warn("Reading an unsupported version of the NRRD format; things may go haywire.");\n    }\n\n    // Parse lines\n    for(i=1; i<lines.length; i++) {\n        match = lineRE.exec(lines[i]);\n        if (!match) {\n            console.warn("Unrecognized line in NRRD header: " + lines[i]);\n            continue;\n        }\n        if (match[2] == \': \') { // Field specification\n            match[1] = mapNRRDToJavascript(match[1]);\n            if ( match[1] == \'dataFile\' &&\n                 (match2 = dataFileListRE.exec(match[3]))) {\n                // This should be the last field specification,\n                // and the rest of the lines should contain file names.\n                if (match2.length == 2 && match2[1]) { // subdim specification\n                    ret[match[1]] = {\n                        files: lines.slice(i+1),\n                        subdim: parseNRRDInteger(match2[1])\n                    };\n                } else {\n                    ret[match[1]] = lines.slice(i+1);\n                }\n                lines.length = i;\n            } else {\n                ret[match[1]] = parseField(match[1], match[3]);\n            }\n        } else if (match[2] == \':=\') { // Key/value pair\n            ret.keys[match[1]] = unescapeValue(match[3]);\n        } else {\n            throw new Error("Logic error in NRRD parser."); // This should never happen (unless the NRRD syntax is extended and the regexp is updated, but this section is not, or some other programmer error).\n        }\n    }\n\n    // Make sure the file satisfies the requirements of the NRRD format\n    checkNRRD(ret);\n   \n\n    // where to get this from???\n    ret.datascaling = \n    {\n      slope:1,\n      offset:0,\n      id: function() {return (this.slope==1 & this.offset==0) },\n      e: function(v) { return v*this.slope+this.offset },\n      ie: function (v) { return (v-this.offset)/this.slope }\n    };\n\n    if (ret.space == "left-posterior-superior")\n      ret; \n\n\n    ret.datatype = ret.type;\n    ret.filetype = "nrrd"\n    \n    ret.pixdim = [ret.sizes.length]\n    ret.pixdim = ret.pixdim.concat(ret.sizes);\n\n    // "Parse" data\n    if (\'dataFile\' in ret) {\n        console.warn("No support for external data yet!");\n    } else {\n        switch(ret.encoding) {\n        case \'raw\':\n            ret.data = parseNRRDRawData(ret.buffer, ret.type, ret.sizes, {\n                endian: ret.endian, blockSize: ret.blockSize\n            });\n            break;\n        case \'ascii\':\n            ret.data = parseNRRDTextData(ret.buffer, ret.type, ret.sizes);\n            break;\n        case \'gzip\':\n            var buf = pako.inflate(ret.buffer)\n             ret.data = parseNRRDRawData(buf.buffer, ret.type,ret.sizes, {\n                endian: ret.endian, blockSize: ret.blockSize\n            });\n            break;\n        default:\n            console.warn("Unsupported NRRD encoding: " + ret.encoding);\n        }\n    }\n    \n    return ret;\n};\n\nfunction escapeValue(val) {\n    return val.replace(\'\\\\\', \'\\\\\\\\\').replace(\'\\n\', \'\\\\n\');\n}\n\nfunction unescapeValue(val) {\n    return val.split(\'\\\\\\\\\').map(\n        function(s) { return s.replace(\'\\\\n\', \'\\n\'); }\n        ).join(\'\\\\\');\n}\n\n// Serializes NRRD fields\nfunction serializeField(prop, value, dimension, spaceDimension) {\n    var line;\n    var propNRRD = mapJavascriptToNRRD(prop);\n    switch(prop) {\n    // nrrd-js stuff: skip\n    case \'data\':\n    case \'buffer\':\n    case \'keys\':\n    case \'version\':\n        break;\n    // Literal (uninterpreted) fields\n    case \'content\':\n    case \'number\':\n    case \'sampleUnits\':\n    case \'space\':\n        line = propNRRD + ": " + value;\n        break;\n    // Integers (no infinity or whatever, just a plain integer, so the default serialization is good enough)\n    case \'blockSize\':\n    case \'lineSkip\':\n    case \'byteSkip\':\n    case \'dimension\':\n    case \'spaceDimension\':\n        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should at least contain a number!");\n        line = propNRRD + ": " + value;\n        break;\n    // Floats (default serialization is good enough, as NaN contains nan, ignoring case, and similarly for Infinity inf)\n    case \'min\':\n    case \'max\':\n    case \'oldMin\':\n    case \'oldMax\':\n        assert((typeof value) == "number" || value instanceof Number, "Field " + prop + " should contain a number!");\n        line = propNRRD + ": " + value;\n        break;\n    // Vectors\n    case \'spaceOrigin\':\n        assert(value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");\n        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });\n        line = propNRRD + ": (" + value.join(",") + ")";\n        break;\n    // Lists of strings\n    case \'labels\':\n    case \'units\':\n    case \'spaceUnits\':\n        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");\n        value.forEach(function (val) { assert((typeof val) == "string" || val instanceof String, "Field " + prop + " should be a list of numbers!"); });\n        line = propNRRD + ": " + value.map(serializeNRRDQuotedString).join(" ");\n        break;\n    // Lists of integers\n    case \'sizes\':\n        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");\n        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });\n        line = propNRRD + ": " + value.join(" ");\n        break;\n    // Lists of floats\n    case \'spacings\':\n    case \'thicknesses\':\n    case \'axisMins\':\n    case \'axisMaxs\':\n        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");\n        value.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "Field " + prop + " should be a list of numbers!"); });\n        line = propNRRD + ": " + value.join(" ");\n        break;\n    // Lists of vectors (dimension sized)\n    case \'spaceDirections\':\n        assert(value.length !== undefined && value.length === dimension, "Field " + prop + " should be a list with length equal to the dimension!");\n        value.forEach(function (vec) {\n          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");\n          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });\n        });\n        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");\n        break;\n    // Lists of vectors (space dimension sized)\n    case \'measurementFrame\':\n        assert(value.length !== undefined && value.length === spaceDimension, "Field " + prop + " should be a list with length equal to the space dimension!");\n        value.forEach(function (vec) {\n          assert(vec === null || (vec.length !== undefined && vec.length === spaceDimension), "The elements of field " + prop + " should be lists with length equal to the space dimension!");\n          if (vec !== null) vec.forEach(function (val) { assert((typeof val) == "number" || val instanceof Number, "The elements of field " + prop + " should be lists of numbers!"); });\n        });\n        line = propNRRD + ": " + value.map(function(vec) { return vec === null ? "none" : ("(" + vec.join(",") + ")"); }).join(" ");\n        break;\n    // One-of-a-kind fields\n    case \'type\':\n        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");\n        line = propNRRD + ": " + value;\n        break;\n    case \'encoding\':\n        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");\n        line = propNRRD + ": " + value;\n        break;\n    case \'endian\':\n        assert((typeof value) == "string" || value instanceof String, "Field " + prop + " should contain a string!");\n        line = propNRRD + ": " + value;\n        break;\n    case \'dataFile\':\n        if (value.length || (value.files && \'subdim\' in value)) {\n            // List of data files: skip for now\n        } else {\n            line = propNRRD + ": " + serializeNRRDDataFile(value);\n        }\n        break;\n    case \'centers\':\n        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");\n        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");\n        break;\n    case \'kinds\':\n        assert(value.length !== undefined && value.length == dimension, "Field " + prop + " should be a list with length equal to the dimension!");\n        line = propNRRD + ": " + value.map(serializeNRRDOptional).join(" ");\n        break;\n    // Something unknown\n    default:\n        console.warn("Unrecognized NRRD field: " + prop + ", skipping.");\n    }\n    return line;\n}\n\n// Parses and normalizes NRRD fields, assumes the field names are already lower case.\nfunction parseField(identifier, descriptor) {\n    switch(identifier) {\n    // Literal (uninterpreted) fields\n    case \'content\':\n    case \'number\':\n    case \'sampleUnits\':\n        break;\n    // Integers\n    case \'dimension\':\n    case \'blockSize\':\n    case \'lineSkip\':\n    case \'byteSkip\':\n    case \'spaceDimension\':\n        descriptor = parseNRRDInteger(descriptor);\n        break;\n    // Floats\n    case \'min\':\n    case \'max\':\n    case \'oldMin\':\n    case \'oldMax\':\n        descriptor = parseNRRDFloat(descriptor);\n        break;\n    // Vectors\n    case \'spaceOrigin\':\n        descriptor = parseNRRDVector(descriptor);\n        break;\n    // Lists of strings\n    case \'labels\':\n    case \'units\':\n    case \'spaceUnits\':\n        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDQuotedString);\n        break;\n    // Lists of integers\n    case \'sizes\':\n        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDInteger);\n        break;\n    // Lists of floats\n    case \'spacings\':\n    case \'thicknesses\':\n    case \'axisMins\':\n    case \'axisMaxs\':\n        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDFloat);\n        break;\n    // Lists of vectors\n    case \'spaceDirections\':\n    case \'measurementFrame\':\n        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDVector);\n        break;\n    // One-of-a-kind fields\n    case \'type\':\n        descriptor = parseNRRDType(descriptor);\n        break;\n    case \'encoding\':\n        descriptor = parseNRRDEncoding(descriptor);\n        break;\n    case \'endian\':\n        descriptor = parseNRRDEndian(descriptor);\n        break;\n    case \'dataFile\':\n        descriptor = parseNRRDDataFile(descriptor);\n        break;\n    case \'centers\':\n        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDCenter);\n        break;\n    case \'kinds\':\n        descriptor = parseNRRDWhitespaceSeparatedList(descriptor, parseNRRDKind);\n        break;\n    case \'space\':\n        descriptor = parseNRRDSpace(descriptor);\n        break;\n    // Something unknown\n    default:\n        console.warn("Unrecognized NRRD field: " + identifier);\n    }\n    return descriptor;\n}\n\n// This only includes names whose lower case form is different from the Javascript form.\nvar mapNRRDToJavascriptStatic = {\n    \'block size\': \'blockSize\',\n    \'blocksize\': \'blockSize\',\n    \'old min\': \'oldMin\',\n    \'oldmin\': \'oldMin\',\n    \'old max\': \'oldMax\',\n    \'oldmax\': \'oldMax\',\n    \'data file\': \'dataFile\',\n    \'datafile\': \'dataFile\',\n    \'line skip\': \'lineSkip\',\n    \'lineskip\': \'lineSkip\',\n    \'byte skip\': \'byteSkip\',\n    \'byteskip\': \'byteSkip\',\n    \'sample units\': \'sampleUnits\',\n    \'sampleunits\': \'sampleUnits\',\n    \'axis mins\': \'axisMins\',\n    \'axis maxs\': \'axisMaxs\',\n    \'centers\': \'centers\', // Not different, just included so it is clear why centerings maps to centers\n    \'centerings\': \'centers\',\n    \'space dimension\': \'spaceDimension\',\n    \'space units\': \'spaceUnits\',\n    \'space origin\': \'spaceOrigin\',\n    \'space directions\': \'spaceDirections\',\n    \'measurement frame\': \'measurementFrame\'\n};\nvar mapJavascriptToNRRDStatic = function() {\n  var id, m = {};\n  for(id in mapNRRDToJavascriptStatic) {\n    m[mapNRRDToJavascriptStatic[id]] = id;\n  }\n  return m;\n}();\nfunction mapNRRDToJavascript(id) {\n    // In any case, use the lower case version of the id\n    id = id.toLowerCase();\n    // Filter out any fields for which we have an explicit Javascript name\n    if (id in mapNRRDToJavascriptStatic) return mapNRRDToJavascriptStatic[id];\n    // Otherwise, just return the (lower case) id\n    return id;\n}\nfunction mapJavascriptToNRRD(id) {\n    // Filter out any fields for which we have an explicit NRRD name\n    if (id in mapJavascriptToNRRDStatic) return mapJavascriptToNRRDStatic[id];\n    // Otherwise, just return the id\n    return id;\n}\n\nfunction parseNRRDInteger(str) {\n    var val = parseInt(str, 10);\n    if (Number.isNaN(val)) throw new Error("Malformed NRRD integer: " + str);\n    return val;\n}\n\nfunction parseNRRDFloat(str) {\n    str = str.toLowerCase();\n    if (str.indexOf(\'nan\')>=0) return NaN;\n    if (str.indexOf(\'-inf\')>=0) return -Infinity;\n    if (str.indexOf(\'inf\')>=0) return Infinity;\n    var val = parseFloat(str);\n    if (Number.isNaN(val)) throw new Error("Malformed NRRD float: " + str);\n    return val;\n}\n\nfunction parseNRRDVector(str) {\n    if (str == "none") return null;\n    if (str.length<2 || str[0]!=="(" || str[str.length-1]!==")") throw new Error("Malformed NRRD vector: " + str);\n    return str.slice(1, -1).split(",").map(parseNRRDFloat);\n}\n\nfunction parseNRRDQuotedString(str) {\n    if (length<2 || str[0]!=\'"\' || str[str.length-1]!=\'"\') {\n        throw new Error("Invalid NRRD quoted string: " + str);\n    }\n    return str.slice(1, -1).replace(\'\\\\"\', \'"\');\n}\n\nfunction serializeNRRDQuotedString(str) {\n    return \'"\' + str.replace(\'"\', \'\\\\"\') + \'"\';\n}\n\nvar whitespaceListSeparator = /[ \\t]+/; // Note that this excludes other types of whitespace on purpose!\nfunction parseNRRDWhitespaceSeparatedList(str, parseElement) {\n    return str.split(whitespaceListSeparator).map(parseElement);\n}\n\nfunction parseNRRDType(descriptor) {\n    switch(descriptor.toLowerCase()) {\n    case "signed char":\n    case "int8":\n    case "int8_t":\n        return \'int8\';\n    case "uchar":\n    case "unsigned char":\n    case "uint8":\n    case "uint8_t":\n        return \'uint8\';\n    case "short":\n    case "short int":\n    case "signed short":\n    case "signed short int":\n    case "int16":\n    case "int16_t":\n        return \'int16\';\n    case "ushort":\n    case "unsigned short":\n    case "unsigned short int":\n    case "uint16":\n    case "uint16_t":\n        return \'uint16\';\n    case "int":\n    case "signed int":\n    case "int32":\n    case "int32_t":\n        return \'int32\';\n    case "uint":\n    case "unsigned int":\n    case "uint32":\n    case "uint32_t":\n        return \'uint32\';\n    case "longlong":\n    case "long long":\n    case "long long int":\n    case "signed long long":\n    case "signed long long int":\n    case "int64":\n    case "int64_t":\n        return \'int64\';\n    case "ulonglong":\n    case "unsigned long long":\n    case "unsigned long long int":\n    case "uint64":\n    case "uint64_t":\n        return \'uint64\';\n    case "float":\n        return \'float\';\n    case "double":\n        return \'double\';\n    case "block":\n        return \'block\';\n    default:\n        console.warn("Unrecognized NRRD type: " + descriptor);\n        return descriptor;\n    }\n}\n\nfunction parseNRRDEncoding(encoding) {\n    switch(encoding.toLowerCase()) {\n    case "raw":\n        return "raw";\n    case "txt":\n    case "text":\n    case "ascii":\n        return "ascii";\n    case "hex":\n        return "hex";\n    case "gz":\n    case "gzip":\n        return "gzip";\n    case "bz2":\n    case "bzip2":\n        return "bzip2";\n    default:\n        console.warn("Unrecognized NRRD encoding: " + encoding);\n        return encoding;\n    }\n}\n\nfunction parseNRRDSpace(space) {\n    switch(space.toLowerCase()) {\n    case "right-anterior-superior":\n    case "ras":\n        return "right-anterior-superior";\n    case "left-anterior-superior":\n    case "las":\n        return "left-anterior-superior";\n    case "left-posterior-superior":\n    case "lps":\n        return "left-posterior-superior";\n \t  case "right-anterior-superior-time":\n \t  case "rast":\n        return "right-anterior-superior-time";\n    case "left-anterior-superior-time":\n    case "last":\n        return "left-anterior-superior-time";\n    case "left-posterior-superior-time":\n    case "lpst":\n        return "left-posterior-superior-time";\n    case "scanner-xyz":\n        return "scanner-xyz";\n    case "scanner-xyz-time":\n        return "scanner-xyz-time";\n    case "3d-right-handed":\n        return "3D-right-handed";\n    case "3d-left-handed":\n        return "3D-left-handed";\n    case "3d-right-handed-time":\n        return "3D-right-handed-time";\n    case "3d-left-handed-time":\n        return "3D-left-handed-time";\n    default:\n        console.warn("Unrecognized space: " + space);\n        return space;\n    }\n}\n\nfunction parseNRRDEndian(endian) {\n    switch(endian.toLowerCase()) {\n    case \'little\':\n        return \'little\';\n    case \'big\':\n        return \'big\';\n    default:\n        console.warn("Unrecognized NRRD endianness: " + endian);\n        return endian;\n    }\n}\n\n// Note that this function will never encounter the LIST data file specification format, as this is handled elsewhere.\nvar dataFileFormatRE = / (-?\\d+) (-?\\d+) (-?\\d+)(?: (\\d+))?$/;\nfunction parseNRRDDataFile(dataFile) {\n    var match = dataFileFormatRE.exec(dataFile);\n    if (match) { // We have a format specification\n        if (match.length == 5 && match[4]) { // subdim specification\n            return {\n                format: dataFile.substring(0, match.index),\n                min: parseNRRDInteger(match[1]),\n                max: parseNRRDInteger(match[2]),\n                step: parseNRRDInteger(match[3]),\n                subdim: parseNRRDInteger(match[4])\n            };\n        } else {\n            return {\n                format: dataFile.substring(0, match.index),\n                min: parseNRRDInteger(match[1]),\n                max: parseNRRDInteger(match[2]),\n                step: parseNRRDInteger(match[3])\n            };\n        }\n    } else { // Just a file\n        return dataFile;\n    }\n}\n\nfunction serializeNRRDDataFile(dataFile) {\n    if ((typeof dataFile) == "string" || dataFile instanceof String) {\n        return dataFile;\n    } else if (\'format\' in dataFile && \'min\' in dataFile && \'max\' in dataFile && \'step\' in dataFile) {\n        if (\'subdim\' in dataFile) {\n            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step + " " + dataFile.subdim;\n        } else {\n            return dataFile.format + " " + dataFile.min + " " + dataFile.max + " " + dataFile.step;\n        }\n    } else {\n        throw new Error("Unrecognized data file format!");\n    }\n}\n\nfunction parseNRRDCenter(center) {\n    switch(center.toLowerCase()) {\n    case "cell":\n        return "cell";\n    case "node":\n        return "node";\n    case "???":\n    case "none":\n        return null;\n    default:\n        console.warn("Unrecognized NRRD center: " + center);\n        return center;\n    }\n}\n\nvar NRRDKinds = {\n    "domain": "domain",\n    "space": "space",\n    "time": "time",\n    "list": "list",\n    "point": "point",\n    "vector": "vector",\n    "covariant-vector": "covariant-vector",\n    "normal": "normal",\n    "stub": "stub",\n    "scalar": "scalar",\n    "complex": "complex",\n    "2-vector": "2-vector",\n    "3-color": "3-color",\n    "rgb-color": "RGB-color",\n    "hsv-color": "HSV-color",\n    "xyz-color": "XYZ-color",\n    "4-color": "4-color",\n    "rgba-color": "RGBA-color",\n    "3-vector": "3-vector",\n    "3-gradient": "3-gradient",\n    "3-normal": "3-normal",\n    "4-vector": "4-vector",\n    "quaternion": "quaternion",\n    "2d-symmetric-matrix": "2D-symmetric-matrix",\n    "2d-masked-symmetric-matrix": "2D-masked-symmetric-matrix",\n    "2d-matrix": "2D-matrix",\n    "2d-masked-matrix": "2D-masked-matrix",\n    "3d-symmetric-matrix": "3D-symmetric-matrix",\n    "3d-masked-symmetric-matrix": "3D-masked-symmetric-matrix",\n    "3d-matrix": "3D-matrix",\n    "3d-masked-matrix": "3D-masked-matrix",\n    "???": null,\n    "none": null\n};\nfunction parseNRRDKind(kind) {\n    var kindLC = kind.toLowerCase();\n    if (kindLC in NRRDKinds) return NRRDKinds[kindLC];\n    console.warn("Unrecognized NRRD kind: " + kind);\n    return kind;\n}\n\nfunction serializeNRRDOptional(a) {\n    return a===null ? "???" : a;\n}\n\nvar systemEndianness = (function() {\n    var buf = new ArrayBuffer(4),\n        intArr = new Uint32Array(buf),\n        byteArr = new Uint8Array(buf);\n    intArr[0] = 0x01020304;\n    if (byteArr[0]==1 && byteArr[1]==2 && byteArr[2]==3 && byteArr[3]==4) {\n        return \'big\';\n    } else if (byteArr[0]==4 && byteArr[1]==3 && byteArr[2]==2 && byteArr[3]==1) {\n        return \'little\';\n    }\n    console.warn("Unrecognized system endianness!");\n    return undefined;\n})();\n\nfunction parseNRRDRawData(buffer, type, sizes, options) {\n    var i, arr, view, totalLen = 1, endianFlag;\n    for(i=0; i<sizes.length; i++) {\n        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");\n        totalLen *= sizes[i];\n    }\n    if (type == \'block\') {\n        // Don\'t do anything special, just return the slice containing all blocks.\n        return buffer.slice(0,totalLen*options.blockSize);\n    } else if (type == \'int8\' || type == \'uint8\' || options.endian == systemEndianness) {\n        switch(type) {\n        case "int8":\n            checkSize(1);\n            return new Int8Array(buffer.slice(0,totalLen));\n        case "uint8":\n            checkSize(1);\n            return new Uint8Array(buffer.slice(0,totalLen));\n        case "int16":\n            checkSize(2);\n            return new Int16Array(buffer.slice(0,totalLen*2));\n        case "uint16":\n            checkSize(2);\n            return new Uint16Array(buffer.slice(0,totalLen*2));\n        case "int32":\n            checkSize(4);\n            return new Int32Array(buffer.slice(0,totalLen*4));\n        case "uint32":\n            checkSize(4);\n            return new Uint32Array(buffer.slice(0,totalLen*4));\n        //case "int64":\n        //    checkSize(8);\n        //    return new Int64Array(buffer.slice(0,totalLen*8));\n        //case "uint64":\n        //    checkSize(8);\n        //    return new Uint64Array(buffer.slice(0,totalLen*8));\n        case "float":\n            checkSize(4);\n            return new Float32Array(buffer.slice(0,totalLen*4));\n        case "double":\n            checkSize(8);\n            return new Float64Array(buffer.slice(0,totalLen*8));\n        default:\n            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");\n            return undefined;\n        }\n    } else {\n        switch(options.endian) {\n        case \'big\':\n            endianFlag = false;\n            break;\n        case \'little\':\n            endianFlag = true;\n            break;\n        default:\n            console.warn("Unsupported endianness in NRRD file: " + options.endian);\n            return undefined;\n        }\n        view = new DataView(buffer);\n        switch(type) {\n        case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.\n            arr = new Int8Array(totalLen);\n            for(i=0; i<totalLen; i++) {\n                arr[i] = view.getInt8(i);\n            }\n            return arr;\n        case "uint8":\n            arr = new Uint8Array(totalLen);\n            for(i=0; i<totalLen; i++) {\n                arr[i] = view.getUint8(i);\n            }\n            return arr;\n        case "int16":\n            arr = new Int16Array(totalLen);\n            for(i=0; i<totalLen; i++) {\n                arr[i] = view.getInt16(i*2);\n            }\n            return arr;\n        case "uint16":\n            arr = new Uint16Array(totalLen);\n            for(i=0; i<totalLen; i++) {\n                arr[i] = view.getUint16(i*2);\n            }\n            return arr;\n        case "int32":\n            arr = new Int32Array(totalLen);\n            for(i=0; i<totalLen; i++) {\n                arr[i] = view.getInt32(i*4);\n            }\n            return arr;\n        case "uint32":\n            arr = new Uint32Array(totalLen);\n            for(i=0; i<totalLen; i++) {\n                arr[i] = view.getUint32(i*4);\n            }\n            return arr;\n        //case "int64":\n        //    arr = new Int64Array(totalLen);\n        //    for(i=0; i<totalLen; i++) {\n        //        arr[i] = view.getInt64(i*8);\n        //    }\n        //    return arr;\n        //case "uint64":\n        //    arr = new Uint64Array(totalLen);\n        //    for(i=0; i<totalLen; i++) {\n        //        arr[i] = view.getUint64(i*8);\n        //    }\n        //    return arr;\n        case "float":\n            arr = new Float32Array(totalLen);\n            for(i=0; i<totalLen; i++) {\n                arr[i] = view.getFloat32(i*4);\n            }\n            return arr;\n        case "double":\n            arr = new Float64Array(totalLen);\n            for(i=0; i<totalLen; i++) {\n                arr[i] = view.getFloat64(i*8);\n            }\n            return arr;\n        default:\n            console.warn("Unsupported NRRD type: " + type + ", returning raw buffer.");\n            return undefined;\n        }\n    }\n    function checkSize(sizeOfType) {\n        if (buffer.byteLength<totalLen*sizeOfType) throw new Error("NRRD file does not contain enough data!");\n    }\n}\n\nvar whitespaceDataValueListSeparatorRE = /[ \\t\\n\\r\\v\\f]+/;\nfunction parseNRRDTextData(buffer, type, sizes) {\n    var i, buf8, str, strList, totalLen = 1;\n    for(i=0; i<sizes.length; i++) {\n        if (sizes[i]<=0) throw new Error("Sizes should be a list of positive (>0) integers!");\n        totalLen *= sizes[i];\n    }\n    buf8 = new Uint8Array(buffer);\n    str = String.fromCharCode.apply(null, buf8);\n    strList = str.split(whitespaceDataValueListSeparatorRE);\n    if (strList.length<totalLen) {\n        throw new Error("Not enough data in NRRD file!");\n    } else if (strList.length>totalLen) {\n        if (strList[0] === \'\') strList = strList.slice(1); // Strictly speaking the spec doesn\'t (explicitly) allow whitespace in front of the first number, but let\'s be lenient.\n        strList = strList.slice(0, totalLen);\n    }\n    switch(type) {\n    case "int8":\n        return new Int8Array(strList.map(parseNRRDInteger));\n    case "uint8":\n        return new Uint8Array(strList.map(parseNRRDInteger));\n    case "int16":\n        return new Int16Array(strList.map(parseNRRDInteger));\n    case "uint16":\n        return new Uint16Array(strList.map(parseNRRDInteger));\n    case "int32":\n        return new Int32Array(strList.map(parseNRRDInteger));\n    case "uint32":\n        return new Uint32Array(strList.map(parseNRRDInteger));\n    //case "int64":\n    //    return new Int64Array(strList.map(parseNRRDInteger));\n    //case "uint64":\n    //    return new Uint64Array(strList.map(parseNRRDInteger));\n    case "float":\n        return new Float32Array(strList.map(parseNRRDFloat));\n    case "double":\n        return new Float64Array(strList.map(parseNRRDFloat));\n    default:\n        console.warn("Unsupported NRRD type: " + type + ".");\n        return undefined;\n    }\n}\n\n// This ALWAYS returns an integer, or throws an exception.\nfunction getNRRDTypeSize(type) {\n    switch(type) {\n    case "int8":\n        return 1;\n    case "uint8":\n        return 1;\n    case "int16":\n        return 2;\n    case "uint16":\n        return 2;\n    case "int32":\n        return 4;\n    case "uint32":\n        return 4;\n    case "int64":\n        return 8;\n    case "uint64":\n        return 8;\n    case "float":\n        return 4;\n    case "double":\n        return 8;\n    default:\n        throw new Error("Do not know the size of NRRD type: " + type);\n    }\n}\n\nfunction checkNRRD(ret) {\n    // Always necessary fields\n    if (ret.dimension===undefined) {\n        throw new Error("Dimension missing from NRRD file!");\n    } else if (ret.type===undefined) {\n        throw new Error("Type missing from NRRD file!");\n    } else if (ret.encoding===undefined) {\n        throw new Error("Encoding missing from NRRD file!");\n    } else if (ret.sizes===undefined) {\n        throw new Error("Sizes missing from NRRD file!");\n    }\n    \n    // Sometimes necessary fields\n    if (ret.type != \'block\' && ret.type != \'int8\' && ret.type != \'uint8\' &&\n          ret.encoding != \'ascii\' && ret.endian === undefined) {\n        throw new Error("Endianness missing from NRRD file!");\n    } else if (ret.type == \'block\' && ret.blockSize === undefined) {\n        throw new Error("Missing block size in NRRD file!");\n    }\n    \n    // Check dimension and per-axis field lengths\n    if (ret.dimension === 0) {\n        throw new Error("Zero-dimensional NRRD file?");\n    } else if (ret.dimension != ret.sizes.length) {\n        throw new Error("Length of \'sizes\' is different from \'dimension\' in an NRRD file!");\n    } else if (ret.spacings && ret.dimension != ret.spacings.length) {\n        throw new Error("Length of \'spacings\' is different from \'dimension\' in an NRRD file!");\n    } else if (ret.thicknesses && ret.dimension != ret.thicknesses.length) {\n        throw new Error("Length of \'thicknesses\' is different from \'dimension\' in an NRRD file!");\n    } else if (ret.axisMins && ret.dimension != ret.axisMins.length) {\n        throw new Error("Length of \'axis mins\' is different from \'dimension\' in an NRRD file!");\n    } else if (ret.axisMaxs && ret.dimension != ret.axisMaxs.length) {\n        throw new Error("Length of \'axis maxs\' is different from \'dimension\' in an NRRD file!");\n    } else if (ret.centers && ret.dimension != ret.centers.length) {\n        throw new Error("Length of \'centers\' is different from \'dimension\' in an NRRD file!");\n    } else if (ret.labels && ret.dimension != ret.labels.length) {\n        throw new Error("Length of \'labels\' is different from \'dimension\' in an NRRD file!");\n    } else if (ret.units && ret.dimension != ret.units.length) {\n        throw new Error("Length of \'units\' is different from \'dimension\' in an NRRD file!");\n    } else if (ret.kinds && ret.dimension != ret.kinds.length) {\n        throw new Error("Length of \'kinds\' is different from \'dimension\' in an NRRD file!");\n    }\n    \n    // TODO: Check space/orientation fields.\n    \n    // We should either have inline data or external data\n    if ((ret.data === undefined || ret.data.length === 0) && (ret.buffer === undefined || ret.buffer.byteLength === 0) && ret.dataFile === undefined) {\n        throw new Error("NRRD file has neither inline or external data!");\n    }\n}\n\nfunction castTypedArray(data, type) {\n    switch(type) {\n    case "int8":\n        return new Int8Array(data);\n    case "uint8":\n        return new Uint8Array(data);\n    case "int16":\n        return new Int16Array(data);\n    case "uint16":\n        return new Uint16Array(data);\n    case "int32":\n        return new Int32Array(data);\n    case "uint32":\n        return new Uint32Array(data);\n    //case "int64":\n    //    return new Int64Array(data);\n    //case "uint64":\n    //    return new Uint64Array(data);\n    case "float":\n        return new Float32Array(data);\n    case "double":\n        return new Float64Array(data);\n    default:\n        throw new Error("Cannot cast to NRRD type: " + type);\n    }\n}\n\nfunction serializeToBuffer(data, type, endian) {\n    var i, endianFlag, view, nativeSize = getNRRDTypeSize(type), buffer = new ArrayBuffer(data.length*nativeSize);\n    switch(endian) {\n    case \'big\':\n        endianFlag = false;\n        break;\n    case \'little\':\n        endianFlag = true;\n        break;\n    default:\n        console.warn("Unsupported endianness in NRRD file: " + endian);\n        return undefined;\n    }\n    view = new DataView(buffer);\n    switch(type) {\n    case "int8": // Note that here we do not need to check the size of the buffer, as the DataView.get methods should throw an exception if we read beyond the buffer.\n        for(i=0; i<data.length; i++) {\n            view.setInt8(i, data[i], endianFlag);\n        }\n        return buffer;\n    case "uint8":\n        for(i=0; i<data.length; i++) {\n            view.setUint8(i, data[i], endianFlag);\n        }\n        return buffer;\n    case "int16":\n        for(i=0; i<data.length; i++) {\n            view.setInt16(i*2, data[i], endianFlag);\n        }\n        return buffer;\n    case "uint16":\n        for(i=0; i<data.length; i++) {\n            view.setUint16(i*2, data[i], endianFlag);\n        }\n        return buffer;\n    case "int32":\n        for(i=0; i<data.length; i++) {\n            view.setInt32(i*4, data[i], endianFlag);\n        }\n        return buffer;\n    case "uint32":\n        for(i=0; i<data.length; i++) {\n            view.setUint32(i*4, data[i], endianFlag);\n        }\n        return buffer;\n    //case "int64":\n    //    for(i=0; i<data.length; i++) {\n    //        view.setInt64(i*8, data[i], endianFlag);\n    //    }\n    //    return buffer;\n    //case "uint64":\n    //    for(i=0; i<data.length; i++) {\n    //        view.setUint64(i*8, data[i], endianFlag);\n    //    }\n    //    return buffer;\n    case "float":\n        for(i=0; i<data.length; i++) {\n            view.setFloat32(i*4, data[i], endianFlag);\n        }\n        return buffer;\n    case "double":\n        for(i=0; i<data.length; i++) {\n            view.setFloat64(i*8, data[i], endianFlag);\n        }\n        return buffer;\n    default:\n        console.warn("Cannot serialize NRRD type: " + type + ".");\n        return undefined;\n    }\n}\n\nfunction serializeToTextBuffer(data) {\n    var i, strs = new Array(data.length), str, buffer, arr;\n    for(i=0; i<data.length; i++) {\n        strs[i] = \'\' + data[i];\n    }\n    str = strs.join(" ");\n    buffer = new ArrayBuffer(str.length);\n    arr = new Uint8Array(buffer);\n    for(i=0; i<arr.length; i++) {\n        arr[i] = str.charCodeAt(i);\n    }\n    return buffer;\n}\n\n  return nrrd;\n\n}\nnrrd = NRRD();\n\n\n'},function(t,n){t.exports="/* pako 1.0.5 nodeca/pako */(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.pako = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\n'use strict';\n\n\nvar zlib_deflate = require('./zlib/deflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\n\nvar toString = Object.prototype.toString;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\nvar Z_NO_FLUSH      = 0;\nvar Z_FINISH        = 4;\n\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_SYNC_FLUSH    = 2;\n\nvar Z_DEFAULT_COMPRESSION = -1;\n\nvar Z_DEFAULT_STRATEGY    = 0;\n\nvar Z_DEFLATED  = 8;\n\n/* ===========================================================================*/\n\n\n/**\n * class Deflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[deflate]],\n * [[deflateRaw]] and [[gzip]].\n **/\n\n/* internal\n * Deflate.chunks -> Array\n *\n * Chunks of output data, if [[Deflate#onData]] not overriden.\n **/\n\n/**\n * Deflate.result -> Uint8Array|Array\n *\n * Compressed result, generated by default [[Deflate#onData]]\n * and [[Deflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Deflate#push]] with `Z_FINISH` / `true` param)  or if you\n * push a chunk with explicit flush (call [[Deflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Deflate.err -> Number\n *\n * Error code after deflate finished. 0 (Z_OK) on success.\n * You will not need it in real life, because deflate errors\n * are possible only on wrong options or bad `onData` / `onEnd`\n * custom handlers.\n **/\n\n/**\n * Deflate.msg -> String\n *\n * Error message, if [[Deflate.err]] != 0\n **/\n\n\n/**\n * new Deflate(options)\n * - options (Object): zlib deflate options.\n *\n * Creates new deflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `level`\n * - `windowBits`\n * - `memLevel`\n * - `strategy`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw deflate\n * - `gzip` (Boolean) - create gzip wrapper\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n * - `header` (Object) - custom header for gzip\n *   - `text` (Boolean) - true if compressed data believed to be text\n *   - `time` (Number) - modification time, unix timestamp\n *   - `os` (Number) - operation system code\n *   - `extra` (Array) - array of bytes with extra data (max 65536)\n *   - `name` (String) - file name (binary string)\n *   - `comment` (String) - comment (binary string)\n *   - `hcrc` (Boolean) - true if header crc should be added\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var deflate = new pako.Deflate({ level: 3});\n *\n * deflate.push(chunk1, false);\n * deflate.push(chunk2, true);  // true -> last chunk\n *\n * if (deflate.err) { throw new Error(deflate.err); }\n *\n * console.log(deflate.result);\n * ```\n **/\nfunction Deflate(options) {\n  if (!(this instanceof Deflate)) return new Deflate(options);\n\n  this.options = utils.assign({\n    level: Z_DEFAULT_COMPRESSION,\n    method: Z_DEFLATED,\n    chunkSize: 16384,\n    windowBits: 15,\n    memLevel: 8,\n    strategy: Z_DEFAULT_STRATEGY,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  if (opt.raw && (opt.windowBits > 0)) {\n    opt.windowBits = -opt.windowBits;\n  }\n\n  else if (opt.gzip && (opt.windowBits > 0) && (opt.windowBits < 16)) {\n    opt.windowBits += 16;\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status = zlib_deflate.deflateInit2(\n    this.strm,\n    opt.level,\n    opt.method,\n    opt.windowBits,\n    opt.memLevel,\n    opt.strategy\n  );\n\n  if (status !== Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  if (opt.header) {\n    zlib_deflate.deflateSetHeader(this.strm, opt.header);\n  }\n\n  if (opt.dictionary) {\n    var dict;\n    // Convert data if needed\n    if (typeof opt.dictionary === 'string') {\n      // If we need to compress text, change encoding to utf8.\n      dict = strings.string2buf(opt.dictionary);\n    } else if (toString.call(opt.dictionary) === '[object ArrayBuffer]') {\n      dict = new Uint8Array(opt.dictionary);\n    } else {\n      dict = opt.dictionary;\n    }\n\n    status = zlib_deflate.deflateSetDictionary(this.strm, dict);\n\n    if (status !== Z_OK) {\n      throw new Error(msg[status]);\n    }\n\n    this._dict_set = true;\n  }\n}\n\n/**\n * Deflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data. Strings will be\n *   converted to utf8 byte sequence.\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n *\n * Sends input data to deflate pipe, generating [[Deflate#onData]] calls with\n * new compressed chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Deflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the compression context.\n *\n * On fail call [[Deflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * array format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nDeflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var status, _mode;\n\n  if (this.ended) { return false; }\n\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? Z_FINISH : Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // If we need to compress text, change encoding to utf8.\n    strm.input = strings.string2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n    status = zlib_deflate.deflate(strm, _mode);    /* no bad return value */\n\n    if (status !== Z_STREAM_END && status !== Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n    if (strm.avail_out === 0 || (strm.avail_in === 0 && (_mode === Z_FINISH || _mode === Z_SYNC_FLUSH))) {\n      if (this.options.to === 'string') {\n        this.onData(strings.buf2binstring(utils.shrinkBuf(strm.output, strm.next_out)));\n      } else {\n        this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n      }\n    }\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== Z_STREAM_END);\n\n  // Finalize on the last chunk.\n  if (_mode === Z_FINISH) {\n    status = zlib_deflate.deflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === Z_SYNC_FLUSH) {\n    this.onEnd(Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Deflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nDeflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Deflate#onEnd(status) -> Void\n * - status (Number): deflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called once after you tell deflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nDeflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === Z_OK) {\n    if (this.options.to === 'string') {\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * deflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * Compress `data` with deflate algorithm and `options`.\n *\n * Supported options are:\n *\n * - level\n * - windowBits\n * - memLevel\n * - strategy\n * - dictionary\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be \"binary string\"\n *    (each char code [0..255])\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , data = Uint8Array([1,2,3,4,5,6,7,8,9]);\n *\n * console.log(pako.deflate(data));\n * ```\n **/\nfunction deflate(input, options) {\n  var deflator = new Deflate(options);\n\n  deflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (deflator.err) { throw deflator.msg || msg[deflator.err]; }\n\n  return deflator.result;\n}\n\n\n/**\n * deflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction deflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return deflate(input, options);\n}\n\n\n/**\n * gzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to compress.\n * - options (Object): zlib deflate options.\n *\n * The same as [[deflate]], but create gzip wrapper instead of\n * deflate one.\n **/\nfunction gzip(input, options) {\n  options = options || {};\n  options.gzip = true;\n  return deflate(input, options);\n}\n\n\nexports.Deflate = Deflate;\nexports.deflate = deflate;\nexports.deflateRaw = deflateRaw;\nexports.gzip = gzip;\n\n},{\"./utils/common\":3,\"./utils/strings\":4,\"./zlib/deflate\":8,\"./zlib/messages\":13,\"./zlib/zstream\":15}],2:[function(require,module,exports){\n'use strict';\n\n\nvar zlib_inflate = require('./zlib/inflate');\nvar utils        = require('./utils/common');\nvar strings      = require('./utils/strings');\nvar c            = require('./zlib/constants');\nvar msg          = require('./zlib/messages');\nvar ZStream      = require('./zlib/zstream');\nvar GZheader     = require('./zlib/gzheader');\n\nvar toString = Object.prototype.toString;\n\n/**\n * class Inflate\n *\n * Generic JS-style wrapper for zlib calls. If you don't need\n * streaming behaviour - use more simple functions: [[inflate]]\n * and [[inflateRaw]].\n **/\n\n/* internal\n * inflate.chunks -> Array\n *\n * Chunks of output data, if [[Inflate#onData]] not overriden.\n **/\n\n/**\n * Inflate.result -> Uint8Array|Array|String\n *\n * Uncompressed result, generated by default [[Inflate#onData]]\n * and [[Inflate#onEnd]] handlers. Filled after you push last chunk\n * (call [[Inflate#push]] with `Z_FINISH` / `true` param) or if you\n * push a chunk with explicit flush (call [[Inflate#push]] with\n * `Z_SYNC_FLUSH` param).\n **/\n\n/**\n * Inflate.err -> Number\n *\n * Error code after inflate finished. 0 (Z_OK) on success.\n * Should be checked if broken data possible.\n **/\n\n/**\n * Inflate.msg -> String\n *\n * Error message, if [[Inflate.err]] != 0\n **/\n\n\n/**\n * new Inflate(options)\n * - options (Object): zlib inflate options.\n *\n * Creates new inflator instance with specified params. Throws exception\n * on bad params. Supported options:\n *\n * - `windowBits`\n * - `dictionary`\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information on these.\n *\n * Additional options, for internal needs:\n *\n * - `chunkSize` - size of generated data chunks (16K by default)\n * - `raw` (Boolean) - do raw inflate\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n * By default, when no options set, autodetect deflate/gzip data format via\n * wrapper header.\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , chunk1 = Uint8Array([1,2,3,4,5,6,7,8,9])\n *   , chunk2 = Uint8Array([10,11,12,13,14,15,16,17,18,19]);\n *\n * var inflate = new pako.Inflate({ level: 3});\n *\n * inflate.push(chunk1, false);\n * inflate.push(chunk2, true);  // true -> last chunk\n *\n * if (inflate.err) { throw new Error(inflate.err); }\n *\n * console.log(inflate.result);\n * ```\n **/\nfunction Inflate(options) {\n  if (!(this instanceof Inflate)) return new Inflate(options);\n\n  this.options = utils.assign({\n    chunkSize: 16384,\n    windowBits: 0,\n    to: ''\n  }, options || {});\n\n  var opt = this.options;\n\n  // Force window size for `raw` data, if not set directly,\n  // because we have no header for autodetect.\n  if (opt.raw && (opt.windowBits >= 0) && (opt.windowBits < 16)) {\n    opt.windowBits = -opt.windowBits;\n    if (opt.windowBits === 0) { opt.windowBits = -15; }\n  }\n\n  // If `windowBits` not defined (and mode not raw) - set autodetect flag for gzip/deflate\n  if ((opt.windowBits >= 0) && (opt.windowBits < 16) &&\n      !(options && options.windowBits)) {\n    opt.windowBits += 32;\n  }\n\n  // Gzip header has no info about windows size, we can do autodetect only\n  // for deflate. So, if window size not set, force it to max when gzip possible\n  if ((opt.windowBits > 15) && (opt.windowBits < 48)) {\n    // bit 3 (16) -> gzipped data\n    // bit 4 (32) -> autodetect gzip/deflate\n    if ((opt.windowBits & 15) === 0) {\n      opt.windowBits |= 15;\n    }\n  }\n\n  this.err    = 0;      // error code, if happens (0 = Z_OK)\n  this.msg    = '';     // error message\n  this.ended  = false;  // used to avoid multiple onEnd() calls\n  this.chunks = [];     // chunks of compressed data\n\n  this.strm   = new ZStream();\n  this.strm.avail_out = 0;\n\n  var status  = zlib_inflate.inflateInit2(\n    this.strm,\n    opt.windowBits\n  );\n\n  if (status !== c.Z_OK) {\n    throw new Error(msg[status]);\n  }\n\n  this.header = new GZheader();\n\n  zlib_inflate.inflateGetHeader(this.strm, this.header);\n}\n\n/**\n * Inflate#push(data[, mode]) -> Boolean\n * - data (Uint8Array|Array|ArrayBuffer|String): input data\n * - mode (Number|Boolean): 0..6 for corresponding Z_NO_FLUSH..Z_TREE modes.\n *   See constants. Skipped or `false` means Z_NO_FLUSH, `true` meansh Z_FINISH.\n *\n * Sends input data to inflate pipe, generating [[Inflate#onData]] calls with\n * new output chunks. Returns `true` on success. The last data block must have\n * mode Z_FINISH (or `true`). That will flush internal pending buffers and call\n * [[Inflate#onEnd]]. For interim explicit flushes (without ending the stream) you\n * can use mode Z_SYNC_FLUSH, keeping the decompression context.\n *\n * On fail call [[Inflate#onEnd]] with error code and return false.\n *\n * We strongly recommend to use `Uint8Array` on input for best speed (output\n * format is detected automatically). Also, don't skip last param and always\n * use the same type in your code (boolean or number). That will improve JS speed.\n *\n * For regular `Array`-s make sure all elements are [0..255].\n *\n * ##### Example\n *\n * ```javascript\n * push(chunk, false); // push one of data chunks\n * ...\n * push(chunk, true);  // push last chunk\n * ```\n **/\nInflate.prototype.push = function (data, mode) {\n  var strm = this.strm;\n  var chunkSize = this.options.chunkSize;\n  var dictionary = this.options.dictionary;\n  var status, _mode;\n  var next_out_utf8, tail, utf8str;\n  var dict;\n\n  // Flag to properly process Z_BUF_ERROR on testing inflate call\n  // when we check that all output data was flushed.\n  var allowBufError = false;\n\n  if (this.ended) { return false; }\n  _mode = (mode === ~~mode) ? mode : ((mode === true) ? c.Z_FINISH : c.Z_NO_FLUSH);\n\n  // Convert data if needed\n  if (typeof data === 'string') {\n    // Only binary strings can be decompressed on practice\n    strm.input = strings.binstring2buf(data);\n  } else if (toString.call(data) === '[object ArrayBuffer]') {\n    strm.input = new Uint8Array(data);\n  } else {\n    strm.input = data;\n  }\n\n  strm.next_in = 0;\n  strm.avail_in = strm.input.length;\n\n  do {\n    if (strm.avail_out === 0) {\n      strm.output = new utils.Buf8(chunkSize);\n      strm.next_out = 0;\n      strm.avail_out = chunkSize;\n    }\n\n    status = zlib_inflate.inflate(strm, c.Z_NO_FLUSH);    /* no bad return value */\n\n    if (status === c.Z_NEED_DICT && dictionary) {\n      // Convert data if needed\n      if (typeof dictionary === 'string') {\n        dict = strings.string2buf(dictionary);\n      } else if (toString.call(dictionary) === '[object ArrayBuffer]') {\n        dict = new Uint8Array(dictionary);\n      } else {\n        dict = dictionary;\n      }\n\n      status = zlib_inflate.inflateSetDictionary(this.strm, dict);\n\n    }\n\n    if (status === c.Z_BUF_ERROR && allowBufError === true) {\n      status = c.Z_OK;\n      allowBufError = false;\n    }\n\n    if (status !== c.Z_STREAM_END && status !== c.Z_OK) {\n      this.onEnd(status);\n      this.ended = true;\n      return false;\n    }\n\n    if (strm.next_out) {\n      if (strm.avail_out === 0 || status === c.Z_STREAM_END || (strm.avail_in === 0 && (_mode === c.Z_FINISH || _mode === c.Z_SYNC_FLUSH))) {\n\n        if (this.options.to === 'string') {\n\n          next_out_utf8 = strings.utf8border(strm.output, strm.next_out);\n\n          tail = strm.next_out - next_out_utf8;\n          utf8str = strings.buf2string(strm.output, next_out_utf8);\n\n          // move tail\n          strm.next_out = tail;\n          strm.avail_out = chunkSize - tail;\n          if (tail) { utils.arraySet(strm.output, strm.output, next_out_utf8, tail, 0); }\n\n          this.onData(utf8str);\n\n        } else {\n          this.onData(utils.shrinkBuf(strm.output, strm.next_out));\n        }\n      }\n    }\n\n    // When no more input data, we should check that internal inflate buffers\n    // are flushed. The only way to do it when avail_out = 0 - run one more\n    // inflate pass. But if output data not exists, inflate return Z_BUF_ERROR.\n    // Here we set flag to process this error properly.\n    //\n    // NOTE. Deflate does not return error in this case and does not needs such\n    // logic.\n    if (strm.avail_in === 0 && strm.avail_out === 0) {\n      allowBufError = true;\n    }\n\n  } while ((strm.avail_in > 0 || strm.avail_out === 0) && status !== c.Z_STREAM_END);\n\n  if (status === c.Z_STREAM_END) {\n    _mode = c.Z_FINISH;\n  }\n\n  // Finalize on the last chunk.\n  if (_mode === c.Z_FINISH) {\n    status = zlib_inflate.inflateEnd(this.strm);\n    this.onEnd(status);\n    this.ended = true;\n    return status === c.Z_OK;\n  }\n\n  // callback interim results if Z_SYNC_FLUSH.\n  if (_mode === c.Z_SYNC_FLUSH) {\n    this.onEnd(c.Z_OK);\n    strm.avail_out = 0;\n    return true;\n  }\n\n  return true;\n};\n\n\n/**\n * Inflate#onData(chunk) -> Void\n * - chunk (Uint8Array|Array|String): ouput data. Type of array depends\n *   on js engine support. When string output requested, each chunk\n *   will be string.\n *\n * By default, stores data blocks in `chunks[]` property and glue\n * those in `onEnd`. Override this handler, if you need another behaviour.\n **/\nInflate.prototype.onData = function (chunk) {\n  this.chunks.push(chunk);\n};\n\n\n/**\n * Inflate#onEnd(status) -> Void\n * - status (Number): inflate status. 0 (Z_OK) on success,\n *   other if not.\n *\n * Called either after you tell inflate that the input stream is\n * complete (Z_FINISH) or should be flushed (Z_SYNC_FLUSH)\n * or if an error happened. By default - join collected chunks,\n * free memory and fill `results` / `err` properties.\n **/\nInflate.prototype.onEnd = function (status) {\n  // On success - join\n  if (status === c.Z_OK) {\n    if (this.options.to === 'string') {\n      // Glue & convert here, until we teach pako to send\n      // utf8 alligned strings to onData\n      this.result = this.chunks.join('');\n    } else {\n      this.result = utils.flattenChunks(this.chunks);\n    }\n  }\n  this.chunks = [];\n  this.err = status;\n  this.msg = this.strm.msg;\n};\n\n\n/**\n * inflate(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Decompress `data` with inflate/ungzip and `options`. Autodetect\n * format via wrapper header by default. That's why we don't provide\n * separate `ungzip` method.\n *\n * Supported options are:\n *\n * - windowBits\n *\n * [http://zlib.net/manual.html#Advanced](http://zlib.net/manual.html#Advanced)\n * for more information.\n *\n * Sugar (options):\n *\n * - `raw` (Boolean) - say that we work with raw stream, if you don't wish to specify\n *   negative windowBits implicitly.\n * - `to` (String) - if equal to 'string', then result will be converted\n *   from utf8 to utf16 (javascript) string. When string output requested,\n *   chunk length can differ from `chunkSize`, depending on content.\n *\n *\n * ##### Example:\n *\n * ```javascript\n * var pako = require('pako')\n *   , input = pako.deflate([1,2,3,4,5,6,7,8,9])\n *   , output;\n *\n * try {\n *   output = pako.inflate(input);\n * } catch (err)\n *   console.log(err);\n * }\n * ```\n **/\nfunction inflate(input, options) {\n  var inflator = new Inflate(options);\n\n  inflator.push(input, true);\n\n  // That will never happens, if you don't cheat with options :)\n  if (inflator.err) { throw inflator.msg || msg[inflator.err]; }\n\n  return inflator.result;\n}\n\n\n/**\n * inflateRaw(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * The same as [[inflate]], but creates raw data, without wrapper\n * (header and adler32 crc).\n **/\nfunction inflateRaw(input, options) {\n  options = options || {};\n  options.raw = true;\n  return inflate(input, options);\n}\n\n\n/**\n * ungzip(data[, options]) -> Uint8Array|Array|String\n * - data (Uint8Array|Array|String): input data to decompress.\n * - options (Object): zlib inflate options.\n *\n * Just shortcut to [[inflate]], because it autodetects format\n * by header.content. Done for convenience.\n **/\n\n\nexports.Inflate = Inflate;\nexports.inflate = inflate;\nexports.inflateRaw = inflateRaw;\nexports.ungzip  = inflate;\n\n},{\"./utils/common\":3,\"./utils/strings\":4,\"./zlib/constants\":6,\"./zlib/gzheader\":9,\"./zlib/inflate\":11,\"./zlib/messages\":13,\"./zlib/zstream\":15}],3:[function(require,module,exports){\n'use strict';\n\n\nvar TYPED_OK =  (typeof Uint8Array !== 'undefined') &&\n                (typeof Uint16Array !== 'undefined') &&\n                (typeof Int32Array !== 'undefined');\n\n\nexports.assign = function (obj /*from1, from2, from3, ...*/) {\n  var sources = Array.prototype.slice.call(arguments, 1);\n  while (sources.length) {\n    var source = sources.shift();\n    if (!source) { continue; }\n\n    if (typeof source !== 'object') {\n      throw new TypeError(source + 'must be non-object');\n    }\n\n    for (var p in source) {\n      if (source.hasOwnProperty(p)) {\n        obj[p] = source[p];\n      }\n    }\n  }\n\n  return obj;\n};\n\n\n// reduce buffer size, avoiding mem copy\nexports.shrinkBuf = function (buf, size) {\n  if (buf.length === size) { return buf; }\n  if (buf.subarray) { return buf.subarray(0, size); }\n  buf.length = size;\n  return buf;\n};\n\n\nvar fnTyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    if (src.subarray && dest.subarray) {\n      dest.set(src.subarray(src_offs, src_offs + len), dest_offs);\n      return;\n    }\n    // Fallback to ordinary array\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    var i, l, len, pos, chunk, result;\n\n    // calculate data length\n    len = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      len += chunks[i].length;\n    }\n\n    // join chunks\n    result = new Uint8Array(len);\n    pos = 0;\n    for (i = 0, l = chunks.length; i < l; i++) {\n      chunk = chunks[i];\n      result.set(chunk, pos);\n      pos += chunk.length;\n    }\n\n    return result;\n  }\n};\n\nvar fnUntyped = {\n  arraySet: function (dest, src, src_offs, len, dest_offs) {\n    for (var i = 0; i < len; i++) {\n      dest[dest_offs + i] = src[src_offs + i];\n    }\n  },\n  // Join array of chunks to single array.\n  flattenChunks: function (chunks) {\n    return [].concat.apply([], chunks);\n  }\n};\n\n\n// Enable/Disable typed arrays use, for testing\n//\nexports.setTyped = function (on) {\n  if (on) {\n    exports.Buf8  = Uint8Array;\n    exports.Buf16 = Uint16Array;\n    exports.Buf32 = Int32Array;\n    exports.assign(exports, fnTyped);\n  } else {\n    exports.Buf8  = Array;\n    exports.Buf16 = Array;\n    exports.Buf32 = Array;\n    exports.assign(exports, fnUntyped);\n  }\n};\n\nexports.setTyped(TYPED_OK);\n\n},{}],4:[function(require,module,exports){\n// String encode/decode helpers\n'use strict';\n\n\nvar utils = require('./common');\n\n\n// Quick check if we can use fast array to bin string conversion\n//\n// - apply(Array) can fail on Android 2.2\n// - apply(Uint8Array) can fail on iOS 5.1 Safary\n//\nvar STR_APPLY_OK = true;\nvar STR_APPLY_UIA_OK = true;\n\ntry { String.fromCharCode.apply(null, [ 0 ]); } catch (__) { STR_APPLY_OK = false; }\ntry { String.fromCharCode.apply(null, new Uint8Array(1)); } catch (__) { STR_APPLY_UIA_OK = false; }\n\n\n// Table with utf8 lengths (calculated by first byte of sequence)\n// Note, that 5 & 6-byte values and some 4-byte values can not be represented in JS,\n// because max possible codepoint is 0x10ffff\nvar _utf8len = new utils.Buf8(256);\nfor (var q = 0; q < 256; q++) {\n  _utf8len[q] = (q >= 252 ? 6 : q >= 248 ? 5 : q >= 240 ? 4 : q >= 224 ? 3 : q >= 192 ? 2 : 1);\n}\n_utf8len[254] = _utf8len[254] = 1; // Invalid sequence start\n\n\n// convert string to array (typed, when possible)\nexports.string2buf = function (str) {\n  var buf, c, c2, m_pos, i, str_len = str.length, buf_len = 0;\n\n  // count binary size\n  for (m_pos = 0; m_pos < str_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    buf_len += c < 0x80 ? 1 : c < 0x800 ? 2 : c < 0x10000 ? 3 : 4;\n  }\n\n  // allocate buffer\n  buf = new utils.Buf8(buf_len);\n\n  // convert\n  for (i = 0, m_pos = 0; i < buf_len; m_pos++) {\n    c = str.charCodeAt(m_pos);\n    if ((c & 0xfc00) === 0xd800 && (m_pos + 1 < str_len)) {\n      c2 = str.charCodeAt(m_pos + 1);\n      if ((c2 & 0xfc00) === 0xdc00) {\n        c = 0x10000 + ((c - 0xd800) << 10) + (c2 - 0xdc00);\n        m_pos++;\n      }\n    }\n    if (c < 0x80) {\n      /* one byte */\n      buf[i++] = c;\n    } else if (c < 0x800) {\n      /* two bytes */\n      buf[i++] = 0xC0 | (c >>> 6);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else if (c < 0x10000) {\n      /* three bytes */\n      buf[i++] = 0xE0 | (c >>> 12);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    } else {\n      /* four bytes */\n      buf[i++] = 0xf0 | (c >>> 18);\n      buf[i++] = 0x80 | (c >>> 12 & 0x3f);\n      buf[i++] = 0x80 | (c >>> 6 & 0x3f);\n      buf[i++] = 0x80 | (c & 0x3f);\n    }\n  }\n\n  return buf;\n};\n\n// Helper (used in 2 places)\nfunction buf2binstring(buf, len) {\n  // use fallback for big arrays to avoid stack overflow\n  if (len < 65537) {\n    if ((buf.subarray && STR_APPLY_UIA_OK) || (!buf.subarray && STR_APPLY_OK)) {\n      return String.fromCharCode.apply(null, utils.shrinkBuf(buf, len));\n    }\n  }\n\n  var result = '';\n  for (var i = 0; i < len; i++) {\n    result += String.fromCharCode(buf[i]);\n  }\n  return result;\n}\n\n\n// Convert byte array to binary string\nexports.buf2binstring = function (buf) {\n  return buf2binstring(buf, buf.length);\n};\n\n\n// Convert binary string (typed, when possible)\nexports.binstring2buf = function (str) {\n  var buf = new utils.Buf8(str.length);\n  for (var i = 0, len = buf.length; i < len; i++) {\n    buf[i] = str.charCodeAt(i);\n  }\n  return buf;\n};\n\n\n// convert array to string\nexports.buf2string = function (buf, max) {\n  var i, out, c, c_len;\n  var len = max || buf.length;\n\n  // Reserve max possible length (2 words per char)\n  // NB: by unknown reasons, Array is significantly faster for\n  //     String.fromCharCode.apply than Uint16Array.\n  var utf16buf = new Array(len * 2);\n\n  for (out = 0, i = 0; i < len;) {\n    c = buf[i++];\n    // quick process ascii\n    if (c < 0x80) { utf16buf[out++] = c; continue; }\n\n    c_len = _utf8len[c];\n    // skip 5 & 6 byte codes\n    if (c_len > 4) { utf16buf[out++] = 0xfffd; i += c_len - 1; continue; }\n\n    // apply mask on first byte\n    c &= c_len === 2 ? 0x1f : c_len === 3 ? 0x0f : 0x07;\n    // join the rest\n    while (c_len > 1 && i < len) {\n      c = (c << 6) | (buf[i++] & 0x3f);\n      c_len--;\n    }\n\n    // terminated by end of string?\n    if (c_len > 1) { utf16buf[out++] = 0xfffd; continue; }\n\n    if (c < 0x10000) {\n      utf16buf[out++] = c;\n    } else {\n      c -= 0x10000;\n      utf16buf[out++] = 0xd800 | ((c >> 10) & 0x3ff);\n      utf16buf[out++] = 0xdc00 | (c & 0x3ff);\n    }\n  }\n\n  return buf2binstring(utf16buf, out);\n};\n\n\n// Calculate max possible position in utf8 buffer,\n// that will not break sequence. If that's not possible\n// - (very small limits) return max size as is.\n//\n// buf[] - utf8 bytes array\n// max   - length limit (mandatory);\nexports.utf8border = function (buf, max) {\n  var pos;\n\n  max = max || buf.length;\n  if (max > buf.length) { max = buf.length; }\n\n  // go back from last position, until start of sequence found\n  pos = max - 1;\n  while (pos >= 0 && (buf[pos] & 0xC0) === 0x80) { pos--; }\n\n  // Fuckup - very small and broken sequence,\n  // return max, because we should return something anyway.\n  if (pos < 0) { return max; }\n\n  // If we came to start of buffer - that means vuffer is too small,\n  // return max too.\n  if (pos === 0) { return max; }\n\n  return (pos + _utf8len[buf[pos]] > max) ? pos : max;\n};\n\n},{\"./common\":3}],5:[function(require,module,exports){\n'use strict';\n\n// Note: adler32 takes 12% for level 0 and 2% for level 6.\n// It doesn't worth to make additional optimizationa as in original.\n// Small size is preferable.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction adler32(adler, buf, len, pos) {\n  var s1 = (adler & 0xffff) |0,\n      s2 = ((adler >>> 16) & 0xffff) |0,\n      n = 0;\n\n  while (len !== 0) {\n    // Set limit ~ twice less than 5552, to keep\n    // s2 in 31-bits, because we force signed ints.\n    // in other case %= will fail.\n    n = len > 2000 ? 2000 : len;\n    len -= n;\n\n    do {\n      s1 = (s1 + buf[pos++]) |0;\n      s2 = (s2 + s1) |0;\n    } while (--n);\n\n    s1 %= 65521;\n    s2 %= 65521;\n  }\n\n  return (s1 | (s2 << 16)) |0;\n}\n\n\nmodule.exports = adler32;\n\n},{}],6:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n\n  /* Allowed flush values; see deflate() and inflate() below for details */\n  Z_NO_FLUSH:         0,\n  Z_PARTIAL_FLUSH:    1,\n  Z_SYNC_FLUSH:       2,\n  Z_FULL_FLUSH:       3,\n  Z_FINISH:           4,\n  Z_BLOCK:            5,\n  Z_TREES:            6,\n\n  /* Return codes for the compression/decompression functions. Negative values\n  * are errors, positive values are used for special but normal events.\n  */\n  Z_OK:               0,\n  Z_STREAM_END:       1,\n  Z_NEED_DICT:        2,\n  Z_ERRNO:           -1,\n  Z_STREAM_ERROR:    -2,\n  Z_DATA_ERROR:      -3,\n  //Z_MEM_ERROR:     -4,\n  Z_BUF_ERROR:       -5,\n  //Z_VERSION_ERROR: -6,\n\n  /* compression levels */\n  Z_NO_COMPRESSION:         0,\n  Z_BEST_SPEED:             1,\n  Z_BEST_COMPRESSION:       9,\n  Z_DEFAULT_COMPRESSION:   -1,\n\n\n  Z_FILTERED:               1,\n  Z_HUFFMAN_ONLY:           2,\n  Z_RLE:                    3,\n  Z_FIXED:                  4,\n  Z_DEFAULT_STRATEGY:       0,\n\n  /* Possible values of the data_type field (though see inflate()) */\n  Z_BINARY:                 0,\n  Z_TEXT:                   1,\n  //Z_ASCII:                1, // = Z_TEXT (deprecated)\n  Z_UNKNOWN:                2,\n\n  /* The deflate compression method */\n  Z_DEFLATED:               8\n  //Z_NULL:                 null // Use -1 or null inline, depending on var type\n};\n\n},{}],7:[function(require,module,exports){\n'use strict';\n\n// Note: we can't get significant speed boost here.\n// So write code to minimize size - no pregenerated tables\n// and array tools dependencies.\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// Use ordinary array, since untyped makes no boost here\nfunction makeTable() {\n  var c, table = [];\n\n  for (var n = 0; n < 256; n++) {\n    c = n;\n    for (var k = 0; k < 8; k++) {\n      c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));\n    }\n    table[n] = c;\n  }\n\n  return table;\n}\n\n// Create table on load. Just 255 signed longs. Not a problem.\nvar crcTable = makeTable();\n\n\nfunction crc32(crc, buf, len, pos) {\n  var t = crcTable,\n      end = pos + len;\n\n  crc ^= -1;\n\n  for (var i = pos; i < end; i++) {\n    crc = (crc >>> 8) ^ t[(crc ^ buf[i]) & 0xFF];\n  }\n\n  return (crc ^ (-1)); // >>> 0;\n}\n\n\nmodule.exports = crc32;\n\n},{}],8:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils   = require('../utils/common');\nvar trees   = require('./trees');\nvar adler32 = require('./adler32');\nvar crc32   = require('./crc32');\nvar msg     = require('./messages');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\nvar Z_NO_FLUSH      = 0;\nvar Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\nvar Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\n//var Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\n//var Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\n//var Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n\n/* compression levels */\n//var Z_NO_COMPRESSION      = 0;\n//var Z_BEST_SPEED          = 1;\n//var Z_BEST_COMPRESSION    = 9;\nvar Z_DEFAULT_COMPRESSION = -1;\n\n\nvar Z_FILTERED            = 1;\nvar Z_HUFFMAN_ONLY        = 2;\nvar Z_RLE                 = 3;\nvar Z_FIXED               = 4;\nvar Z_DEFAULT_STRATEGY    = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\n//var Z_BINARY              = 0;\n//var Z_TEXT                = 1;\n//var Z_ASCII               = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n/*============================================================================*/\n\n\nvar MAX_MEM_LEVEL = 9;\n/* Maximum value for memLevel in deflateInit2 */\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_MEM_LEVEL = 8;\n\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\nvar D_CODES       = 30;\n/* number of distance codes */\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\nvar MAX_BITS  = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar MIN_MATCH = 3;\nvar MAX_MATCH = 258;\nvar MIN_LOOKAHEAD = (MAX_MATCH + MIN_MATCH + 1);\n\nvar PRESET_DICT = 0x20;\n\nvar INIT_STATE = 42;\nvar EXTRA_STATE = 69;\nvar NAME_STATE = 73;\nvar COMMENT_STATE = 91;\nvar HCRC_STATE = 103;\nvar BUSY_STATE = 113;\nvar FINISH_STATE = 666;\n\nvar BS_NEED_MORE      = 1; /* block not completed, need more input or more output */\nvar BS_BLOCK_DONE     = 2; /* block flush performed */\nvar BS_FINISH_STARTED = 3; /* finish started, need only more output at next deflate */\nvar BS_FINISH_DONE    = 4; /* finish done, accept no more input or output */\n\nvar OS_CODE = 0x03; // Unix :) . Don't detect, use this default.\n\nfunction err(strm, errorCode) {\n  strm.msg = msg[errorCode];\n  return errorCode;\n}\n\nfunction rank(f) {\n  return ((f) << 1) - ((f) > 4 ? 9 : 0);\n}\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n\n/* =========================================================================\n * Flush as much pending output as possible. All deflate() output goes\n * through this function so some applications may wish to modify it\n * to avoid allocating a large strm->output buffer and copying into it.\n * (See also read_buf()).\n */\nfunction flush_pending(strm) {\n  var s = strm.state;\n\n  //_tr_flush_bits(s);\n  var len = s.pending;\n  if (len > strm.avail_out) {\n    len = strm.avail_out;\n  }\n  if (len === 0) { return; }\n\n  utils.arraySet(strm.output, s.pending_buf, s.pending_out, len, strm.next_out);\n  strm.next_out += len;\n  s.pending_out += len;\n  strm.total_out += len;\n  strm.avail_out -= len;\n  s.pending -= len;\n  if (s.pending === 0) {\n    s.pending_out = 0;\n  }\n}\n\n\nfunction flush_block_only(s, last) {\n  trees._tr_flush_block(s, (s.block_start >= 0 ? s.block_start : -1), s.strstart - s.block_start, last);\n  s.block_start = s.strstart;\n  flush_pending(s.strm);\n}\n\n\nfunction put_byte(s, b) {\n  s.pending_buf[s.pending++] = b;\n}\n\n\n/* =========================================================================\n * Put a short in the pending buffer. The 16-bit value is put in MSB order.\n * IN assertion: the stream state is correct and there is enough room in\n * pending_buf.\n */\nfunction putShortMSB(s, b) {\n//  put_byte(s, (Byte)(b >> 8));\n//  put_byte(s, (Byte)(b & 0xff));\n  s.pending_buf[s.pending++] = (b >>> 8) & 0xff;\n  s.pending_buf[s.pending++] = b & 0xff;\n}\n\n\n/* ===========================================================================\n * Read a new buffer from the current input stream, update the adler32\n * and total number of bytes read.  All deflate() input goes through\n * this function so some applications may wish to modify it to avoid\n * allocating a large strm->input buffer and copying from it.\n * (See also flush_pending()).\n */\nfunction read_buf(strm, buf, start, size) {\n  var len = strm.avail_in;\n\n  if (len > size) { len = size; }\n  if (len === 0) { return 0; }\n\n  strm.avail_in -= len;\n\n  // zmemcpy(buf, strm->next_in, len);\n  utils.arraySet(buf, strm.input, strm.next_in, len, start);\n  if (strm.state.wrap === 1) {\n    strm.adler = adler32(strm.adler, buf, len, start);\n  }\n\n  else if (strm.state.wrap === 2) {\n    strm.adler = crc32(strm.adler, buf, len, start);\n  }\n\n  strm.next_in += len;\n  strm.total_in += len;\n\n  return len;\n}\n\n\n/* ===========================================================================\n * Set match_start to the longest match starting at the given string and\n * return its length. Matches shorter or equal to prev_length are discarded,\n * in which case the result is equal to prev_length and match_start is\n * garbage.\n * IN assertions: cur_match is the head of the hash chain for the current\n *   string (strstart) and its distance is <= MAX_DIST, and prev_length >= 1\n * OUT assertion: the match length is not greater than s->lookahead.\n */\nfunction longest_match(s, cur_match) {\n  var chain_length = s.max_chain_length;      /* max hash chain length */\n  var scan = s.strstart; /* current string */\n  var match;                       /* matched string */\n  var len;                           /* length of current match */\n  var best_len = s.prev_length;              /* best match length so far */\n  var nice_match = s.nice_match;             /* stop if match long enough */\n  var limit = (s.strstart > (s.w_size - MIN_LOOKAHEAD)) ?\n      s.strstart - (s.w_size - MIN_LOOKAHEAD) : 0/*NIL*/;\n\n  var _win = s.window; // shortcut\n\n  var wmask = s.w_mask;\n  var prev  = s.prev;\n\n  /* Stop when cur_match becomes <= limit. To simplify the code,\n   * we prevent matches with the string of window index 0.\n   */\n\n  var strend = s.strstart + MAX_MATCH;\n  var scan_end1  = _win[scan + best_len - 1];\n  var scan_end   = _win[scan + best_len];\n\n  /* The code is optimized for HASH_BITS >= 8 and MAX_MATCH-2 multiple of 16.\n   * It is easy to get rid of this optimization if necessary.\n   */\n  // Assert(s->hash_bits >= 8 && MAX_MATCH == 258, \"Code too clever\");\n\n  /* Do not waste too much time if we already have a good match: */\n  if (s.prev_length >= s.good_match) {\n    chain_length >>= 2;\n  }\n  /* Do not look for matches beyond the end of the input. This is necessary\n   * to make deflate deterministic.\n   */\n  if (nice_match > s.lookahead) { nice_match = s.lookahead; }\n\n  // Assert((ulg)s->strstart <= s->window_size-MIN_LOOKAHEAD, \"need lookahead\");\n\n  do {\n    // Assert(cur_match < s->strstart, \"no future\");\n    match = cur_match;\n\n    /* Skip to next match if the match length cannot increase\n     * or if the match length is less than 2.  Note that the checks below\n     * for insufficient lookahead only occur occasionally for performance\n     * reasons.  Therefore uninitialized memory will be accessed, and\n     * conditional jumps will be made that depend on those values.\n     * However the length of the match is limited to the lookahead, so\n     * the output of deflate is not affected by the uninitialized values.\n     */\n\n    if (_win[match + best_len]     !== scan_end  ||\n        _win[match + best_len - 1] !== scan_end1 ||\n        _win[match]                !== _win[scan] ||\n        _win[++match]              !== _win[scan + 1]) {\n      continue;\n    }\n\n    /* The check at best_len-1 can be removed because it will be made\n     * again later. (This heuristic is not always a win.)\n     * It is not necessary to compare scan[2] and match[2] since they\n     * are always equal when the other bytes match, given that\n     * the hash keys are equal and that HASH_BITS >= 8.\n     */\n    scan += 2;\n    match++;\n    // Assert(*scan == *match, \"match[2]?\");\n\n    /* We check for insufficient lookahead only every 8th comparison;\n     * the 256th check will be made at strstart+258.\n     */\n    do {\n      /*jshint noempty:false*/\n    } while (_win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             _win[++scan] === _win[++match] && _win[++scan] === _win[++match] &&\n             scan < strend);\n\n    // Assert(scan <= s->window+(unsigned)(s->window_size-1), \"wild scan\");\n\n    len = MAX_MATCH - (strend - scan);\n    scan = strend - MAX_MATCH;\n\n    if (len > best_len) {\n      s.match_start = cur_match;\n      best_len = len;\n      if (len >= nice_match) {\n        break;\n      }\n      scan_end1  = _win[scan + best_len - 1];\n      scan_end   = _win[scan + best_len];\n    }\n  } while ((cur_match = prev[cur_match & wmask]) > limit && --chain_length !== 0);\n\n  if (best_len <= s.lookahead) {\n    return best_len;\n  }\n  return s.lookahead;\n}\n\n\n/* ===========================================================================\n * Fill the window when the lookahead becomes insufficient.\n * Updates strstart and lookahead.\n *\n * IN assertion: lookahead < MIN_LOOKAHEAD\n * OUT assertions: strstart <= window_size-MIN_LOOKAHEAD\n *    At least one byte has been read, or avail_in == 0; reads are\n *    performed for at least two bytes (required for the zip translate_eol\n *    option -- not supported here).\n */\nfunction fill_window(s) {\n  var _w_size = s.w_size;\n  var p, n, m, more, str;\n\n  //Assert(s->lookahead < MIN_LOOKAHEAD, \"already enough lookahead\");\n\n  do {\n    more = s.window_size - s.lookahead - s.strstart;\n\n    // JS ints have 32 bit, block below not needed\n    /* Deal with !@#$% 64K limit: */\n    //if (sizeof(int) <= 2) {\n    //    if (more == 0 && s->strstart == 0 && s->lookahead == 0) {\n    //        more = wsize;\n    //\n    //  } else if (more == (unsigned)(-1)) {\n    //        /* Very unlikely, but possible on 16 bit machine if\n    //         * strstart == 0 && lookahead == 1 (input done a byte at time)\n    //         */\n    //        more--;\n    //    }\n    //}\n\n\n    /* If the window is almost full and there is insufficient lookahead,\n     * move the upper half to the lower one to make room in the upper half.\n     */\n    if (s.strstart >= _w_size + (_w_size - MIN_LOOKAHEAD)) {\n\n      utils.arraySet(s.window, s.window, _w_size, _w_size, 0);\n      s.match_start -= _w_size;\n      s.strstart -= _w_size;\n      /* we now have strstart >= MAX_DIST */\n      s.block_start -= _w_size;\n\n      /* Slide the hash table (could be avoided with 32 bit values\n       at the expense of memory usage). We slide even when level == 0\n       to keep the hash table consistent if we switch back to level > 0\n       later. (Using level 0 permanently is not an optimal usage of\n       zlib, so we don't care about this pathological case.)\n       */\n\n      n = s.hash_size;\n      p = n;\n      do {\n        m = s.head[--p];\n        s.head[p] = (m >= _w_size ? m - _w_size : 0);\n      } while (--n);\n\n      n = _w_size;\n      p = n;\n      do {\n        m = s.prev[--p];\n        s.prev[p] = (m >= _w_size ? m - _w_size : 0);\n        /* If n is not on any hash chain, prev[n] is garbage but\n         * its value will never be used.\n         */\n      } while (--n);\n\n      more += _w_size;\n    }\n    if (s.strm.avail_in === 0) {\n      break;\n    }\n\n    /* If there was no sliding:\n     *    strstart <= WSIZE+MAX_DIST-1 && lookahead <= MIN_LOOKAHEAD - 1 &&\n     *    more == window_size - lookahead - strstart\n     * => more >= window_size - (MIN_LOOKAHEAD-1 + WSIZE + MAX_DIST-1)\n     * => more >= window_size - 2*WSIZE + 2\n     * In the BIG_MEM or MMAP case (not yet supported),\n     *   window_size == input_size + MIN_LOOKAHEAD  &&\n     *   strstart + s->lookahead <= input_size => more >= MIN_LOOKAHEAD.\n     * Otherwise, window_size == 2*WSIZE so more >= 2.\n     * If there was sliding, more >= WSIZE. So in all cases, more >= 2.\n     */\n    //Assert(more >= 2, \"more < 2\");\n    n = read_buf(s.strm, s.window, s.strstart + s.lookahead, more);\n    s.lookahead += n;\n\n    /* Initialize the hash value now that we have some input: */\n    if (s.lookahead + s.insert >= MIN_MATCH) {\n      str = s.strstart - s.insert;\n      s.ins_h = s.window[str];\n\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + 1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + 1]) & s.hash_mask;\n//#if MIN_MATCH != 3\n//        Call update_hash() MIN_MATCH-3 more times\n//#endif\n      while (s.insert) {\n        /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n        s.prev[str & s.w_mask] = s.head[s.ins_h];\n        s.head[s.ins_h] = str;\n        str++;\n        s.insert--;\n        if (s.lookahead + s.insert < MIN_MATCH) {\n          break;\n        }\n      }\n    }\n    /* If the whole input has less than MIN_MATCH bytes, ins_h is garbage,\n     * but this is not important since only literal bytes will be emitted.\n     */\n\n  } while (s.lookahead < MIN_LOOKAHEAD && s.strm.avail_in !== 0);\n\n  /* If the WIN_INIT bytes after the end of the current data have never been\n   * written, then zero those bytes in order to avoid memory check reports of\n   * the use of uninitialized (or uninitialised as Julian writes) bytes by\n   * the longest match routines.  Update the high water mark for the next\n   * time through here.  WIN_INIT is set to MAX_MATCH since the longest match\n   * routines allow scanning to strstart + MAX_MATCH, ignoring lookahead.\n   */\n//  if (s.high_water < s.window_size) {\n//    var curr = s.strstart + s.lookahead;\n//    var init = 0;\n//\n//    if (s.high_water < curr) {\n//      /* Previous high water mark below current data -- zero WIN_INIT\n//       * bytes or up to end of window, whichever is less.\n//       */\n//      init = s.window_size - curr;\n//      if (init > WIN_INIT)\n//        init = WIN_INIT;\n//      zmemzero(s->window + curr, (unsigned)init);\n//      s->high_water = curr + init;\n//    }\n//    else if (s->high_water < (ulg)curr + WIN_INIT) {\n//      /* High water mark at or above current data, but below current data\n//       * plus WIN_INIT -- zero out to current data plus WIN_INIT, or up\n//       * to end of window, whichever is less.\n//       */\n//      init = (ulg)curr + WIN_INIT - s->high_water;\n//      if (init > s->window_size - s->high_water)\n//        init = s->window_size - s->high_water;\n//      zmemzero(s->window + s->high_water, (unsigned)init);\n//      s->high_water += init;\n//    }\n//  }\n//\n//  Assert((ulg)s->strstart <= s->window_size - MIN_LOOKAHEAD,\n//    \"not enough room for search\");\n}\n\n/* ===========================================================================\n * Copy without compression as much as possible from the input stream, return\n * the current block state.\n * This function does not insert new strings in the dictionary since\n * uncompressible data is probably not useful. This function is used\n * only for the level=0 compression option.\n * NOTE: this function should be optimized to avoid extra copying from\n * window to pending_buf.\n */\nfunction deflate_stored(s, flush) {\n  /* Stored blocks are limited to 0xffff bytes, pending_buf is limited\n   * to pending_buf_size, and each stored block has a 5 byte header:\n   */\n  var max_block_size = 0xffff;\n\n  if (max_block_size > s.pending_buf_size - 5) {\n    max_block_size = s.pending_buf_size - 5;\n  }\n\n  /* Copy as much as possible from input to output: */\n  for (;;) {\n    /* Fill the window as much as possible: */\n    if (s.lookahead <= 1) {\n\n      //Assert(s->strstart < s->w_size+MAX_DIST(s) ||\n      //  s->block_start >= (long)s->w_size, \"slide too late\");\n//      if (!(s.strstart < s.w_size + (s.w_size - MIN_LOOKAHEAD) ||\n//        s.block_start >= s.w_size)) {\n//        throw  new Error(\"slide too late\");\n//      }\n\n      fill_window(s);\n      if (s.lookahead === 0 && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n\n      if (s.lookahead === 0) {\n        break;\n      }\n      /* flush the current block */\n    }\n    //Assert(s->block_start >= 0L, \"block gone\");\n//    if (s.block_start < 0) throw new Error(\"block gone\");\n\n    s.strstart += s.lookahead;\n    s.lookahead = 0;\n\n    /* Emit a stored block if pending_buf will be full: */\n    var max_start = s.block_start + max_block_size;\n\n    if (s.strstart === 0 || s.strstart >= max_start) {\n      /* strstart == 0 is possible when wraparound on 16-bit machine */\n      s.lookahead = s.strstart - max_start;\n      s.strstart = max_start;\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n\n\n    }\n    /* Flush if we may have to slide, otherwise block_start may become\n     * negative and the data will be gone:\n     */\n    if (s.strstart - s.block_start >= (s.w_size - MIN_LOOKAHEAD)) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n\n  s.insert = 0;\n\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n\n  if (s.strstart > s.block_start) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_NEED_MORE;\n}\n\n/* ===========================================================================\n * Compress as much as possible from the input stream, return the current\n * block state.\n * This function does not perform lazy evaluation of matches and inserts\n * new strings in the dictionary only for unmatched strings or for short\n * matches. It is used only for the fast compression options.\n */\nfunction deflate_fast(s, flush) {\n  var hash_head;        /* head of the hash chain */\n  var bflush;           /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) {\n        break; /* flush the current block */\n      }\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     * At this point we have always match_length < MIN_MATCH\n     */\n    if (hash_head !== 0/*NIL*/ && ((s.strstart - hash_head) <= (s.w_size - MIN_LOOKAHEAD))) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n    }\n    if (s.match_length >= MIN_MATCH) {\n      // check_match(s, s.strstart, s.match_start, s.match_length); // for debug only\n\n      /*** _tr_tally_dist(s, s.strstart - s.match_start,\n                     s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, s.strstart - s.match_start, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n\n      /* Insert new strings in the hash table only if the match length\n       * is not too large. This saves time but degrades compression.\n       */\n      if (s.match_length <= s.max_lazy_match/*max_insert_length*/ && s.lookahead >= MIN_MATCH) {\n        s.match_length--; /* string at strstart already in table */\n        do {\n          s.strstart++;\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n          /* strstart never exceeds WSIZE-MAX_MATCH, so there are\n           * always MIN_MATCH bytes ahead.\n           */\n        } while (--s.match_length !== 0);\n        s.strstart++;\n      } else\n      {\n        s.strstart += s.match_length;\n        s.match_length = 0;\n        s.ins_h = s.window[s.strstart];\n        /* UPDATE_HASH(s, s.ins_h, s.window[s.strstart+1]); */\n        s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + 1]) & s.hash_mask;\n\n//#if MIN_MATCH != 3\n//                Call UPDATE_HASH() MIN_MATCH-3 more times\n//#endif\n        /* If lookahead < MIN_MATCH, ins_h is garbage, but it does not\n         * matter since it will be recomputed at next deflate call.\n         */\n      }\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s.window[s.strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = ((s.strstart < (MIN_MATCH - 1)) ? s.strstart : MIN_MATCH - 1);\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * Same as above, but achieves better compression. We use a lazy\n * evaluation for matches: a match is finally adopted only if there is\n * no better match at the next window position.\n */\nfunction deflate_slow(s, flush) {\n  var hash_head;          /* head of hash chain */\n  var bflush;              /* set if current block must be flushed */\n\n  var max_insert;\n\n  /* Process the input block. */\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the next match, plus MIN_MATCH bytes to insert the\n     * string following the next match.\n     */\n    if (s.lookahead < MIN_LOOKAHEAD) {\n      fill_window(s);\n      if (s.lookahead < MIN_LOOKAHEAD && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* Insert the string window[strstart .. strstart+2] in the\n     * dictionary, and set hash_head to the head of the hash chain:\n     */\n    hash_head = 0/*NIL*/;\n    if (s.lookahead >= MIN_MATCH) {\n      /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n      hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n      s.head[s.ins_h] = s.strstart;\n      /***/\n    }\n\n    /* Find the longest match, discarding those <= prev_length.\n     */\n    s.prev_length = s.match_length;\n    s.prev_match = s.match_start;\n    s.match_length = MIN_MATCH - 1;\n\n    if (hash_head !== 0/*NIL*/ && s.prev_length < s.max_lazy_match &&\n        s.strstart - hash_head <= (s.w_size - MIN_LOOKAHEAD)/*MAX_DIST(s)*/) {\n      /* To simplify the code, we prevent matches with the string\n       * of window index 0 (in particular we have to avoid a match\n       * of the string with itself at the start of the input file).\n       */\n      s.match_length = longest_match(s, hash_head);\n      /* longest_match() sets match_start */\n\n      if (s.match_length <= 5 &&\n         (s.strategy === Z_FILTERED || (s.match_length === MIN_MATCH && s.strstart - s.match_start > 4096/*TOO_FAR*/))) {\n\n        /* If prev_match is also MIN_MATCH, match_start is garbage\n         * but we will ignore the current match anyway.\n         */\n        s.match_length = MIN_MATCH - 1;\n      }\n    }\n    /* If there was a match at the previous step and the current\n     * match is not better, output the previous match:\n     */\n    if (s.prev_length >= MIN_MATCH && s.match_length <= s.prev_length) {\n      max_insert = s.strstart + s.lookahead - MIN_MATCH;\n      /* Do not insert strings in hash table beyond this. */\n\n      //check_match(s, s.strstart-1, s.prev_match, s.prev_length);\n\n      /***_tr_tally_dist(s, s.strstart - 1 - s.prev_match,\n                     s.prev_length - MIN_MATCH, bflush);***/\n      bflush = trees._tr_tally(s, s.strstart - 1 - s.prev_match, s.prev_length - MIN_MATCH);\n      /* Insert in hash table all strings up to the end of the match.\n       * strstart-1 and strstart are already inserted. If there is not\n       * enough lookahead, the last two strings are not inserted in\n       * the hash table.\n       */\n      s.lookahead -= s.prev_length - 1;\n      s.prev_length -= 2;\n      do {\n        if (++s.strstart <= max_insert) {\n          /*** INSERT_STRING(s, s.strstart, hash_head); ***/\n          s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[s.strstart + MIN_MATCH - 1]) & s.hash_mask;\n          hash_head = s.prev[s.strstart & s.w_mask] = s.head[s.ins_h];\n          s.head[s.ins_h] = s.strstart;\n          /***/\n        }\n      } while (--s.prev_length !== 0);\n      s.match_available = 0;\n      s.match_length = MIN_MATCH - 1;\n      s.strstart++;\n\n      if (bflush) {\n        /*** FLUSH_BLOCK(s, 0); ***/\n        flush_block_only(s, false);\n        if (s.strm.avail_out === 0) {\n          return BS_NEED_MORE;\n        }\n        /***/\n      }\n\n    } else if (s.match_available) {\n      /* If there was no match at the previous position, output a\n       * single literal. If there was a match but the current match\n       * is longer, truncate the previous match to a single literal.\n       */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n      /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n      if (bflush) {\n        /*** FLUSH_BLOCK_ONLY(s, 0) ***/\n        flush_block_only(s, false);\n        /***/\n      }\n      s.strstart++;\n      s.lookahead--;\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n    } else {\n      /* There is no previous match to compare with, wait for\n       * the next step to decide.\n       */\n      s.match_available = 1;\n      s.strstart++;\n      s.lookahead--;\n    }\n  }\n  //Assert (flush != Z_NO_FLUSH, \"no flush?\");\n  if (s.match_available) {\n    //Tracevv((stderr,\"%c\", s->window[s->strstart-1]));\n    /*** _tr_tally_lit(s, s.window[s.strstart-1], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart - 1]);\n\n    s.match_available = 0;\n  }\n  s.insert = s.strstart < MIN_MATCH - 1 ? s.strstart : MIN_MATCH - 1;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n\n  return BS_BLOCK_DONE;\n}\n\n\n/* ===========================================================================\n * For Z_RLE, simply look for runs of bytes, generate matches only of distance\n * one.  Do not maintain a hash table.  (It will be regenerated if this run of\n * deflate switches away from Z_RLE.)\n */\nfunction deflate_rle(s, flush) {\n  var bflush;            /* set if current block must be flushed */\n  var prev;              /* byte at distance one to match */\n  var scan, strend;      /* scan goes up to strend for length of run */\n\n  var _win = s.window;\n\n  for (;;) {\n    /* Make sure that we always have enough lookahead, except\n     * at the end of the input file. We need MAX_MATCH bytes\n     * for the longest run, plus one for the unrolled loop.\n     */\n    if (s.lookahead <= MAX_MATCH) {\n      fill_window(s);\n      if (s.lookahead <= MAX_MATCH && flush === Z_NO_FLUSH) {\n        return BS_NEED_MORE;\n      }\n      if (s.lookahead === 0) { break; } /* flush the current block */\n    }\n\n    /* See how many times the previous byte repeats */\n    s.match_length = 0;\n    if (s.lookahead >= MIN_MATCH && s.strstart > 0) {\n      scan = s.strstart - 1;\n      prev = _win[scan];\n      if (prev === _win[++scan] && prev === _win[++scan] && prev === _win[++scan]) {\n        strend = s.strstart + MAX_MATCH;\n        do {\n          /*jshint noempty:false*/\n        } while (prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 prev === _win[++scan] && prev === _win[++scan] &&\n                 scan < strend);\n        s.match_length = MAX_MATCH - (strend - scan);\n        if (s.match_length > s.lookahead) {\n          s.match_length = s.lookahead;\n        }\n      }\n      //Assert(scan <= s->window+(uInt)(s->window_size-1), \"wild scan\");\n    }\n\n    /* Emit match if have run of MIN_MATCH or longer, else emit literal */\n    if (s.match_length >= MIN_MATCH) {\n      //check_match(s, s.strstart, s.strstart - 1, s.match_length);\n\n      /*** _tr_tally_dist(s, 1, s.match_length - MIN_MATCH, bflush); ***/\n      bflush = trees._tr_tally(s, 1, s.match_length - MIN_MATCH);\n\n      s.lookahead -= s.match_length;\n      s.strstart += s.match_length;\n      s.match_length = 0;\n    } else {\n      /* No match, output a literal byte */\n      //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n      /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n      bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n\n      s.lookahead--;\n      s.strstart++;\n    }\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* ===========================================================================\n * For Z_HUFFMAN_ONLY, do not look for matches.  Do not maintain a hash table.\n * (It will be regenerated if this run of deflate switches away from Huffman.)\n */\nfunction deflate_huff(s, flush) {\n  var bflush;             /* set if current block must be flushed */\n\n  for (;;) {\n    /* Make sure that we have a literal to write. */\n    if (s.lookahead === 0) {\n      fill_window(s);\n      if (s.lookahead === 0) {\n        if (flush === Z_NO_FLUSH) {\n          return BS_NEED_MORE;\n        }\n        break;      /* flush the current block */\n      }\n    }\n\n    /* Output a literal byte */\n    s.match_length = 0;\n    //Tracevv((stderr,\"%c\", s->window[s->strstart]));\n    /*** _tr_tally_lit(s, s.window[s.strstart], bflush); ***/\n    bflush = trees._tr_tally(s, 0, s.window[s.strstart]);\n    s.lookahead--;\n    s.strstart++;\n    if (bflush) {\n      /*** FLUSH_BLOCK(s, 0); ***/\n      flush_block_only(s, false);\n      if (s.strm.avail_out === 0) {\n        return BS_NEED_MORE;\n      }\n      /***/\n    }\n  }\n  s.insert = 0;\n  if (flush === Z_FINISH) {\n    /*** FLUSH_BLOCK(s, 1); ***/\n    flush_block_only(s, true);\n    if (s.strm.avail_out === 0) {\n      return BS_FINISH_STARTED;\n    }\n    /***/\n    return BS_FINISH_DONE;\n  }\n  if (s.last_lit) {\n    /*** FLUSH_BLOCK(s, 0); ***/\n    flush_block_only(s, false);\n    if (s.strm.avail_out === 0) {\n      return BS_NEED_MORE;\n    }\n    /***/\n  }\n  return BS_BLOCK_DONE;\n}\n\n/* Values for max_lazy_match, good_match and max_chain_length, depending on\n * the desired pack level (0..9). The values given below have been tuned to\n * exclude worst case performance for pathological files. Better values may be\n * found for specific files.\n */\nfunction Config(good_length, max_lazy, nice_length, max_chain, func) {\n  this.good_length = good_length;\n  this.max_lazy = max_lazy;\n  this.nice_length = nice_length;\n  this.max_chain = max_chain;\n  this.func = func;\n}\n\nvar configuration_table;\n\nconfiguration_table = [\n  /*      good lazy nice chain */\n  new Config(0, 0, 0, 0, deflate_stored),          /* 0 store only */\n  new Config(4, 4, 8, 4, deflate_fast),            /* 1 max speed, no lazy matches */\n  new Config(4, 5, 16, 8, deflate_fast),           /* 2 */\n  new Config(4, 6, 32, 32, deflate_fast),          /* 3 */\n\n  new Config(4, 4, 16, 16, deflate_slow),          /* 4 lazy matches */\n  new Config(8, 16, 32, 32, deflate_slow),         /* 5 */\n  new Config(8, 16, 128, 128, deflate_slow),       /* 6 */\n  new Config(8, 32, 128, 256, deflate_slow),       /* 7 */\n  new Config(32, 128, 258, 1024, deflate_slow),    /* 8 */\n  new Config(32, 258, 258, 4096, deflate_slow)     /* 9 max compression */\n];\n\n\n/* ===========================================================================\n * Initialize the \"longest match\" routines for a new zlib stream\n */\nfunction lm_init(s) {\n  s.window_size = 2 * s.w_size;\n\n  /*** CLEAR_HASH(s); ***/\n  zero(s.head); // Fill with NIL (= 0);\n\n  /* Set the default configuration parameters:\n   */\n  s.max_lazy_match = configuration_table[s.level].max_lazy;\n  s.good_match = configuration_table[s.level].good_length;\n  s.nice_match = configuration_table[s.level].nice_length;\n  s.max_chain_length = configuration_table[s.level].max_chain;\n\n  s.strstart = 0;\n  s.block_start = 0;\n  s.lookahead = 0;\n  s.insert = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  s.ins_h = 0;\n}\n\n\nfunction DeflateState() {\n  this.strm = null;            /* pointer back to this zlib stream */\n  this.status = 0;            /* as the name implies */\n  this.pending_buf = null;      /* output still pending */\n  this.pending_buf_size = 0;  /* size of pending_buf */\n  this.pending_out = 0;       /* next pending byte to output to the stream */\n  this.pending = 0;           /* nb of bytes in the pending buffer */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.gzhead = null;         /* gzip header information to write */\n  this.gzindex = 0;           /* where in extra, name, or comment */\n  this.method = Z_DEFLATED; /* can only be DEFLATED */\n  this.last_flush = -1;   /* value of flush param for previous deflate call */\n\n  this.w_size = 0;  /* LZ77 window size (32K by default) */\n  this.w_bits = 0;  /* log2(w_size)  (8..16) */\n  this.w_mask = 0;  /* w_size - 1 */\n\n  this.window = null;\n  /* Sliding window. Input bytes are read into the second half of the window,\n   * and move to the first half later to keep a dictionary of at least wSize\n   * bytes. With this organization, matches are limited to a distance of\n   * wSize-MAX_MATCH bytes, but this ensures that IO is always\n   * performed with a length multiple of the block size.\n   */\n\n  this.window_size = 0;\n  /* Actual size of window: 2*wSize, except when the user input buffer\n   * is directly used as sliding window.\n   */\n\n  this.prev = null;\n  /* Link to older string with same hash index. To limit the size of this\n   * array to 64K, this link is maintained only for the last 32K strings.\n   * An index in this array is thus a window index modulo 32K.\n   */\n\n  this.head = null;   /* Heads of the hash chains or NIL. */\n\n  this.ins_h = 0;       /* hash index of string to be inserted */\n  this.hash_size = 0;   /* number of elements in hash table */\n  this.hash_bits = 0;   /* log2(hash_size) */\n  this.hash_mask = 0;   /* hash_size-1 */\n\n  this.hash_shift = 0;\n  /* Number of bits by which ins_h must be shifted at each input\n   * step. It must be such that after MIN_MATCH steps, the oldest\n   * byte no longer takes part in the hash key, that is:\n   *   hash_shift * MIN_MATCH >= hash_bits\n   */\n\n  this.block_start = 0;\n  /* Window position at the beginning of the current output block. Gets\n   * negative when the window is moved backwards.\n   */\n\n  this.match_length = 0;      /* length of best match */\n  this.prev_match = 0;        /* previous match */\n  this.match_available = 0;   /* set if previous match exists */\n  this.strstart = 0;          /* start of string to insert */\n  this.match_start = 0;       /* start of matching string */\n  this.lookahead = 0;         /* number of valid bytes ahead in window */\n\n  this.prev_length = 0;\n  /* Length of the best match at previous step. Matches not greater than this\n   * are discarded. This is used in the lazy match evaluation.\n   */\n\n  this.max_chain_length = 0;\n  /* To speed up deflation, hash chains are never searched beyond this\n   * length.  A higher limit improves compression ratio but degrades the\n   * speed.\n   */\n\n  this.max_lazy_match = 0;\n  /* Attempt to find a better match only when the current match is strictly\n   * smaller than this value. This mechanism is used only for compression\n   * levels >= 4.\n   */\n  // That's alias to max_lazy_match, don't use directly\n  //this.max_insert_length = 0;\n  /* Insert new strings in the hash table only if the match length is not\n   * greater than this length. This saves time but degrades compression.\n   * max_insert_length is used only for compression levels <= 3.\n   */\n\n  this.level = 0;     /* compression level (1..9) */\n  this.strategy = 0;  /* favor or force Huffman coding*/\n\n  this.good_match = 0;\n  /* Use a faster search when the previous match is longer than this */\n\n  this.nice_match = 0; /* Stop searching when current match exceeds this */\n\n              /* used by trees.c: */\n\n  /* Didn't use ct_data typedef below to suppress compiler warning */\n\n  // struct ct_data_s dyn_ltree[HEAP_SIZE];   /* literal and length tree */\n  // struct ct_data_s dyn_dtree[2*D_CODES+1]; /* distance tree */\n  // struct ct_data_s bl_tree[2*BL_CODES+1];  /* Huffman tree for bit lengths */\n\n  // Use flat array of DOUBLE size, with interleaved fata,\n  // because JS does not support effective\n  this.dyn_ltree  = new utils.Buf16(HEAP_SIZE * 2);\n  this.dyn_dtree  = new utils.Buf16((2 * D_CODES + 1) * 2);\n  this.bl_tree    = new utils.Buf16((2 * BL_CODES + 1) * 2);\n  zero(this.dyn_ltree);\n  zero(this.dyn_dtree);\n  zero(this.bl_tree);\n\n  this.l_desc   = null;         /* desc. for literal tree */\n  this.d_desc   = null;         /* desc. for distance tree */\n  this.bl_desc  = null;         /* desc. for bit length tree */\n\n  //ush bl_count[MAX_BITS+1];\n  this.bl_count = new utils.Buf16(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  //int heap[2*L_CODES+1];      /* heap used to build the Huffman trees */\n  this.heap = new utils.Buf16(2 * L_CODES + 1);  /* heap used to build the Huffman trees */\n  zero(this.heap);\n\n  this.heap_len = 0;               /* number of elements in the heap */\n  this.heap_max = 0;               /* element of largest frequency */\n  /* The sons of heap[n] are heap[2*n] and heap[2*n+1]. heap[0] is not used.\n   * The same heap array is used to build all trees.\n   */\n\n  this.depth = new utils.Buf16(2 * L_CODES + 1); //uch depth[2*L_CODES+1];\n  zero(this.depth);\n  /* Depth of each subtree used as tie breaker for trees of equal frequency\n   */\n\n  this.l_buf = 0;          /* buffer index for literals or lengths */\n\n  this.lit_bufsize = 0;\n  /* Size of match buffer for literals/lengths.  There are 4 reasons for\n   * limiting lit_bufsize to 64K:\n   *   - frequencies can be kept in 16 bit counters\n   *   - if compression is not successful for the first block, all input\n   *     data is still in the window so we can still emit a stored block even\n   *     when input comes from standard input.  (This can also be done for\n   *     all blocks if lit_bufsize is not greater than 32K.)\n   *   - if compression is not successful for a file smaller than 64K, we can\n   *     even emit a stored file instead of a stored block (saving 5 bytes).\n   *     This is applicable only for zip (not gzip or zlib).\n   *   - creating new Huffman trees less frequently may not provide fast\n   *     adaptation to changes in the input data statistics. (Take for\n   *     example a binary file with poorly compressible code followed by\n   *     a highly compressible string table.) Smaller buffer sizes give\n   *     fast adaptation but have of course the overhead of transmitting\n   *     trees more frequently.\n   *   - I can't count above 4\n   */\n\n  this.last_lit = 0;      /* running index in l_buf */\n\n  this.d_buf = 0;\n  /* Buffer index for distances. To simplify the code, d_buf and l_buf have\n   * the same number of elements. To use different lengths, an extra flag\n   * array would be necessary.\n   */\n\n  this.opt_len = 0;       /* bit length of current block with optimal trees */\n  this.static_len = 0;    /* bit length of current block with static trees */\n  this.matches = 0;       /* number of string matches in current block */\n  this.insert = 0;        /* bytes at end of window left to insert */\n\n\n  this.bi_buf = 0;\n  /* Output buffer. bits are inserted starting at the bottom (least\n   * significant bits).\n   */\n  this.bi_valid = 0;\n  /* Number of valid bits in bi_buf.  All bits above the last valid bit\n   * are always zero.\n   */\n\n  // Used for window memory init. We safely ignore it for JS. That makes\n  // sense only for pointers and memory check tools.\n  //this.high_water = 0;\n  /* High water mark offset in window for initialized bytes -- bytes above\n   * this are set to zero in order to avoid memory check warnings when\n   * longest match routines access bytes past the input.  This is then\n   * updated to the new high water mark.\n   */\n}\n\n\nfunction deflateResetKeep(strm) {\n  var s;\n\n  if (!strm || !strm.state) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.total_in = strm.total_out = 0;\n  strm.data_type = Z_UNKNOWN;\n\n  s = strm.state;\n  s.pending = 0;\n  s.pending_out = 0;\n\n  if (s.wrap < 0) {\n    s.wrap = -s.wrap;\n    /* was made negative by deflate(..., Z_FINISH); */\n  }\n  s.status = (s.wrap ? INIT_STATE : BUSY_STATE);\n  strm.adler = (s.wrap === 2) ?\n    0  // crc32(0, Z_NULL, 0)\n  :\n    1; // adler32(0, Z_NULL, 0)\n  s.last_flush = Z_NO_FLUSH;\n  trees._tr_init(s);\n  return Z_OK;\n}\n\n\nfunction deflateReset(strm) {\n  var ret = deflateResetKeep(strm);\n  if (ret === Z_OK) {\n    lm_init(strm.state);\n  }\n  return ret;\n}\n\n\nfunction deflateSetHeader(strm, head) {\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  if (strm.state.wrap !== 2) { return Z_STREAM_ERROR; }\n  strm.state.gzhead = head;\n  return Z_OK;\n}\n\n\nfunction deflateInit2(strm, level, method, windowBits, memLevel, strategy) {\n  if (!strm) { // === Z_NULL\n    return Z_STREAM_ERROR;\n  }\n  var wrap = 1;\n\n  if (level === Z_DEFAULT_COMPRESSION) {\n    level = 6;\n  }\n\n  if (windowBits < 0) { /* suppress zlib wrapper */\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n\n  else if (windowBits > 15) {\n    wrap = 2;           /* write gzip wrapper instead */\n    windowBits -= 16;\n  }\n\n\n  if (memLevel < 1 || memLevel > MAX_MEM_LEVEL || method !== Z_DEFLATED ||\n    windowBits < 8 || windowBits > 15 || level < 0 || level > 9 ||\n    strategy < 0 || strategy > Z_FIXED) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n\n  if (windowBits === 8) {\n    windowBits = 9;\n  }\n  /* until 256-byte window bug fixed */\n\n  var s = new DeflateState();\n\n  strm.state = s;\n  s.strm = strm;\n\n  s.wrap = wrap;\n  s.gzhead = null;\n  s.w_bits = windowBits;\n  s.w_size = 1 << s.w_bits;\n  s.w_mask = s.w_size - 1;\n\n  s.hash_bits = memLevel + 7;\n  s.hash_size = 1 << s.hash_bits;\n  s.hash_mask = s.hash_size - 1;\n  s.hash_shift = ~~((s.hash_bits + MIN_MATCH - 1) / MIN_MATCH);\n\n  s.window = new utils.Buf8(s.w_size * 2);\n  s.head = new utils.Buf16(s.hash_size);\n  s.prev = new utils.Buf16(s.w_size);\n\n  // Don't need mem init magic for JS.\n  //s.high_water = 0;  /* nothing written to s->window yet */\n\n  s.lit_bufsize = 1 << (memLevel + 6); /* 16K elements by default */\n\n  s.pending_buf_size = s.lit_bufsize * 4;\n\n  //overlay = (ushf *) ZALLOC(strm, s->lit_bufsize, sizeof(ush)+2);\n  //s->pending_buf = (uchf *) overlay;\n  s.pending_buf = new utils.Buf8(s.pending_buf_size);\n\n  // It is offset from `s.pending_buf` (size is `s.lit_bufsize * 2`)\n  //s->d_buf = overlay + s->lit_bufsize/sizeof(ush);\n  s.d_buf = 1 * s.lit_bufsize;\n\n  //s->l_buf = s->pending_buf + (1+sizeof(ush))*s->lit_bufsize;\n  s.l_buf = (1 + 2) * s.lit_bufsize;\n\n  s.level = level;\n  s.strategy = strategy;\n  s.method = method;\n\n  return deflateReset(strm);\n}\n\nfunction deflateInit(strm, level) {\n  return deflateInit2(strm, level, Z_DEFLATED, MAX_WBITS, DEF_MEM_LEVEL, Z_DEFAULT_STRATEGY);\n}\n\n\nfunction deflate(strm, flush) {\n  var old_flush, s;\n  var beg, val; // for gzip header write only\n\n  if (!strm || !strm.state ||\n    flush > Z_BLOCK || flush < 0) {\n    return strm ? err(strm, Z_STREAM_ERROR) : Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n\n  if (!strm.output ||\n      (!strm.input && strm.avail_in !== 0) ||\n      (s.status === FINISH_STATE && flush !== Z_FINISH)) {\n    return err(strm, (strm.avail_out === 0) ? Z_BUF_ERROR : Z_STREAM_ERROR);\n  }\n\n  s.strm = strm; /* just in case */\n  old_flush = s.last_flush;\n  s.last_flush = flush;\n\n  /* Write the header */\n  if (s.status === INIT_STATE) {\n\n    if (s.wrap === 2) { // GZIP header\n      strm.adler = 0;  //crc32(0L, Z_NULL, 0);\n      put_byte(s, 31);\n      put_byte(s, 139);\n      put_byte(s, 8);\n      if (!s.gzhead) { // s->gzhead == Z_NULL\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, 0);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, OS_CODE);\n        s.status = BUSY_STATE;\n      }\n      else {\n        put_byte(s, (s.gzhead.text ? 1 : 0) +\n                    (s.gzhead.hcrc ? 2 : 0) +\n                    (!s.gzhead.extra ? 0 : 4) +\n                    (!s.gzhead.name ? 0 : 8) +\n                    (!s.gzhead.comment ? 0 : 16)\n                );\n        put_byte(s, s.gzhead.time & 0xff);\n        put_byte(s, (s.gzhead.time >> 8) & 0xff);\n        put_byte(s, (s.gzhead.time >> 16) & 0xff);\n        put_byte(s, (s.gzhead.time >> 24) & 0xff);\n        put_byte(s, s.level === 9 ? 2 :\n                    (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2 ?\n                     4 : 0));\n        put_byte(s, s.gzhead.os & 0xff);\n        if (s.gzhead.extra && s.gzhead.extra.length) {\n          put_byte(s, s.gzhead.extra.length & 0xff);\n          put_byte(s, (s.gzhead.extra.length >> 8) & 0xff);\n        }\n        if (s.gzhead.hcrc) {\n          strm.adler = crc32(strm.adler, s.pending_buf, s.pending, 0);\n        }\n        s.gzindex = 0;\n        s.status = EXTRA_STATE;\n      }\n    }\n    else // DEFLATE header\n    {\n      var header = (Z_DEFLATED + ((s.w_bits - 8) << 4)) << 8;\n      var level_flags = -1;\n\n      if (s.strategy >= Z_HUFFMAN_ONLY || s.level < 2) {\n        level_flags = 0;\n      } else if (s.level < 6) {\n        level_flags = 1;\n      } else if (s.level === 6) {\n        level_flags = 2;\n      } else {\n        level_flags = 3;\n      }\n      header |= (level_flags << 6);\n      if (s.strstart !== 0) { header |= PRESET_DICT; }\n      header += 31 - (header % 31);\n\n      s.status = BUSY_STATE;\n      putShortMSB(s, header);\n\n      /* Save the adler32 of the preset dictionary: */\n      if (s.strstart !== 0) {\n        putShortMSB(s, strm.adler >>> 16);\n        putShortMSB(s, strm.adler & 0xffff);\n      }\n      strm.adler = 1; // adler32(0L, Z_NULL, 0);\n    }\n  }\n\n//#ifdef GZIP\n  if (s.status === EXTRA_STATE) {\n    if (s.gzhead.extra/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n\n      while (s.gzindex < (s.gzhead.extra.length & 0xffff)) {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            break;\n          }\n        }\n        put_byte(s, s.gzhead.extra[s.gzindex] & 0xff);\n        s.gzindex++;\n      }\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (s.gzindex === s.gzhead.extra.length) {\n        s.gzindex = 0;\n        s.status = NAME_STATE;\n      }\n    }\n    else {\n      s.status = NAME_STATE;\n    }\n  }\n  if (s.status === NAME_STATE) {\n    if (s.gzhead.name/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.name.length) {\n          val = s.gzhead.name.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.gzindex = 0;\n        s.status = COMMENT_STATE;\n      }\n    }\n    else {\n      s.status = COMMENT_STATE;\n    }\n  }\n  if (s.status === COMMENT_STATE) {\n    if (s.gzhead.comment/* != Z_NULL*/) {\n      beg = s.pending;  /* start of bytes to update crc */\n      //int val;\n\n      do {\n        if (s.pending === s.pending_buf_size) {\n          if (s.gzhead.hcrc && s.pending > beg) {\n            strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n          }\n          flush_pending(strm);\n          beg = s.pending;\n          if (s.pending === s.pending_buf_size) {\n            val = 1;\n            break;\n          }\n        }\n        // JS specific: little magic to add zero terminator to end of string\n        if (s.gzindex < s.gzhead.comment.length) {\n          val = s.gzhead.comment.charCodeAt(s.gzindex++) & 0xff;\n        } else {\n          val = 0;\n        }\n        put_byte(s, val);\n      } while (val !== 0);\n\n      if (s.gzhead.hcrc && s.pending > beg) {\n        strm.adler = crc32(strm.adler, s.pending_buf, s.pending - beg, beg);\n      }\n      if (val === 0) {\n        s.status = HCRC_STATE;\n      }\n    }\n    else {\n      s.status = HCRC_STATE;\n    }\n  }\n  if (s.status === HCRC_STATE) {\n    if (s.gzhead.hcrc) {\n      if (s.pending + 2 > s.pending_buf_size) {\n        flush_pending(strm);\n      }\n      if (s.pending + 2 <= s.pending_buf_size) {\n        put_byte(s, strm.adler & 0xff);\n        put_byte(s, (strm.adler >> 8) & 0xff);\n        strm.adler = 0; //crc32(0L, Z_NULL, 0);\n        s.status = BUSY_STATE;\n      }\n    }\n    else {\n      s.status = BUSY_STATE;\n    }\n  }\n//#endif\n\n  /* Flush as much pending output as possible */\n  if (s.pending !== 0) {\n    flush_pending(strm);\n    if (strm.avail_out === 0) {\n      /* Since avail_out is 0, deflate will be called again with\n       * more output space, but possibly with both pending and\n       * avail_in equal to zero. There won't be anything to do,\n       * but this is not an error situation so make sure we\n       * return OK instead of BUF_ERROR at next call of deflate:\n       */\n      s.last_flush = -1;\n      return Z_OK;\n    }\n\n    /* Make sure there is something to do and avoid duplicate consecutive\n     * flushes. For repeated and useless calls with Z_FINISH, we keep\n     * returning Z_STREAM_END instead of Z_BUF_ERROR.\n     */\n  } else if (strm.avail_in === 0 && rank(flush) <= rank(old_flush) &&\n    flush !== Z_FINISH) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* User must not provide more input after the first FINISH: */\n  if (s.status === FINISH_STATE && strm.avail_in !== 0) {\n    return err(strm, Z_BUF_ERROR);\n  }\n\n  /* Start a new block or continue the current one.\n   */\n  if (strm.avail_in !== 0 || s.lookahead !== 0 ||\n    (flush !== Z_NO_FLUSH && s.status !== FINISH_STATE)) {\n    var bstate = (s.strategy === Z_HUFFMAN_ONLY) ? deflate_huff(s, flush) :\n      (s.strategy === Z_RLE ? deflate_rle(s, flush) :\n        configuration_table[s.level].func(s, flush));\n\n    if (bstate === BS_FINISH_STARTED || bstate === BS_FINISH_DONE) {\n      s.status = FINISH_STATE;\n    }\n    if (bstate === BS_NEED_MORE || bstate === BS_FINISH_STARTED) {\n      if (strm.avail_out === 0) {\n        s.last_flush = -1;\n        /* avoid BUF_ERROR next call, see above */\n      }\n      return Z_OK;\n      /* If flush != Z_NO_FLUSH && avail_out == 0, the next call\n       * of deflate should use the same flush parameter to make sure\n       * that the flush is complete. So we don't have to output an\n       * empty block here, this will be done at next call. This also\n       * ensures that for a very small output buffer, we emit at most\n       * one empty block.\n       */\n    }\n    if (bstate === BS_BLOCK_DONE) {\n      if (flush === Z_PARTIAL_FLUSH) {\n        trees._tr_align(s);\n      }\n      else if (flush !== Z_BLOCK) { /* FULL_FLUSH or SYNC_FLUSH */\n\n        trees._tr_stored_block(s, 0, 0, false);\n        /* For a full flush, this empty block will be recognized\n         * as a special marker by inflate_sync().\n         */\n        if (flush === Z_FULL_FLUSH) {\n          /*** CLEAR_HASH(s); ***/             /* forget history */\n          zero(s.head); // Fill with NIL (= 0);\n\n          if (s.lookahead === 0) {\n            s.strstart = 0;\n            s.block_start = 0;\n            s.insert = 0;\n          }\n        }\n      }\n      flush_pending(strm);\n      if (strm.avail_out === 0) {\n        s.last_flush = -1; /* avoid BUF_ERROR at next call, see above */\n        return Z_OK;\n      }\n    }\n  }\n  //Assert(strm->avail_out > 0, \"bug2\");\n  //if (strm.avail_out <= 0) { throw new Error(\"bug2\");}\n\n  if (flush !== Z_FINISH) { return Z_OK; }\n  if (s.wrap <= 0) { return Z_STREAM_END; }\n\n  /* Write the trailer */\n  if (s.wrap === 2) {\n    put_byte(s, strm.adler & 0xff);\n    put_byte(s, (strm.adler >> 8) & 0xff);\n    put_byte(s, (strm.adler >> 16) & 0xff);\n    put_byte(s, (strm.adler >> 24) & 0xff);\n    put_byte(s, strm.total_in & 0xff);\n    put_byte(s, (strm.total_in >> 8) & 0xff);\n    put_byte(s, (strm.total_in >> 16) & 0xff);\n    put_byte(s, (strm.total_in >> 24) & 0xff);\n  }\n  else\n  {\n    putShortMSB(s, strm.adler >>> 16);\n    putShortMSB(s, strm.adler & 0xffff);\n  }\n\n  flush_pending(strm);\n  /* If avail_out is zero, the application will call deflate again\n   * to flush the rest.\n   */\n  if (s.wrap > 0) { s.wrap = -s.wrap; }\n  /* write the trailer only once! */\n  return s.pending !== 0 ? Z_OK : Z_STREAM_END;\n}\n\nfunction deflateEnd(strm) {\n  var status;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  status = strm.state.status;\n  if (status !== INIT_STATE &&\n    status !== EXTRA_STATE &&\n    status !== NAME_STATE &&\n    status !== COMMENT_STATE &&\n    status !== HCRC_STATE &&\n    status !== BUSY_STATE &&\n    status !== FINISH_STATE\n  ) {\n    return err(strm, Z_STREAM_ERROR);\n  }\n\n  strm.state = null;\n\n  return status === BUSY_STATE ? err(strm, Z_DATA_ERROR) : Z_OK;\n}\n\n\n/* =========================================================================\n * Initializes the compression dictionary from the given byte\n * sequence without producing any compressed output.\n */\nfunction deflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var s;\n  var str, n;\n  var wrap;\n  var avail;\n  var next;\n  var input;\n  var tmpDict;\n\n  if (!strm/*== Z_NULL*/ || !strm.state/*== Z_NULL*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  s = strm.state;\n  wrap = s.wrap;\n\n  if (wrap === 2 || (wrap === 1 && s.status !== INIT_STATE) || s.lookahead) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* when using zlib wrappers, compute Adler-32 for provided dictionary */\n  if (wrap === 1) {\n    /* adler32(strm->adler, dictionary, dictLength); */\n    strm.adler = adler32(strm.adler, dictionary, dictLength, 0);\n  }\n\n  s.wrap = 0;   /* avoid computing Adler-32 in read_buf */\n\n  /* if dictionary would fill window, just replace the history */\n  if (dictLength >= s.w_size) {\n    if (wrap === 0) {            /* already empty otherwise */\n      /*** CLEAR_HASH(s); ***/\n      zero(s.head); // Fill with NIL (= 0);\n      s.strstart = 0;\n      s.block_start = 0;\n      s.insert = 0;\n    }\n    /* use the tail */\n    // dictionary = dictionary.slice(dictLength - s.w_size);\n    tmpDict = new utils.Buf8(s.w_size);\n    utils.arraySet(tmpDict, dictionary, dictLength - s.w_size, s.w_size, 0);\n    dictionary = tmpDict;\n    dictLength = s.w_size;\n  }\n  /* insert dictionary into window and hash */\n  avail = strm.avail_in;\n  next = strm.next_in;\n  input = strm.input;\n  strm.avail_in = dictLength;\n  strm.next_in = 0;\n  strm.input = dictionary;\n  fill_window(s);\n  while (s.lookahead >= MIN_MATCH) {\n    str = s.strstart;\n    n = s.lookahead - (MIN_MATCH - 1);\n    do {\n      /* UPDATE_HASH(s, s->ins_h, s->window[str + MIN_MATCH-1]); */\n      s.ins_h = ((s.ins_h << s.hash_shift) ^ s.window[str + MIN_MATCH - 1]) & s.hash_mask;\n\n      s.prev[str & s.w_mask] = s.head[s.ins_h];\n\n      s.head[s.ins_h] = str;\n      str++;\n    } while (--n);\n    s.strstart = str;\n    s.lookahead = MIN_MATCH - 1;\n    fill_window(s);\n  }\n  s.strstart += s.lookahead;\n  s.block_start = s.strstart;\n  s.insert = s.lookahead;\n  s.lookahead = 0;\n  s.match_length = s.prev_length = MIN_MATCH - 1;\n  s.match_available = 0;\n  strm.next_in = next;\n  strm.input = input;\n  strm.avail_in = avail;\n  s.wrap = wrap;\n  return Z_OK;\n}\n\n\nexports.deflateInit = deflateInit;\nexports.deflateInit2 = deflateInit2;\nexports.deflateReset = deflateReset;\nexports.deflateResetKeep = deflateResetKeep;\nexports.deflateSetHeader = deflateSetHeader;\nexports.deflate = deflate;\nexports.deflateEnd = deflateEnd;\nexports.deflateSetDictionary = deflateSetDictionary;\nexports.deflateInfo = 'pako deflate (from Nodeca project)';\n\n/* Not implemented\nexports.deflateBound = deflateBound;\nexports.deflateCopy = deflateCopy;\nexports.deflateParams = deflateParams;\nexports.deflatePending = deflatePending;\nexports.deflatePrime = deflatePrime;\nexports.deflateTune = deflateTune;\n*/\n\n},{\"../utils/common\":3,\"./adler32\":5,\"./crc32\":7,\"./messages\":13,\"./trees\":14}],9:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction GZheader() {\n  /* true if compressed data believed to be text */\n  this.text       = 0;\n  /* modification time */\n  this.time       = 0;\n  /* extra flags (not used when writing a gzip file) */\n  this.xflags     = 0;\n  /* operating system */\n  this.os         = 0;\n  /* pointer to extra field or Z_NULL if none */\n  this.extra      = null;\n  /* extra field length (valid if extra != Z_NULL) */\n  this.extra_len  = 0; // Actually, we don't need it in JS,\n                       // but leave for few code modifications\n\n  //\n  // Setup limits is not necessary because in js we should not preallocate memory\n  // for inflate use constant limit in 65536 bytes\n  //\n\n  /* space at extra (only when reading header) */\n  // this.extra_max  = 0;\n  /* pointer to zero-terminated file name or Z_NULL */\n  this.name       = '';\n  /* space at name (only when reading header) */\n  // this.name_max   = 0;\n  /* pointer to zero-terminated comment or Z_NULL */\n  this.comment    = '';\n  /* space at comment (only when reading header) */\n  // this.comm_max   = 0;\n  /* true if there was or will be a header crc */\n  this.hcrc       = 0;\n  /* true when done reading gzip header (not used when writing a gzip file) */\n  this.done       = false;\n}\n\nmodule.exports = GZheader;\n\n},{}],10:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\n// See state defs from inflate.js\nvar BAD = 30;       /* got a data error -- remain here until reset */\nvar TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\n\n/*\n   Decode literal, length, and distance codes and write out the resulting\n   literal and match bytes until either not enough input or output is\n   available, an end-of-block is encountered, or a data error is encountered.\n   When large enough input and output buffers are supplied to inflate(), for\n   example, a 16K input buffer and a 64K output buffer, more than 95% of the\n   inflate execution time is spent in this routine.\n\n   Entry assumptions:\n\n        state.mode === LEN\n        strm.avail_in >= 6\n        strm.avail_out >= 258\n        start >= strm.avail_out\n        state.bits < 8\n\n   On return, state.mode is one of:\n\n        LEN -- ran out of enough output space or enough available input\n        TYPE -- reached end of block code, inflate() to interpret next block\n        BAD -- error in block data\n\n   Notes:\n\n    - The maximum input bits used by a length/distance pair is 15 bits for the\n      length code, 5 bits for the length extra, 15 bits for the distance code,\n      and 13 bits for the distance extra.  This totals 48 bits, or six bytes.\n      Therefore if strm.avail_in >= 6, then there is enough input to avoid\n      checking for available input while decoding.\n\n    - The maximum bytes that a single length/distance pair can output is 258\n      bytes, which is the maximum length that can be coded.  inflate_fast()\n      requires strm.avail_out >= 258 for each loop to avoid checking for\n      output space.\n */\nmodule.exports = function inflate_fast(strm, start) {\n  var state;\n  var _in;                    /* local strm.input */\n  var last;                   /* have enough input while in < last */\n  var _out;                   /* local strm.output */\n  var beg;                    /* inflate()'s initial strm.output */\n  var end;                    /* while out < end, enough space available */\n//#ifdef INFLATE_STRICT\n  var dmax;                   /* maximum distance from zlib header */\n//#endif\n  var wsize;                  /* window size or zero if not using window */\n  var whave;                  /* valid bytes in the window */\n  var wnext;                  /* window write index */\n  // Use `s_window` instead `window`, avoid conflict with instrumentation tools\n  var s_window;               /* allocated sliding window, if wsize != 0 */\n  var hold;                   /* local strm.hold */\n  var bits;                   /* local strm.bits */\n  var lcode;                  /* local strm.lencode */\n  var dcode;                  /* local strm.distcode */\n  var lmask;                  /* mask for first level of length codes */\n  var dmask;                  /* mask for first level of distance codes */\n  var here;                   /* retrieved table entry */\n  var op;                     /* code bits, operation, extra bits, or */\n                              /*  window position, window bytes to copy */\n  var len;                    /* match length, unused bytes */\n  var dist;                   /* match distance */\n  var from;                   /* where to copy match from */\n  var from_source;\n\n\n  var input, output; // JS specific, because we have no pointers\n\n  /* copy state to local variables */\n  state = strm.state;\n  //here = state.here;\n  _in = strm.next_in;\n  input = strm.input;\n  last = _in + (strm.avail_in - 5);\n  _out = strm.next_out;\n  output = strm.output;\n  beg = _out - (start - strm.avail_out);\n  end = _out + (strm.avail_out - 257);\n//#ifdef INFLATE_STRICT\n  dmax = state.dmax;\n//#endif\n  wsize = state.wsize;\n  whave = state.whave;\n  wnext = state.wnext;\n  s_window = state.window;\n  hold = state.hold;\n  bits = state.bits;\n  lcode = state.lencode;\n  dcode = state.distcode;\n  lmask = (1 << state.lenbits) - 1;\n  dmask = (1 << state.distbits) - 1;\n\n\n  /* decode literals and length/distances until end-of-block or not enough\n     input data or output space */\n\n  top:\n  do {\n    if (bits < 15) {\n      hold += input[_in++] << bits;\n      bits += 8;\n      hold += input[_in++] << bits;\n      bits += 8;\n    }\n\n    here = lcode[hold & lmask];\n\n    dolen:\n    for (;;) { // Goto emulation\n      op = here >>> 24/*here.bits*/;\n      hold >>>= op;\n      bits -= op;\n      op = (here >>> 16) & 0xff/*here.op*/;\n      if (op === 0) {                          /* literal */\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        output[_out++] = here & 0xffff/*here.val*/;\n      }\n      else if (op & 16) {                     /* length base */\n        len = here & 0xffff/*here.val*/;\n        op &= 15;                           /* number of extra bits */\n        if (op) {\n          if (bits < op) {\n            hold += input[_in++] << bits;\n            bits += 8;\n          }\n          len += hold & ((1 << op) - 1);\n          hold >>>= op;\n          bits -= op;\n        }\n        //Tracevv((stderr, \"inflate:         length %u\\n\", len));\n        if (bits < 15) {\n          hold += input[_in++] << bits;\n          bits += 8;\n          hold += input[_in++] << bits;\n          bits += 8;\n        }\n        here = dcode[hold & dmask];\n\n        dodist:\n        for (;;) { // goto emulation\n          op = here >>> 24/*here.bits*/;\n          hold >>>= op;\n          bits -= op;\n          op = (here >>> 16) & 0xff/*here.op*/;\n\n          if (op & 16) {                      /* distance base */\n            dist = here & 0xffff/*here.val*/;\n            op &= 15;                       /* number of extra bits */\n            if (bits < op) {\n              hold += input[_in++] << bits;\n              bits += 8;\n              if (bits < op) {\n                hold += input[_in++] << bits;\n                bits += 8;\n              }\n            }\n            dist += hold & ((1 << op) - 1);\n//#ifdef INFLATE_STRICT\n            if (dist > dmax) {\n              strm.msg = 'invalid distance too far back';\n              state.mode = BAD;\n              break top;\n            }\n//#endif\n            hold >>>= op;\n            bits -= op;\n            //Tracevv((stderr, \"inflate:         distance %u\\n\", dist));\n            op = _out - beg;                /* max distance in output */\n            if (dist > op) {                /* see if copy from window */\n              op = dist - op;               /* distance back in window */\n              if (op > whave) {\n                if (state.sane) {\n                  strm.msg = 'invalid distance too far back';\n                  state.mode = BAD;\n                  break top;\n                }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//                if (len <= op - whave) {\n//                  do {\n//                    output[_out++] = 0;\n//                  } while (--len);\n//                  continue top;\n//                }\n//                len -= op - whave;\n//                do {\n//                  output[_out++] = 0;\n//                } while (--op > whave);\n//                if (op === 0) {\n//                  from = _out - dist;\n//                  do {\n//                    output[_out++] = output[from++];\n//                  } while (--len);\n//                  continue top;\n//                }\n//#endif\n              }\n              from = 0; // window index\n              from_source = s_window;\n              if (wnext === 0) {           /* very common case */\n                from += wsize - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              else if (wnext < op) {      /* wrap around window */\n                from += wsize + wnext - op;\n                op -= wnext;\n                if (op < len) {         /* some from end of window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = 0;\n                  if (wnext < len) {  /* some from start of window */\n                    op = wnext;\n                    len -= op;\n                    do {\n                      output[_out++] = s_window[from++];\n                    } while (--op);\n                    from = _out - dist;      /* rest from output */\n                    from_source = output;\n                  }\n                }\n              }\n              else {                      /* contiguous in window */\n                from += wnext - op;\n                if (op < len) {         /* some from window */\n                  len -= op;\n                  do {\n                    output[_out++] = s_window[from++];\n                  } while (--op);\n                  from = _out - dist;  /* rest from output */\n                  from_source = output;\n                }\n              }\n              while (len > 2) {\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                output[_out++] = from_source[from++];\n                len -= 3;\n              }\n              if (len) {\n                output[_out++] = from_source[from++];\n                if (len > 1) {\n                  output[_out++] = from_source[from++];\n                }\n              }\n            }\n            else {\n               from = _out - dist;    \n\n               /// this is faster with chrome ~60, but still slower than with older chromes\n               if (dist==1)\n               {\n                  var tmp = output[from];\n                  output.fill(tmp,_out,_out+len);\n                  _out += len;\n               }\n               else if (dist>len)\n               {\n                  output.set(output.subarray(from,from+len),_out);\n                  _out += len;\n               }\n               else \n               {\n                  for (var ee = 0; ee < len; ee++)   \n                     output[_out++] = output[from++];\n               }\n               len = 1;\n \n                    /* \n               // very slow with chrome ~60 \n               do {  \n                  output[_out++] = output[from++];\n                  output[_out++] = output[from++];\n                  output[_out++] = output[from++];\n                  len -= 3;\n                } while (len > 2);\n                if (len) {\n                  output[_out++] = output[from++];\n                  if (len > 1) {\n                    output[_out++] = output[from++];\n                  }\n                }\n                */\n              }\n          }\n          else if ((op & 64) === 0) {          /* 2nd level distance code */\n            here = dcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n            continue dodist;\n          }\n          else {\n            strm.msg = 'invalid distance code';\n            state.mode = BAD;\n            break top;\n          }\n\n          break; // need to emulate goto via \"continue\"\n        }\n      }\n      else if ((op & 64) === 0) {              /* 2nd level length code */\n        here = lcode[(here & 0xffff)/*here.val*/ + (hold & ((1 << op) - 1))];\n        continue dolen;\n      }\n      else if (op & 32) {                     /* end-of-block */\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.mode = TYPE;\n        break top;\n      }\n      else {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break top;\n      }\n\n      break; // need to emulate goto via \"continue\"\n    }\n  } while (_in < last && _out < end);\n\n  /* return unused bytes (on entry, bits < 8, so in won't go too far back) */\n  len = bits >> 3;\n  _in -= len;\n  bits -= len << 3;\n  hold &= (1 << bits) - 1;\n\n  /* update state and return */\n  strm.next_in = _in;\n  strm.next_out = _out;\n  strm.avail_in = (_in < last ? 5 + (last - _in) : 5 - (_in - last));\n  strm.avail_out = (_out < end ? 257 + (end - _out) : 257 - (_out - end));\n  state.hold = hold;\n  state.bits = bits;\n  return;\n};\n\n},{}],11:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils         = require('../utils/common');\nvar adler32       = require('./adler32');\nvar crc32         = require('./crc32');\nvar inflate_fast  = require('./inffast');\nvar inflate_table = require('./inftrees');\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n/* Allowed flush values; see deflate() and inflate() below for details */\n//var Z_NO_FLUSH      = 0;\n//var Z_PARTIAL_FLUSH = 1;\n//var Z_SYNC_FLUSH    = 2;\n//var Z_FULL_FLUSH    = 3;\nvar Z_FINISH        = 4;\nvar Z_BLOCK         = 5;\nvar Z_TREES         = 6;\n\n\n/* Return codes for the compression/decompression functions. Negative values\n * are errors, positive values are used for special but normal events.\n */\nvar Z_OK            = 0;\nvar Z_STREAM_END    = 1;\nvar Z_NEED_DICT     = 2;\n//var Z_ERRNO         = -1;\nvar Z_STREAM_ERROR  = -2;\nvar Z_DATA_ERROR    = -3;\nvar Z_MEM_ERROR     = -4;\nvar Z_BUF_ERROR     = -5;\n//var Z_VERSION_ERROR = -6;\n\n/* The deflate compression method */\nvar Z_DEFLATED  = 8;\n\n\n/* STATES ====================================================================*/\n/* ===========================================================================*/\n\n\nvar    HEAD = 1;       /* i: waiting for magic header */\nvar    FLAGS = 2;      /* i: waiting for method and flags (gzip) */\nvar    TIME = 3;       /* i: waiting for modification time (gzip) */\nvar    OS = 4;         /* i: waiting for extra flags and operating system (gzip) */\nvar    EXLEN = 5;      /* i: waiting for extra length (gzip) */\nvar    EXTRA = 6;      /* i: waiting for extra bytes (gzip) */\nvar    NAME = 7;       /* i: waiting for end of file name (gzip) */\nvar    COMMENT = 8;    /* i: waiting for end of comment (gzip) */\nvar    HCRC = 9;       /* i: waiting for header crc (gzip) */\nvar    DICTID = 10;    /* i: waiting for dictionary check value */\nvar    DICT = 11;      /* waiting for inflateSetDictionary() call */\nvar        TYPE = 12;      /* i: waiting for type bits, including last-flag bit */\nvar        TYPEDO = 13;    /* i: same, but skip check to exit inflate on new block */\nvar        STORED = 14;    /* i: waiting for stored size (length and complement) */\nvar        COPY_ = 15;     /* i/o: same as COPY below, but only first time in */\nvar        COPY = 16;      /* i/o: waiting for input or output to copy stored block */\nvar        TABLE = 17;     /* i: waiting for dynamic block table lengths */\nvar        LENLENS = 18;   /* i: waiting for code length code lengths */\nvar        CODELENS = 19;  /* i: waiting for length/lit and distance code lengths */\nvar            LEN_ = 20;      /* i: same as LEN below, but only first time in */\nvar            LEN = 21;       /* i: waiting for length/lit/eob code */\nvar            LENEXT = 22;    /* i: waiting for length extra bits */\nvar            DIST = 23;      /* i: waiting for distance code */\nvar            DISTEXT = 24;   /* i: waiting for distance extra bits */\nvar            MATCH = 25;     /* o: waiting for output space to copy string */\nvar            LIT = 26;       /* o: waiting for output space to write literal */\nvar    CHECK = 27;     /* i: waiting for 32-bit check value */\nvar    LENGTH = 28;    /* i: waiting for 32-bit length (gzip) */\nvar    DONE = 29;      /* finished check, done -- remain here until reset */\nvar    BAD = 30;       /* got a data error -- remain here until reset */\nvar    MEM = 31;       /* got an inflate() memory error -- remain here until reset */\nvar    SYNC = 32;      /* looking for synchronization bytes to restart inflate() */\n\n/* ===========================================================================*/\n\n\n\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH =  (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar MAX_WBITS = 15;\n/* 32K LZ77 window */\nvar DEF_WBITS = MAX_WBITS;\n\n\nfunction zswap32(q) {\n  return  (((q >>> 24) & 0xff) +\n          ((q >>> 8) & 0xff00) +\n          ((q & 0xff00) << 8) +\n          ((q & 0xff) << 24));\n}\n\n\nfunction InflateState() {\n  this.mode = 0;             /* current inflate mode */\n  this.last = false;          /* true if processing last block */\n  this.wrap = 0;              /* bit 0 true for zlib, bit 1 true for gzip */\n  this.havedict = false;      /* true if dictionary provided */\n  this.flags = 0;             /* gzip header method and flags (0 if zlib) */\n  this.dmax = 0;              /* zlib header max distance (INFLATE_STRICT) */\n  this.check = 0;             /* protected copy of check value */\n  this.total = 0;             /* protected copy of output count */\n  // TODO: may be {}\n  this.head = null;           /* where to save gzip header information */\n\n  /* sliding window */\n  this.wbits = 0;             /* log base 2 of requested window size */\n  this.wsize = 0;             /* window size or zero if not using window */\n  this.whave = 0;             /* valid bytes in the window */\n  this.wnext = 0;             /* window write index */\n  this.window = null;         /* allocated sliding window, if needed */\n\n  /* bit accumulator */\n  this.hold = 0;              /* input bit accumulator */\n  this.bits = 0;              /* number of bits in \"in\" */\n\n  /* for string and stored block copying */\n  this.length = 0;            /* literal or length of data to copy */\n  this.offset = 0;            /* distance back to copy string from */\n\n  /* for table and code decoding */\n  this.extra = 0;             /* extra bits needed */\n\n  /* fixed and dynamic code tables */\n  this.lencode = null;          /* starting table for length/literal codes */\n  this.distcode = null;         /* starting table for distance codes */\n  this.lenbits = 0;           /* index bits for lencode */\n  this.distbits = 0;          /* index bits for distcode */\n\n  /* dynamic table building */\n  this.ncode = 0;             /* number of code length code lengths */\n  this.nlen = 0;              /* number of length code lengths */\n  this.ndist = 0;             /* number of distance code lengths */\n  this.have = 0;              /* number of code lengths in lens[] */\n  this.next = null;              /* next available space in codes[] */\n\n  this.lens = new utils.Buf16(320); /* temporary storage for code lengths */\n  this.work = new utils.Buf16(288); /* work area for code table building */\n\n  /*\n   because we don't have pointers in js, we use lencode and distcode directly\n   as buffers so we don't need codes\n  */\n  //this.codes = new utils.Buf32(ENOUGH);       /* space for code tables */\n  this.lendyn = null;              /* dynamic table for length/literal codes (JS specific) */\n  this.distdyn = null;             /* dynamic table for distance codes (JS specific) */\n  this.sane = 0;                   /* if false, allow invalid distance too far */\n  this.back = 0;                   /* bits back of last unprocessed length/lit */\n  this.was = 0;                    /* initial length of match */\n}\n\nfunction inflateResetKeep(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  strm.total_in = strm.total_out = state.total = 0;\n  strm.msg = ''; /*Z_NULL*/\n  if (state.wrap) {       /* to support ill-conceived Java test suite */\n    strm.adler = state.wrap & 1;\n  }\n  state.mode = HEAD;\n  state.last = 0;\n  state.havedict = 0;\n  state.dmax = 32768;\n  state.head = null/*Z_NULL*/;\n  state.hold = 0;\n  state.bits = 0;\n  //state.lencode = state.distcode = state.next = state.codes;\n  state.lencode = state.lendyn = new utils.Buf32(ENOUGH_LENS);\n  state.distcode = state.distdyn = new utils.Buf32(ENOUGH_DISTS);\n\n  state.sane = 1;\n  state.back = -1;\n  //Tracev((stderr, \"inflate: reset\\n\"));\n  return Z_OK;\n}\n\nfunction inflateReset(strm) {\n  var state;\n\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  state.wsize = 0;\n  state.whave = 0;\n  state.wnext = 0;\n  return inflateResetKeep(strm);\n\n}\n\nfunction inflateReset2(strm, windowBits) {\n  var wrap;\n  var state;\n\n  /* get the state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  /* extract wrap request from windowBits parameter */\n  if (windowBits < 0) {\n    wrap = 0;\n    windowBits = -windowBits;\n  }\n  else {\n    wrap = (windowBits >> 4) + 1;\n    if (windowBits < 48) {\n      windowBits &= 15;\n    }\n  }\n\n  /* set number of window bits, free window if different */\n  if (windowBits && (windowBits < 8 || windowBits > 15)) {\n    return Z_STREAM_ERROR;\n  }\n  if (state.window !== null && state.wbits !== windowBits) {\n    state.window = null;\n  }\n\n  /* update state and reset the rest of it */\n  state.wrap = wrap;\n  state.wbits = windowBits;\n  return inflateReset(strm);\n}\n\nfunction inflateInit2(strm, windowBits) {\n  var ret;\n  var state;\n\n  if (!strm) { return Z_STREAM_ERROR; }\n  //strm.msg = Z_NULL;                 /* in case we return an error */\n\n  state = new InflateState();\n\n  //if (state === Z_NULL) return Z_MEM_ERROR;\n  //Tracev((stderr, \"inflate: allocated\\n\"));\n  strm.state = state;\n  state.window = null/*Z_NULL*/;\n  ret = inflateReset2(strm, windowBits);\n  if (ret !== Z_OK) {\n    strm.state = null/*Z_NULL*/;\n  }\n  return ret;\n}\n\nfunction inflateInit(strm) {\n  return inflateInit2(strm, DEF_WBITS);\n}\n\n\n/*\n Return state with length and distance decoding tables and index sizes set to\n fixed code decoding.  Normally this returns fixed tables from inffixed.h.\n If BUILDFIXED is defined, then instead this routine builds the tables the\n first time it's called, and returns those tables the first time and\n thereafter.  This reduces the size of the code by about 2K bytes, in\n exchange for a little execution time.  However, BUILDFIXED should not be\n used for threaded applications, since the rewriting of the tables and virgin\n may not be thread-safe.\n */\nvar virgin = true;\n\nvar lenfix, distfix; // We have no pointers in JS, so keep tables separate\n\nfunction fixedtables(state) {\n  /* build fixed huffman tables if first call (may not be thread safe) */\n  if (virgin) {\n    var sym;\n\n    lenfix = new utils.Buf32(512);\n    distfix = new utils.Buf32(32);\n\n    /* literal/length table */\n    sym = 0;\n    while (sym < 144) { state.lens[sym++] = 8; }\n    while (sym < 256) { state.lens[sym++] = 9; }\n    while (sym < 280) { state.lens[sym++] = 7; }\n    while (sym < 288) { state.lens[sym++] = 8; }\n\n    inflate_table(LENS,  state.lens, 0, 288, lenfix,   0, state.work, { bits: 9 });\n\n    /* distance table */\n    sym = 0;\n    while (sym < 32) { state.lens[sym++] = 5; }\n\n    inflate_table(DISTS, state.lens, 0, 32,   distfix, 0, state.work, { bits: 5 });\n\n    /* do this just once */\n    virgin = false;\n  }\n\n  state.lencode = lenfix;\n  state.lenbits = 9;\n  state.distcode = distfix;\n  state.distbits = 5;\n}\n\n\n/*\n Update the window with the last wsize (normally 32K) bytes written before\n returning.  If window does not exist yet, create it.  This is only called\n when a window is already in use, or when output has been written during this\n inflate call, but the end of the deflate stream has not been reached yet.\n It is also called to create a window for dictionary data when a dictionary\n is loaded.\n\n Providing output buffers larger than 32K to inflate() should provide a speed\n advantage, since only the last 32K of output is copied to the sliding window\n upon return from inflate(), and since all distances after the first 32K of\n output will fall in the output data, making match copies simpler and faster.\n The advantage may be dependent on the size of the processor's data caches.\n */\nfunction updatewindow(strm, src, end, copy) {\n  var dist;\n  var state = strm.state;\n\n  /* if it hasn't been done already, allocate space for the window */\n  if (state.window === null) {\n    state.wsize = 1 << state.wbits;\n    state.wnext = 0;\n    state.whave = 0;\n\n    state.window = new utils.Buf8(state.wsize);\n  }\n\n  /* copy state->wsize or less output bytes into the circular window */\n  if (copy >= state.wsize) {\n    utils.arraySet(state.window, src, end - state.wsize, state.wsize, 0);\n    state.wnext = 0;\n    state.whave = state.wsize;\n  }\n  else {\n    dist = state.wsize - state.wnext;\n    if (dist > copy) {\n      dist = copy;\n    }\n    //zmemcpy(state->window + state->wnext, end - copy, dist);\n    utils.arraySet(state.window, src, end - copy, dist, state.wnext);\n    copy -= dist;\n    if (copy) {\n      //zmemcpy(state->window, end - copy, copy);\n      utils.arraySet(state.window, src, end - copy, copy, 0);\n      state.wnext = copy;\n      state.whave = state.wsize;\n    }\n    else {\n      state.wnext += dist;\n      if (state.wnext === state.wsize) { state.wnext = 0; }\n      if (state.whave < state.wsize) { state.whave += dist; }\n    }\n  }\n  return 0;\n}\n\nfunction inflate(strm, flush) {\n  var state;\n  var input, output;          // input/output buffers\n  var next;                   /* next input INDEX */\n  var put;                    /* next output INDEX */\n  var have, left;             /* available input and output */\n  var hold;                   /* bit buffer */\n  var bits;                   /* bits in bit buffer */\n  var _in, _out;              /* save starting available input and output */\n  var copy;                   /* number of stored or match bytes to copy */\n  var from;                   /* where to copy match bytes from */\n  var from_source;\n  var here = 0;               /* current decoding table entry */\n  var here_bits, here_op, here_val; // paked \"here\" denormalized (JS specific)\n  //var last;                   /* parent table entry */\n  var last_bits, last_op, last_val; // paked \"last\" denormalized (JS specific)\n  var len;                    /* length to copy for repeats, bits to drop */\n  var ret;                    /* return code */\n  var hbuf = new utils.Buf8(4);    /* buffer for gzip header crc calculation */\n  var opts;\n\n\n\n\n  var n; // temporary var for NEED_BITS\n\n  var order = /* permutation of code lengths */\n    [ 16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\n  if (!strm || !strm.state || !strm.output ||\n      (!strm.input && strm.avail_in !== 0)) {\n    return Z_STREAM_ERROR;\n  }\n\n  state = strm.state;\n  if (state.mode === TYPE) { state.mode = TYPEDO; }    /* skip check */\n\n\n  //--- LOAD() ---\n  put = strm.next_out;\n  output = strm.output;\n  left = strm.avail_out;\n  next = strm.next_in;\n  input = strm.input;\n  have = strm.avail_in;\n  hold = state.hold;\n  bits = state.bits;\n  //---\n\n  _in = have;\n  _out = left;\n  ret = Z_OK;\n\n  inf_leave: // goto emulation\n  for (;;) {\n    switch (state.mode) {\n    case HEAD:\n      if (state.wrap === 0) {\n        state.mode = TYPEDO;\n        break;\n      }\n      //=== NEEDBITS(16);\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((state.wrap & 2) && hold === 0x8b1f) {  /* gzip header */\n        state.check = 0/*crc32(0L, Z_NULL, 0)*/;\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        state.mode = FLAGS;\n        break;\n      }\n      state.flags = 0;           /* expect zlib header */\n      if (state.head) {\n        state.head.done = false;\n      }\n      if (!(state.wrap & 1) ||   /* check if zlib header allowed */\n        (((hold & 0xff)/*BITS(8)*/ << 8) + (hold >> 8)) % 31) {\n        strm.msg = 'incorrect header check';\n        state.mode = BAD;\n        break;\n      }\n      if ((hold & 0x0f)/*BITS(4)*/ !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n      len = (hold & 0x0f)/*BITS(4)*/ + 8;\n      if (state.wbits === 0) {\n        state.wbits = len;\n      }\n      else if (len > state.wbits) {\n        strm.msg = 'invalid window size';\n        state.mode = BAD;\n        break;\n      }\n      state.dmax = 1 << len;\n      //Tracev((stderr, \"inflate:   zlib header ok\\n\"));\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = hold & 0x200 ? DICTID : TYPE;\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      break;\n    case FLAGS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.flags = hold;\n      if ((state.flags & 0xff) !== Z_DEFLATED) {\n        strm.msg = 'unknown compression method';\n        state.mode = BAD;\n        break;\n      }\n      if (state.flags & 0xe000) {\n        strm.msg = 'unknown header flags set';\n        state.mode = BAD;\n        break;\n      }\n      if (state.head) {\n        state.head.text = ((hold >> 8) & 1);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = TIME;\n      /* falls through */\n    case TIME:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.time = hold;\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC4(state.check, hold)\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        hbuf[2] = (hold >>> 16) & 0xff;\n        hbuf[3] = (hold >>> 24) & 0xff;\n        state.check = crc32(state.check, hbuf, 4, 0);\n        //===\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = OS;\n      /* falls through */\n    case OS:\n      //=== NEEDBITS(16); */\n      while (bits < 16) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if (state.head) {\n        state.head.xflags = (hold & 0xff);\n        state.head.os = (hold >> 8);\n      }\n      if (state.flags & 0x0200) {\n        //=== CRC2(state.check, hold);\n        hbuf[0] = hold & 0xff;\n        hbuf[1] = (hold >>> 8) & 0xff;\n        state.check = crc32(state.check, hbuf, 2, 0);\n        //===//\n      }\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = EXLEN;\n      /* falls through */\n    case EXLEN:\n      if (state.flags & 0x0400) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length = hold;\n        if (state.head) {\n          state.head.extra_len = hold;\n        }\n        if (state.flags & 0x0200) {\n          //=== CRC2(state.check, hold);\n          hbuf[0] = hold & 0xff;\n          hbuf[1] = (hold >>> 8) & 0xff;\n          state.check = crc32(state.check, hbuf, 2, 0);\n          //===//\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      else if (state.head) {\n        state.head.extra = null/*Z_NULL*/;\n      }\n      state.mode = EXTRA;\n      /* falls through */\n    case EXTRA:\n      if (state.flags & 0x0400) {\n        copy = state.length;\n        if (copy > have) { copy = have; }\n        if (copy) {\n          if (state.head) {\n            len = state.head.extra_len - state.length;\n            if (!state.head.extra) {\n              // Use untyped array for more conveniend processing later\n              state.head.extra = new Array(state.head.extra_len);\n            }\n            utils.arraySet(\n              state.head.extra,\n              input,\n              next,\n              // extra field is limited to 65536 bytes\n              // - no need for additional size check\n              copy,\n              /*len + copy > state.head.extra_max - len ? state.head.extra_max : copy,*/\n              len\n            );\n            //zmemcpy(state.head.extra + len, next,\n            //        len + copy > state.head.extra_max ?\n            //        state.head.extra_max - len : copy);\n          }\n          if (state.flags & 0x0200) {\n            state.check = crc32(state.check, input, copy, next);\n          }\n          have -= copy;\n          next += copy;\n          state.length -= copy;\n        }\n        if (state.length) { break inf_leave; }\n      }\n      state.length = 0;\n      state.mode = NAME;\n      /* falls through */\n    case NAME:\n      if (state.flags & 0x0800) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          // TODO: 2 or 1 bytes?\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.name_max*/)) {\n            state.head.name += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.name = null;\n      }\n      state.length = 0;\n      state.mode = COMMENT;\n      /* falls through */\n    case COMMENT:\n      if (state.flags & 0x1000) {\n        if (have === 0) { break inf_leave; }\n        copy = 0;\n        do {\n          len = input[next + copy++];\n          /* use constant limit because in js we should not preallocate memory */\n          if (state.head && len &&\n              (state.length < 65536 /*state.head.comm_max*/)) {\n            state.head.comment += String.fromCharCode(len);\n          }\n        } while (len && copy < have);\n        if (state.flags & 0x0200) {\n          state.check = crc32(state.check, input, copy, next);\n        }\n        have -= copy;\n        next += copy;\n        if (len) { break inf_leave; }\n      }\n      else if (state.head) {\n        state.head.comment = null;\n      }\n      state.mode = HCRC;\n      /* falls through */\n    case HCRC:\n      if (state.flags & 0x0200) {\n        //=== NEEDBITS(16); */\n        while (bits < 16) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.check & 0xffff)) {\n          strm.msg = 'header crc mismatch';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n      }\n      if (state.head) {\n        state.head.hcrc = ((state.flags >> 9) & 1);\n        state.head.done = true;\n      }\n      strm.adler = state.check = 0;\n      state.mode = TYPE;\n      break;\n    case DICTID:\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      strm.adler = state.check = zswap32(hold);\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = DICT;\n      /* falls through */\n    case DICT:\n      if (state.havedict === 0) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        return Z_NEED_DICT;\n      }\n      strm.adler = state.check = 1/*adler32(0L, Z_NULL, 0)*/;\n      state.mode = TYPE;\n      /* falls through */\n    case TYPE:\n      if (flush === Z_BLOCK || flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case TYPEDO:\n      if (state.last) {\n        //--- BYTEBITS() ---//\n        hold >>>= bits & 7;\n        bits -= bits & 7;\n        //---//\n        state.mode = CHECK;\n        break;\n      }\n      //=== NEEDBITS(3); */\n      while (bits < 3) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.last = (hold & 0x01)/*BITS(1)*/;\n      //--- DROPBITS(1) ---//\n      hold >>>= 1;\n      bits -= 1;\n      //---//\n\n      switch ((hold & 0x03)/*BITS(2)*/) {\n      case 0:                             /* stored block */\n        //Tracev((stderr, \"inflate:     stored block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = STORED;\n        break;\n      case 1:                             /* fixed block */\n        fixedtables(state);\n        //Tracev((stderr, \"inflate:     fixed codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = LEN_;             /* decode codes */\n        if (flush === Z_TREES) {\n          //--- DROPBITS(2) ---//\n          hold >>>= 2;\n          bits -= 2;\n          //---//\n          break inf_leave;\n        }\n        break;\n      case 2:                             /* dynamic block */\n        //Tracev((stderr, \"inflate:     dynamic codes block%s\\n\",\n        //        state.last ? \" (last)\" : \"\"));\n        state.mode = TABLE;\n        break;\n      case 3:\n        strm.msg = 'invalid block type';\n        state.mode = BAD;\n      }\n      //--- DROPBITS(2) ---//\n      hold >>>= 2;\n      bits -= 2;\n      //---//\n      break;\n    case STORED:\n      //--- BYTEBITS() ---// /* go to byte boundary */\n      hold >>>= bits & 7;\n      bits -= bits & 7;\n      //---//\n      //=== NEEDBITS(32); */\n      while (bits < 32) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      if ((hold & 0xffff) !== ((hold >>> 16) ^ 0xffff)) {\n        strm.msg = 'invalid stored block lengths';\n        state.mode = BAD;\n        break;\n      }\n      state.length = hold & 0xffff;\n      //Tracev((stderr, \"inflate:       stored length %u\\n\",\n      //        state.length));\n      //=== INITBITS();\n      hold = 0;\n      bits = 0;\n      //===//\n      state.mode = COPY_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case COPY_:\n      state.mode = COPY;\n      /* falls through */\n    case COPY:\n      copy = state.length;\n      if (copy) {\n        if (copy > have) { copy = have; }\n        if (copy > left) { copy = left; }\n        if (copy === 0) { break inf_leave; }\n        //--- zmemcpy(put, next, copy); ---\n        utils.arraySet(output, input, next, copy, put);\n        //---//\n        have -= copy;\n        next += copy;\n        left -= copy;\n        put += copy;\n        state.length -= copy;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       stored end\\n\"));\n      state.mode = TYPE;\n      break;\n    case TABLE:\n      //=== NEEDBITS(14); */\n      while (bits < 14) {\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n      }\n      //===//\n      state.nlen = (hold & 0x1f)/*BITS(5)*/ + 257;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ndist = (hold & 0x1f)/*BITS(5)*/ + 1;\n      //--- DROPBITS(5) ---//\n      hold >>>= 5;\n      bits -= 5;\n      //---//\n      state.ncode = (hold & 0x0f)/*BITS(4)*/ + 4;\n      //--- DROPBITS(4) ---//\n      hold >>>= 4;\n      bits -= 4;\n      //---//\n//#ifndef PKZIP_BUG_WORKAROUND\n      if (state.nlen > 286 || state.ndist > 30) {\n        strm.msg = 'too many length or distance symbols';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracev((stderr, \"inflate:       table sizes ok\\n\"));\n      state.have = 0;\n      state.mode = LENLENS;\n      /* falls through */\n    case LENLENS:\n      while (state.have < state.ncode) {\n        //=== NEEDBITS(3);\n        while (bits < 3) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.lens[order[state.have++]] = (hold & 0x07);//BITS(3);\n        //--- DROPBITS(3) ---//\n        hold >>>= 3;\n        bits -= 3;\n        //---//\n      }\n      while (state.have < 19) {\n        state.lens[order[state.have++]] = 0;\n      }\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      //state.next = state.codes;\n      //state.lencode = state.next;\n      // Switch to use dynamic table\n      state.lencode = state.lendyn;\n      state.lenbits = 7;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(CODES, state.lens, 0, 19, state.lencode, 0, state.work, opts);\n      state.lenbits = opts.bits;\n\n      if (ret) {\n        strm.msg = 'invalid code lengths set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, \"inflate:       code lengths ok\\n\"));\n      state.have = 0;\n      state.mode = CODELENS;\n      /* falls through */\n    case CODELENS:\n      while (state.have < state.nlen + state.ndist) {\n        for (;;) {\n          here = state.lencode[hold & ((1 << state.lenbits) - 1)];/*BITS(state.lenbits)*/\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        if (here_val < 16) {\n          //--- DROPBITS(here.bits) ---//\n          hold >>>= here_bits;\n          bits -= here_bits;\n          //---//\n          state.lens[state.have++] = here_val;\n        }\n        else {\n          if (here_val === 16) {\n            //=== NEEDBITS(here.bits + 2);\n            n = here_bits + 2;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            if (state.have === 0) {\n              strm.msg = 'invalid bit length repeat';\n              state.mode = BAD;\n              break;\n            }\n            len = state.lens[state.have - 1];\n            copy = 3 + (hold & 0x03);//BITS(2);\n            //--- DROPBITS(2) ---//\n            hold >>>= 2;\n            bits -= 2;\n            //---//\n          }\n          else if (here_val === 17) {\n            //=== NEEDBITS(here.bits + 3);\n            n = here_bits + 3;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 3 + (hold & 0x07);//BITS(3);\n            //--- DROPBITS(3) ---//\n            hold >>>= 3;\n            bits -= 3;\n            //---//\n          }\n          else {\n            //=== NEEDBITS(here.bits + 7);\n            n = here_bits + 7;\n            while (bits < n) {\n              if (have === 0) { break inf_leave; }\n              have--;\n              hold += input[next++] << bits;\n              bits += 8;\n            }\n            //===//\n            //--- DROPBITS(here.bits) ---//\n            hold >>>= here_bits;\n            bits -= here_bits;\n            //---//\n            len = 0;\n            copy = 11 + (hold & 0x7f);//BITS(7);\n            //--- DROPBITS(7) ---//\n            hold >>>= 7;\n            bits -= 7;\n            //---//\n          }\n          if (state.have + copy > state.nlen + state.ndist) {\n            strm.msg = 'invalid bit length repeat';\n            state.mode = BAD;\n            break;\n          }\n          while (copy--) {\n            state.lens[state.have++] = len;\n          }\n        }\n      }\n\n      /* handle error breaks in while */\n      if (state.mode === BAD) { break; }\n\n      /* check for end-of-block code (better have one) */\n      if (state.lens[256] === 0) {\n        strm.msg = 'invalid code -- missing end-of-block';\n        state.mode = BAD;\n        break;\n      }\n\n      /* build code tables -- note: do not change the lenbits or distbits\n         values here (9 and 6) without reading the comments in inftrees.h\n         concerning the ENOUGH constants, which depend on those values */\n      state.lenbits = 9;\n\n      opts = { bits: state.lenbits };\n      ret = inflate_table(LENS, state.lens, 0, state.nlen, state.lencode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.lenbits = opts.bits;\n      // state.lencode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid literal/lengths set';\n        state.mode = BAD;\n        break;\n      }\n\n      state.distbits = 6;\n      //state.distcode.copy(state.codes);\n      // Switch to use dynamic table\n      state.distcode = state.distdyn;\n      opts = { bits: state.distbits };\n      ret = inflate_table(DISTS, state.lens, state.nlen, state.ndist, state.distcode, 0, state.work, opts);\n      // We have separate tables & no pointers. 2 commented lines below not needed.\n      // state.next_index = opts.table_index;\n      state.distbits = opts.bits;\n      // state.distcode = state.next;\n\n      if (ret) {\n        strm.msg = 'invalid distances set';\n        state.mode = BAD;\n        break;\n      }\n      //Tracev((stderr, 'inflate:       codes ok\\n'));\n      state.mode = LEN_;\n      if (flush === Z_TREES) { break inf_leave; }\n      /* falls through */\n    case LEN_:\n      state.mode = LEN;\n      /* falls through */\n    case LEN:\n      if (have >= 6 && left >= 258) {\n        //--- RESTORE() ---\n        strm.next_out = put;\n        strm.avail_out = left;\n        strm.next_in = next;\n        strm.avail_in = have;\n        state.hold = hold;\n        state.bits = bits;\n        //---\n        inflate_fast(strm, _out);\n        //--- LOAD() ---\n        put = strm.next_out;\n        output = strm.output;\n        left = strm.avail_out;\n        next = strm.next_in;\n        input = strm.input;\n        have = strm.avail_in;\n        hold = state.hold;\n        bits = state.bits;\n        //---\n\n        if (state.mode === TYPE) {\n          state.back = -1;\n        }\n        break;\n      }\n      state.back = 0;\n      for (;;) {\n        here = state.lencode[hold & ((1 << state.lenbits) - 1)];  /*BITS(state.lenbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if (here_bits <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if (here_op && (here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.lencode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      state.length = here_val;\n      if (here_op === 0) {\n        //Tracevv((stderr, here.val >= 0x20 && here.val < 0x7f ?\n        //        \"inflate:         literal '%c'\\n\" :\n        //        \"inflate:         literal 0x%02x\\n\", here.val));\n        state.mode = LIT;\n        break;\n      }\n      if (here_op & 32) {\n        //Tracevv((stderr, \"inflate:         end of block\\n\"));\n        state.back = -1;\n        state.mode = TYPE;\n        break;\n      }\n      if (here_op & 64) {\n        strm.msg = 'invalid literal/length code';\n        state.mode = BAD;\n        break;\n      }\n      state.extra = here_op & 15;\n      state.mode = LENEXT;\n      /* falls through */\n    case LENEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.length += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n      //Tracevv((stderr, \"inflate:         length %u\\n\", state.length));\n      state.was = state.length;\n      state.mode = DIST;\n      /* falls through */\n    case DIST:\n      for (;;) {\n        here = state.distcode[hold & ((1 << state.distbits) - 1)];/*BITS(state.distbits)*/\n        here_bits = here >>> 24;\n        here_op = (here >>> 16) & 0xff;\n        here_val = here & 0xffff;\n\n        if ((here_bits) <= bits) { break; }\n        //--- PULLBYTE() ---//\n        if (have === 0) { break inf_leave; }\n        have--;\n        hold += input[next++] << bits;\n        bits += 8;\n        //---//\n      }\n      if ((here_op & 0xf0) === 0) {\n        last_bits = here_bits;\n        last_op = here_op;\n        last_val = here_val;\n        for (;;) {\n          here = state.distcode[last_val +\n                  ((hold & ((1 << (last_bits + last_op)) - 1))/*BITS(last.bits + last.op)*/ >> last_bits)];\n          here_bits = here >>> 24;\n          here_op = (here >>> 16) & 0xff;\n          here_val = here & 0xffff;\n\n          if ((last_bits + here_bits) <= bits) { break; }\n          //--- PULLBYTE() ---//\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n          //---//\n        }\n        //--- DROPBITS(last.bits) ---//\n        hold >>>= last_bits;\n        bits -= last_bits;\n        //---//\n        state.back += last_bits;\n      }\n      //--- DROPBITS(here.bits) ---//\n      hold >>>= here_bits;\n      bits -= here_bits;\n      //---//\n      state.back += here_bits;\n      if (here_op & 64) {\n        strm.msg = 'invalid distance code';\n        state.mode = BAD;\n        break;\n      }\n      state.offset = here_val;\n      state.extra = (here_op) & 15;\n      state.mode = DISTEXT;\n      /* falls through */\n    case DISTEXT:\n      if (state.extra) {\n        //=== NEEDBITS(state.extra);\n        n = state.extra;\n        while (bits < n) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        state.offset += hold & ((1 << state.extra) - 1)/*BITS(state.extra)*/;\n        //--- DROPBITS(state.extra) ---//\n        hold >>>= state.extra;\n        bits -= state.extra;\n        //---//\n        state.back += state.extra;\n      }\n//#ifdef INFLATE_STRICT\n      if (state.offset > state.dmax) {\n        strm.msg = 'invalid distance too far back';\n        state.mode = BAD;\n        break;\n      }\n//#endif\n      //Tracevv((stderr, \"inflate:         distance %u\\n\", state.offset));\n      state.mode = MATCH;\n      /* falls through */\n    case MATCH:\n      if (left === 0) { break inf_leave; }\n      copy = _out - left;\n      if (state.offset > copy) {         /* copy from window */\n        copy = state.offset - copy;\n        if (copy > state.whave) {\n          if (state.sane) {\n            strm.msg = 'invalid distance too far back';\n            state.mode = BAD;\n            break;\n          }\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n//#ifdef INFLATE_ALLOW_INVALID_DISTANCE_TOOFAR_ARRR\n//          Trace((stderr, \"inflate.c too far\\n\"));\n//          copy -= state.whave;\n//          if (copy > state.length) { copy = state.length; }\n//          if (copy > left) { copy = left; }\n//          left -= copy;\n//          state.length -= copy;\n//          do {\n//            output[put++] = 0;\n//          } while (--copy);\n//          if (state.length === 0) { state.mode = LEN; }\n//          break;\n//#endif\n        }\n        if (copy > state.wnext) {\n          copy -= state.wnext;\n          from = state.wsize - copy;\n        }\n        else {\n          from = state.wnext - copy;\n        }\n        if (copy > state.length) { copy = state.length; }\n        from_source = state.window;\n      }\n      else {                              /* copy from output */\n        from_source = output;\n        from = put - state.offset;\n        copy = state.length;\n      }\n      if (copy > left) { copy = left; }\n      left -= copy;\n      state.length -= copy;\n      do {\n        output[put++] = from_source[from++];\n      } while (--copy);\n      if (state.length === 0) { state.mode = LEN; }\n      break;\n    case LIT:\n      if (left === 0) { break inf_leave; }\n      output[put++] = state.length;\n      left--;\n      state.mode = LEN;\n      break;\n    case CHECK:\n      if (state.wrap) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          // Use '|' insdead of '+' to make sure that result is signed\n          hold |= input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        _out -= left;\n        strm.total_out += _out;\n        state.total += _out;\n        if (_out) {\n          strm.adler = state.check =\n              /*UPDATE(state.check, put - _out, _out);*/\n              (state.flags ? crc32(state.check, output, _out, put - _out) : adler32(state.check, output, _out, put - _out));\n\n        }\n        _out = left;\n        // NB: crc32 stored as signed 32-bit int, zswap32 returns signed too\n        if ((state.flags ? hold : zswap32(hold)) !== state.check) {\n          strm.msg = 'incorrect data check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   check matches trailer\\n\"));\n      }\n      state.mode = LENGTH;\n      /* falls through */\n    case LENGTH:\n      if (state.wrap && state.flags) {\n        //=== NEEDBITS(32);\n        while (bits < 32) {\n          if (have === 0) { break inf_leave; }\n          have--;\n          hold += input[next++] << bits;\n          bits += 8;\n        }\n        //===//\n        if (hold !== (state.total & 0xffffffff)) {\n          strm.msg = 'incorrect length check';\n          state.mode = BAD;\n          break;\n        }\n        //=== INITBITS();\n        hold = 0;\n        bits = 0;\n        //===//\n        //Tracev((stderr, \"inflate:   length matches trailer\\n\"));\n      }\n      state.mode = DONE;\n      /* falls through */\n    case DONE:\n      ret = Z_STREAM_END;\n      break inf_leave;\n    case BAD:\n      ret = Z_DATA_ERROR;\n      break inf_leave;\n    case MEM:\n      return Z_MEM_ERROR;\n    case SYNC:\n      /* falls through */\n    default:\n      return Z_STREAM_ERROR;\n    }\n  }\n\n  // inf_leave <- here is real place for \"goto inf_leave\", emulated via \"break inf_leave\"\n\n  /*\n     Return from inflate(), updating the total counts and the check value.\n     If there was no progress during the inflate() call, return a buffer\n     error.  Call updatewindow() to create and/or update the window state.\n     Note: a memory error from inflate() is non-recoverable.\n   */\n\n  //--- RESTORE() ---\n  strm.next_out = put;\n  strm.avail_out = left;\n  strm.next_in = next;\n  strm.avail_in = have;\n  state.hold = hold;\n  state.bits = bits;\n  //---\n\n  if (state.wsize || (_out !== strm.avail_out && state.mode < BAD &&\n                      (state.mode < CHECK || flush !== Z_FINISH))) {\n    if (updatewindow(strm, strm.output, strm.next_out, _out - strm.avail_out)) {\n      state.mode = MEM;\n      return Z_MEM_ERROR;\n    }\n  }\n  _in -= strm.avail_in;\n  _out -= strm.avail_out;\n  strm.total_in += _in;\n  strm.total_out += _out;\n  state.total += _out;\n  if (state.wrap && _out) {\n    strm.adler = state.check = /*UPDATE(state.check, strm.next_out - _out, _out);*/\n      (state.flags ? crc32(state.check, output, _out, strm.next_out - _out) : adler32(state.check, output, _out, strm.next_out - _out));\n  }\n  strm.data_type = state.bits + (state.last ? 64 : 0) +\n                    (state.mode === TYPE ? 128 : 0) +\n                    (state.mode === LEN_ || state.mode === COPY_ ? 256 : 0);\n  if (((_in === 0 && _out === 0) || flush === Z_FINISH) && ret === Z_OK) {\n    ret = Z_BUF_ERROR;\n  }\n  return ret;\n}\n\nfunction inflateEnd(strm) {\n\n  if (!strm || !strm.state /*|| strm->zfree == (free_func)0*/) {\n    return Z_STREAM_ERROR;\n  }\n\n  var state = strm.state;\n  if (state.window) {\n    state.window = null;\n  }\n  strm.state = null;\n  return Z_OK;\n}\n\nfunction inflateGetHeader(strm, head) {\n  var state;\n\n  /* check state */\n  if (!strm || !strm.state) { return Z_STREAM_ERROR; }\n  state = strm.state;\n  if ((state.wrap & 2) === 0) { return Z_STREAM_ERROR; }\n\n  /* save header structure */\n  state.head = head;\n  head.done = false;\n  return Z_OK;\n}\n\nfunction inflateSetDictionary(strm, dictionary) {\n  var dictLength = dictionary.length;\n\n  var state;\n  var dictid;\n  var ret;\n\n  /* check state */\n  if (!strm /* == Z_NULL */ || !strm.state /* == Z_NULL */) { return Z_STREAM_ERROR; }\n  state = strm.state;\n\n  if (state.wrap !== 0 && state.mode !== DICT) {\n    return Z_STREAM_ERROR;\n  }\n\n  /* check for correct dictionary identifier */\n  if (state.mode === DICT) {\n    dictid = 1; /* adler32(0, null, 0)*/\n    /* dictid = adler32(dictid, dictionary, dictLength); */\n    dictid = adler32(dictid, dictionary, dictLength, 0);\n    if (dictid !== state.check) {\n      return Z_DATA_ERROR;\n    }\n  }\n  /* copy dictionary to window using updatewindow(), which will amend the\n   existing dictionary if appropriate */\n  ret = updatewindow(strm, dictionary, dictLength, dictLength);\n  if (ret) {\n    state.mode = MEM;\n    return Z_MEM_ERROR;\n  }\n  state.havedict = 1;\n  // Tracev((stderr, \"inflate:   dictionary set\\n\"));\n  return Z_OK;\n}\n\nexports.inflateReset = inflateReset;\nexports.inflateReset2 = inflateReset2;\nexports.inflateResetKeep = inflateResetKeep;\nexports.inflateInit = inflateInit;\nexports.inflateInit2 = inflateInit2;\nexports.inflate = inflate;\nexports.inflateEnd = inflateEnd;\nexports.inflateGetHeader = inflateGetHeader;\nexports.inflateSetDictionary = inflateSetDictionary;\nexports.inflateInfo = 'pako inflate (from Nodeca project)';\n\n/* Not implemented\nexports.inflateCopy = inflateCopy;\nexports.inflateGetDictionary = inflateGetDictionary;\nexports.inflateMark = inflateMark;\nexports.inflatePrime = inflatePrime;\nexports.inflateSync = inflateSync;\nexports.inflateSyncPoint = inflateSyncPoint;\nexports.inflateUndermine = inflateUndermine;\n*/\n\n},{\"../utils/common\":3,\"./adler32\":5,\"./crc32\":7,\"./inffast\":10,\"./inftrees\":12}],12:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\nvar MAXBITS = 15;\nvar ENOUGH_LENS = 852;\nvar ENOUGH_DISTS = 592;\n//var ENOUGH = (ENOUGH_LENS+ENOUGH_DISTS);\n\nvar CODES = 0;\nvar LENS = 1;\nvar DISTS = 2;\n\nvar lbase = [ /* Length codes 257..285 base */\n  3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31,\n  35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0\n];\n\nvar lext = [ /* Length codes 257..285 extra */\n  16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18,\n  19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78\n];\n\nvar dbase = [ /* Distance codes 0..29 base */\n  1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193,\n  257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145,\n  8193, 12289, 16385, 24577, 0, 0\n];\n\nvar dext = [ /* Distance codes 0..29 extra */\n  16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22,\n  23, 23, 24, 24, 25, 25, 26, 26, 27, 27,\n  28, 28, 29, 29, 64, 64\n];\n\nmodule.exports = function inflate_table(type, lens, lens_index, codes, table, table_index, work, opts)\n{\n  var bits = opts.bits;\n      //here = opts.here; /* table entry for duplication */\n\n  var len = 0;               /* a code's length in bits */\n  var sym = 0;               /* index of code symbols */\n  var min = 0, max = 0;          /* minimum and maximum code lengths */\n  var root = 0;              /* number of index bits for root table */\n  var curr = 0;              /* number of index bits for current table */\n  var drop = 0;              /* code bits to drop for sub-table */\n  var left = 0;                   /* number of prefix codes available */\n  var used = 0;              /* code entries in table used */\n  var huff = 0;              /* Huffman code */\n  var incr;              /* for incrementing code, index */\n  var fill;              /* index for replicating entries */\n  var low;               /* low bits for current root entry */\n  var mask;              /* mask for low root bits */\n  var next;             /* next available space in table */\n  var base = null;     /* base value table to use */\n  var base_index = 0;\n//  var shoextra;    /* extra bits table to use */\n  var end;                    /* use base and extra for symbol > end */\n  var count = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];    /* number of codes of each length */\n  var offs = new utils.Buf16(MAXBITS + 1); //[MAXBITS+1];     /* offsets in table for each length */\n  var extra = null;\n  var extra_index = 0;\n\n  var here_bits, here_op, here_val;\n\n  /*\n   Process a set of code lengths to create a canonical Huffman code.  The\n   code lengths are lens[0..codes-1].  Each length corresponds to the\n   symbols 0..codes-1.  The Huffman code is generated by first sorting the\n   symbols by length from short to long, and retaining the symbol order\n   for codes with equal lengths.  Then the code starts with all zero bits\n   for the first code of the shortest length, and the codes are integer\n   increments for the same length, and zeros are appended as the length\n   increases.  For the deflate format, these bits are stored backwards\n   from their more natural integer increment ordering, and so when the\n   decoding tables are built in the large loop below, the integer codes\n   are incremented backwards.\n\n   This routine assumes, but does not check, that all of the entries in\n   lens[] are in the range 0..MAXBITS.  The caller must assure this.\n   1..MAXBITS is interpreted as that code length.  zero means that that\n   symbol does not occur in this code.\n\n   The codes are sorted by computing a count of codes for each length,\n   creating from that a table of starting indices for each length in the\n   sorted table, and then entering the symbols in order in the sorted\n   table.  The sorted table is work[], with that space being provided by\n   the caller.\n\n   The length counts are used for other purposes as well, i.e. finding\n   the minimum and maximum length codes, determining if there are any\n   codes at all, checking for a valid set of lengths, and looking ahead\n   at length counts to determine sub-table sizes when building the\n   decoding tables.\n   */\n\n  /* accumulate lengths for codes (assumes lens[] all in 0..MAXBITS) */\n  for (len = 0; len <= MAXBITS; len++) {\n    count[len] = 0;\n  }\n  for (sym = 0; sym < codes; sym++) {\n    count[lens[lens_index + sym]]++;\n  }\n\n  /* bound code lengths, force root to be within code lengths */\n  root = bits;\n  for (max = MAXBITS; max >= 1; max--) {\n    if (count[max] !== 0) { break; }\n  }\n  if (root > max) {\n    root = max;\n  }\n  if (max === 0) {                     /* no symbols to code at all */\n    //table.op[opts.table_index] = 64;  //here.op = (var char)64;    /* invalid code marker */\n    //table.bits[opts.table_index] = 1;   //here.bits = (var char)1;\n    //table.val[opts.table_index++] = 0;   //here.val = (var short)0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n\n    //table.op[opts.table_index] = 64;\n    //table.bits[opts.table_index] = 1;\n    //table.val[opts.table_index++] = 0;\n    table[table_index++] = (1 << 24) | (64 << 16) | 0;\n\n    opts.bits = 1;\n    return 0;     /* no symbols, but wait for decoding to report error */\n  }\n  for (min = 1; min < max; min++) {\n    if (count[min] !== 0) { break; }\n  }\n  if (root < min) {\n    root = min;\n  }\n\n  /* check for an over-subscribed or incomplete set of lengths */\n  left = 1;\n  for (len = 1; len <= MAXBITS; len++) {\n    left <<= 1;\n    left -= count[len];\n    if (left < 0) {\n      return -1;\n    }        /* over-subscribed */\n  }\n  if (left > 0 && (type === CODES || max !== 1)) {\n    return -1;                      /* incomplete set */\n  }\n\n  /* generate offsets into symbol table for each length for sorting */\n  offs[1] = 0;\n  for (len = 1; len < MAXBITS; len++) {\n    offs[len + 1] = offs[len] + count[len];\n  }\n\n  /* sort symbols by length, by symbol order within each length */\n  for (sym = 0; sym < codes; sym++) {\n    if (lens[lens_index + sym] !== 0) {\n      work[offs[lens[lens_index + sym]]++] = sym;\n    }\n  }\n\n  /*\n   Create and fill in decoding tables.  In this loop, the table being\n   filled is at next and has curr index bits.  The code being used is huff\n   with length len.  That code is converted to an index by dropping drop\n   bits off of the bottom.  For codes where len is less than drop + curr,\n   those top drop + curr - len bits are incremented through all values to\n   fill the table with replicated entries.\n\n   root is the number of index bits for the root table.  When len exceeds\n   root, sub-tables are created pointed to by the root entry with an index\n   of the low root bits of huff.  This is saved in low to check for when a\n   new sub-table should be started.  drop is zero when the root table is\n   being filled, and drop is root when sub-tables are being filled.\n\n   When a new sub-table is needed, it is necessary to look ahead in the\n   code lengths to determine what size sub-table is needed.  The length\n   counts are used for this, and so count[] is decremented as codes are\n   entered in the tables.\n\n   used keeps track of how many table entries have been allocated from the\n   provided *table space.  It is checked for LENS and DIST tables against\n   the constants ENOUGH_LENS and ENOUGH_DISTS to guard against changes in\n   the initial root table size constants.  See the comments in inftrees.h\n   for more information.\n\n   sym increments through all symbols, and the loop terminates when\n   all codes of length max, i.e. all codes, have been processed.  This\n   routine permits incomplete codes, so another loop after this one fills\n   in the rest of the decoding tables with invalid code markers.\n   */\n\n  /* set up for code type */\n  // poor man optimization - use if-else instead of switch,\n  // to avoid deopts in old v8\n  if (type === CODES) {\n    base = extra = work;    /* dummy value--not used */\n    end = 19;\n\n  } else if (type === LENS) {\n    base = lbase;\n    base_index -= 257;\n    extra = lext;\n    extra_index -= 257;\n    end = 256;\n\n  } else {                    /* DISTS */\n    base = dbase;\n    extra = dext;\n    end = -1;\n  }\n\n  /* initialize opts for loop */\n  huff = 0;                   /* starting code */\n  sym = 0;                    /* starting code symbol */\n  len = min;                  /* starting code length */\n  next = table_index;              /* current table to fill in */\n  curr = root;                /* current table index bits */\n  drop = 0;                   /* current bits to drop from code for index */\n  low = -1;                   /* trigger new sub-table when len > root */\n  used = 1 << root;          /* use root table entries */\n  mask = used - 1;            /* mask for comparing low */\n\n  /* check available table space */\n  if ((type === LENS && used > ENOUGH_LENS) ||\n    (type === DISTS && used > ENOUGH_DISTS)) {\n    return 1;\n  }\n\n  /* process all codes and make table entries */\n  for (;;) {\n    /* create table entry */\n    here_bits = len - drop;\n    if (work[sym] < end) {\n      here_op = 0;\n      here_val = work[sym];\n    }\n    else if (work[sym] > end) {\n      here_op = extra[extra_index + work[sym]];\n      here_val = base[base_index + work[sym]];\n    }\n    else {\n      here_op = 32 + 64;         /* end of block */\n      here_val = 0;\n    }\n\n    /* replicate for those indices with low len bits equal to huff */\n    incr = 1 << (len - drop);\n    fill = 1 << curr;\n    min = fill;                 /* save offset to next table */\n    do {\n      fill -= incr;\n      table[next + (huff >> drop) + fill] = (here_bits << 24) | (here_op << 16) | here_val |0;\n    } while (fill !== 0);\n\n    /* backwards increment the len-bit code huff */\n    incr = 1 << (len - 1);\n    while (huff & incr) {\n      incr >>= 1;\n    }\n    if (incr !== 0) {\n      huff &= incr - 1;\n      huff += incr;\n    } else {\n      huff = 0;\n    }\n\n    /* go to next symbol, update count, len */\n    sym++;\n    if (--count[len] === 0) {\n      if (len === max) { break; }\n      len = lens[lens_index + work[sym]];\n    }\n\n    /* create new sub-table if needed */\n    if (len > root && (huff & mask) !== low) {\n      /* if first time, transition to sub-tables */\n      if (drop === 0) {\n        drop = root;\n      }\n\n      /* increment past last table */\n      next += min;            /* here min is 1 << curr */\n\n      /* determine length of next table */\n      curr = len - drop;\n      left = 1 << curr;\n      while (curr + drop < max) {\n        left -= count[curr + drop];\n        if (left <= 0) { break; }\n        curr++;\n        left <<= 1;\n      }\n\n      /* check for enough space */\n      used += 1 << curr;\n      if ((type === LENS && used > ENOUGH_LENS) ||\n        (type === DISTS && used > ENOUGH_DISTS)) {\n        return 1;\n      }\n\n      /* point entry in root table to sub-table */\n      low = huff & mask;\n      /*table.op[low] = curr;\n      table.bits[low] = root;\n      table.val[low] = next - opts.table_index;*/\n      table[low] = (root << 24) | (curr << 16) | (next - table_index) |0;\n    }\n  }\n\n  /* fill in remaining table entry if code is incomplete (guaranteed to have\n   at most one remaining entry, since if the code is incomplete, the\n   maximum code length that was allowed to get this far is one bit) */\n  if (huff !== 0) {\n    //table.op[next + huff] = 64;            /* invalid code marker */\n    //table.bits[next + huff] = len - drop;\n    //table.val[next + huff] = 0;\n    table[next + huff] = ((len - drop) << 24) | (64 << 16) |0;\n  }\n\n  /* set return parameters */\n  //opts.table_index += used;\n  opts.bits = root;\n  return 0;\n};\n\n},{\"../utils/common\":3}],13:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nmodule.exports = {\n  2:      'need dictionary',     /* Z_NEED_DICT       2  */\n  1:      'stream end',          /* Z_STREAM_END      1  */\n  0:      '',                    /* Z_OK              0  */\n  '-1':   'file error',          /* Z_ERRNO         (-1) */\n  '-2':   'stream error',        /* Z_STREAM_ERROR  (-2) */\n  '-3':   'data error',          /* Z_DATA_ERROR    (-3) */\n  '-4':   'insufficient memory', /* Z_MEM_ERROR     (-4) */\n  '-5':   'buffer error',        /* Z_BUF_ERROR     (-5) */\n  '-6':   'incompatible version' /* Z_VERSION_ERROR (-6) */\n};\n\n},{}],14:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nvar utils = require('../utils/common');\n\n/* Public constants ==========================================================*/\n/* ===========================================================================*/\n\n\n//var Z_FILTERED          = 1;\n//var Z_HUFFMAN_ONLY      = 2;\n//var Z_RLE               = 3;\nvar Z_FIXED               = 4;\n//var Z_DEFAULT_STRATEGY  = 0;\n\n/* Possible values of the data_type field (though see inflate()) */\nvar Z_BINARY              = 0;\nvar Z_TEXT                = 1;\n//var Z_ASCII             = 1; // = Z_TEXT\nvar Z_UNKNOWN             = 2;\n\n/*============================================================================*/\n\n\nfunction zero(buf) { var len = buf.length; while (--len >= 0) { buf[len] = 0; } }\n\n// From zutil.h\n\nvar STORED_BLOCK = 0;\nvar STATIC_TREES = 1;\nvar DYN_TREES    = 2;\n/* The three kinds of block type */\n\nvar MIN_MATCH    = 3;\nvar MAX_MATCH    = 258;\n/* The minimum and maximum match lengths */\n\n// From deflate.h\n/* ===========================================================================\n * Internal compression state.\n */\n\nvar LENGTH_CODES  = 29;\n/* number of length codes, not counting the special END_BLOCK code */\n\nvar LITERALS      = 256;\n/* number of literal bytes 0..255 */\n\nvar L_CODES       = LITERALS + 1 + LENGTH_CODES;\n/* number of Literal or Length codes, including the END_BLOCK code */\n\nvar D_CODES       = 30;\n/* number of distance codes */\n\nvar BL_CODES      = 19;\n/* number of codes used to transfer the bit lengths */\n\nvar HEAP_SIZE     = 2 * L_CODES + 1;\n/* maximum heap size */\n\nvar MAX_BITS      = 15;\n/* All codes must not exceed MAX_BITS bits */\n\nvar Buf_size      = 16;\n/* size of bit buffer in bi_buf */\n\n\n/* ===========================================================================\n * Constants\n */\n\nvar MAX_BL_BITS = 7;\n/* Bit length codes must not exceed MAX_BL_BITS bits */\n\nvar END_BLOCK   = 256;\n/* end of block literal code */\n\nvar REP_3_6     = 16;\n/* repeat previous bit length 3-6 times (2 bits of repeat count) */\n\nvar REPZ_3_10   = 17;\n/* repeat a zero length 3-10 times  (3 bits of repeat count) */\n\nvar REPZ_11_138 = 18;\n/* repeat a zero length 11-138 times  (7 bits of repeat count) */\n\n/* eslint-disable comma-spacing,array-bracket-spacing */\nvar extra_lbits =   /* extra bits for each length code */\n  [0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0];\n\nvar extra_dbits =   /* extra bits for each distance code */\n  [0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13];\n\nvar extra_blbits =  /* extra bits for each bit length code */\n  [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,3,7];\n\nvar bl_order =\n  [16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15];\n/* eslint-enable comma-spacing,array-bracket-spacing */\n\n/* The lengths of the bit length codes are sent in order of decreasing\n * probability, to avoid transmitting the lengths for unused bit length codes.\n */\n\n/* ===========================================================================\n * Local data. These are initialized only once.\n */\n\n// We pre-fill arrays with 0 to avoid uninitialized gaps\n\nvar DIST_CODE_LEN = 512; /* see definition of array dist_code below */\n\n// !!!! Use flat array insdead of structure, Freq = i*2, Len = i*2+1\nvar static_ltree  = new Array((L_CODES + 2) * 2);\nzero(static_ltree);\n/* The static literal tree. Since the bit lengths are imposed, there is no\n * need for the L_CODES extra codes used during heap construction. However\n * The codes 286 and 287 are needed to build a canonical tree (see _tr_init\n * below).\n */\n\nvar static_dtree  = new Array(D_CODES * 2);\nzero(static_dtree);\n/* The static distance tree. (Actually a trivial tree since all codes use\n * 5 bits.)\n */\n\nvar _dist_code    = new Array(DIST_CODE_LEN);\nzero(_dist_code);\n/* Distance codes. The first 256 values correspond to the distances\n * 3 .. 258, the last 256 values correspond to the top 8 bits of\n * the 15 bit distances.\n */\n\nvar _length_code  = new Array(MAX_MATCH - MIN_MATCH + 1);\nzero(_length_code);\n/* length code for each normalized match length (0 == MIN_MATCH) */\n\nvar base_length   = new Array(LENGTH_CODES);\nzero(base_length);\n/* First normalized length for each code (0 = MIN_MATCH) */\n\nvar base_dist     = new Array(D_CODES);\nzero(base_dist);\n/* First normalized distance for each code (0 = distance of 1) */\n\n\nfunction StaticTreeDesc(static_tree, extra_bits, extra_base, elems, max_length) {\n\n  this.static_tree  = static_tree;  /* static tree or NULL */\n  this.extra_bits   = extra_bits;   /* extra bits for each code or NULL */\n  this.extra_base   = extra_base;   /* base index for extra_bits */\n  this.elems        = elems;        /* max number of elements in the tree */\n  this.max_length   = max_length;   /* max bit length for the codes */\n\n  // show if `static_tree` has data or dummy - needed for monomorphic objects\n  this.has_stree    = static_tree && static_tree.length;\n}\n\n\nvar static_l_desc;\nvar static_d_desc;\nvar static_bl_desc;\n\n\nfunction TreeDesc(dyn_tree, stat_desc) {\n  this.dyn_tree = dyn_tree;     /* the dynamic tree */\n  this.max_code = 0;            /* largest code with non zero frequency */\n  this.stat_desc = stat_desc;   /* the corresponding static tree */\n}\n\n\n\nfunction d_code(dist) {\n  return dist < 256 ? _dist_code[dist] : _dist_code[256 + (dist >>> 7)];\n}\n\n\n/* ===========================================================================\n * Output a short LSB first on the stream.\n * IN assertion: there is enough room in pendingBuf.\n */\nfunction put_short(s, w) {\n//    put_byte(s, (uch)((w) & 0xff));\n//    put_byte(s, (uch)((ush)(w) >> 8));\n  s.pending_buf[s.pending++] = (w) & 0xff;\n  s.pending_buf[s.pending++] = (w >>> 8) & 0xff;\n}\n\n\n/* ===========================================================================\n * Send a value on a given number of bits.\n * IN assertion: length <= 16 and value fits in length bits.\n */\nfunction send_bits(s, value, length) {\n  if (s.bi_valid > (Buf_size - length)) {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    put_short(s, s.bi_buf);\n    s.bi_buf = value >> (Buf_size - s.bi_valid);\n    s.bi_valid += length - Buf_size;\n  } else {\n    s.bi_buf |= (value << s.bi_valid) & 0xffff;\n    s.bi_valid += length;\n  }\n}\n\n\nfunction send_code(s, c, tree) {\n  send_bits(s, tree[c * 2]/*.Code*/, tree[c * 2 + 1]/*.Len*/);\n}\n\n\n/* ===========================================================================\n * Reverse the first len bits of a code, using straightforward code (a faster\n * method would use a table)\n * IN assertion: 1 <= len <= 15\n */\nfunction bi_reverse(code, len) {\n  var res = 0;\n  do {\n    res |= code & 1;\n    code >>>= 1;\n    res <<= 1;\n  } while (--len > 0);\n  return res >>> 1;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer, keeping at most 7 bits in it.\n */\nfunction bi_flush(s) {\n  if (s.bi_valid === 16) {\n    put_short(s, s.bi_buf);\n    s.bi_buf = 0;\n    s.bi_valid = 0;\n\n  } else if (s.bi_valid >= 8) {\n    s.pending_buf[s.pending++] = s.bi_buf & 0xff;\n    s.bi_buf >>= 8;\n    s.bi_valid -= 8;\n  }\n}\n\n\n/* ===========================================================================\n * Compute the optimal bit lengths for a tree and update the total bit length\n * for the current block.\n * IN assertion: the fields freq and dad are set, heap[heap_max] and\n *    above are the tree nodes sorted by increasing frequency.\n * OUT assertions: the field len is set to the optimal bit length, the\n *     array bl_count contains the frequencies for each bit length.\n *     The length opt_len is updated; static_len is also updated if stree is\n *     not null.\n */\nfunction gen_bitlen(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc;    /* the tree descriptor */\n{\n  var tree            = desc.dyn_tree;\n  var max_code        = desc.max_code;\n  var stree           = desc.stat_desc.static_tree;\n  var has_stree       = desc.stat_desc.has_stree;\n  var extra           = desc.stat_desc.extra_bits;\n  var base            = desc.stat_desc.extra_base;\n  var max_length      = desc.stat_desc.max_length;\n  var h;              /* heap index */\n  var n, m;           /* iterate over the tree elements */\n  var bits;           /* bit length */\n  var xbits;          /* extra bits */\n  var f;              /* frequency */\n  var overflow = 0;   /* number of elements with bit length too large */\n\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    s.bl_count[bits] = 0;\n  }\n\n  /* In a first pass, compute the optimal bit lengths (which may\n   * overflow in the case of the bit length tree).\n   */\n  tree[s.heap[s.heap_max] * 2 + 1]/*.Len*/ = 0; /* root of the heap */\n\n  for (h = s.heap_max + 1; h < HEAP_SIZE; h++) {\n    n = s.heap[h];\n    bits = tree[tree[n * 2 + 1]/*.Dad*/ * 2 + 1]/*.Len*/ + 1;\n    if (bits > max_length) {\n      bits = max_length;\n      overflow++;\n    }\n    tree[n * 2 + 1]/*.Len*/ = bits;\n    /* We overwrite tree[n].Dad which is no longer needed */\n\n    if (n > max_code) { continue; } /* not a leaf node */\n\n    s.bl_count[bits]++;\n    xbits = 0;\n    if (n >= base) {\n      xbits = extra[n - base];\n    }\n    f = tree[n * 2]/*.Freq*/;\n    s.opt_len += f * (bits + xbits);\n    if (has_stree) {\n      s.static_len += f * (stree[n * 2 + 1]/*.Len*/ + xbits);\n    }\n  }\n  if (overflow === 0) { return; }\n\n  // Trace((stderr,\"\\nbit length overflow\\n\"));\n  /* This happens for example on obj2 and pic of the Calgary corpus */\n\n  /* Find the first bit length which could increase: */\n  do {\n    bits = max_length - 1;\n    while (s.bl_count[bits] === 0) { bits--; }\n    s.bl_count[bits]--;      /* move one leaf down the tree */\n    s.bl_count[bits + 1] += 2; /* move one overflow item as its brother */\n    s.bl_count[max_length]--;\n    /* The brother of the overflow item also moves one step up,\n     * but this does not affect bl_count[max_length]\n     */\n    overflow -= 2;\n  } while (overflow > 0);\n\n  /* Now recompute all bit lengths, scanning in increasing frequency.\n   * h is still equal to HEAP_SIZE. (It is simpler to reconstruct all\n   * lengths instead of fixing only the wrong ones. This idea is taken\n   * from 'ar' written by Haruhiko Okumura.)\n   */\n  for (bits = max_length; bits !== 0; bits--) {\n    n = s.bl_count[bits];\n    while (n !== 0) {\n      m = s.heap[--h];\n      if (m > max_code) { continue; }\n      if (tree[m * 2 + 1]/*.Len*/ !== bits) {\n        // Trace((stderr,\"code %d bits %d->%d\\n\", m, tree[m].Len, bits));\n        s.opt_len += (bits - tree[m * 2 + 1]/*.Len*/) * tree[m * 2]/*.Freq*/;\n        tree[m * 2 + 1]/*.Len*/ = bits;\n      }\n      n--;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Generate the codes for a given tree and bit counts (which need not be\n * optimal).\n * IN assertion: the array bl_count contains the bit length statistics for\n * the given tree and the field len is set for all tree elements.\n * OUT assertion: the field code is set for all tree elements of non\n *     zero code length.\n */\nfunction gen_codes(tree, max_code, bl_count)\n//    ct_data *tree;             /* the tree to decorate */\n//    int max_code;              /* largest code with non zero frequency */\n//    ushf *bl_count;            /* number of codes at each bit length */\n{\n  var next_code = new Array(MAX_BITS + 1); /* next code value for each bit length */\n  var code = 0;              /* running code value */\n  var bits;                  /* bit index */\n  var n;                     /* code index */\n\n  /* The distribution counts are first used to generate the code values\n   * without bit reversal.\n   */\n  for (bits = 1; bits <= MAX_BITS; bits++) {\n    next_code[bits] = code = (code + bl_count[bits - 1]) << 1;\n  }\n  /* Check that the bit counts in bl_count are consistent. The last code\n   * must be all ones.\n   */\n  //Assert (code + bl_count[MAX_BITS]-1 == (1<<MAX_BITS)-1,\n  //        \"inconsistent bit counts\");\n  //Tracev((stderr,\"\\ngen_codes: max_code %d \", max_code));\n\n  for (n = 0;  n <= max_code; n++) {\n    var len = tree[n * 2 + 1]/*.Len*/;\n    if (len === 0) { continue; }\n    /* Now reverse the bits */\n    tree[n * 2]/*.Code*/ = bi_reverse(next_code[len]++, len);\n\n    //Tracecv(tree != static_ltree, (stderr,\"\\nn %3d %c l %2d c %4x (%x) \",\n    //     n, (isgraph(n) ? n : ' '), len, tree[n].Code, next_code[len]-1));\n  }\n}\n\n\n/* ===========================================================================\n * Initialize the various 'constant' tables.\n */\nfunction tr_static_init() {\n  var n;        /* iterates over tree elements */\n  var bits;     /* bit counter */\n  var length;   /* length value */\n  var code;     /* code value */\n  var dist;     /* distance index */\n  var bl_count = new Array(MAX_BITS + 1);\n  /* number of codes at each bit length for an optimal tree */\n\n  // do check in _tr_init()\n  //if (static_init_done) return;\n\n  /* For some embedded targets, global variables are not initialized: */\n/*#ifdef NO_INIT_GLOBAL_POINTERS\n  static_l_desc.static_tree = static_ltree;\n  static_l_desc.extra_bits = extra_lbits;\n  static_d_desc.static_tree = static_dtree;\n  static_d_desc.extra_bits = extra_dbits;\n  static_bl_desc.extra_bits = extra_blbits;\n#endif*/\n\n  /* Initialize the mapping length (0..255) -> length code (0..28) */\n  length = 0;\n  for (code = 0; code < LENGTH_CODES - 1; code++) {\n    base_length[code] = length;\n    for (n = 0; n < (1 << extra_lbits[code]); n++) {\n      _length_code[length++] = code;\n    }\n  }\n  //Assert (length == 256, \"tr_static_init: length != 256\");\n  /* Note that the length 255 (match length 258) can be represented\n   * in two different ways: code 284 + 5 bits or code 285, so we\n   * overwrite length_code[255] to use the best encoding:\n   */\n  _length_code[length - 1] = code;\n\n  /* Initialize the mapping dist (0..32K) -> dist code (0..29) */\n  dist = 0;\n  for (code = 0; code < 16; code++) {\n    base_dist[code] = dist;\n    for (n = 0; n < (1 << extra_dbits[code]); n++) {\n      _dist_code[dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: dist != 256\");\n  dist >>= 7; /* from now on, all distances are divided by 128 */\n  for (; code < D_CODES; code++) {\n    base_dist[code] = dist << 7;\n    for (n = 0; n < (1 << (extra_dbits[code] - 7)); n++) {\n      _dist_code[256 + dist++] = code;\n    }\n  }\n  //Assert (dist == 256, \"tr_static_init: 256+dist != 512\");\n\n  /* Construct the codes of the static literal tree */\n  for (bits = 0; bits <= MAX_BITS; bits++) {\n    bl_count[bits] = 0;\n  }\n\n  n = 0;\n  while (n <= 143) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  while (n <= 255) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 9;\n    n++;\n    bl_count[9]++;\n  }\n  while (n <= 279) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 7;\n    n++;\n    bl_count[7]++;\n  }\n  while (n <= 287) {\n    static_ltree[n * 2 + 1]/*.Len*/ = 8;\n    n++;\n    bl_count[8]++;\n  }\n  /* Codes 286 and 287 do not exist, but we must include them in the\n   * tree construction to get a canonical Huffman tree (longest code\n   * all ones)\n   */\n  gen_codes(static_ltree, L_CODES + 1, bl_count);\n\n  /* The static distance tree is trivial: */\n  for (n = 0; n < D_CODES; n++) {\n    static_dtree[n * 2 + 1]/*.Len*/ = 5;\n    static_dtree[n * 2]/*.Code*/ = bi_reverse(n, 5);\n  }\n\n  // Now data ready and we can init static trees\n  static_l_desc = new StaticTreeDesc(static_ltree, extra_lbits, LITERALS + 1, L_CODES, MAX_BITS);\n  static_d_desc = new StaticTreeDesc(static_dtree, extra_dbits, 0,          D_CODES, MAX_BITS);\n  static_bl_desc = new StaticTreeDesc(new Array(0), extra_blbits, 0,         BL_CODES, MAX_BL_BITS);\n\n  //static_init_done = true;\n}\n\n\n/* ===========================================================================\n * Initialize a new block.\n */\nfunction init_block(s) {\n  var n; /* iterates over tree elements */\n\n  /* Initialize the trees. */\n  for (n = 0; n < L_CODES;  n++) { s.dyn_ltree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < D_CODES;  n++) { s.dyn_dtree[n * 2]/*.Freq*/ = 0; }\n  for (n = 0; n < BL_CODES; n++) { s.bl_tree[n * 2]/*.Freq*/ = 0; }\n\n  s.dyn_ltree[END_BLOCK * 2]/*.Freq*/ = 1;\n  s.opt_len = s.static_len = 0;\n  s.last_lit = s.matches = 0;\n}\n\n\n/* ===========================================================================\n * Flush the bit buffer and align the output on a byte boundary\n */\nfunction bi_windup(s)\n{\n  if (s.bi_valid > 8) {\n    put_short(s, s.bi_buf);\n  } else if (s.bi_valid > 0) {\n    //put_byte(s, (Byte)s->bi_buf);\n    s.pending_buf[s.pending++] = s.bi_buf;\n  }\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n}\n\n/* ===========================================================================\n * Copy a stored block, storing first the length and its\n * one's complement if requested.\n */\nfunction copy_block(s, buf, len, header)\n//DeflateState *s;\n//charf    *buf;    /* the input data */\n//unsigned len;     /* its length */\n//int      header;  /* true if block header must be written */\n{\n  bi_windup(s);        /* align on byte boundary */\n\n  if (header) {\n    put_short(s, len);\n    put_short(s, ~len);\n  }\n//  while (len--) {\n//    put_byte(s, *buf++);\n//  }\n  utils.arraySet(s.pending_buf, s.window, buf, len, s.pending);\n  s.pending += len;\n}\n\n/* ===========================================================================\n * Compares to subtrees, using the tree depth as tie breaker when\n * the subtrees have equal frequency. This minimizes the worst case length.\n */\nfunction smaller(tree, n, m, depth) {\n  var _n2 = n * 2;\n  var _m2 = m * 2;\n  return (tree[_n2]/*.Freq*/ < tree[_m2]/*.Freq*/ ||\n         (tree[_n2]/*.Freq*/ === tree[_m2]/*.Freq*/ && depth[n] <= depth[m]));\n}\n\n/* ===========================================================================\n * Restore the heap property by moving down the tree starting at node k,\n * exchanging a node with the smallest of its two sons if necessary, stopping\n * when the heap property is re-established (each father smaller than its\n * two sons).\n */\nfunction pqdownheap(s, tree, k)\n//    deflate_state *s;\n//    ct_data *tree;  /* the tree to restore */\n//    int k;               /* node to move down */\n{\n  var v = s.heap[k];\n  var j = k << 1;  /* left son of k */\n  while (j <= s.heap_len) {\n    /* Set j to the smallest of the two sons: */\n    if (j < s.heap_len &&\n      smaller(tree, s.heap[j + 1], s.heap[j], s.depth)) {\n      j++;\n    }\n    /* Exit if v is smaller than both sons */\n    if (smaller(tree, v, s.heap[j], s.depth)) { break; }\n\n    /* Exchange v with the smallest son */\n    s.heap[k] = s.heap[j];\n    k = j;\n\n    /* And continue down the tree, setting j to the left son of k */\n    j <<= 1;\n  }\n  s.heap[k] = v;\n}\n\n\n// inlined manually\n// var SMALLEST = 1;\n\n/* ===========================================================================\n * Send the block data compressed using the given Huffman trees\n */\nfunction compress_block(s, ltree, dtree)\n//    deflate_state *s;\n//    const ct_data *ltree; /* literal tree */\n//    const ct_data *dtree; /* distance tree */\n{\n  var dist;           /* distance of matched string */\n  var lc;             /* match length or unmatched char (if dist == 0) */\n  var lx = 0;         /* running index in l_buf */\n  var code;           /* the code to send */\n  var extra;          /* number of extra bits to send */\n\n  if (s.last_lit !== 0) {\n    do {\n      dist = (s.pending_buf[s.d_buf + lx * 2] << 8) | (s.pending_buf[s.d_buf + lx * 2 + 1]);\n      lc = s.pending_buf[s.l_buf + lx];\n      lx++;\n\n      if (dist === 0) {\n        send_code(s, lc, ltree); /* send a literal byte */\n        //Tracecv(isgraph(lc), (stderr,\" '%c' \", lc));\n      } else {\n        /* Here, lc is the match length - MIN_MATCH */\n        code = _length_code[lc];\n        send_code(s, code + LITERALS + 1, ltree); /* send the length code */\n        extra = extra_lbits[code];\n        if (extra !== 0) {\n          lc -= base_length[code];\n          send_bits(s, lc, extra);       /* send the extra length bits */\n        }\n        dist--; /* dist is now the match distance - 1 */\n        code = d_code(dist);\n        //Assert (code < D_CODES, \"bad d_code\");\n\n        send_code(s, code, dtree);       /* send the distance code */\n        extra = extra_dbits[code];\n        if (extra !== 0) {\n          dist -= base_dist[code];\n          send_bits(s, dist, extra);   /* send the extra distance bits */\n        }\n      } /* literal or match pair ? */\n\n      /* Check that the overlay between pending_buf and d_buf+l_buf is ok: */\n      //Assert((uInt)(s->pending) < s->lit_bufsize + 2*lx,\n      //       \"pendingBuf overflow\");\n\n    } while (lx < s.last_lit);\n  }\n\n  send_code(s, END_BLOCK, ltree);\n}\n\n\n/* ===========================================================================\n * Construct one Huffman tree and assigns the code bit strings and lengths.\n * Update the total bit length for the current block.\n * IN assertion: the field freq is set for all tree elements.\n * OUT assertions: the fields len and code are set to the optimal bit length\n *     and corresponding code. The length opt_len is updated; static_len is\n *     also updated if stree is not null. The field max_code is set.\n */\nfunction build_tree(s, desc)\n//    deflate_state *s;\n//    tree_desc *desc; /* the tree descriptor */\n{\n  var tree     = desc.dyn_tree;\n  var stree    = desc.stat_desc.static_tree;\n  var has_stree = desc.stat_desc.has_stree;\n  var elems    = desc.stat_desc.elems;\n  var n, m;          /* iterate over heap elements */\n  var max_code = -1; /* largest code with non zero frequency */\n  var node;          /* new node being created */\n\n  /* Construct the initial heap, with least frequent element in\n   * heap[SMALLEST]. The sons of heap[n] are heap[2*n] and heap[2*n+1].\n   * heap[0] is not used.\n   */\n  s.heap_len = 0;\n  s.heap_max = HEAP_SIZE;\n\n  for (n = 0; n < elems; n++) {\n    if (tree[n * 2]/*.Freq*/ !== 0) {\n      s.heap[++s.heap_len] = max_code = n;\n      s.depth[n] = 0;\n\n    } else {\n      tree[n * 2 + 1]/*.Len*/ = 0;\n    }\n  }\n\n  /* The pkzip format requires that at least one distance code exists,\n   * and that at least one bit should be sent even if there is only one\n   * possible code. So to avoid special checks later on we force at least\n   * two codes of non zero frequency.\n   */\n  while (s.heap_len < 2) {\n    node = s.heap[++s.heap_len] = (max_code < 2 ? ++max_code : 0);\n    tree[node * 2]/*.Freq*/ = 1;\n    s.depth[node] = 0;\n    s.opt_len--;\n\n    if (has_stree) {\n      s.static_len -= stree[node * 2 + 1]/*.Len*/;\n    }\n    /* node is 0 or 1 so it does not have extra bits */\n  }\n  desc.max_code = max_code;\n\n  /* The elements heap[heap_len/2+1 .. heap_len] are leaves of the tree,\n   * establish sub-heaps of increasing lengths:\n   */\n  for (n = (s.heap_len >> 1/*int /2*/); n >= 1; n--) { pqdownheap(s, tree, n); }\n\n  /* Construct the Huffman tree by repeatedly combining the least two\n   * frequent nodes.\n   */\n  node = elems;              /* next internal node of the tree */\n  do {\n    //pqremove(s, tree, n);  /* n = node of least frequency */\n    /*** pqremove ***/\n    n = s.heap[1/*SMALLEST*/];\n    s.heap[1/*SMALLEST*/] = s.heap[s.heap_len--];\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n    /***/\n\n    m = s.heap[1/*SMALLEST*/]; /* m = node of next least frequency */\n\n    s.heap[--s.heap_max] = n; /* keep the nodes sorted by frequency */\n    s.heap[--s.heap_max] = m;\n\n    /* Create a new node father of n and m */\n    tree[node * 2]/*.Freq*/ = tree[n * 2]/*.Freq*/ + tree[m * 2]/*.Freq*/;\n    s.depth[node] = (s.depth[n] >= s.depth[m] ? s.depth[n] : s.depth[m]) + 1;\n    tree[n * 2 + 1]/*.Dad*/ = tree[m * 2 + 1]/*.Dad*/ = node;\n\n    /* and insert the new node in the heap */\n    s.heap[1/*SMALLEST*/] = node++;\n    pqdownheap(s, tree, 1/*SMALLEST*/);\n\n  } while (s.heap_len >= 2);\n\n  s.heap[--s.heap_max] = s.heap[1/*SMALLEST*/];\n\n  /* At this point, the fields freq and dad are set. We can now\n   * generate the bit lengths.\n   */\n  gen_bitlen(s, desc);\n\n  /* The field len is now set, we can generate the bit codes */\n  gen_codes(tree, max_code, s.bl_count);\n}\n\n\n/* ===========================================================================\n * Scan a literal or distance tree to determine the frequencies of the codes\n * in the bit length tree.\n */\nfunction scan_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree;   /* the tree to be scanned */\n//    int max_code;    /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n  tree[(max_code + 1) * 2 + 1]/*.Len*/ = 0xffff; /* guard */\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      s.bl_tree[curlen * 2]/*.Freq*/ += count;\n\n    } else if (curlen !== 0) {\n\n      if (curlen !== prevlen) { s.bl_tree[curlen * 2]/*.Freq*/++; }\n      s.bl_tree[REP_3_6 * 2]/*.Freq*/++;\n\n    } else if (count <= 10) {\n      s.bl_tree[REPZ_3_10 * 2]/*.Freq*/++;\n\n    } else {\n      s.bl_tree[REPZ_11_138 * 2]/*.Freq*/++;\n    }\n\n    count = 0;\n    prevlen = curlen;\n\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Send a literal or distance tree in compressed form, using the codes in\n * bl_tree.\n */\nfunction send_tree(s, tree, max_code)\n//    deflate_state *s;\n//    ct_data *tree; /* the tree to be scanned */\n//    int max_code;       /* and its largest code of non zero frequency */\n{\n  var n;                     /* iterates over all tree elements */\n  var prevlen = -1;          /* last emitted length */\n  var curlen;                /* length of current code */\n\n  var nextlen = tree[0 * 2 + 1]/*.Len*/; /* length of next code */\n\n  var count = 0;             /* repeat count of the current code */\n  var max_count = 7;         /* max repeat count */\n  var min_count = 4;         /* min repeat count */\n\n  /* tree[max_code+1].Len = -1; */  /* guard already set */\n  if (nextlen === 0) {\n    max_count = 138;\n    min_count = 3;\n  }\n\n  for (n = 0; n <= max_code; n++) {\n    curlen = nextlen;\n    nextlen = tree[(n + 1) * 2 + 1]/*.Len*/;\n\n    if (++count < max_count && curlen === nextlen) {\n      continue;\n\n    } else if (count < min_count) {\n      do { send_code(s, curlen, s.bl_tree); } while (--count !== 0);\n\n    } else if (curlen !== 0) {\n      if (curlen !== prevlen) {\n        send_code(s, curlen, s.bl_tree);\n        count--;\n      }\n      //Assert(count >= 3 && count <= 6, \" 3_6?\");\n      send_code(s, REP_3_6, s.bl_tree);\n      send_bits(s, count - 3, 2);\n\n    } else if (count <= 10) {\n      send_code(s, REPZ_3_10, s.bl_tree);\n      send_bits(s, count - 3, 3);\n\n    } else {\n      send_code(s, REPZ_11_138, s.bl_tree);\n      send_bits(s, count - 11, 7);\n    }\n\n    count = 0;\n    prevlen = curlen;\n    if (nextlen === 0) {\n      max_count = 138;\n      min_count = 3;\n\n    } else if (curlen === nextlen) {\n      max_count = 6;\n      min_count = 3;\n\n    } else {\n      max_count = 7;\n      min_count = 4;\n    }\n  }\n}\n\n\n/* ===========================================================================\n * Construct the Huffman tree for the bit lengths and return the index in\n * bl_order of the last bit length code to send.\n */\nfunction build_bl_tree(s) {\n  var max_blindex;  /* index of last bit length code of non zero freq */\n\n  /* Determine the bit length frequencies for literal and distance trees */\n  scan_tree(s, s.dyn_ltree, s.l_desc.max_code);\n  scan_tree(s, s.dyn_dtree, s.d_desc.max_code);\n\n  /* Build the bit length tree: */\n  build_tree(s, s.bl_desc);\n  /* opt_len now includes the length of the tree representations, except\n   * the lengths of the bit lengths codes and the 5+5+4 bits for the counts.\n   */\n\n  /* Determine the number of bit length codes to send. The pkzip format\n   * requires that at least 4 bit length codes be sent. (appnote.txt says\n   * 3 but the actual value used is 4.)\n   */\n  for (max_blindex = BL_CODES - 1; max_blindex >= 3; max_blindex--) {\n    if (s.bl_tree[bl_order[max_blindex] * 2 + 1]/*.Len*/ !== 0) {\n      break;\n    }\n  }\n  /* Update opt_len to include the bit length tree and counts */\n  s.opt_len += 3 * (max_blindex + 1) + 5 + 5 + 4;\n  //Tracev((stderr, \"\\ndyn trees: dyn %ld, stat %ld\",\n  //        s->opt_len, s->static_len));\n\n  return max_blindex;\n}\n\n\n/* ===========================================================================\n * Send the header for a block using dynamic Huffman trees: the counts, the\n * lengths of the bit length codes, the literal tree and the distance tree.\n * IN assertion: lcodes >= 257, dcodes >= 1, blcodes >= 4.\n */\nfunction send_all_trees(s, lcodes, dcodes, blcodes)\n//    deflate_state *s;\n//    int lcodes, dcodes, blcodes; /* number of codes for each tree */\n{\n  var rank;                    /* index in bl_order */\n\n  //Assert (lcodes >= 257 && dcodes >= 1 && blcodes >= 4, \"not enough codes\");\n  //Assert (lcodes <= L_CODES && dcodes <= D_CODES && blcodes <= BL_CODES,\n  //        \"too many codes\");\n  //Tracev((stderr, \"\\nbl counts: \"));\n  send_bits(s, lcodes - 257, 5); /* not +255 as stated in appnote.txt */\n  send_bits(s, dcodes - 1,   5);\n  send_bits(s, blcodes - 4,  4); /* not -3 as stated in appnote.txt */\n  for (rank = 0; rank < blcodes; rank++) {\n    //Tracev((stderr, \"\\nbl code %2d \", bl_order[rank]));\n    send_bits(s, s.bl_tree[bl_order[rank] * 2 + 1]/*.Len*/, 3);\n  }\n  //Tracev((stderr, \"\\nbl tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_ltree, lcodes - 1); /* literal tree */\n  //Tracev((stderr, \"\\nlit tree: sent %ld\", s->bits_sent));\n\n  send_tree(s, s.dyn_dtree, dcodes - 1); /* distance tree */\n  //Tracev((stderr, \"\\ndist tree: sent %ld\", s->bits_sent));\n}\n\n\n/* ===========================================================================\n * Check if the data type is TEXT or BINARY, using the following algorithm:\n * - TEXT if the two conditions below are satisfied:\n *    a) There are no non-portable control characters belonging to the\n *       \"black list\" (0..6, 14..25, 28..31).\n *    b) There is at least one printable character belonging to the\n *       \"white list\" (9 {TAB}, 10 {LF}, 13 {CR}, 32..255).\n * - BINARY otherwise.\n * - The following partially-portable control characters form a\n *   \"gray list\" that is ignored in this detection algorithm:\n *   (7 {BEL}, 8 {BS}, 11 {VT}, 12 {FF}, 26 {SUB}, 27 {ESC}).\n * IN assertion: the fields Freq of dyn_ltree are set.\n */\nfunction detect_data_type(s) {\n  /* black_mask is the bit mask of black-listed bytes\n   * set bits 0..6, 14..25, and 28..31\n   * 0xf3ffc07f = binary 11110011111111111100000001111111\n   */\n  var black_mask = 0xf3ffc07f;\n  var n;\n\n  /* Check for non-textual (\"black-listed\") bytes. */\n  for (n = 0; n <= 31; n++, black_mask >>>= 1) {\n    if ((black_mask & 1) && (s.dyn_ltree[n * 2]/*.Freq*/ !== 0)) {\n      return Z_BINARY;\n    }\n  }\n\n  /* Check for textual (\"white-listed\") bytes. */\n  if (s.dyn_ltree[9 * 2]/*.Freq*/ !== 0 || s.dyn_ltree[10 * 2]/*.Freq*/ !== 0 ||\n      s.dyn_ltree[13 * 2]/*.Freq*/ !== 0) {\n    return Z_TEXT;\n  }\n  for (n = 32; n < LITERALS; n++) {\n    if (s.dyn_ltree[n * 2]/*.Freq*/ !== 0) {\n      return Z_TEXT;\n    }\n  }\n\n  /* There are no \"black-listed\" or \"white-listed\" bytes:\n   * this stream either is empty or has tolerated (\"gray-listed\") bytes only.\n   */\n  return Z_BINARY;\n}\n\n\nvar static_init_done = false;\n\n/* ===========================================================================\n * Initialize the tree data structures for a new zlib stream.\n */\nfunction _tr_init(s)\n{\n\n  if (!static_init_done) {\n    tr_static_init();\n    static_init_done = true;\n  }\n\n  s.l_desc  = new TreeDesc(s.dyn_ltree, static_l_desc);\n  s.d_desc  = new TreeDesc(s.dyn_dtree, static_d_desc);\n  s.bl_desc = new TreeDesc(s.bl_tree, static_bl_desc);\n\n  s.bi_buf = 0;\n  s.bi_valid = 0;\n\n  /* Initialize the first block of the first file: */\n  init_block(s);\n}\n\n\n/* ===========================================================================\n * Send a stored block\n */\nfunction _tr_stored_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  send_bits(s, (STORED_BLOCK << 1) + (last ? 1 : 0), 3);    /* send block type */\n  copy_block(s, buf, stored_len, true); /* with header */\n}\n\n\n/* ===========================================================================\n * Send one empty static block to give enough lookahead for inflate.\n * This takes 10 bits, of which 7 may remain in the bit buffer.\n */\nfunction _tr_align(s) {\n  send_bits(s, STATIC_TREES << 1, 3);\n  send_code(s, END_BLOCK, static_ltree);\n  bi_flush(s);\n}\n\n\n/* ===========================================================================\n * Determine the best encoding for the current block: dynamic trees, static\n * trees or store, and output the encoded block to the zip file.\n */\nfunction _tr_flush_block(s, buf, stored_len, last)\n//DeflateState *s;\n//charf *buf;       /* input block, or NULL if too old */\n//ulg stored_len;   /* length of input block */\n//int last;         /* one if this is the last block for a file */\n{\n  var opt_lenb, static_lenb;  /* opt_len and static_len in bytes */\n  var max_blindex = 0;        /* index of last bit length code of non zero freq */\n\n  /* Build the Huffman trees unless a stored block is forced */\n  if (s.level > 0) {\n\n    /* Check if the file is binary or text */\n    if (s.strm.data_type === Z_UNKNOWN) {\n      s.strm.data_type = detect_data_type(s);\n    }\n\n    /* Construct the literal and distance trees */\n    build_tree(s, s.l_desc);\n    // Tracev((stderr, \"\\nlit data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n\n    build_tree(s, s.d_desc);\n    // Tracev((stderr, \"\\ndist data: dyn %ld, stat %ld\", s->opt_len,\n    //        s->static_len));\n    /* At this point, opt_len and static_len are the total bit lengths of\n     * the compressed block data, excluding the tree representations.\n     */\n\n    /* Build the bit length tree for the above two trees, and get the index\n     * in bl_order of the last bit length code to send.\n     */\n    max_blindex = build_bl_tree(s);\n\n    /* Determine the best encoding. Compute the block lengths in bytes. */\n    opt_lenb = (s.opt_len + 3 + 7) >>> 3;\n    static_lenb = (s.static_len + 3 + 7) >>> 3;\n\n    // Tracev((stderr, \"\\nopt %lu(%lu) stat %lu(%lu) stored %lu lit %u \",\n    //        opt_lenb, s->opt_len, static_lenb, s->static_len, stored_len,\n    //        s->last_lit));\n\n    if (static_lenb <= opt_lenb) { opt_lenb = static_lenb; }\n\n  } else {\n    // Assert(buf != (char*)0, \"lost buf\");\n    opt_lenb = static_lenb = stored_len + 5; /* force a stored block */\n  }\n\n  if ((stored_len + 4 <= opt_lenb) && (buf !== -1)) {\n    /* 4: two words for the lengths */\n\n    /* The test buf != NULL is only necessary if LIT_BUFSIZE > WSIZE.\n     * Otherwise we can't have processed more than WSIZE input bytes since\n     * the last block flush, because compression would have been\n     * successful. If LIT_BUFSIZE <= WSIZE, it is never too late to\n     * transform a block into a stored block.\n     */\n    _tr_stored_block(s, buf, stored_len, last);\n\n  } else if (s.strategy === Z_FIXED || static_lenb === opt_lenb) {\n\n    send_bits(s, (STATIC_TREES << 1) + (last ? 1 : 0), 3);\n    compress_block(s, static_ltree, static_dtree);\n\n  } else {\n    send_bits(s, (DYN_TREES << 1) + (last ? 1 : 0), 3);\n    send_all_trees(s, s.l_desc.max_code + 1, s.d_desc.max_code + 1, max_blindex + 1);\n    compress_block(s, s.dyn_ltree, s.dyn_dtree);\n  }\n  // Assert (s->compressed_len == s->bits_sent, \"bad compressed size\");\n  /* The above check is made mod 2^32, for files larger than 512 MB\n   * and uLong implemented on 32 bits.\n   */\n  init_block(s);\n\n  if (last) {\n    bi_windup(s);\n  }\n  // Tracev((stderr,\"\\ncomprlen %lu(%lu) \", s->compressed_len>>3,\n  //       s->compressed_len-7*last));\n}\n\n/* ===========================================================================\n * Save the match info and tally the frequency counts. Return true if\n * the current block must be flushed.\n */\nfunction _tr_tally(s, dist, lc)\n//    deflate_state *s;\n//    unsigned dist;  /* distance of matched string */\n//    unsigned lc;    /* match length-MIN_MATCH or unmatched char (if dist==0) */\n{\n  //var out_length, in_length, dcode;\n\n  s.pending_buf[s.d_buf + s.last_lit * 2]     = (dist >>> 8) & 0xff;\n  s.pending_buf[s.d_buf + s.last_lit * 2 + 1] = dist & 0xff;\n\n  s.pending_buf[s.l_buf + s.last_lit] = lc & 0xff;\n  s.last_lit++;\n\n  if (dist === 0) {\n    /* lc is the unmatched char */\n    s.dyn_ltree[lc * 2]/*.Freq*/++;\n  } else {\n    s.matches++;\n    /* Here, lc is the match length - MIN_MATCH */\n    dist--;             /* dist = match distance - 1 */\n    //Assert((ush)dist < (ush)MAX_DIST(s) &&\n    //       (ush)lc <= (ush)(MAX_MATCH-MIN_MATCH) &&\n    //       (ush)d_code(dist) < (ush)D_CODES,  \"_tr_tally: bad match\");\n\n    s.dyn_ltree[(_length_code[lc] + LITERALS + 1) * 2]/*.Freq*/++;\n    s.dyn_dtree[d_code(dist) * 2]/*.Freq*/++;\n  }\n\n// (!) This block is disabled in zlib defailts,\n// don't enable it for binary compatibility\n\n//#ifdef TRUNCATE_BLOCK\n//  /* Try to guess if it is profitable to stop the current block here */\n//  if ((s.last_lit & 0x1fff) === 0 && s.level > 2) {\n//    /* Compute an upper bound for the compressed length */\n//    out_length = s.last_lit*8;\n//    in_length = s.strstart - s.block_start;\n//\n//    for (dcode = 0; dcode < D_CODES; dcode++) {\n//      out_length += s.dyn_dtree[dcode*2]/*.Freq*/ * (5 + extra_dbits[dcode]);\n//    }\n//    out_length >>>= 3;\n//    //Tracev((stderr,\"\\nlast_lit %u, in %ld, out ~%ld(%ld%%) \",\n//    //       s->last_lit, in_length, out_length,\n//    //       100L - out_length*100L/in_length));\n//    if (s.matches < (s.last_lit>>1)/*int /2*/ && out_length < (in_length>>1)/*int /2*/) {\n//      return true;\n//    }\n//  }\n//#endif\n\n  return (s.last_lit === s.lit_bufsize - 1);\n  /* We avoid equality with lit_bufsize because of wraparound at 64K\n   * on 16 bit machines and because stored blocks are restricted to\n   * 64K-1 bytes.\n   */\n}\n\nexports._tr_init  = _tr_init;\nexports._tr_stored_block = _tr_stored_block;\nexports._tr_flush_block  = _tr_flush_block;\nexports._tr_tally = _tr_tally;\nexports._tr_align = _tr_align;\n\n},{\"../utils/common\":3}],15:[function(require,module,exports){\n'use strict';\n\n// (C) 1995-2013 Jean-loup Gailly and Mark Adler\n// (C) 2014-2017 Vitaly Puzrin and Andrey Tupitsin\n//\n// This software is provided 'as-is', without any express or implied\n// warranty. In no event will the authors be held liable for any damages\n// arising from the use of this software.\n//\n// Permission is granted to anyone to use this software for any purpose,\n// including commercial applications, and to alter it and redistribute it\n// freely, subject to the following restrictions:\n//\n// 1. The origin of this software must not be misrepresented; you must not\n//   claim that you wrote the original software. If you use this software\n//   in a product, an acknowledgment in the product documentation would be\n//   appreciated but is not required.\n// 2. Altered source versions must be plainly marked as such, and must not be\n//   misrepresented as being the original software.\n// 3. This notice may not be removed or altered from any source distribution.\n\nfunction ZStream() {\n  /* next input byte */\n  this.input = null; // JS specific, because we have no pointers\n  this.next_in = 0;\n  /* number of bytes available at input */\n  this.avail_in = 0;\n  /* total number of input bytes read so far */\n  this.total_in = 0;\n  /* next output byte should be put there */\n  this.output = null; // JS specific, because we have no pointers\n  this.next_out = 0;\n  /* remaining free space at output */\n  this.avail_out = 0;\n  /* total number of bytes output so far */\n  this.total_out = 0;\n  /* last error message, NULL if no error */\n  this.msg = ''/*Z_NULL*/;\n  /* not visible by applications */\n  this.state = null;\n  /* best guess about the data type: binary or text */\n  this.data_type = 2/*Z_UNKNOWN*/;\n  /* adler32 value of the uncompressed data */\n  this.adler = 0;\n}\n\nmodule.exports = ZStream;\n\n},{}],\"/\":[function(require,module,exports){\n// Top level file is just a mixin of submodules & constants\n'use strict';\n\nvar assign    = require('./lib/utils/common').assign;\n\nvar deflate   = require('./lib/deflate');\nvar inflate   = require('./lib/inflate');\nvar constants = require('./lib/zlib/constants');\n\nvar pako = {};\n\nassign(pako, deflate, inflate, constants);\n\nmodule.exports = pako;\n\n},{\"./lib/deflate\":1,\"./lib/inflate\":2,\"./lib/utils/common\":3,\"./lib/zlib/constants\":6}]},{},[])(\"/\")\n});"},function(t,n){t.exports='/**\n * alertify\n * An unobtrusive customizable JavaScript notification system\n *\n * @author Fabien Doiron <fabien.doiron@gmail.com>\n * @copyright Fabien Doiron 2013\n * @license MIT <http://opensource.org/licenses/mit-license.php>\n * @link http://fabien-d.github.com/alertify.js/\n * @module alertify\n * @version 0.3.11\n */\n(function (global, undefined) {\n\t"use strict";\n\n\tvar document = global.document,\n\t    Alertify;\n\n\tAlertify = function () {\n\n\t\tvar _alertify = {},\n\t\t    dialogs   = {},\n\t\t    isopen    = false,\n\t\t    keys      = { ENTER: 13, ESC: 27, SPACE: 32 },\n\t\t    queue     = [],\n\t\t    $, btnCancel, btnOK, btnReset, btnResetBack, btnFocus, elCallee, elCover, elDialog, elLog, form, option,input, getTransitionEvent;\n\n\t\t/**\n\t\t * Markup pieces\n\t\t * @type {Object}\n\t\t */\n\t\tdialogs = {\n\t\t\tbuttons : {\n\t\t\t\tholder : "<nav class=\\"alertify-buttons\\">{{buttons}}</nav>",\n\t\t\t\tsubmit : "<button type=\\"submit\\" class=\\"alertify-button alertify-button-ok\\" id=\\"alertify-ok\\">{{ok}}</button>",\n\t\t\t\tok     : "<button class=\\"alertify-button alertify-button-ok\\" id=\\"alertify-ok\\">{{ok}}</button>",\n\t\t\t\tcancel : "<button class=\\"alertify-button alertify-button-cancel\\" id=\\"alertify-cancel\\">{{cancel}}</button>"\n\t\t\t},\n\t\t\tinput   : "<div class=\\"alertify-text-wrapper\\"><input type=\\"text\\" class=\\"alertify-text\\" id=\\"alertify-text\\"></div>",\n\t\t\tmessage : "<p class=\\"alertify-message\\">{{message}}</p>",\n\t\t\tlog     : "<article class=\\"alertify-log{{class}}\\">{{message}}</article>"\n\t\t};\n\n\t\t/**\n\t\t * Return the proper transitionend event\n\t\t * @return {String}    Transition type string\n\t\t */\n\t\tgetTransitionEvent = function () {\n\t\t\tvar t,\n\t\t\t    type,\n\t\t\t    supported   = false,\n\t\t\t    el          = document.createElement("fakeelement"),\n\t\t\t    transitions = {\n\t\t\t\t    "WebkitTransition" : "webkitTransitionEnd",\n\t\t\t\t    "MozTransition"    : "transitionend",\n\t\t\t\t    "OTransition"      : "otransitionend",\n\t\t\t\t    "transition"       : "transitionend"\n\t\t\t    };\n\n\t\t\tfor (t in transitions) {\n\t\t\t\tif (el.style[t] !== undefined) {\n\t\t\t\t\ttype      = transitions[t];\n\t\t\t\t\tsupported = true;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn {\n\t\t\t\ttype      : type,\n\t\t\t\tsupported : supported\n\t\t\t};\n\t\t};\n\n\t\t/**\n\t\t * Shorthand for document.getElementById()\n\t\t *\n\t\t * @param  {String} id    A specific element ID\n\t\t * @return {Object}       HTML element\n\t\t */\n\t\t$ = function (id) {\n\t\t\treturn document.getElementById(id);\n\t\t};\n\n\t\t/**\n\t\t * Alertify private object\n\t\t * @type {Object}\n\t\t */\n\t\t_alertify = {\n\n\t\t\t/**\n\t\t\t * Labels object\n\t\t\t * @type {Object}\n\t\t\t */\n\t\t\tlabels : {\n\t\t\t\tok     : "OK",\n\t\t\t\tcancel : "Cancel"\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Delay number\n\t\t\t * @type {Number}\n\t\t\t */\n\t\t\tdelay : 5000,\n\n\t\t\t/**\n\t\t\t * Whether buttons are reversed (default is secondary/primary)\n\t\t\t * @type {Boolean}\n\t\t\t */\n\t\t\tbuttonReverse : false,\n\n\t\t\t/**\n\t\t\t * Which button should be focused by default\n\t\t\t * @type {String}\t"ok" (default), "cancel", or "none"\n\t\t\t */\n\t\t\tbuttonFocus : "ok",\n\n\t\t\t/**\n\t\t\t * Set the transition event on load\n\t\t\t * @type {[type]}\n\t\t\t */\n\t\t\ttransition : undefined,\n\n\t\t\t/**\n\t\t\t * Set the proper button click events\n\t\t\t *\n\t\t\t * @param {Function} fn    [Optional] Callback function\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\taddListeners : function (fn) {\n\t\t\t\tvar hasOK     = (typeof btnOK !== "undefined"),\n\t\t\t\t    hasCancel = (typeof btnCancel !== "undefined"),\n\t\t\t\t    hasInput  = (typeof input !== "undefined"),\n\t\t\t\t    hasOption  = (typeof option !== "undefined"),\n\t\t\t\t    val       = "",\n\t\t\t\t    self      = this,\n\t\t\t\t    ok, cancel, common, key, reset;\n\n\t\t\t\t// ok event handler\n\t\t\t\tok = function (event) {\n\t\t\t\t\tif (typeof event.preventDefault !== "undefined") event.preventDefault();\n\t\t\t\t\tcommon(event);\n\t\t\t\t\tif (typeof input !== "undefined") {\n\t\t\t\t\t\tif (input.length>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tval = [];\n\t\t\t\t\t\t\tfor (var k = 0; k <input.length;k++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tval[k] = input[k].value;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (val.length == 1)\n\t\t\t\t\t\t\t\tval = val[0];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\t \n\t\t\t\t\t\t\tval = input.value;\t\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof option !== "undefined")\n\t\t\t\t\t{\n\t\t\t\t\t\tval = {str:val,option:option.value};\n\t\t\t\t\t}\n\t\t\t\t\tif (typeof fn === "function") {\n\t\t\t\t\t\tif (typeof input !== "undefined") {\n\t\t\t\t\t\t\tfn(true, val);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse fn(true);\n\t\t\t\t\t}\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\n\t\t\t\t// cancel event handler\n\t\t\t\tcancel = function (event) {\n\t\t\t\t\tif (typeof event.preventDefault !== "undefined") event.preventDefault();\n\t\t\t\t\tcommon(event);\n\t\t\t\t\tif (typeof fn === "function") fn(false);\n\t\t\t\t\treturn false;\n\t\t\t\t};\n\n\t\t\t\t// common event handler (keyup, ok and cancel)\n\t\t\t\tcommon = function (event) {\n\t\t\t\t\tself.hide();\n\t\t\t\t\tself.unbind(document.body, "keyup", key);\n\t\t\t\t\tself.unbind(btnReset, "focus", reset);\n\t\t\t\t\tif (hasOK) self.unbind(btnOK, "click", ok);\n\t\t\t\t\tif (hasCancel) self.unbind(btnCancel, "click", cancel);\n\t\t\t\t};\n\n\t\t\t\t// keyup handler\n\t\t\t\tkey = function (event) {\n\t\t\t\t\tvar keyCode = event.keyCode;\n\t\t\t\t\tif ((keyCode === keys.SPACE && !hasInput) || (hasInput && keyCode === keys.ENTER)) ok(event);\n\t\t\t\t\tif (keyCode === keys.ESC && hasCancel) cancel(event);\n\t\t\t\t};\n\n\t\t\t\t// reset focus to first item in the dialog\n\t\t\t\treset = function (event) {\n\t\t\t\t\tif (hasInput) input.focus();\n\t\t\t\t\telse if (!hasCancel || self.buttonReverse) btnOK.focus();\n\t\t\t\t\telse btnCancel.focus();\n\t\t\t\t};\n\n\t\t\t\t// handle reset focus link\n\t\t\t\t// this ensures that the keyboard focus does not\n\t\t\t\t// ever leave the dialog box until an action has\n\t\t\t\t// been taken\n\t\t\t\tthis.bind(btnReset, "focus", reset);\n\t\t\t\tthis.bind(btnResetBack, "focus", reset);\n\t\t\t\t// handle OK click\n\t\t\t\tif (hasOK) this.bind(btnOK, "click", ok);\n\t\t\t\t// handle Cancel click\n\t\t\t\tif (hasCancel) this.bind(btnCancel, "click", cancel);\n\t\t\t\t// listen for keys, Cancel => ESC\n\t\t\t\tthis.bind(document.body, "keyup", key);\n\t\t\t\tif (!this.transition.supported) {\n\t\t\t\t\tthis.setFocus();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Bind events to elements\n\t\t\t *\n\t\t\t * @param  {Object}   el       HTML Object\n\t\t\t * @param  {Event}    event    Event to attach to element\n\t\t\t * @param  {Function} fn       Callback function\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\tbind : function (el, event, fn) {\n\t\t\t\tif (typeof el.addEventListener === "function") {\n\t\t\t\t\tel.addEventListener(event, fn, false);\n\t\t\t\t} else if (el.attachEvent) {\n\t\t\t\t\tel.attachEvent("on" + event, fn);\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Use alertify as the global error handler (using window.onerror)\n\t\t\t *\n\t\t\t * @return {boolean} success\n\t\t\t */\n\t\t\thandleErrors : function () {\n\t\t\t\tif (typeof global.onerror !== "undefined") {\n\t\t\t\t\tvar self = this;\n\t\t\t\t\tglobal.onerror = function (msg, url, line) {\n\t\t\t\t\t\tself.error("[" + msg + " on line " + line + " of " + url + "]", 0);\n\t\t\t\t\t};\n\t\t\t\t\treturn true;\n\t\t\t\t} else {\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Append button HTML strings\n\t\t\t *\n\t\t\t * @param {String} secondary    The secondary button HTML string\n\t\t\t * @param {String} primary      The primary button HTML string\n\t\t\t *\n\t\t\t * @return {String}             The appended button HTML strings\n\t\t\t */\n\t\t\tappendButtons : function (secondary, primary) {\n\t\t\t\treturn this.buttonReverse ? primary + secondary : secondary + primary;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Build the proper message box\n\t\t\t *\n\t\t\t * @param  {Object} item    Current object in the queue\n\t\t\t *\n\t\t\t * @return {String}         An HTML string of the message box\n\t\t\t */\n\t\t\tbuild : function (item) {\n\t\t\t\tvar html    = "",\n\t\t\t\t    type    = item.type,\n\t\t\t\t    messageObj = item.message,\n\t\t\t\t    css     = item.cssClass || "";\n                var message;\n\t\t\t\t\n\t\t\t\tif ( messageObj.msg != undefined )\n\t\t\t\t\tmessage = messageObj.msg;\n\t\t\t\telse\n\t\t\t\t\tmessage = messageObj;\t\n\t\t\t\t\t\n\n\t\t\t\thtml += "<div class=\\"alertify-dialog\\">";\n\t\t\t\thtml += "<a id=\\"alertify-resetFocusBack\\" class=\\"alertify-resetFocus\\" href=\\"#\\">Reset Focus</a>";\n\n\t\t\t\tif (_alertify.buttonFocus === "none") html += "<a href=\\"#\\" id=\\"alertify-noneFocus\\" class=\\"alertify-hidden\\"></a>";\n\n\t\t\t\t// doens\'t require an actual form\n\t\t\t\tif (type === "prompt") html += "<div id=\\"alertify-form\\">";\n\n\t\t\t\thtml += "<article class=\\"alertify-inner\\">";\n\n\t\t\t\tif (Array.isArray(messageObj))\n\t\t\t\t{\n\t\t\t\t\tfor (var k = 0; k < message.length;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (message[k].msg != undefined)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t    html += dialogs.message.replace("{{message}}", message[k].msg);                        \n\t\t\t\t\t\t}\n\t\t\t\t\t\t else\n\t\t\t\t\t\t    html += dialogs.message.replace("{{message}}", message[k]);\n\n\n\n\t\t\t\t\t\tif (type === "prompt") \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar x = dialogs.input.replace(\'id="alertify-text"\',\'autocomplete=off id="alertify-text\'+k+\'"\')\n\t\t\t\t\t\t\thtml += x;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (message[k].msg != undefined)\n    \t\t\t\t\t\tif (message[k].addon != undefined)\n\t\t\t\t\t\t        html += message[k].addon\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\thtml += dialogs.message.replace("{{message}}", message);\n\t\t\t\t\tif (type === "prompt") \n\t\t\t\t\t\thtml += dialogs.input;\n\t\t\t\t}\n\n\t\t\t\tif (messageObj.opt != undefined)\n\t\t\t\t{\n\t\t\t\t\thtml += messageObj.optMsg;\n\t\t\t\t\thtml += "<select  class=\\"alertify-option\\"  id=\\"alertify-option\\">";\n\t\t\t\t\tfor (var k = 0; k < messageObj.opt.length;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\thtml += "<option>" +  messageObj.opt[k] + "</option>";\n\n\t\t\t\t\t}\n\t\t\t\t\thtml += "</select>";\n\t\t\t\t}\n\n\t\t\t\thtml += dialogs.buttons.holder;\n\t\t\t\thtml += "</article>";\n\n\t\t\t\tif (type === "prompt") html += "</div>";\n\n\t\t\t\thtml += "<a id=\\"alertify-resetFocus\\" class=\\"alertify-resetFocus\\" href=\\"#\\">Reset Focus</a>";\n\t\t\t\thtml += "</div>";\n\n\t\t\t\tswitch (type) {\n\t\t\t\tcase "confirm":\n\t\t\t\t\thtml = html.replace("{{buttons}}", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.ok));\n\t\t\t\t\thtml = html.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);\n\t\t\t\t\tbreak;\n\t\t\t\tcase "prompt":\n\t\t\t\t\thtml = html.replace("{{buttons}}", this.appendButtons(dialogs.buttons.cancel, dialogs.buttons.submit));\n\t\t\t\t\thtml = html.replace("{{ok}}", this.labels.ok).replace("{{cancel}}", this.labels.cancel);\n\t\t\t\t\tbreak;\n\t\t\t\tcase "alert":\n\t\t\t\t\thtml = html.replace("{{buttons}}", dialogs.buttons.ok);\n\t\t\t\t\thtml = html.replace("{{ok}}", this.labels.ok);\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\telDialog.className = "alertify alertify-" + type + " " + css;\n\t\t\t\telCover.className  = "alertify-cover";\n\t\t\t\treturn html;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Close the log messages\n\t\t\t *\n\t\t\t * @param  {Object} elem    HTML Element of log message to close\n\t\t\t * @param  {Number} wait    [optional] Time (in ms) to wait before automatically hiding the message, if 0 never hide\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\tclose : function (elem, wait) {\n\t\t\t\t// Unary Plus: +"2" === 2\n\t\t\t\tvar timer = (wait && !isNaN(wait)) ? +wait : this.delay,\n\t\t\t\t    self  = this,\n\t\t\t\t    hideElement, transitionDone;\n\n\t\t\t\t// set click event on log messages\n\t\t\t\tthis.bind(elem, "click", function () {\n\t\t\t\t\thideElement(elem);\n\t\t\t\t});\n\t\t\t\t// Hide the dialog box after transition\n\t\t\t\t// This ensure it doens\'t block any element from being clicked\n\t\t\t\ttransitionDone = function (event) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t// unbind event so function only gets called once\n\t\t\t\t\tself.unbind(this, self.transition.type, transitionDone);\n\t\t\t\t\t// remove log message\n\t\t\t\t\telLog.removeChild(this);\n\t\t\t\t\tif (!elLog.hasChildNodes()) elLog.className += " alertify-logs-hidden";\n\t\t\t\t};\n\t\t\t\t// this sets the hide class to transition out\n\t\t\t\t// or removes the child if css transitions aren\'t supported\n\t\t\t\thideElement = function (el) {\n\t\t\t\t\t// ensure element exists\n\t\t\t\t\tif (typeof el !== "undefined" && el.parentNode === elLog) {\n\t\t\t\t\t\t// whether CSS transition exists\n\t\t\t\t\t\tif (self.transition.supported) {\n\t\t\t\t\t\t\tself.bind(el, self.transition.type, transitionDone);\n\t\t\t\t\t\t\tel.className += " alertify-log-hide";\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\telLog.removeChild(el);\n\t\t\t\t\t\t\tif (!elLog.hasChildNodes()) elLog.className += " alertify-logs-hidden";\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t\t// never close (until click) if wait is set to 0\n\t\t\t\tif (wait === 0) return;\n\t\t\t\t// set timeout to auto close the log message\n\t\t\t\tsetTimeout(function () { hideElement(elem); }, timer);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Create a dialog box\n\t\t\t *\n\t\t\t * @param  {String}   message        The message passed from the callee\n\t\t\t * @param  {String}   type           Type of dialog to create\n\t\t\t * @param  {Function} fn             [Optional] Callback function\n\t\t\t * @param  {String}   placeholder    [Optional] Default value for prompt input field\n\t\t\t * @param  {String}   cssClass       [Optional] Class(es) to append to dialog box\n\t\t\t *\n\t\t\t * @return {Object}\n\t\t\t */\n\t\t\tdialog : function (message, type, fn, placeholder, cssClass) {\n\t\t\t\t// set the current active element\n\t\t\t\t// this allows the keyboard focus to be resetted\n\t\t\t\t// after the dialog box is closedplaceholderplaceholder\n\t\t\t\telCallee = document.activeElement;\n\t\t\t\t// check to ensure the alertify dialog element\n\t\t\t\t// has been successfully created\n\t\t\t\tvar check = function () {\n\t\t\t\t\tif ((elLog && elLog.scrollTop !== null) && (elCover && elCover.scrollTop !== null)) return;\n\t\t\t\t\telse check();\n\t\t\t\t};\n\t\t\t\t// error catching\n\t\t\t\tif (typeof type !== "string") throw new Error("type must be a string");\n\t\t\t\tif (typeof fn !== "undefined" && typeof fn !== "function") throw new Error("fn must be a function");\n\t\t\t\t// initialize alertify if it hasn\'t already been done\n\t\t\t\tthis.init();\n\t\t\t\tcheck();\n\n\t\t\t\tqueue.push({ type: type, message: message, callback: fn, placeholder: placeholder, cssClass: cssClass });\n\t\t\t\tif (!isopen) this.setup();\n\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Extend the log method to create custom methods\n\t\t\t *\n\t\t\t * @param  {String} type    Custom method name\n\t\t\t *\n\t\t\t * @return {Function}\n\t\t\t */\n\t\t\textend : function (type) {\n\t\t\t\tif (typeof type !== "string") throw new Error("extend method must have exactly one paramter");\n\t\t\t\treturn function (message, wait) {\n\t\t\t\t\tthis.log(message, type, wait);\n\t\t\t\t\treturn this;\n\t\t\t\t};\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Hide the dialog and rest to defaults\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\thide : function () {\n\t\t\t\tvar transitionDone,\n\t\t\t\t    self = this;\n\t\t\t\t// remove reference from queue\n\t\t\t\tqueue.splice(0,1);\n\t\t\t\t// if items remaining in the queue\n\t\t\t\tif (queue.length > 0) this.setup(true);\n\t\t\t\telse {\n\t\t\t\t\tisopen = false;\n\t\t\t\t\t// Hide the dialog box after transition\n\t\t\t\t\t// This ensure it doens\'t block any element from being clicked\n\t\t\t\t\ttransitionDone = function (event) {\n\t\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\t\t// unbind event so function only gets called once\n\t\t\t\t\t\tself.unbind(elDialog, self.transition.type, transitionDone);\n\t\t\t\t\t};\n\t\t\t\t\t// whether CSS transition exists\n\t\t\t\t\tif (this.transition.supported) {\n\t\t\t\t\t\tthis.bind(elDialog, this.transition.type, transitionDone);\n\t\t\t\t\t\telDialog.className = "alertify alertify-hide alertify-hidden";\n\t\t\t\t\t} else {\n\t\t\t\t\t\telDialog.className = "alertify alertify-hide alertify-hidden alertify-isHidden";\n\t\t\t\t\t}\n\t\t\t\t\telCover.className  = "alertify-cover alertify-cover-hidden";\n\t\t\t\t\t// set focus to the last element or body\n\t\t\t\t\t// after the dialog is closed\n\t\t\t\t\telCallee.focus();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Initialize Alertify\n\t\t\t * Create the 2 main elements\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\tinit : function () {\n\t\t\t\t// ensure legacy browsers support html5 tags\n\t\t\t\tdocument.createElement("nav");\n\t\t\t\tdocument.createElement("article");\n\t\t\t\tdocument.createElement("section");\n\t\t\t\t// cover\n\t\t\t\tif ($("alertify-cover") == null) {\n\t\t\t\t\telCover = document.createElement("div");\n\t\t\t\t\telCover.setAttribute("id", "alertify-cover");\n\t\t\t\t\telCover.className = "alertify-cover alertify-cover-hidden";\n\t\t\t\t\tdocument.body.appendChild(elCover);\n\t\t\t\t}\n\t\t\t\t// main element\n\t\t\t\tif ($("alertify") == null) {\n\t\t\t\t\tisopen = false;\n\t\t\t\t\tqueue = [];\n\t\t\t\t\telDialog = document.createElement("section");\n\t\t\t\t\telDialog.setAttribute("id", "alertify");\n\t\t\t\t\telDialog.className = "alertify alertify-hidden";\n\t\t\t\t\tdocument.body.appendChild(elDialog);\n\t\t\t\t}\n\t\t\t\t// log element\n\t\t\t\tif ($("alertify-logs") == null) {\n\t\t\t\t\telLog = document.createElement("section");\n\t\t\t\t\telLog.setAttribute("id", "alertify-logs");\n\t\t\t\t\telLog.className = "alertify-logs alertify-logs-hidden";\n\t\t\t\t\tdocument.body.appendChild(elLog);\n\t\t\t\t}\n\t\t\t\t// set tabindex attribute on body element\n\t\t\t\t// this allows script to give it focus\n\t\t\t\t// after the dialog is closed\n\t\t\t\tdocument.body.setAttribute("tabindex", "0");\n\t\t\t\t// set transition type\n\t\t\t\tthis.transition = getTransitionEvent();\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Show a new log message box\n\t\t\t *\n\t\t\t * @param  {String} message    The message passed from the callee\n\t\t\t * @param  {String} type       [Optional] Optional type of log message\n\t\t\t * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding the log\n\t\t\t *\n\t\t\t * @return {Object}\n\t\t\t */\n\t\t\tlog : function (message, type, wait) {\n\t\t\t\t// check to ensure the alertify dialog element\n\t\t\t\t// has been successfully created\n\t\t\t\tvar check = function () {\n\t\t\t\t\tif (elLog && elLog.scrollTop !== null) return;\n\t\t\t\t\telse check();\n\t\t\t\t};\n\t\t\t\t// initialize alertify if it hasn\'t already been done\n\t\t\t\tthis.init();\n\t\t\t\tcheck();\n\n\t\t\t\telLog.className = "alertify-logs";\n\t\t\t\tthis.notify(message, type, wait);\n\t\t\t\treturn this;\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Add new log message\n\t\t\t * If a type is passed, a class name "alertify-log-{type}" will get added.\n\t\t\t * This allows for custom look and feel for various types of notifications.\n\t\t\t *\n\t\t\t * @param  {String} message    The message passed from the callee\n\t\t\t * @param  {String} type       [Optional] Type of log message\n\t\t\t * @param  {Number} wait       [Optional] Time (in ms) to wait before auto-hiding\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\tnotify : function (message, type, wait) {\n\t\t\t\tvar log = document.createElement("article");\n\t\t\t\tlog.className = "alertify-log" + ((typeof type === "string" && type !== "") ? " alertify-log-" + type : "");\n\t\t\t\tlog.innerHTML = message;\n\t\t\t\t// append child\n\t\t\t\telLog.appendChild(log);\n\t\t\t\t// triggers the CSS animation\n\t\t\t\tsetTimeout(function() { log.className = log.className + " alertify-log-show"; }, 50);\n\t\t\t\tthis.close(log, wait);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Set properties\n\t\t\t *\n\t\t\t * @param {Object} args     Passing parameters\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\tset : function (args) {\n\t\t\t\tvar k;\n\t\t\t\t// error catching\n\t\t\t\tif (typeof args !== "object" && args instanceof Array) throw new Error("args must be an object");\n\t\t\t\t// set parameters\n\t\t\t\tfor (k in args) {\n\t\t\t\t\tif (args.hasOwnProperty(k)) {\n\t\t\t\t\t\tthis[k] = args[k];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Common place to set focus to proper element\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\tsetFocus : function () {\n\t\t\t\tif (input) {\n\t\t\t\t\tinput.focus();\n\t\t\t\t\tinput.select();\n\t\t\t\t}\n\t\t\t\telse btnFocus.focus();\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Initiate all the required pieces for the dialog box\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\tsetup : function (fromQueue) {\n\t\t\t\tvar item = queue[0],\n\t\t\t\t    self = this,\n\t\t\t\t    transitionDone;\n\n\t\t\t\t// dialog is open\n\t\t\t\tisopen = true;\n\t\t\t\t// Set button focus after transition\n\t\t\t\ttransitionDone = function (event) {\n\t\t\t\t\tevent.stopPropagation();\n\t\t\t\t\tself.setFocus();\n\t\t\t\t\t// unbind event so function only gets called once\n\t\t\t\t\tself.unbind(elDialog, self.transition.type, transitionDone);\n\t\t\t\t};\n\t\t\t\t// whether CSS transition exists\n\t\t\t\tif (this.transition.supported && !fromQueue) {\n\t\t\t\t\tthis.bind(elDialog, this.transition.type, transitionDone);\n\t\t\t\t}\n\t\t\t\t// build the proper dialog HTML\n\t\t\t\telDialog.innerHTML = this.build(item);\n\t\t\t\t// assign all the common elements\n\t\t\t\tbtnReset  = $("alertify-resetFocus");\n\t\t\t\tbtnResetBack  = $("alertify-resetFocusBack");\n\t\t\t\tbtnOK     = $("alertify-ok")     || undefined;\n\t\t\t\tbtnCancel = $("alertify-cancel") || undefined;\n\t\t\t\tbtnFocus  = (_alertify.buttonFocus === "cancel") ? btnCancel : ((_alertify.buttonFocus === "none") ? $("alertify-noneFocus") : btnOK),\n\t\t\t\tinput     = jQuery(".alertify-text")  || undefined;\n\t\t\t\toption     = $("alertify-option")   || undefined;\n\t\t\t\tform      = $("alertify-form")   || undefined;\n\t\t\t\t// add placeholder value to the input field\n\t\t\t\tif (typeof item.placeholder === "string" && item.placeholder !== "")\n\t\t\t\t{ input[0].value = item.placeholder;\n\t\t\t\t}\n\t\t\t\tif (typeof item.placeholder === "object") \n\t\t\t\t{\n\t\t\t\t\tfor (var k = 0; k < item.placeholder.length;k++)\n\t\t\t\t\t\tinput[k].value = item.placeholder[k];\n\t\t\t\t}\n\n\n\t\t\t\tif (fromQueue) this.setFocus();\n\t\t\t\tthis.addListeners(item.callback);\n\t\t\t},\n\n\t\t\t/**\n\t\t\t * Unbind events to elements\n\t\t\t *\n\t\t\t * @param  {Object}   el       HTML Object\n\t\t\t * @param  {Event}    event    Event to detach to element\n\t\t\t * @param  {Function} fn       Callback function\n\t\t\t *\n\t\t\t * @return {undefined}\n\t\t\t */\n\t\t\tunbind : function (el, event, fn) {\n\t\t\t\tif (typeof el.removeEventListener === "function") {\n\t\t\t\t\tel.removeEventListener(event, fn, false);\n\t\t\t\t} else if (el.detachEvent) {\n\t\t\t\t\tel.detachEvent("on" + event, fn);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\treturn {\n\t\t\talert   : function (message, fn, cssClass) { _alertify.dialog(message, "alert", fn, "", cssClass); return this; },\n\t\t\tconfirm : function (message, fn, cssClass) { _alertify.dialog(message, "confirm", fn, "", cssClass); return this; },\n\t\t\textend  : _alertify.extend,\n\t\t\tinit    : _alertify.init,\n\t\t\tlog     : function (message, type, wait) { _alertify.log(message, type, wait); return this; },\n\t\t\tprompt  : function (message, fn, placeholder, cssClass) { _alertify.dialog(message, "prompt", fn, placeholder, cssClass); return this; },\n\t\t\tpromptCombo  : function (message, fn, placeholder, cssClass) { _alertify.dialog(message, "prompt", fn, placeholder, cssClass); return this; },\n\t\t\tsuccess : function (message, wait) { _alertify.log(message, "success", wait); return this; },\n\t\t\terror   : function (message, wait) { \n\t\t\tif (typeof logProcess != "undefined")\n\t\t\t\t logProcess("error:" + message);\n\t\t\t_alertify.log(message, "error", wait); return this; },\n\t\t\tset     : function (args) { _alertify.set(args); },\n\t\t\tlabels  : _alertify.labels,\n\t\t\tdebug   : _alertify.handleErrors\n\t\t};\n\t};\n\n\t// AMD and window support\n\tif (typeof define === "function") {\n\t\tdefine([], function () { return new Alertify(); });\n\t} else if (typeof global.alertify === "undefined") {\n\t\tglobal.alertify = new Alertify();\n\t}\n\n}(this));\n'},function(t,n){t.exports='/* Notify.js - http://notifyjs.com/ Copyright (c) 2015 MIT */\n(function (factory) {\n\t// UMD start\n\t// https://github.com/umdjs/umd/blob/master/jqueryPluginCommonjs.js\n\tif (typeof define === \'function\' && define.amd) {\n\t\t// AMD. Register as an anonymous module.\n\t\tdefine([\'jquery\'], factory);\n\t} else if (typeof module === \'object\' && module.exports) {\n\t\t// Node/CommonJS\n\t\tmodule.exports = function( root, jQuery ) {\n\t\t\tif ( jQuery === undefined ) {\n\t\t\t\t// require(\'jQuery\') returns a factory that requires window to\n\t\t\t\t// build a jQuery instance, we normalize how we use modules\n\t\t\t\t// that require this pattern but the window provided is a noop\n\t\t\t\t// if it\'s defined (how jquery works)\n\t\t\t\tif ( typeof window !== \'undefined\' ) {\n\t\t\t\t\tjQuery = require(\'jquery\');\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tjQuery = require(\'jquery\')(root);\n\t\t\t\t}\n\t\t\t}\n\t\t\tfactory(jQuery);\n\t\t\treturn jQuery;\n\t\t};\n\t} else {\n\t\t// Browser globals\n\t\tfactory(jQuery);\n\t}\n}(function ($) {\n\t//IE8 indexOf polyfill\n\tvar indexOf = [].indexOf || function(item) {\n\t\tfor (var i = 0, l = this.length; i < l; i++) {\n\t\t\tif (i in this && this[i] === item) {\n\t\t\t\treturn i;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t};\n\n\tvar pluginName = "notify";\n\tvar pluginClassName = pluginName + "js";\n\tvar blankFieldName = pluginName + "!blank";\n\n\tvar positions = {\n\t\tt: "top",\n\t\tm: "middle",\n\t\tb: "bottom",\n\t\tl: "left",\n\t\tc: "center",\n\t\tr: "right"\n\t};\n\tvar hAligns = ["l", "c", "r"];\n\tvar vAligns = ["t", "m", "b"];\n\tvar mainPositions = ["t", "b", "l", "r"];\n\tvar opposites = {\n\t\tt: "b",\n\t\tm: null,\n\t\tb: "t",\n\t\tl: "r",\n\t\tc: null,\n\t\tr: "l"\n\t};\n\n\tvar parsePosition = function(str) {\n\t\tvar pos;\n\t\tpos = [];\n\t\t$.each(str.split(/\\W+/), function(i, word) {\n\t\t\tvar w;\n\t\t\tw = word.toLowerCase().charAt(0);\n\t\t\tif (positions[w]) {\n\t\t\t\treturn pos.push(w);\n\t\t\t}\n\t\t});\n\t\treturn pos;\n\t};\n\n\tvar styles = {};\n\n\tvar coreStyle = {\n\t\tname: "core",\n\t\thtml: "<div class=\\"" + pluginClassName + "-wrapper\\">\\n\t<div class=\\"" + pluginClassName + "-arrow\\"></div>\\n\t<div class=\\"" + pluginClassName + "-container\\"></div>\\n</div>",\n\t\tcss: "." + pluginClassName + "-corner {\\n\tposition: fixed;\\n\tmargin: 5px;\\n\tz-index: 1050;\\n}\\n\\n." + pluginClassName + "-corner ." + pluginClassName + "-wrapper,\\n." + pluginClassName + "-corner ." + pluginClassName + "-container {\\n\tposition: relative;\\n\tdisplay: block;\\n\theight: inherit;\\n\twidth: inherit;\\n\tmargin: 3px;\\n}\\n\\n." + pluginClassName + "-wrapper {\\n\tz-index: 1;\\n\tposition: absolute;\\n\tdisplay: inline-block;\\n\theight: 0;\\n\twidth: 0;\\n}\\n\\n." + pluginClassName + "-container {\\n\tdisplay: none;\\n\tz-index: 1;\\n\tposition: absolute;\\n}\\n\\n." + pluginClassName + "-hidable {\\n\tcursor: pointer;\\n}\\n\\n[data-notify-text],[data-notify-html] {\\n\tposition: relative;\\n}\\n\\n." + pluginClassName + "-arrow {\\n\tposition: absolute;\\n\tz-index: 2;\\n\twidth: 0;\\n\theight: 0;\\n}"\n\t};\n\n\tvar stylePrefixes = {\n\t\t"border-radius": ["-webkit-", "-moz-"]\n\t};\n\n\tvar getStyle = function(name) {\n\t\treturn styles[name];\n\t};\n\n\tvar addStyle = function(name, def) {\n\t\tif (!name) {\n\t\t\tthrow "Missing Style name";\n\t\t}\n\t\tif (!def) {\n\t\t\tthrow "Missing Style definition";\n\t\t}\n\t\tif (!def.html) {\n\t\t\tthrow "Missing Style HTML";\n\t\t}\n\t\t//remove existing style\n\t\tvar existing = styles[name];\n\t\tif (existing && existing.cssElem) {\n\t\t\tif (window.console) {\n\t\t\t\tconsole.warn(pluginName + ": overwriting style \'" + name + "\'");\n\t\t\t}\n\t\t\tstyles[name].cssElem.remove();\n\t\t}\n\t\tdef.name = name;\n\t\tstyles[name] = def;\n\t\tvar cssText = "";\n\t\tif (def.classes) {\n\t\t\t$.each(def.classes, function(className, props) {\n\t\t\t\tcssText += "." + pluginClassName + "-" + def.name + "-" + className + " {\\n";\n\t\t\t\t$.each(props, function(name, val) {\n\t\t\t\t\tif (stylePrefixes[name]) {\n\t\t\t\t\t\t$.each(stylePrefixes[name], function(i, prefix) {\n\t\t\t\t\t\t\treturn cssText += "\t" + prefix + name + ": " + val + ";\\n";\n\t\t\t\t\t\t});\n\t\t\t\t\t}\n\t\t\t\t\treturn cssText += "\t" + name + ": " + val + ";\\n";\n\t\t\t\t});\n\t\t\t\treturn cssText += "}\\n";\n\t\t\t});\n\t\t}\n\t\tif (def.css) {\n\t\t\tcssText += "/* styles for " + def.name + " */\\n" + def.css;\n\t\t}\n\t\tif (cssText) {\n\t\t\tdef.cssElem = insertCSS(cssText);\n\t\t\tdef.cssElem.attr("id", "notify-" + def.name);\n\t\t}\n\t\tvar fields = {};\n\t\tvar elem = $(def.html);\n\t\tfindFields("html", elem, fields);\n\t\tfindFields("text", elem, fields);\n\t\tdef.fields = fields;\n\t};\n\n\tvar insertCSS = function(cssText) {\n\t\tvar e, elem, error;\n\t\telem = createElem("style");\n\t\telem.attr("type", \'text/css\');\n\t\t$("head").append(elem);\n\t\ttry {\n\t\t\telem.html(cssText);\n\t\t} catch (_) {\n\t\t\telem[0].styleSheet.cssText = cssText;\n\t\t}\n\t\treturn elem;\n\t};\n\n\tvar findFields = function(type, elem, fields) {\n\t\tvar attr;\n\t\tif (type !== "html") {\n\t\t\ttype = "text";\n\t\t}\n\t\tattr = "data-notify-" + type;\n\t\treturn find(elem, "[" + attr + "]").each(function() {\n\t\t\tvar name;\n\t\t\tname = $(this).attr(attr);\n\t\t\tif (!name) {\n\t\t\t\tname = blankFieldName;\n\t\t\t}\n\t\t\tfields[name] = type;\n\t\t});\n\t};\n\n\tvar find = function(elem, selector) {\n\t\tif (elem.is(selector)) {\n\t\t\treturn elem;\n\t\t} else {\n\t\t\treturn elem.find(selector);\n\t\t}\n\t};\n\n\tvar pluginOptions = {\n\t\tclickToHide: true,\n\t\tautoHide: true,\n\t\tautoHideDelay: 5000,\n\t\tarrowShow: true,\n\t\tarrowSize: 5,\n\t\tbreakNewLines: true,\n\t\telementPosition: "bottom",\n\t\tglobalPosition: "top right",\n\t\tstyle: "bootstrap",\n\t\tclassName: "error",\n\t\tshowAnimation: "slideDown",\n\t\tshowDuration: 400,\n\t\thideAnimation: "slideUp",\n\t\thideDuration: 200,\n\t\tgap: 5\n\t};\n\n\tvar inherit = function(a, b) {\n\t\tvar F;\n\t\tF = function() {};\n\t\tF.prototype = a;\n\t\treturn $.extend(true, new F(), b);\n\t};\n\n\tvar defaults = function(opts) {\n\t\treturn $.extend(pluginOptions, opts);\n\t};\n\n\tvar createElem = function(tag) {\n\t\treturn $("<" + tag + "></" + tag + ">");\n\t};\n\n\tvar globalAnchors = {};\n\n\tvar getAnchorElement = function(element) {\n\t\tvar radios;\n\t\tif (element.is(\'[type=radio]\')) {\n\t\t\tradios = element.parents(\'form:first\').find(\'[type=radio]\').filter(function(i, e) {\n\t\t\t\treturn $(e).attr("name") === element.attr("name");\n\t\t\t});\n\t\t\telement = radios.first();\n\t\t}\n\t\treturn element;\n\t};\n\n\tvar incr = function(obj, pos, val) {\n\t\tvar opp, temp;\n\t\tif (typeof val === "string") {\n\t\t\tval = parseInt(val, 10);\n\t\t} else if (typeof val !== "number") {\n\t\t\treturn;\n\t\t}\n\t\tif (isNaN(val)) {\n\t\t\treturn;\n\t\t}\n\t\topp = positions[opposites[pos.charAt(0)]];\n\t\ttemp = pos;\n\t\tif (obj[opp] !== undefined) {\n\t\t\tpos = positions[opp.charAt(0)];\n\t\t\tval = -val;\n\t\t}\n\t\tif (obj[pos] === undefined) {\n\t\t\tobj[pos] = val;\n\t\t} else {\n\t\t\tobj[pos] += val;\n\t\t}\n\t\treturn null;\n\t};\n\n\tvar realign = function(alignment, inner, outer) {\n\t\tif (alignment === "l" || alignment === "t") {\n\t\t\treturn 0;\n\t\t} else if (alignment === "c" || alignment === "m") {\n\t\t\treturn outer / 2 - inner / 2;\n\t\t} else if (alignment === "r" || alignment === "b") {\n\t\t\treturn outer - inner;\n\t\t}\n\t\tthrow "Invalid alignment";\n\t};\n\n\tvar encode = function(text) {\n\t\tencode.e = encode.e || createElem("div");\n\t\treturn encode.e.text(text).html();\n\t};\n\n\tfunction Notification(elem, data, options) {\n\t\tif (typeof options === "string") {\n\t\t\toptions = {\n\t\t\t\tclassName: options\n\t\t\t};\n\t\t}\n\t\tthis.options = inherit(pluginOptions, $.isPlainObject(options) ? options : {});\n\t\tthis.loadHTML();\n\t\tthis.wrapper = $(coreStyle.html);\n\t\tif (this.options.clickToHide) {\n\t\t\tthis.wrapper.addClass(pluginClassName + "-hidable");\n\t\t}\n\t\tthis.wrapper.data(pluginClassName, this);\n\t\tthis.arrow = this.wrapper.find("." + pluginClassName + "-arrow");\n\t\tthis.container = this.wrapper.find("." + pluginClassName + "-container");\n\t\tthis.container.append(this.userContainer);\n\t\tif (elem && elem.length) {\n\t\t\tthis.elementType = elem.attr("type");\n\t\t\tthis.originalElement = elem;\n\t\t\tthis.elem = getAnchorElement(elem);\n\t\t\tthis.elem.data(pluginClassName, this);\n\t\t\tthis.elem.before(this.wrapper);\n\t\t}\n\t\tthis.container.hide();\n\t\tthis.run(data);\n\t}\n\n\tNotification.prototype.loadHTML = function() {\n\t\tvar style;\n\t\tstyle = this.getStyle();\n\t\tthis.userContainer = $(style.html);\n\t\tthis.userFields = style.fields;\n\t};\n\n\tNotification.prototype.show = function(show, userCallback) {\n\t\tvar args, callback, elems, fn, hidden;\n\t\tcallback = (function(_this) {\n\t\t\treturn function() {\n\t\t\t\tif (!show && !_this.elem) {\n\t\t\t\t\t_this.destroy();\n\t\t\t\t}\n\t\t\t\tif (userCallback) {\n\t\t\t\t\treturn userCallback();\n\t\t\t\t}\n\t\t\t};\n\t\t})(this);\n\t\thidden = this.container.parent().parents(\':hidden\').length > 0;\n\t\telems = this.container.add(this.arrow);\n\t\targs = [];\n\t\tif (hidden && show) {\n\t\t\tfn = "show";\n\t\t} else if (hidden && !show) {\n\t\t\tfn = "hide";\n\t\t} else if (!hidden && show) {\n\t\t\tfn = this.options.showAnimation;\n\t\t\targs.push(this.options.showDuration);\n\t\t} else if (!hidden && !show) {\n\t\t\tfn = this.options.hideAnimation;\n\t\t\targs.push(this.options.hideDuration);\n\t\t} else {\n\t\t\treturn callback();\n\t\t}\n\t\targs.push(callback);\n\t\treturn elems[fn].apply(elems, args);\n\t};\n\n\tNotification.prototype.setGlobalPosition = function() {\n\t\tvar p = this.getPosition();\n\t\tvar pMain = p[0];\n\t\tvar pAlign = p[1];\n\t\tvar main = positions[pMain];\n\t\tvar align = positions[pAlign];\n\t\tvar key = pMain + "|" + pAlign;\n\t\tvar anchor = globalAnchors[key];\n\t\tif (!anchor) {\n\t\t\tanchor = globalAnchors[key] = createElem("div");\n\t\t\tvar css = {};\n\t\t\tcss[main] = 0;\n\t\t\tif (align === "middle") {\n\t\t\t\tcss.top = \'45%\';\n\t\t\t} else if (align === "center") {\n\t\t\t\tcss.left = \'45%\';\n\t\t\t} else {\n\t\t\t\tcss[align] = 0;\n\t\t\t}\n\t\t\tanchor.css(css).addClass(pluginClassName + "-corner");\n\t\t\t$("body").append(anchor);\n\t\t}\n\t\treturn anchor.prepend(this.wrapper);\n\t};\n\n\tNotification.prototype.setElementPosition = function() {\n\t\tvar arrowColor, arrowCss, arrowSize, color, contH, contW, css, elemH, elemIH, elemIW, elemPos, elemW, gap, j, k, len, len1, mainFull, margin, opp, oppFull, pAlign, pArrow, pMain, pos, posFull, position, ref, wrapPos;\n\t\tposition = this.getPosition();\n\t\tpMain = position[0];\n\t\tpAlign = position[1];\n\t\tpArrow = position[2];\n\t\telemPos = this.elem.position();\n\t\telemH = this.elem.outerHeight();\n\t\telemW = this.elem.outerWidth();\n\t\telemIH = this.elem.innerHeight();\n\t\telemIW = this.elem.innerWidth();\n\t\twrapPos = this.wrapper.position();\n\t\tcontH = this.container.height();\n\t\tcontW = this.container.width();\n\t\tmainFull = positions[pMain];\n\t\topp = opposites[pMain];\n\t\toppFull = positions[opp];\n\t\tcss = {};\n\t\tcss[oppFull] = pMain === "b" ? elemH : pMain === "r" ? elemW : 0;\n\t\tincr(css, "top", elemPos.top - wrapPos.top);\n\t\tincr(css, "left", elemPos.left - wrapPos.left);\n\t\tref = ["top", "left"];\n\t\tfor (j = 0, len = ref.length; j < len; j++) {\n\t\t\tpos = ref[j];\n\t\t\tmargin = parseInt(this.elem.css("margin-" + pos), 10);\n\t\t\tif (margin) {\n\t\t\t\tincr(css, pos, margin);\n\t\t\t}\n\t\t}\n\t\tgap = Math.max(0, this.options.gap - (this.options.arrowShow ? arrowSize : 0));\n\t\tincr(css, oppFull, gap);\n\t\tif (!this.options.arrowShow) {\n\t\t\tthis.arrow.hide();\n\t\t} else {\n\t\t\tarrowSize = this.options.arrowSize;\n\t\t\tarrowCss = $.extend({}, css);\n\t\t\tarrowColor = this.userContainer.css("border-color") || this.userContainer.css("border-top-color") || this.userContainer.css("background-color") || "white";\n\t\t\tfor (k = 0, len1 = mainPositions.length; k < len1; k++) {\n\t\t\t\tpos = mainPositions[k];\n\t\t\t\tposFull = positions[pos];\n\t\t\t\tif (pos === opp) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tcolor = posFull === mainFull ? arrowColor : "transparent";\n\t\t\t\tarrowCss["border-" + posFull] = arrowSize + "px solid " + color;\n\t\t\t}\n\t\t\tincr(css, positions[opp], arrowSize);\n\t\t\tif (indexOf.call(mainPositions, pAlign) >= 0) {\n\t\t\t\tincr(arrowCss, positions[pAlign], arrowSize * 2);\n\t\t\t}\n\t\t}\n\t\tif (indexOf.call(vAligns, pMain) >= 0) {\n\t\t\tincr(css, "left", realign(pAlign, contW, elemW));\n\t\t\tif (arrowCss) {\n\t\t\t\tincr(arrowCss, "left", realign(pAlign, arrowSize, elemIW));\n\t\t\t}\n\t\t} else if (indexOf.call(hAligns, pMain) >= 0) {\n\t\t\tincr(css, "top", realign(pAlign, contH, elemH));\n\t\t\tif (arrowCss) {\n\t\t\t\tincr(arrowCss, "top", realign(pAlign, arrowSize, elemIH));\n\t\t\t}\n\t\t}\n\t\tif (this.container.is(":visible")) {\n\t\t\tcss.display = "block";\n\t\t}\n\t\tthis.container.removeAttr("style").css(css);\n\t\tif (arrowCss) {\n\t\t\treturn this.arrow.removeAttr("style").css(arrowCss);\n\t\t}\n\t};\n\n\tNotification.prototype.getPosition = function() {\n\t\tvar pos, ref, ref1, ref2, ref3, ref4, ref5, text;\n\t\ttext = this.options.position || (this.elem ? this.options.elementPosition : this.options.globalPosition);\n\t\tpos = parsePosition(text);\n\t\tif (pos.length === 0) {\n\t\t\tpos[0] = "b";\n\t\t}\n\t\tif (ref = pos[0], indexOf.call(mainPositions, ref) < 0) {\n\t\t\tthrow "Must be one of [" + mainPositions + "]";\n\t\t}\n\t\tif (pos.length === 1 || ((ref1 = pos[0], indexOf.call(vAligns, ref1) >= 0) && (ref2 = pos[1], indexOf.call(hAligns, ref2) < 0)) || ((ref3 = pos[0], indexOf.call(hAligns, ref3) >= 0) && (ref4 = pos[1], indexOf.call(vAligns, ref4) < 0))) {\n\t\t\tpos[1] = (ref5 = pos[0], indexOf.call(hAligns, ref5) >= 0) ? "m" : "l";\n\t\t}\n\t\tif (pos.length === 2) {\n\t\t\tpos[2] = pos[1];\n\t\t}\n\t\treturn pos;\n\t};\n\n\tNotification.prototype.getStyle = function(name) {\n\t\tvar style;\n\t\tif (!name) {\n\t\t\tname = this.options.style;\n\t\t}\n\t\tif (!name) {\n\t\t\tname = "default";\n\t\t}\n\t\tstyle = styles[name];\n\t\tif (!style) {\n\t\t\tthrow "Missing style: " + name;\n\t\t}\n\t\treturn style;\n\t};\n\n\tNotification.prototype.updateClasses = function() {\n\t\tvar classes, style;\n\t\tclasses = ["base"];\n\t\tif ($.isArray(this.options.className)) {\n\t\t\tclasses = classes.concat(this.options.className);\n\t\t} else if (this.options.className) {\n\t\t\tclasses.push(this.options.className);\n\t\t}\n\t\tstyle = this.getStyle();\n\t\tclasses = $.map(classes, function(n) {\n\t\t\treturn pluginClassName + "-" + style.name + "-" + n;\n\t\t}).join(" ");\n\t\treturn this.userContainer.attr("class", classes);\n\t};\n\n\tNotification.prototype.run = function(data, options) {\n\t\tvar d, datas, name, type, value;\n\t\tif ($.isPlainObject(options)) {\n\t\t\t$.extend(this.options, options);\n\t\t} else if ($.type(options) === "string") {\n\t\t\tthis.options.className = options;\n\t\t}\n\t\tif (this.container && !data) {\n\t\t\tthis.show(false);\n\t\t\treturn;\n\t\t} else if (!this.container && !data) {\n\t\t\treturn;\n\t\t}\n\t\tdatas = {};\n\t\tif ($.isPlainObject(data)) {\n\t\t\tdatas = data;\n\t\t} else {\n\t\t\tdatas[blankFieldName] = data;\n\t\t}\n\t\tfor (name in datas) {\n\t\t\td = datas[name];\n\t\t\ttype = this.userFields[name];\n\t\t\tif (!type) {\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (type === "text") {\n\t\t\t\td = encode(d);\n\t\t\t\tif (this.options.breakNewLines) {\n\t\t\t\t\td = d.replace(/\\n/g, \'<br/>\');\n\t\t\t\t}\n\t\t\t}\n\t\t\tvalue = name === blankFieldName ? \'\' : \'=\' + name;\n\t\t\tfind(this.userContainer, "[data-notify-" + type + value + "]").html(d);\n\t\t}\n\t\tthis.updateClasses();\n\t\tif (this.elem) {\n\t\t\tthis.setElementPosition();\n\t\t} else {\n\t\t\tthis.setGlobalPosition();\n\t\t}\n\t\tthis.show(true);\n\t\tif (this.options.autoHide) {\n\t\t\tclearTimeout(this.autohideTimer);\n\t\t\tthis.autohideTimer = setTimeout(this.show.bind(this, false), this.options.autoHideDelay);\n\t\t}\n\t};\n\n\tNotification.prototype.destroy = function() {\n\t\tthis.wrapper.data(pluginClassName, null);\n\t\tthis.wrapper.remove();\n\t};\n\n\t$[pluginName] = function(elem, data, options) {\n\t\tif ((elem && elem.nodeName) || elem.jquery) {\n\t\t\t$(elem)[pluginName](data, options);\n\t\t} else {\n\t\t\toptions = data;\n\t\t\tdata = elem;\n\t\t\tvar out = new Notification(null, data, options);\n\t\t}\n\t\treturn out;\n\t};\n\n\t$.fn[pluginName] = function(data, options) {\n\t\t$(this).each(function() {\n\t\t\tvar prev = getAnchorElement($(this)).data(pluginClassName);\n\t\t\tif (prev) {\n\t\t\t\tprev.destroy();\n\t\t\t}\n\t\t\tvar curr = new Notification($(this), data, options);\n\t\t});\n\t\treturn this;\n\t};\n\n\t$.extend($[pluginName], {\n\t\tdefaults: defaults,\n\t\taddStyle: addStyle,\n\t\tpluginOptions: pluginOptions,\n\t\tgetStyle: getStyle,\n\t\tinsertCSS: insertCSS\n\t});\n\n\t//always include the default bootstrap style\n\taddStyle("bootstrap", {\n\t\thtml: "<div>\\n<span data-notify-text></span>\\n</div>",\n\t\tclasses: {\n\t\t\tbase: {\n\t\t\t\t"font-weight": "bold",\n\t\t\t\t"padding": "8px 15px 8px 14px",\n\t\t\t\t"text-shadow": "0 1px 0 rgba(255, 255, 255, 0.5)",\n\t\t\t\t"background-color": "#fcf8e3",\n\t\t\t\t"border": "1px solid #fbeed5",\n\t\t\t\t"border-radius": "4px",\n\t\t\t\t"white-space": "nowrap",\n\t\t\t\t"padding-left": "25px",\n\t\t\t\t"background-repeat": "no-repeat",\n\t\t\t\t"background-position": "3px 7px"\n\t\t\t},\n\t\t\terror: {\n\t\t\t\t"color": "#B94A48",\n\t\t\t\t"background-color": "#F2DEDE",\n\t\t\t\t"border-color": "#EED3D7",\n\t\t\t\t"background-image": "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAtRJREFUeNqkVc1u00AQHq+dOD+0poIQfkIjalW0SEGqRMuRnHos3DjwAH0ArlyQeANOOSMeAA5VjyBxKBQhgSpVUKKQNGloFdw4cWw2jtfMOna6JOUArDTazXi/b3dm55socPqQhFka++aHBsI8GsopRJERNFlY88FCEk9Yiwf8RhgRyaHFQpPHCDmZG5oX2ui2yilkcTT1AcDsbYC1NMAyOi7zTX2Agx7A9luAl88BauiiQ/cJaZQfIpAlngDcvZZMrl8vFPK5+XktrWlx3/ehZ5r9+t6e+WVnp1pxnNIjgBe4/6dAysQc8dsmHwPcW9C0h3fW1hans1ltwJhy0GxK7XZbUlMp5Ww2eyan6+ft/f2FAqXGK4CvQk5HueFz7D6GOZtIrK+srupdx1GRBBqNBtzc2AiMr7nPplRdKhb1q6q6zjFhrklEFOUutoQ50xcX86ZlqaZpQrfbBdu2R6/G19zX6XSgh6RX5ubyHCM8nqSID6ICrGiZjGYYxojEsiw4PDwMSL5VKsC8Yf4VRYFzMzMaxwjlJSlCyAQ9l0CW44PBADzXhe7xMdi9HtTrdYjFYkDQL0cn4Xdq2/EAE+InCnvADTf2eah4Sx9vExQjkqXT6aAERICMewd/UAp/IeYANM2joxt+q5VI+ieq2i0Wg3l6DNzHwTERPgo1ko7XBXj3vdlsT2F+UuhIhYkp7u7CarkcrFOCtR3H5JiwbAIeImjT/YQKKBtGjRFCU5IUgFRe7fF4cCNVIPMYo3VKqxwjyNAXNepuopyqnld602qVsfRpEkkz+GFL1wPj6ySXBpJtWVa5xlhpcyhBNwpZHmtX8AGgfIExo0ZpzkWVTBGiXCSEaHh62/PoR0p/vHaczxXGnj4bSo+G78lELU80h1uogBwWLf5YlsPmgDEd4M236xjm+8nm4IuE/9u+/PH2JXZfbwz4zw1WbO+SQPpXfwG/BBgAhCNZiSb/pOQAAAAASUVORK5CYII=)"\n\t\t\t},\n\t\t\tsuccess: {\n\t\t\t\t"color": "#468847",\n\t\t\t\t"background-color": "#DFF0D8",\n\t\t\t\t"border-color": "#D6E9C6",\n\t\t\t\t"background-image": "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAutJREFUeNq0lctPE0Ecx38zu/RFS1EryqtgJFA08YCiMZIAQQ4eRG8eDGdPJiYeTIwHTfwPiAcvXIwXLwoXPaDxkWgQ6islKlJLSQWLUraPLTv7Gme32zoF9KSTfLO7v53vZ3d/M7/fIth+IO6INt2jjoA7bjHCJoAlzCRw59YwHYjBnfMPqAKWQYKjGkfCJqAF0xwZjipQtA3MxeSG87VhOOYegVrUCy7UZM9S6TLIdAamySTclZdYhFhRHloGYg7mgZv1Zzztvgud7V1tbQ2twYA34LJmF4p5dXF1KTufnE+SxeJtuCZNsLDCQU0+RyKTF27Unw101l8e6hns3u0PBalORVVVkcaEKBJDgV3+cGM4tKKmI+ohlIGnygKX00rSBfszz/n2uXv81wd6+rt1orsZCHRdr1Imk2F2Kob3hutSxW8thsd8AXNaln9D7CTfA6O+0UgkMuwVvEFFUbbAcrkcTA8+AtOk8E6KiQiDmMFSDqZItAzEVQviRkdDdaFgPp8HSZKAEAL5Qh7Sq2lIJBJwv2scUqkUnKoZgNhcDKhKg5aH+1IkcouCAdFGAQsuWZYhOjwFHQ96oagWgRoUov1T9kRBEODAwxM2QtEUl+Wp+Ln9VRo6BcMw4ErHRYjH4/B26AlQoQQTRdHWwcd9AH57+UAXddvDD37DmrBBV34WfqiXPl61g+vr6xA9zsGeM9gOdsNXkgpEtTwVvwOklXLKm6+/p5ezwk4B+j6droBs2CsGa/gNs6RIxazl4Tc25mpTgw/apPR1LYlNRFAzgsOxkyXYLIM1V8NMwyAkJSctD1eGVKiq5wWjSPdjmeTkiKvVW4f2YPHWl3GAVq6ymcyCTgovM3FzyRiDe2TaKcEKsLpJvNHjZgPNqEtyi6mZIm4SRFyLMUsONSSdkPeFtY1n0mczoY3BHTLhwPRy9/lzcziCw9ACI+yql0VLzcGAZbYSM5CCSZg1/9oc/nn7+i8N9p/8An4JMADxhH+xHfuiKwAAAABJRU5ErkJggg==)"\n\t\t\t},\n\t\t\tinfo: {\n\t\t\t\t"color": "#3A87AD",\n\t\t\t\t"background-color": "#D9EDF7",\n\t\t\t\t"border-color": "#BCE8F1",\n\t\t\t\t"background-image": "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAABmJLR0QA/wD/AP+gvaeTAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAB3RJTUUH3QYFAhkSsdes/QAAA8dJREFUOMvVlGtMW2UYx//POaWHXg6lLaW0ypAtw1UCgbniNOLcVOLmAjHZolOYlxmTGXVZdAnRfXQm+7SoU4mXaOaiZsEpC9FkiQs6Z6bdCnNYruM6KNBw6YWewzl9z+sHImEWv+vz7XmT95f/+3/+7wP814v+efDOV3/SoX3lHAA+6ODeUFfMfjOWMADgdk+eEKz0pF7aQdMAcOKLLjrcVMVX3xdWN29/GhYP7SvnP0cWfS8caSkfHZsPE9Fgnt02JNutQ0QYHB2dDz9/pKX8QjjuO9xUxd/66HdxTeCHZ3rojQObGQBcuNjfplkD3b19Y/6MrimSaKgSMmpGU5WevmE/swa6Oy73tQHA0Rdr2Mmv/6A1n9w9suQ7097Z9lM4FlTgTDrzZTu4StXVfpiI48rVcUDM5cmEksrFnHxfpTtU/3BFQzCQF/2bYVoNbH7zmItbSoMj40JSzmMyX5qDvriA7QdrIIpA+3cdsMpu0nXI8cV0MtKXCPZev+gCEM1S2NHPvWfP/hL+7FSr3+0p5RBEyhEN5JCKYr8XnASMT0xBNyzQGQeI8fjsGD39RMPk7se2bd5ZtTyoFYXftF6y37gx7NeUtJJOTFlAHDZLDuILU3j3+H5oOrD3yWbIztugaAzgnBKJuBLpGfQrS8wO4FZgV+c1IxaLgWVU0tMLEETCos4xMzEIv9cJXQcyagIwigDGwJgOAtHAwAhisQUjy0ORGERiELgG4iakkzo4MYAxcM5hAMi1WWG1yYCJIcMUaBkVRLdGeSU2995TLWzcUAzONJ7J6FBVBYIggMzmFbvdBV44Corg8vjhzC+EJEl8U1kJtgYrhCzgc/vvTwXKSib1paRFVRVORDAJAsw5FuTaJEhWM2SHB3mOAlhkNxwuLzeJsGwqWzf5TFNdKgtY5qHp6ZFf67Y/sAVadCaVY5YACDDb3Oi4NIjLnWMw2QthCBIsVhsUTU9tvXsjeq9+X1d75/KEs4LNOfcdf/+HthMnvwxOD0wmHaXr7ZItn2wuH2SnBzbZAbPJwpPx+VQuzcm7dgRCB57a1uBzUDRL4bfnI0RE0eaXd9W89mpjqHZnUI5Hh2l2dkZZUhOqpi2qSmpOmZ64Tuu9qlz/SEXo6MEHa3wOip46F1n7633eekV8ds8Wxjn37Wl63VVa+ej5oeEZ/82ZBETJjpJ1Rbij2D3Z/1trXUvLsblCK0XfOx0SX2kMsn9dX+d+7Kf6h8o4AIykuffjT8L20LU+w4AZd5VvEPY+XpWqLV327HR7DzXuDnD8r+ovkBehJ8i+y8YAAAAASUVORK5CYII=)"\n\t\t\t},\n\t\t\twarn: {\n\t\t\t\t"color": "#C09853",\n\t\t\t\t"background-color": "#FCF8E3",\n\t\t\t\t"border-color": "#FBEED5",\n\t\t\t\t"background-image": "url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAMAAAC6V+0/AAABJlBMVEXr6eb/2oD/wi7/xjr/0mP/ykf/tQD/vBj/3o7/uQ//vyL/twebhgD/4pzX1K3z8e349vK6tHCilCWbiQymn0jGworr6dXQza3HxcKkn1vWvV/5uRfk4dXZ1bD18+/52YebiAmyr5S9mhCzrWq5t6ufjRH54aLs0oS+qD751XqPhAybhwXsujG3sm+Zk0PTwG6Shg+PhhObhwOPgQL4zV2nlyrf27uLfgCPhRHu7OmLgAafkyiWkD3l49ibiAfTs0C+lgCniwD4sgDJxqOilzDWowWFfAH08uebig6qpFHBvH/aw26FfQTQzsvy8OyEfz20r3jAvaKbhgG9q0nc2LbZxXanoUu/u5WSggCtp1anpJKdmFz/zlX/1nGJiYmuq5Dx7+sAAADoPUZSAAAAAXRSTlMAQObYZgAAAAFiS0dEAIgFHUgAAAAJcEhZcwAACxMAAAsTAQCanBgAAAAHdElNRQfdBgUBGhh4aah5AAAAlklEQVQY02NgoBIIE8EUcwn1FkIXM1Tj5dDUQhPU502Mi7XXQxGz5uVIjGOJUUUW81HnYEyMi2HVcUOICQZzMMYmxrEyMylJwgUt5BljWRLjmJm4pI1hYp5SQLGYxDgmLnZOVxuooClIDKgXKMbN5ggV1ACLJcaBxNgcoiGCBiZwdWxOETBDrTyEFey0jYJ4eHjMGWgEAIpRFRCUt08qAAAAAElFTkSuQmCC)"\n\t\t\t}\n\t\t}\n\t});\n\n\t$(function() {\n\t\tinsertCSS(coreStyle.css).attr("id", "core-notify");\n\t\t$(document).on("click", "." + pluginClassName + "-hidable", function(e) {\n\t\t\t$(this).trigger("notify-hide");\n\t\t});\n\t\t$(document).on("notify-hide", "." + pluginClassName + "-wrapper", function(e) {\n\t\t\tvar elem = $(this).data(pluginClassName);\n\t\t\tif(elem) {\n\t\t\t\telem.show(false);\n\t\t\t}\n\t\t});\n\t});\n\n}));\n'},function(t,n){t.exports='// Generated by CoffeeScript 1.8.0\n(function() {\n  var Dragster,\n    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; };\n\n  Dragster = (function() {\n    function Dragster(el) {\n      this.el = el;\n      this.dragleave = __bind(this.dragleave, this);\n      this.dragenter = __bind(this.dragenter, this);\n      if (this.supportsEventConstructors()) {\n        this.first = false;\n        this.second = false;\n        this.el.addEventListener("dragenter", this.dragenter, false);\n        this.el.addEventListener("dragleave", this.dragleave, false);\n      }\n    }\n\n    Dragster.prototype.dragenter = function(event) {\n      if (this.first) {\n        return this.second = true;\n      } else {\n        this.first = true;\n        return this.el.dispatchEvent(new CustomEvent("dragster:enter", {\n          bubbles: true,\n          cancelable: true,\n          detail: {\n            dataTransfer: event.dataTransfer\n          }\n        }));\n      }\n    };\n\n    Dragster.prototype.dragleave = function(event) {\n      if (this.second) {\n        this.second = false;\n      } else if (this.first) {\n        this.first = false;\n      }\n      if (!this.first && !this.second) {\n        return this.el.dispatchEvent(new CustomEvent("dragster:leave", {\n          bubbles: true,\n          cancelable: true,\n          detail: {\n            dataTransfer: event.dataTransfer\n          }\n        }));\n      }\n    };\n\n    Dragster.prototype.removeListeners = function() {\n      this.el.removeEventListener("dragenter", this.dragenter, false);\n      return this.el.removeEventListener("dragleave", this.dragleave, false);\n    };\n\n    Dragster.prototype.supportsEventConstructors = function() {\n      try {\n        new CustomEvent("z");\n      } catch (_error) {\n        return false;\n      }\n      return true;\n    };\n\n    Dragster.prototype.reset = function() {\n      this.first = false;\n      return this.second = false;\n    };\n\n    return Dragster;\n\n  })();\n\n  window.Dragster = Dragster;\n\n  if (typeof module === \'undefined\') {\n    window.Dragster = Dragster;\n  } else {\n    module.exports = Dragster;\n  }\n\n}).call(this);\n\n\n'},function(t,n){t.exports='\nvar BrukerReader = {};\n\nBrukerReader.checkForBrukerData = function (params)\n{\n\n        var bruker = {};\n        for(var k=0;k<params.length;k++)\n        {\n            if(params[k].filename)\n            {\n                if(params[k].filename.substring(params[k].filename.length-5) == "2dseq")\n                        bruker.datafile = params[k];\n                if(params[k].filename.substring(params[k].filename.length-9) == "visu_pars") // visu_pars is the best\n                     bruker.headerfile = params[k];\n                if(params[k].filename.substring(params[k].filename.length-6) == "method") // visu_pars is the best\n                     bruker.headerfile = params[k];\n            }\n        }\n\n        if(Object.getOwnPropertyNames(bruker).length > 0)\n        {\n            if (params.parent && params.parent.parent)\n            {\n                var pparams = params.parent.parent;\n                for (var k = 0; k < pparams.length;k++)\n                {\n                    var splitted = pparams[k].filename.split("/");\n                    var fname = splitted[splitted.length-1];\n                    if (fname == \'method\')\n                    {\n                        bruker.methodfile = pparams[k];\n                        if ( pparams[k].file &&  pparams[k].file.fullPath)\n                        {\n                            var pathseq = pparams[k].file.fullPath.split("/");\n                            bruker.AcqNum = pathseq[pathseq.length-2];\n                        }\n                        break;\n                    }\n\n                }\n            }\n\n\n            return bruker;\n        }\n        else\n            return;\n}\n\n\n\n\n\n\n\nBrukerReader.loadBruker = function (bruker,callback,name)\n{\n    // chekc if both files are included\n    if(bruker.headerfile == undefined | bruker.datafile == undefined)\n    {\n        callback([]);\n        return false;\n    }\n\n    var hdr_params = bruker.headerfile;\n    var data_params = bruker.datafile;\n    var method_params = bruker.methodfile;\n    hdr_params.callback =  function(fobj_hdr) { \n            data_params.callback = function(fobj_data)\n            {\n                if (method_params != undefined)\n                {\n                    method_params.callback = function(fobj_method)\n                    {\n                        BrukerReader.vis2dseq2Nifti(fobj_hdr, fobj_data, fobj_method,bruker.AcqNum, callback);                 \n                    }\n                    KViewer.dataManager.loadData(method_params);\n                }\n                else\n                    BrukerReader.vis2dseq2Nifti(fobj_hdr, fobj_data, undefined,name, callback);\n            } \n            KViewer.dataManager.loadData(data_params);\n    }\n    KViewer.dataManager.loadData(hdr_params);\n\n}\n\n\n\nBrukerReader.vis2dseq2Nifti = function (fobj_hdr, fobj_data,fobj_method, acqnum, callback)\n{\n        var brk = BrukerReader.bruker2nifti(fobj_hdr, fobj_data,fobj_method);\n        var visu_pars = brk.visu_pars;\n        var fileName_pattern = \'<AcquisitionProtocol>\';\n\n        var k = 0;\n        var matches = fileName_pattern.match(/\\<\\w+\\>/g);\n        var fname = fileName_pattern;\n        for (var j = 0; j < matches.length; j++)\n          {\n             var key = \'Visu\' + matches[j].substr(1,matches[j].length-2);\n             if (visu_pars[key] == undefined)\n             {\n                  console.log(key + " is undefined: " + fobj_hdr.fileinfo.SubFolder+"/"+fobj_hdr.fileinfo.filename);\n                  fname = fname.replace(matches[j],"undefined" + k);\n                  k++;\n             }\n             else\n              fname = fname.replace(matches[j],visu_pars[key].content[0]);\n          }\n\n\n        fobj_data.content = prepareMedicalImageData(parse(brk.buffer), fobj_data, {});\n        fobj_data.contentType = \'nii\';\n        fobj_data.filename    = fname + ".nii";\n        fobj_data.fileID = "localfile_" + fname + \'_\' +  acqnum;\n        fobj_data.fileinfo.SubFolder = acqnum;\n        fobj_data.fileinfo.patients_id = visu_pars.VisuSubjectId.content[0].replace(/[^a-zA-Z0-9]/g,"");\n        fobj_data.fileinfo.studies_id = "#" + visu_pars.VisuStudyId.content[0].replace(/[^a-zA-Z0-9]/g,"");\n        fobj_data.fileinfo.FamilyName = visu_pars.VisuSubjectId.content[0];\n        fobj_data.fileinfo.Sex = visu_pars.VisuSubjectSex.content[0] || \'N\';\n        KViewer.dataManager.setFile(fobj_data.fileID,fobj_data);\n      \n\n\n\n        if (brk.bvals.length > 0)\n          {\n            var bvals = brk.bvals;\n              \n            var bvalstr = "";\n            var bvecXstr = "";\n            var bvecYstr = "";\n            var bvecZstr = "";\n            for (var j = 0; j < bvals.length; j++)\n            {\n                bvalstr += bvals[j].ev + " ";\n                var v = bvals[j].v;\n                bvecXstr += v._data[0] + " ";\n                bvecYstr += v._data[1] + " ";\n                bvecZstr += (v._data[2]) + " ";\n            }\n\n            var fobjs_bvals = { };\n            fobjs_bvals.fileID = fobj_data.fileID + "bval";\n            fobjs_bvals.content = bvalstr + "\\n" ;\n            fobjs_bvals.contentType = \'txt\';\n            fobjs_bvals.filename    = fname + ".bvals";\n            fobjs_bvals.fileinfo = $.extend({},fobj_data.fileinfo);\n            KViewer.dataManager.setFile(fobjs_bvals.fileID,fobjs_bvals);\n      \n            var fobjs_bvecs = { };\n            fobjs_bvecs.fileID = fobj_data.fileID + "bvec";\n            fobjs_bvecs.content =  bvecXstr + "\\n" + bvecYstr + "\\n" + bvecZstr + "\\n";\n            fobjs_bvecs.contentType = \'txt\';\n            fobjs_bvecs.filename    = fname + ".bvecs";\n            fobjs_bvecs.fileinfo = $.extend({},fobj_data.fileinfo);\n            KViewer.dataManager.setFile(fobjs_bvecs.fileID,fobjs_bvecs);\n\n\n//            fs.writeFileSync(finalname + ".bvec", bvecXstr + "\\n" + bvecYstr + "\\n" + bvecZstr + "\\n");\n          }\n\n\n\n\n\n\n        KViewer.cacheManager.update();\n        if (callback)\n            callback(fobj_data, {});\n\n}\n\n\nBrukerReader.readHdr = function(brukerhdr)\n{\n    var hdr = {};\n\n    brukerhdr = ab2str(brukerhdr);\n\n    var items = brukerhdr.split(\'##$\');\n    for (var k = 0; k < items.length; k++)\n    {\n        var lines = ksplit(items[k],\'\\n\'); \n        if (lines.length == 0)\n            continue;      \n        var h = lines[0].split(\'=\');\n        var name = h[0].trim();\n        var params = h[1].trim().replace(/\\(/g,"").replace(/\\)/g,"").split(",").map(function(x) { return x.trim() });\n        if (!isNaN(parseInt(params[0])))\n            params = params.map(function(x) {return parseInt(x) });\n        lines = lines.slice(1);\n        var content = [];\n        if (lines.length > 0)\n        {\n            if (lines[0].trim()[0] == \'<\' || lines[0].trim()[0] == \'#\' || lines[0].trim()[0] == \'$\') // strings\n                content = ksplit(lines,"<>");\n            else\n                content = ksplit(lines," ").map(function(x) {\n                     var num = parseFloat(x);\n                     if (!isNaN(num))\n                        return num;\n                     else\n                        return x;\n                  });;\n        }\n        hdr[name] = {param : params, content : content};\n    }\n    hdr.raw = brukerhdr;\n    return hdr;\n\n}\n\n\nfunction ksplit(x,delims)\n{\n    var r = x;\n    if (typeof r == "string")\n       r = [r];\n    for (var k = 0;k < delims.length;k++)\n    {\n        r = r.map(function(y) { return y.split(delims[k]).filter( function (x) { return x!=""}); });\n        r = [].concat.apply([],r);      \n    }\n    return r;\n}\n\n\n\n\nBrukerReader.bruker2nifti = function(hdrfi, databufferfi,methodfi)\n{\n    var method;\n    if (methodfi)\n        method = BrukerReader.readHdr(methodfi.content);\n\n    if (databufferfi == undefined)\n        return;\n\n    var hdr = BrukerReader.readHdr(hdrfi.content);\n    hdr.raw = hdrfi.content;\n\n    var databuffer = databufferfi.content;\n\n    // this is a default nifti buffer in uint8 representation.\n    var niihdr = [92,1,0,0,117,105,110,116,49,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,0,1,0,16,0,16,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,16,0,0,0,0,0,128,191,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,111,110,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,128,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,191,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,191,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,105,49,0,0,0,0,0];  \n    var buffer = (new Uint8Array(niihdr)).buffer;\n \n\n    var sx,sy,sz,st, vx,vy,vz, edges, datatype; \n    var littleEndian = true;\n    // assume uint16 as default           \n    var datatype = 512;       \n            var brukerhdr = hdr.raw;\n\n  \n    {\n      \n            vx = hdr.VisuCoreExtent.content[0]/hdr.VisuCoreSize.content[0];\n            vy = hdr.VisuCoreExtent.content[1]/hdr.VisuCoreSize.content[1];\n            vz = 1;\n            if (hdr.VisuCoreExtent.param[0] > 2)            \n                vz = hdr.VisuCoreExtent.content[2]/hdr.VisuCoreSize.content[2];\n            \n            sx = hdr.VisuCoreSize.content[0];\n            sy = hdr.VisuCoreSize.content[1];\n            if (hdr.VisuCoreSize.param[0] > 2)\n                sz = hdr.VisuCoreSize.content[2];\n            else\n                sz = 1\n            st = hdr.VisuCoreFrameCount.param[0];\n\n            var framesAreSlice = false;\n            if(sz==1 & st >1   ) // slices are in frames ...?\n            {\n                // could still be a mess between slices and time frames (DTI)\n                // only way to find out so far is with visuCore first params\n                 if(1) //vp.VisuCoreOrientation  )\n                 {\n                     sz = nSlices = hdr.VisuCoreOrientation.param[0]; //parseInt(vp.VisuCoreOrientation[0].split(\' \')[0]);\n                     st = st / sz;\n                 }\n                 else\n                 {\n                     sz = st;\n                     st = 1;\n                 }\n                 framesAreSlice  = true;\n            }\n\n\n            \n            {\n                var orient = hdr.VisuCoreOrientation.content;  //vp.VisuCoreOrientation[1].trim().split(/\\s+/);  \n                var offset = hdr.VisuCorePosition.content; //vp.VisuCorePosition[1].trim().split(/\\s+/);\n                if(framesAreSlice & offset.length>3) // calculate the z-vox size from slice distances for multiframe data\n                {\n                    var x = 0;\n                    for(var k=0; k< 3; k++)\n                    { x +=  function (a,b){ return (parseFloat(a) - parseFloat(b))*(parseFloat(a) - parseFloat(b))  }(offset[k], offset[k+3]); }\n                    vz = parseFloat(math.sqrt(x).toFixed(3));\n                }\n\n                for(var k=0;k<12;k++) { orient[k] = parseFloat(orient[k]); }\n                for(var k=0;k<6;k++)  { offset[k] = parseFloat(offset[k]); }\n                \n\n                edges = (new Array(3)).fill(Array(3));\n                edges[0] =  orient.splice(0,3); \n                edges[1] =  orient.splice(0,3);\n                edges[2] =  orient.splice(0,3);\n\n\n\n                edges = kmath.matrix(math.inv(edges))._data;\n                \n                // add the offset\n                edges[0] = edges[0].concat(offset[0]); \n                edges[1] = edges[1].concat(offset[1]); \n                edges[2] = edges[2].concat(offset[2]); \n                edges[3] = [0, 0, 0, 1];\n\n\n\n\n                if(! isNaN(offset[3]) ) // try to get the slice order. Only works if second slice available    \n                {\n                    var v1 =  math.multiply(edges, [offset[0], offset[1], offset[2],1]);\n                    var v2 =  math.multiply(edges, [offset[3], offset[4], offset[5],1]);\n                    var d = math.matrix(math.add(v1, math.multiply(v2,-1)))._data;\n                    var sliceOrder = -math.sign(d[2]);\n                }\n                else\n                {\n                    sliceOrder = 1;\n                }\n\n\n                var voxCorrection = math.diag([vx,vy,vz*sliceOrder,1]);\n\n//                var permuationMatrix = (  [[1,0,0,0],[0,-1,0,0],[0,0,1,0],[0,0,0,1]]  );\n                \n//                edges = ( math.multiply((permuationMatrix), edges));\n\n\n                var saved_edges = edges;\n\n                edges = math.multiply( edges,    voxCorrection);\n    \n\n                if (hdr.VisuCoreDiskSliceOrder != undefined &&  hdr.VisuCoreDiskSliceOrder.param == "disk_reverse_slice_order")\n                    edges = math.multiply(edges, [[1 ,0, 0, 0 ],[ 0, 1, 0, 0 ],[ 0, 0, -1, sz ],[0, 0, 0, 1]]);\n                  \n                \n\n         //  console.log(print_matrix(edges));\n\n\n\n\n\n                edges = edges._data;\n                // make linear matrix\n                edges = edges[0].concat(edges[1]).concat(edges[2]).concat(edges[3]);\n\n\n           \n            }\n\n\n            // ======================\n\n            // datatype: see into nifit.js . bruker datatype can contain underscore in beginning ... ? Be careful with signd and unsigned int\n             var wordtype = hdr.VisuCoreWordType.param[0]; //vp.VisuCoreWordType;\n           \n            if (wordtype.search(\'8BIT_SGN_INT\') > -1 )\n                datatype = 256;       \n            else if (wordtype.search(\'16BIT_SGN_INT\') > -1)\n                datatype = 512;       \n            else if (wordtype.search(\'32BIT_SGN_INT\') > -1)  // signed int 32\n                datatype = 8;       \n\n            // to be implemented\n            //littleEndian =  (vp.VisuCoreByteOrder === \'littleEndian\');   \n\n\n\n        }\n\n\n    var ndims = st>1?4:3;\n\n\n    // set the bruker header to nifti header\n    var view = new DataView(buffer);\n    \n \n    \n    // sizes\n    view.setInt32(0, 348,  littleEndian )\n    view.setInt16(40, ndims,  littleEndian )\n    view.setInt16(42, sx,  littleEndian )\n    view.setInt16(44, sy,  littleEndian )\n    view.setInt16(46, sz,  littleEndian )\n    view.setInt16(48, st,  littleEndian )\n    \n    // edges\n     var srow = new Float32Array(12);\n    if(edges)\n    {\n        for(var i=0; i<12; i++) \n        {\n            srow[i] = view.setFloat32(280+4*i, (edges[i]), littleEndian)\n        }\n    }\n    // ====== apply some other important stuff\n    // set the magic number to n+1\n    view.setInt32(344, 1848324352,  !littleEndian )\n    // set vox offset to 352\n    view.setFloat32(108, 352, littleEndian) \n    // set datatype\n    view.setInt16(70, datatype, littleEndian) \n\n\n\n    // pixdims\n    view.setFloat32(76, -1,  littleEndian )\n    view.setFloat32(80, vx,  littleEndian )\n    view.setFloat32(84, vy,  littleEndian )\n    view.setFloat32(88, vz,  littleEndian )\n\n\n\n\n    // dataslope\n    // NIFTI allows only one dataslope, whereas bruker has one for each slice stored\n    // Hope that slope does not change between slices. Do a check\n    if( hdr.VisuCoreDataSlope != undefined &&  hdr.VisuCoreDataSlope.content != undefined)\n    {\n        var dataslope  = hdr.VisuCoreDataSlope.content\n        var isDifferent = false;\n        for(var k=0; k<dataslope.length; k++)\n        {\n            if(dataslope[0] != dataslope[k])\n                isDifferent = true;\n        }  \n        if(isDifferent)\n        {\n            console.log(\'Warning, different slopes for each slice! Cannot write the slope to the nifti: \'+ hdrfi.fileinfo.SubFolder+"/"+hdrfi.fileinfo.filename)\n        }\n        else\n        {\n            view.setFloat32(112, dataslope[0],  littleEndian )\n            view.setFloat32(116, hdr.VisuCoreDataOffs.content[0],  littleEndian )\n        }\n    }\n\n    // qform=0, \n    view.setInt16(252, 0,  littleEndian )\n\n\n    // change from big to little endian, since  nifti library can only handle these ...\n//     var view = new DataView(databuffer.content.buffer);\n//       for(var k=0; k<databuffer.content.buffer.byteLength; k +=2)\n//           view.setUint16(k, view.getUint16(k, true) , false);\n\n\n        var bvals = [];\n         if (method && method.PVM_DwBMat)\n          {\n              var binfo = method.PVM_DwBMat;\n              var n = binfo.param[0]; \n              var bmat = binfo.content;\n              var reorienter = function(v) { return [v[0],v[1],-v[2]]; };\n              if (method.PVM_SPackArrSliceOrient.content[0] == \'coronal\')\n                   reorienter = function(v) { return [v[1],v[0],-v[2]]; };\n\n              for (var j = 0 ; j < n; j++)\n              {\n                  var ev = math.maxEV(math.matrix([ [bmat[9*j+0],bmat[9*j+1],bmat[9*j+2]],[bmat[9*j+3],bmat[9*j+4],bmat[9*j+5]],[bmat[9*j+6],bmat[9*j+7],bmat[9*j+8]] ]));\n                  ev.v._data = reorienter(ev.v._data);\n                  bvals.push(ev)\n              }\n\n          }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n \n    // combine the header and the dataarray    \n    var tmp = new Uint8Array(buffer.byteLength + databuffer.buffer.byteLength);\n    \n    tmp.set(new Uint8Array(buffer), 0);\n\n    //tmp.set(new Uint8Array(databuffer), buffer.byteLength);\n    tmp.set(new Uint8Array(databuffer.buffer), buffer.byteLength);\n    \n    return {buffer: tmp, edges:saved_edges, visu_pars:hdr, bvals:bvals,method:method};\n\n}\n\n\n\n\n\n\n\n\n\n/*\n\nBrukerReader.bruker2nifti = function(fobj_hdr, databuffer)\n{\n\n\n    // this is a default nifti buffer in uint8 representation.\n    var niihdr = [92,1,0,0,117,105,110,116,49,54,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,114,0,1,0,16,0,16,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,4,0,16,0,0,0,0,0,128,191,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,128,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,111,110,101,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,128,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,191,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,191,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,105,49,0,0,0,0,0];  \n    var buffer = Uint8Array.from(niihdr).buffer;\n    \n    brukerhdr = ab2str(fobj_hdr.content);\n    var sx,sy,sz,st, vx,vy,vz, edges, datatype; \n    var littleEndian = true;\n    // assume uint16 as default           \n    var datatype = 512;       \n\n    if  (fobj_hdr.filename.search("d3proc") > -1)\n    {\n        // ========== header type d3proc\n       // var brukerhdr = "##$SEQTYPE=slices ##$DATTYPE=ip_short ##$IM_SIX=256 ##$IM_SIY=196  ##$IM_SIZ=48  ##$IM_SIT=1 ##$SIM_SIX=256 ##$SIM_SIY=196 ##$SIM_SIZ=48";\n\n\n        var sx = parseInt( (/IM_SIX=(\\d*)/g).exec(brukerhdr)[1] )\n        var sy = parseInt( (/IM_SIY=(\\d*)/g).exec(brukerhdr)[1] )\n        var sz = parseInt( (/IM_SIZ=(\\d*)/g).exec(brukerhdr)[1] )\n        var st = parseInt( (/IM_SIT=(\\d*)/g).exec(brukerhdr)[1] )\n\n    }\n\n    if  (fobj_hdr.filename.search("visu_pars") > -1)\n    {\n    \n            // read important header fields\n            //newlinedelim = \'_newlinedelim_\';\n            //brukerhdr = brukerhdr.replace(/\\n/g, newlinedelim)\n            function getParamMultiline(myregexp, multilineparam)\n            {\n                var out = [false];\n                var res = myregexp.exec(brukerhdr); \n                if(res !== null)\n                {\n\n                    out[0] = res[1]; // same line match;\n                    out[1] = undefined; // following lines match\n                    if(multilineparam)\n                    {\n                            var tempstring = brukerhdr.substr(res.index + res[0].length);\n                            var ind = tempstring.search(/[\\$#]+/); // find the next param line\n                            out[1] = tempstring.substr(0, ind).replace(/\\n/g, \' \');\n                    }\n                }\n                return out;\n\n            }\n    \n            // easy function for zero or one line matches.\n            function getParam(myregexp,index) { return ( (myregexp.exec(brukerhdr) || [] )[index] ) || ""; }\n\n            var vp = {};// bruker parameter set\n            vp.VisuCoreWordType =    getParam(/##\\$VisuCoreWordType=(\\w+)\\n/, 1);\n            vp.VisuCoreByteOrder =   getParam(/##\\VisuCoreByteOrder=(\\w+)\\n/, 1);\n\n            vp.VisuCoreDim = getParam(/##\\$VisuCoreDim=(\\d+)\\n/, 1);\n            vp.VisuCoreFrameCount = getParam(/##\\$VisuCoreFrameCount=(\\d+)\\n/, 1); \n            vp.VisuCoreSize = getParam(/##\\$VisuCoreSize=\\(\\s(\\d)\\s\\)\\n([\\d\\s]+)\\n/, 2).split(\' \');\n            vp.VisuCoreExtent = getParam(/##\\$VisuCoreExtent=\\(\\s(\\d)\\s\\)\\n([\\d\\s.]+)\\n/, 2).split(\' \');\n            \n            // voxel sizes\n            vx = 1;\n            vy = 1;\n            vz = 1;\n\n            vx = parseFloat(vp.VisuCoreExtent[0]) / parseFloat(vp.VisuCoreSize[0]);\n            vy = parseFloat(vp.VisuCoreExtent[1]) / parseFloat(vp.VisuCoreSize[1]);\n\n            if(vp.VisuCoreExtent.length > 2)\n                vz = parseFloat(vp.VisuCoreExtent[2]) / parseFloat(vp.VisuCoreSize[2]);\n            \n\n            // orientations\n          //  vp.VisuCoreOrientation  =   getParamMultiline(/##\\$VisuCoreOrientation=\\(\\s([\\d\\s.,]+)\\)* /, true);\n          //  vp.VisuCorePosition  =      getParamMultiline(/##\\$VisuCorePosition=\\(\\s([\\d\\s.,]+)\\)* /, true);\n            \n            sx = parseInt(vp.VisuCoreSize[0]);\n            sy = parseInt(vp.VisuCoreSize[1]);\n            sz = parseInt(vp.VisuCoreSize[2]) || 1;\n            \n            st = parseInt(vp.VisuCoreFrameCount);\n\n            var framesAreSlice = false;\n            if(sz==1 & st >1   ) // slices are in frames ...?\n            {\n                // could still be a mess between slices and time frames (DTI)\n                // only way to find out so far is with visuCore first params\n                 if(vp.VisuCoreOrientation  )\n                 {\n                     sz = nSlices = parseInt(vp.VisuCoreOrientation[0].split(\' \')[0]);\n                     st = st / sz;\n                 }\n                 else\n                 {\n                     sz = st;\n                     st = 1;\n                 }\n                 framesAreSlice  = true;\n            }\n\n\n            // switched off;\n            if(vp.VisuCoreOrientation )\n            {\n                var orient =  vp.VisuCoreOrientation[1].trim().split(/\\s+/);  \n                var offset = vp.VisuCorePosition[1].trim().split(/\\s+/);\n                if(framesAreSlice & offset.length>3) // calculate the z-vox size from slice distances for multiframe data\n                {\n                    var x = 0;\n                    for(var k=0; k< 3; k++)\n                    { x +=  function (a,b){ return (parseFloat(a) - parseFloat(b))*(parseFloat(a) - parseFloat(b))  }(offset[k], offset[k+3]); }\n                    vz = parseFloat(math.sqrt(x).toFixed(3));\n                }\n\n                for(var k=0;k<12;k++) { orient[k] = parseFloat(orient[k]); }\n                for(var k=0;k<6;k++)  { offset[k] = parseFloat(offset[k]); }\n                \n\n                // according to some manual, following relation holds\n                // i = VisuCoreOrientation * p\n                // where i =firstVoxelInImageSystem and p = VisuCorePosition    \n                \n\n                // orient = [1,0,0,0,1,0,0,0,1];\n                edges = Array(3).fill(Array(3));\n                edges[0] =  orient.splice(0,3); \n                edges[1] =  orient.splice(0,3);\n                edges[2] =  orient.splice(0,3);\n\n            \n\n                edges = math.matrix(math.inv(edges))._data;\n                \n                // add the offset\n                edges[0] = edges[0].concat(offset[0]); \n                edges[1] = edges[1].concat(offset[1]); \n                edges[2] = edges[2].concat(offset[2]); \n                edges[3] = [0, 0, 0, 1];\n\n                if(! isNaN(offset[3]) ) // try to get the slice order. Only works if second slice available    \n                {\n                    var v1 =  math.multiply(edges, [offset[0], offset[1], offset[2],1]);\n                    var v2 =  math.multiply(edges, [offset[3], offset[4], offset[5],1]);\n                    var d = math.matrix(math.add(v1, math.multiply(v2,-1)))._data;\n                    var sliceOrder = -math.sign(d[2]);\n                }\n                else\n                {\n                    sliceOrder = 1;\n                }\n\n\n                var voxCorrection = math.diag([vx,vy,vz*sliceOrder,1]);\n\n                var permuationMatrix = (  [[1,0,0,0],[0,-1,0,0],[0,0,1,0],[0,0,0,1]]  );\n                \n                edges = ( math.multiply((permuationMatrix), edges));\n                edges = math.multiply( edges,    voxCorrection)\n                edges = edges._data;\n                // make linear matrix\n                edges = edges[0].concat(edges[1]).concat(edges[2]).concat(edges[3]);\n\n                //KViewer.applyState()\n           \n            }\n\n\n\n\n\n\n            // ======================\n\n            // datatype: see into nifit.js . bruker datatype can contain underscore in beginning ... ? Be careful with signd and unsigned int\n           \n            if( vp.VisuCoreWordType.search(\'8BIT_SGN_INT\') > -1 )\n                datatype = 256;       \n            else if( vp.VisuCoreWordType.search(\'16BIT_SGN_INT\') > -1)\n                datatype = 512;       \n            else if( vp.VisuCoreWordType.search(\'32BIT_SGN_INT\') > -1)  // signed int 32\n                datatype = 8;       \n\n            // to be implemented\n            //littleEndian =  (vp.VisuCoreByteOrder === \'littleEndian\');   \n\n\n\n        }\n\n\n\n    //  PARAVISION 6 ==> header type "reco""\n    else if  (fobj_hdr.filename.search("reco") > -1)\n    {\n\n\n        var diminfo = (/RECO_size=.+(\\d).+\\n(.+)\\n/g).exec(brukerhdr); \n        if((diminfo || [0]).length < 3)\n        {\n            alertify.message("sorry, could not determine the dimension info");\n            return false;\n        }\n        var dims = diminfo[2].split(" ");\n            //var diminfo = (/RECO_size=.+(\\d).+\\n(\\d+)\\s(\\d+)\\s(\\d+)\\s/g).exec(brukerhdr) \n\n        var ndims = dims.length;\n        sx = parseInt( dims[0] )\n        sy = parseInt( dims[1] )\n        if(ndims == 3)\n            sz = parseInt( dims[2] )\n        else if(ndims == 2)\n            var sz = 1;\n\n        st = parseInt( (/RecoObjectsPerRepetition=(\\d*)/g).exec(brukerhdr)[1] ) || 1;\n        if(sz==1 & st >1   )\n            {\n                sz = st;\n                st = 1;\n            }\n\n    }\n    var ndims = st>1?4:3;\n\n\n    // set the bruker header to nifti header\n    var view = new DataView(buffer);\n    \n    // sizes\n    view.setInt32(0, 348,  littleEndian )\n    view.setInt16(40, ndims,  littleEndian )\n    view.setInt16(42, sx,  littleEndian )\n    view.setInt16(44, sy,  littleEndian )\n    view.setInt16(46, sz,  littleEndian )\n    view.setInt16(48, st,  littleEndian )\n    \n    // edges\n     var srow = new Float32Array(12);\n    if(edges)\n    {\n        for(var i=0; i<12; i++) \n        {\n            srow[i] = view.setFloat32(280+4*i, (edges[i]), littleEndian)\n        }\n    }\n\n\n\n    // ====== apply some other important stuff\n    // set the magic number to n+1\n    view.setInt32(344, 1848324352,  !littleEndian )\n    // set vox offset to 352\n    view.setFloat32(108, 352, littleEndian) \n    // set datatype\n    view.setInt16(70, datatype, littleEndian) \n\n\n   //     view.getFloat32(280+4, littleEndian)\n\n    // change from big to little endian, since  nifti library can only handle these ...\n//     var view = new DataView(databuffer.content.buffer);\n//       for(var k=0; k<databuffer.content.buffer.byteLength; k +=2)\n//           view.setUint16(k, view.getUint16(k, true) , false);\n\n \n    // combine the header and the dataarray\n    var tmp = new Uint8Array(buffer.byteLength + databuffer.content.byteLength);\n    tmp.set(new Uint8Array(buffer), 0);\n    tmp.set(new Uint8Array(databuffer.content), buffer.byteLength);\n    \n    return tmp;\n\n}\n\n\n*/\n\n\n'},function(t,n){t.exports='\n/** A proxy for the tools, tools are just loaded on demand  \n * @class */\nfunction ToolProxy(toolvar, toolObj, toolname)\n{\n    var id;\n    var statetoset;\n\n    if(!hasProxy)\n    {\n        id = ktoolslist.length;\n        return buildTool(id);\n    }\n\n    function buildTool()\n    {\n        if (typeof toolObj == "string")\n            toolObj = eval(toolObj);\n\n        var tool = new toolObj(KViewer,toolname);\n        KViewer[toolvar] = tool;\n        ktoolslist[id] = tool;\n        tool.ktoolsindex = id;\n        if (hasProxy)\n            KToolWindow.attachToollist(tool);\n        tool.resize(standardToolsize);\n        tool.setState(statetoset);\n        return tool\n    }\n\n    var handler = {       \n        get: function(target, name,rec) {\n            if (name == \'isproxy\')\n                return true\n            else if (name == \'notyetloaded\')\n            {\n                var tobj = toolObj\n                if (typeof tobj == "string")\n                    tobj = eval(tobj);\n\n                return tobj.notyetloaded != undefined\n            }\n            else if (name == \'setState\')\n            {\n                return function(x) {\n                     statetoset = x; \n                }\n            }\n            else if (name == \'name\')\n                return toolname;\n            else if (name == \'isinstance\' || name == "enabled")\n            {\n                if (KViewer[toolvar].isproxy)\n                    return false;\n                else\n                    return KViewer[toolvar][name];\n            }\n            else\n            {\n                console.log(toolvar + \' started by \' + name);\n                var tool = buildTool();\n                return tool[name];\n            }\n\n        }\n    };\n    var proxy = new Proxy({},handler);\n    id = ktoolslist.length;\n    ktoolslist.push(proxy);\n\n    return proxy;\n}\n\n\nfunction attachNameDivHandler(fobj, $captiondiv, cb)\n{\n    if (fobj.namedivs == undefined)\n        fobj.namedivs = [];\n\n    $captiondiv.on(\'mousedown\', function() {\n        $captiondiv.attr(\'contenteditable\', true);\n    });\n    $captiondiv.on(\'blur\', function() {\n        $captiondiv.attr(\'contenteditable\', false);\n         $captiondiv.text(fobj.filename);\n    });\n\n    \n    fobj.namedivs.push($captiondiv);\n    $captiondiv.keydown(function(ev) {\n        if (ev.keyCode == 13) {\n            $(ev.target).blur();\n            return false\n        }\n    })\n    .keyup(function(ev)\n    {\n        var subf_given = false\n        var txt = $captiondiv.text().trim();\n        txt = txt.split("/");\n        var name = txt[txt.length-1];\n        var subf = ""\n        if (txt.length > 1)\n        {\n            subf_given = true\n            txt.pop();\n            subf = txt.join("/");            \n        }\n\n        fobj.filename = name;\n        if (fobj.fileinfo == undefined)\n            fobj.fileinfo = {}\n        if (subf != "" | subf_given)\n            fobj.fileinfo.SubFolder = subf;\n\n        if (fobj.namedivs != undefined)\n            for (var i = 0; i < fobj.namedivs.length; i++)\n            {\n                if ($captiondiv != fobj.namedivs[i])\n                    fobj.namedivs[i].text(fobj.filename);\n            }\n        cb();\n\n    });\n\n\n}\n\n\n\n// ======================================================================================\n// ============= frame for undocked tool\n// ======================================================================================\nfunction resizeTriangle(afterResize,onresize,$frame_)\n{\n    var $resizer = $("<div class=\'dialog_generic_resizeTriangle\'></div>")\n    .mousedown(function()\n    {\n        if ($frame_ != undefined)\n            $frame = $frame_\n        else\n            $frame = $resizer.parent();\n        $resizer.addClass(\'dialog_generic_resizeTriangle_hovered\');\n        $(document.body).on(\'mousemove\', function(ev) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            var newwidth = ev.clientX - $frame.offset().left + window.pageXOffset+10;\n            var newheight = ev.clientY - $frame.offset().top + window.pageYOffset+10;\n            if (newwidth < 200 | newheight < 200)\n            {\n                return;\n            }\n            $frame.width(newwidth);\n            $frame.height(newheight);\n            if (onresize)\n                onresize(newheight)\n\n        });\n        $(document.body).on(\'mouseup\', function() {\n            $resizer.removeClass(\'dialog_generic_resizeTriangle_hovered\');\n            $(document.body).off(\'mousemove mouseup\');\n            if (afterResize)\n                afterResize();\n        });\n\n    });\n    return $resizer;\n}\n\n// ======================================================================================\n// ======================================================================================\n// ============= the generic toolwindow\n// ======================================================================================\n// ======================================================================================\n\n\nvar ktoolslist = [];\n\nfunction KToolWindow(master, $toggle)\n{\n    /** The generic tool window functionality\n   * @class \n   * @alias KToolWindow\n   */\n    var that = new Object();\n    that.name = \'generic\';\n\n    // stuff for viewport attachment\n    that.viewerType = \'Manager\';\n\t/** if tool is whithin a viewport this is the parent viewport */\n    that.viewport = undefined;\n\t/** this is a true instance and not just a proxy {@link ToolProxy} */\n    that.isinstance = true;\n    var saved_height;\n\n\n    that.$toggle = $toggle.click(function(ev) {\n        that.toggle();\n    });\n\n    that.update = function() {}\n    that.setState = function () {}\n    that.getState = function () {}\n\n    that.enabled = false;\n    that.master = master;\n\n\n    var $container = $("<div class=\'annotation_tool\'></div>");\n    that.$container = $container;\n\n    that.onresize = function(ev)\n    {\n        if (that.tstate.target != -2)\n            return;\n\n        // var maxdelta = $("#frame").height()  - $("#patientTableLowerContainer").height() - 100;\n\n        var th = that;\n\n        var s = ev.clientY;\n        var h = th.$container.height();\n\n        var th_lower = KToolWindow.findToolbyContainer(th.$container.next());\n        var th_upper = KToolWindow.findToolbyContainer(th.$container.prev());\n        var h_upper;\n        if (th_upper != undefined)\n            h_upper = th_upper.$container.height();\n\n        $(document.body).on("mousemove", function(ev)\n        {\n            //if (s-ev.clientY < maxdelta & \n            if (h + s - ev.clientY > 50)\n            {\n                if (th_lower != undefined | userinfo.username != guestuser)\n                   th.resize(h + s - ev.clientY);\n                if (th_upper != undefined)\n                    th_upper.resize(h_upper - s + ev.clientY);\n                setPatientTableLayout();\n            }\n        });\n        $(document.body).on("mouseup", function()\n        {\n            $(document.body).off("mousemove mouseup");\n            saveSizesPt();\n        });\n    }\n    ;\n\n\n\n    /** the spinner $div */\n    that.$spinner = $("<div class=\'KViewPort_spinner\' ><i class=\'fa fa-spinner fa-spin\'></i> <span >Loading</span></div>").appendTo($container);\n    /** spinner callback for this tool (see {@link module:MiscFunctions~theSpinner}) */\n    that.progressSpinner = theSpinner(that.$spinner);\n    that.hideSpinner = function() {  that.$spinner.hide(); }\n\n\n    var $resizer = $("<div class=\'annotion_tool_resizer\'><div><div></div></div></div>").appendTo($container).on("mousedown", that.onresize);\n\n    var $topDiv = $("<div>").appendTo($container);\n\n    var $newdragger = $("<div class=\'KToolsdragger\' draggable=true><i class=\'fa fa-hand-paper-o\' > </i></div>").appendTo($topDiv);\n    $newdragger[0].ondragstart = function(e)\n    {\n        if (that.name == "Workspace" && userinfo.username == guestuser && guestuser != "")\n            return;\n        dragstart(e);\n        setTimeout(function() {\n            that.$topRow.removeClass("highlight");cleanAllDropIndicators();\n        },3000);  \n    } \n\n    var $topRow = $("<ul class=\'KToolsTopMenu menu_generic small\'></ul>").appendTo($topDiv);\n    that.$topRow = $topRow;\n    $topRow.append($("<li  style=\'float:right\'> <a><i class=\'fa fa-close close_button\' ></i></a></li>").appendTooltip("closetool").click(function() {\n        that.toggle(false);\n    }));\n    \n\n    that.$leftToolistDiv =$("<div class=\'KTool_leftdiv\'></div>").appendTo($container); \n\n    \n    that.$leftToolistDiv.on("mouseenter",function() {\n        that.$leftToolistDiv.addClass(\'LDvisible\');\n    })\n\n    that.$leftToolistDiv.on("mouseleave",function() {\n       that.$leftToolistDiv.removeClass(\'LDvisible\');\n    })\n\n\n    function dragstart(ev)\n    {\n        // undock indicator\n        setTimeout(function(e){\n            var $undocker = $("<div class=\'dropindicator_general_vert body_dropindicator\' style=\'\'></div>").hide().appendTo($(document.body)).fadeIn(150);\n            setPixelPosition($undocker, [1,1, 400,100], 0);\n            var $inner = $("<div style=\'padding:9px; background:rgba(20, 139, 0, 0.9)\'>Drop here to undock tool</div>").appendTo($undocker);\n                    $inner.on("dragenter dragover", function(ev)\n                    { $(this).css(\'background\', \'rgba(20, 139, 0, 0.9)\'); \t\t\t\tev.preventDefault();ev.stopPropagation();return false; });\n                    $inner.on("dragleave", function(ev)\n                    { $(this).css(\'background\', \'rgba(20, 139, 0, 0.9)\');\t\t\t\tev.preventDefault();ev.stopPropagation();return false; });\n                    $inner[0].ondrop = function(ev)\n                    { \n                        $undocker.remove();\n                        cleanAllDropIndicators(); \n                        that.show(-1);\n                        that.$container.offset({left:60, top:60});\n                        that.$container.animate({left: tstate.udsize[0], top: tstate.udsize[1]}, 100);\n                        KToolWindow.dragTool = undefined;\t\t\t\t\n                        ev.preventDefault();ev.stopPropagation();return false; \n                    }\n        },250);\n        patientTableScrollLock($("#patientTableWrap"));\n        KToolWindow.dragTool = that;\n        tempObjectInfo = undefined;\n        ev.toolDragDrop = "Tool:" + that.name;\n        buildDragImg(ev);\n        ev.stopPropagation();\n    }\n\n\n    var defaulttarget = (KViewer.standalone?-1:-2);\n    var tstate =\n    {\n        udsize: [400, 400, 600, 600],\n        // undocked size\n        ptsize: [\'100%\', 300],\n        // size in patientable\n        target: defaulttarget,\n        lasttarget: defaulttarget\n       \n    }\n    that.tstate = tstate;\n\n    var $resizeTriangle = resizeTriangle(saveSizesUndocked,function(x) { that.resize(x); } ).hide().appendTo($container);\n\n\n    /***************************************************************************************\n\t* toggle docked state\n\t****************************************************************************************/\n\n    function toggledockedstate(forcewhichstate)\n    {\n        if (forcewhichstate != undefined)\n        {\n            if (forcewhichstate)\n                // force docked state\n                that.show(that.tstate.lasttarget);\n        }\n        else // toggle\n        {\n            if (that.tstate.target == -1) // was undocked, so dock into lasttarget\n            {\n                that.show(that.tstate.lasttarget);\n            }\n            else // was docked, so undock\n            {\n                that.$container.detach();\n              \n                that.show(-1);\n            }\n        }\n         \n    }\n    that.toggledockedstate = toggledockedstate;\n\n    function saveSizesUndocked()\n    {\n        tstate.udsize[0] = $container.offset().left;\n        tstate.udsize[1] = $container.offset().top;\n        tstate.udsize[2] = $container.width();\n        tstate.udsize[3] = $container.height();\n        //that.$container.children().eq(4).height(\'100%\')   \n    }\n\n    function saveSizesPt()\n    {\n        that.tstate.ptsize[1] = $container.height();\n        that.tstate.ptsize[0] = 1;\n    }\n\n    function setdocked()\n    {\n        //saveSizesUndocked(); don\'t! otherwise will be set to zero in some cases\n        $topRow.off(\'mousedown\');\n        $container.css(\'position\', \'static\');\n        $resizeTriangle.hide();\n    }\n\n    function setundocked()\n    {\n        that.tstate.lastttarget = that.tstate.target;\n        $topRow.off(\'mousedown\');\n        $resizer.hide();\n        $container.css(\'position\', \'absolute\')\n        if (!$container.hasClass("movableWindows"))\n            $container.addClass("movableWindows");\n        \n//         var zindex = $container.css(\'z-index\');\n//         if (zindex == 0)\n//         {\n//             var x = getHighestZIndexOfSameClass(("movableWindows"));\n//             $container.css(\'z-index\', (parseInt(x.index) + 1).toString());\n//         }\n        \n        bringToFront($container);\n\n        $container.offset({\n            left: that.tstate.udsize[0],\n            top: that.tstate.udsize[1]\n        }).width(that.tstate.udsize[2]).height(that.tstate.udsize[3]);\n        //setPatientTableLayout();\n        $topRow.mousedown(function(ev) {\n            movableWindowMousedownFn(ev, $container, saveSizesUndocked, \'fa\')\n        });\n        $resizeTriangle.show();\n    }\n\n\n\n    var $toolselector = $("<ul ></ul>");\n    that.$toolselector = $toolselector;\n  \n  //  that.$topRow.append($("<li> <a> <i class=\'fa fa-bars fa-1x\'></i></a></li> ").append($toolselector));\n\n    that.customToggle = function() {\n        return false;\n    }\n    \n\n    // overwrite this for your custom toggle function\n    that.toggle = function(forcestate)\n    {\n        if (forcestate != undefined)\n            that.enabled = forcestate;\n        else\n        {\n\n            if (that.tstate.target >= 0 && that.enabled)\n            {\n                if (!KViewer.viewports[that.tstate.target].visible)\n                {\n                   KViewer.viewports[that.tstate.target].setCurrentViewer();\n                   that.tstate.target = -1;\n                }\n                else\n                    that.enabled = false\n            }\n            else\n                that.enabled = !that.enabled;\n\n\n        }\n\n        if (that.enabled)\n        {\n            that.$toggle.addClass(\'KView_tool_enabled\');\n            that.show();\n        }\n        else\n        {\n            that.$toggle.removeClass(\'KView_tool_enabled\');\n            that.hide();\n        }\n\n        that.customToggle(that.enabled );\n    }\n\n\n    /** insert this tool into some target (patientTable, viewport, or undockeded stat)\n        replace another tool, if target is occupied\n     *  @function \n     *  @param {object} target -\n\t *   <pre>\n\t *\t  0...9 viewport  \n\t *\t  -1\tundocked  \n\t *\t  -2\tpatientTable (inser new)\n\t *\t  $div  patientTable (before anther tool)\n\t *\t  tool  another tool (identify by pointer), in this case, replace the tool\n     *\n\t *\t  undefined: restore state, find last target (save as -2, -1, 0 ... ), if in vp, must check for another existing tool\n\t *   </pre>\n\t */  \t\t\t\t\n    that.show = function(target)\n    {\n\n        // no target specified, try to restore from remembered state\n        if (target == undefined)\n            target = that.tstate.target;\n\n        // translate vp to vpID\n        if (target.viewPortID != undefined)\n            target = target.viewPortID;\n\n        // ******************* check where this item was last\n        if (that.tstate.target >= 0 && that.enabled != 0)\n            KViewer.viewports[that.tstate.target].setCurrentViewer();\n        else if (that.tstate.target == -2)\n        {\n        //saveSizesPt(); //don\'t do this! otherwise will be overwritten on reload\n        }\n\n\n        //***********************  undock ******************************\n        if ($.isNumeric(target) && target == -1)\n        {\n            $(document.body).append($container);\n            setundocked();\n        }\n\n        //***********************  ptable at end ******************************\n        else if ($.isNumeric(target) && target == -2)\n        {\n            setdocked();\n            var childs = $("#patientTableLowerContainer").children();\n\n            var above;\n            if (userinfo.username == guestuser)\n                above = childs[childs.length - 1];\n            else\n                above = childs[0];\n\n            that.$container.insertAfter(above)\n\n            if (that.$container.position().top+that.$container.height() > $("#frame").height()+80)\n            {\n                var toolabove = KToolWindow.findToolbyContainer($(above));\n                var newheight = ($("#frame").height()+80 - $(above).position().top)*0.5;\n                toolabove.resize(newheight)\n                that.resize(newheight);\n            }\n            \n\n            if (KViewer.zoomedViewport != -1)\n                KViewer.setSizeLeftViewportCol();\n\n        }\n\n        //*******************  ptable after another tool ***********************\n        else if (target.append != undefined && target.hasClass(\'annotation_tool\'))\n        {\n            setdocked();\n            that.$container.insertBefore(target);\n            target = -2;\n\n            if (KViewer.zoomedViewport != -1)\n                KViewer.setSizeLeftViewportCol();\n\n        }\n\n        //***********************  viewport ******************************\n        else if ($.isNumeric(target) && target >= 0)\n        {\n            var vp = KViewer.viewports[target]\n            // check if vp is occupied by another tool. If yes, show as undocked\n            // this normally does not happen\n            if (vp.$container.find(\'.annotation_tool\').length > 0)\n            {\n                that.show(-1);\n                return;\n            }\n            setdocked();\n\n            vp.hideDropIndicators();\n            var currview = vp.getCurrentViewer();\n            if (currview != undefined && currview.close != undefined)\n                vp.getCurrentViewer().close();\n            vp.setCurrentViewer(that);\n        }\n\n        // only if we come from an undocked state, save last state\n        if (that.tstate.target !== -1)\n        {\n            that.tstate.lasttarget = that.tstate.target;\n        }\n\n        // final checks and specialities\n        if (target == -2)\n        {\n            $resizer.show();\n            that.resize(that.tstate.ptsize[1]);\n        }\n        else    if (target == -1)\n        {\n            that.resize(that.tstate.ptsize[1]);\n        }\n        else\n        {\n            $resizer.hide();\n        }\n\n        that.tstate.target = target;\n        that.enabled = true;\n        that.setInnerLayout();\n\n        if (that.update)\n            that.update();\n        setPatientTableLayout();\n\n    }\n\n\n    /** close(hide) the tool (but remember state),\n    * @function */\n    that.hide = function(target)\n    {\n        that.enabled = 0;\n        that.$container.detach();\n        if (that.tstate.target >= 0)\n        {\n            KViewer.viewports[that.tstate.target].setCurrentViewer();\n        }\n        else if (that.tstate.target == -2)\n        {\n            if (KViewer.zoomedViewport != -1)\n                KViewer.setSizeLeftViewportCol();\n            \n            setPatientTableLayout();\n        }\n\n    }\n\n\n\n    new Dragster(that.$container.get(0));\n    that.$container.get(0).addEventListener(\'dragenter\', function(ev)\n    {\n        if (KToolWindow.dragTool != undefined)\n        {\n            that.$topRow.addClass("highlight");\n        }\n    });\n\n    that.$container.get(0).addEventListener(\'dragster:leave\', function(ev)\n    {\n        if (KToolWindow.dragTool != undefined)\n        {\n            that.$topRow.removeClass("highlight");\n        }\n    });\n\n    that.$container.on("drop", function(ev)\n    {\n        that.$topRow.removeClass("highlight");\n        if (that.name == \'Files\' & userinfo.username == guestuser)\n        {\n            dropOnLeftBar();\n        }\n        else if (KToolWindow.dragTool != undefined)\n        {\n\n            var source = KToolWindow.dragTool;\n            if (that == source) // drop on itself\n            {\n                KToolWindow.dragTool = undefined;\n            }\n            else if (that.tstate.target == -2) // drop into the ptable: insert new one before\n            {\n                KToolWindow.dragTool.show(that.$container);\n            }\n            else if (that.tstate.target >= -1) // undocked or viewport: full replacement\n            {\n                that.hide();\n                KToolWindow.dragTool.show(that.tstate.target);\n            }\n\n            KToolWindow.dragTool = undefined;\n\n            ev.stopPropagation();\n            ev.preventDefault();\n\n            return;\n        }\n        else if (ev.dataTransfer && ev.dataTransfer.types && ev.dataTransfer.types[0] == \'text/plain\')\n        {\n            // prevent all text drop on tools \n            ev.stopPropagation();\n            ev.preventDefault();\n        }\n\t  \t\t\n\t\n\n        cleanAllDropIndicators();\n\n    });\n\n\n\n    that.detachContent = function()\n    {\n        $container.detach()\n    }\n    ;\n\n    that.setInnerLayout = function()\n    {\n        if (that.tstate.target >= 0) // in a viewport\n        {\n            var vp = KViewer.viewports[that.tstate.target];\n            that.$container.width(vp.$container.width() - 0);\n            that.$container.height(vp.$container.height() - 0);\n        }\n        else if (that.tstate.target == -1) // undocked\n        {\n\n\n        }\n        else if (that.tstate.target == -2) // patientTable\n        {\n            that.$container.css("width", "100%");\n        }\n    }\n    ;\n\n\n    that.tablestate = undefined;\n    that.attachTableOperator = function($to, dummy, sortable) {\n        that.tablestate = attachTableOperator($to, that.tablestate, sortable).state;\n    }\n\n\n    function dropOnLeftBar()\n    {\n        if (KToolWindow.dragTool != undefined)\n        {\n            KToolWindow.dragTool.hide();\n            KToolWindow.dragTool.show();\n            KToolWindow.dragTool = undefined;\n            return;\n        }\n    }\n\n\n    return that;\n}\n\n/** @param {div} $cont - the container div of the tool */\nKToolWindow.findToolbyContainer = function($cont)\n{\n    for (var k = 0; k < ktoolslist.length; k++)\n    {\n        if (ktoolslist[k].isinstance && ktoolslist[k].$container != undefined && ktoolslist[k].$container[0] == $cont[0])\n            return ktoolslist[k];\n    }\n    return undefined;\n}\n\n\n/** @param {div} $cont - the container div of the tool */\nKToolWindow.findToolInLowerContainer = function()\n{\n    var incontainer = [];\n    var tools = $("#patientTableLowerContainer").children();\n    for (var k = 0; k < tools.length; k++)\n    {\n        var t = KToolWindow.findToolbyContainer($(tools[k]))\n        if (t != undefined)\n            incontainer.push(t);\n    }\n    return incontainer;\n}\n\n\n\n/** attach this tool to the list of the "wrench" button of Kview for tool selection\n * $param {div} $container - the KView container\n * @function */\nKToolWindow.attachToolSelectors = function($container)\n{\n    KToolWindow.$thetoggle = $("<div class=\'KView_tool \'><i class=\'fa fa-wrench fa-1x\'></i></div>");\n    KToolWindow.$thetoggle.insertAfter($container.children()[7]);\n    var $menu = $("<ul class=\'KView_tool_menu\'></ul>").appendTo(KToolWindow.$thetoggle);\n    $menu.append($("<li>Toolboxes ...</li>"));\n\n    for (var k = (userinfo.username == guestuser && !KViewer.standalone) ? 1 : 0; k < ktoolslist.length; k++)\n    {\n        if (!hasProxy)\n            KToolWindow.attachToollist(ktoolslist[k]);\n\n        var $tdiv = $("<li draggable=\'true\'>" + ktoolslist[k].name + "</li>").appendTo($menu);\n        $tdiv.click(function(_k) {\n            return function() {\n                ktoolslist[_k].$toggle.trigger(\'click\')\n            }\n        }(k))\n        $tdiv[0].ondragstart = function(_k) {\n            return function(ev)\n            {\n\n                ev.toolDragDrop = "Tool:" + ktoolslist[_k].name;\n                buildDragImg(ev);\n                KToolWindow.dragTool = ktoolslist[_k];\n                //patientTableScrollLock();\n\n            }\n        }(k);\n        $tdiv.on("dragover", function(ev) {\n            ev.preventDefault();\n            ev.stopPropagation();\n            return false;\n        })\n        \n    }\n\n}\n\n/** attach [that] to the list inside the tool for other tool selection \n * @param {object} that - the tool to which the selectoe to be attached */\nKToolWindow.attachToollist = function(that)\n{\n    for (var k = 0; k < ktoolslist.length; k++)\n//    for (var k = (userinfo.username == guestuser  && !KViewer.standalone) ? 1 : 0; k < ktoolslist.length; k++)\n    {\n        var onclick = function(k) {\n            return function()\n            {\n                //console.log("changing tool");\n                if (ktoolslist[k] === that) // self\n                {\n                    return false\n                }\n                if (that.tstate.target == -1)\n                {\n                    ktoolslist[k].show(-1);\n                    ktoolslist[k].$container.offset({\n                        left: that.tstate.udsize[0],\n                        top: that.tstate.udsize[1]\n                    }).width(that.tstate.udsize[2]).height(that.tstate.udsize[3]);\n                    that.hide();\n                }\n                else if (that.tstate.target == -2)\n                {\n                    ktoolslist[k].show(-2);\n                    ktoolslist[k].$container.height(that.$container.height());\n                    var $anchor = that.$container.before();\n                    if ($anchor.length == 0)\n                        // no prev element, append to parent\n                        ktoolslist[k].$container.appendTo($container.parent())\n                    else\n                        ktoolslist[k].$container.insertAfter($anchor);\n                    //that.$container.replaceWith(ktoolslist[k].$container);\t          // replaceWith will loose handlers\n                    that.$container.detach();\n                    that.hide();\n                }\n                else if (that.tstate.target >= 0)\n                {\n                    that.hide();\n                    ktoolslist[k].show(that.tstate.target);\n                }\n            }\n        }(k)\n\n\n        $("<li><a>" + ktoolslist[k].name + "</a></li>").click(onclick).appendTo(that.$toolselector);\n\n        var toolicons = KToolWindow.toolicons ;\n        var thei = "";\n        if (toolicons[ktoolslist[k].name])\n            thei = "<i class=\'fa " + toolicons[ktoolslist[k].name] + "\'></i>";\n        var enabled = "";\n        if (ktoolslist[k] === that)\n            enabled ="KView_tool_enabled";\n        $("<div class=\'KView_tool " + enabled + " KView_tool_small\'>" + thei +" <ul class=\'KView_tool_menu\'> <li> "+ktoolslist[k].name+" </li> </ul></div>").click(onclick).appendTo(that.$leftToolistDiv);\n    }\n}\n\n\nKToolWindow.toolicons = {\n                Workspace:\'fa-navicon\',\n                ROIs:\'fa-pencil\',\n                "Objects 3D":"fa-cube",\n                Atlas:"fa-map",\n                Forms:"fa-file-text-o",\n                "MarkerTool":"fa-comment-o",\n                "Navigation":"fa-arrows",\n                "CurveTool":"fa-area-chart",\n                "ReadingTool":"fa-registered"\n\n}\n\n\n\nKToolWindow.getToolsState = function()\n{\n    var toolstate = [];\n    for (var k = 0; k < ktoolslist.length; k++)\n    {\n        var tool = ktoolslist[k];\n        if (tool.enabled)\n        {\n            var thestate = {\n                tool: tool.name,\n                table: tool.tablestate,\n                tstate: tool.tstate,\n                setting: tool.getState()\n            };\n            toolstate.push(thestate);\n        }\n\n    }\n    return toolstate;\n\n}\n\n\nKToolWindow.closeAll = function()\n{\n    // set the enabled tools\n    for (var k = (userinfo.username != guestuser || electron) ? 0 : 1; k < ktoolslist.length; k++)\n    {\n        if (ktoolslist[k].isinstance)\n        {\n            ktoolslist[k].hide();\n        }\n    }\n}\n\nKToolWindow.reestablishToolState = function(toolstate)\n{\n\n    KToolWindow.closeAll();\n\n    // set the enabled tools\n    for (var k = 0; k < toolstate.length; k++)\n    {\n        for (var j = (userinfo.username != guestuser || electron) ? 0 : 1; j < ktoolslist.length; j++)\n        {\n            var tool = undefined;\n            if (ktoolslist[j].name == toolstate[k].tool)\n                break;\n        }\n        if (ktoolslist[j] != undefined)\n        {\n            var toggleTool = function(j,k)            \n            {\n                if (ktoolslist[j].notyetloaded)\n                {\n                    setTimeout(function() { toggleTool(j,k) },25);\n                }\n                else\n                {\n                    ktoolslist[j].toggle(false);\n\n                    //extend is important!\n                    $.extend(true, ktoolslist[j].tstate, toolstate[k].tstate);\n                    ktoolslist[j].tablestate = toolstate[k].table;\n                    ktoolslist[j].setState(toolstate[k].setting);\n\n                    ktoolslist[j].show();\n                    ktoolslist[j].update();\n                }\n            }\n            toggleTool(j,k);\n           \n        }\n    }\n}\n\n\n\nfunction KTool_enabled()\n{\n    for (var k = 0; k < ktoolslist.length; k++)\n    {\n        if (ktoolslist[k].enabled)\n            return k;\n    }\n    return -1;\n}\n'},function(t,n){t.exports='function fastCos(x) {\n    var x2 = x * x;\n    var x4 = x2 * x2;\n    var x6 = x4 * x2;\n    var x8 = x6 * x2;\n    var x10 = x8 * x2;\n    return 1 - (1814400 * x2 - 151200 * x4 + 5040 * x6 - 90 * x8 + x10) / 3628800;\n}\n\nfunction solvePoissonMC(elecGeometry,params,nii,current,conductivity)\n{\n\n\tvar M = 256;\n\tvar cosLUT = new Array(M)\n\tvar sinLUT = new Array(M)\n\tfor (var l = 0; l < M;l++)\n\t{\n\t\tcosLUT[l] = Math.cos(Math.PI*2*l/M);\n\t\tsinLUT[l] = Math.sin(Math.PI*2*l/M);\n\t}\n\n\tfunction cos(x)\n\t{\n\t\treturn cosLUT[Math.floor(x*M)];\n\t}\n\tfunction sin(x)\n\t{\n\t\treturn sinLUT[Math.floor(x*M)];\n\t}\n\n\tvar alpha = params.alpha;\n\tvar N = 1; //Math.ceil(4*alpha);\n\tvar weight = 1/N;\n\n\tvar num_particles = params.num_particles_;\n\tvar num_steps = params.num_steps\n\n\tvar buffer = new Float32Array(nii.sizes[0]*nii.sizes[1]*nii.sizes[2]);\n\tnii.data = buffer;\n\n\tvar buffer_current = new Float32Array(nii.sizes[0]*nii.sizes[1]*nii.sizes[2]*3);\n\tcurrent.data = buffer_current;\n\n\tvar w = nii.sizes[0];\n\tvar h = nii.sizes[1];\n\tvar d = nii.sizes[2];\n\n\tvar w2 = w/2;\n\tvar h2 = h/2;\n\tvar d2 = d/2;\n\tvar domsq = w2*w2;\n\tvar wh = nii.widhei;\n\tvar whd = w*h*d;\n\tvar e = nii.invedges;\n\tvar ie = nii.edges;\n\n\tif (conductivity)\n\t{\n\t\tvar e2c = conductivity.invedges;\n\t\tvar cond = conductivity.data;\n\t\tvar w_cond = conductivity.sizes[0];\n\t\tvar wh_cond = conductivity.widhei;\n\t\tvar whd_cond = conductivity.sizes[0]*conductivity.sizes[1]*conductivity.sizes[2];\n\t}\n\n\n\n\tvar tip = elecGeometry.tip;\n\tvar end = elecGeometry.end;\n\tvar min = elecGeometry.c_min;\n\tvar max = elecGeometry.c_max;\n\tvar radius = elecGeometry.radius;\n\tvar r2 = elecGeometry.radius*elecGeometry.radius;\n\n\tvar n = [end[0]-tip[0],end[1]-tip[1],end[2]-tip[2]];\n\tvar norm = Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);\n\tn[0] /= norm; n[1] /= norm; n[2] /= norm;\n\n\tvar nx = [ n[0],-n[2],n[1] ];\n\tvar ny = [ n[1]*nx[2] - n[2]*nx[1],\n\t\t\t   n[2]*nx[0] - n[0]*nx[2],\n\t\t\t   n[0]*nx[1] - n[1]*nx[0]];\n\n\tfunction getDisplacement(fac)\n\t{\n\t\t/*\n\t\tvar r = Math.floor(Math.random()*num_dirs);\n\t\tvar sg = 1;\n\t\tif (Math.random()>0.5)\n\t\t\tsg = -1;\n\t\treturn [iso_directions[r][0]*sg,iso_directions[r][1]*sg,iso_directions[r][2]*sg];\n\t\t*/\n\t\tvar u1 = Math.random();\n\t\tvar u2 = Math.random();\n\t\tvar h = Math.sqrt(-2*Math.log(u2))\n\n\t\tvar x = h*cos(u1);\n\t\tvar y = h*sin(u1);\n//\t\tvar x = h*Math.cos(u1*2*Math.PI);\n//\t\tvar y = h*Math.sin(u1*2*Math.PI);\n\t\t\n\t\tvar u1 = Math.random();\n\t\tvar u2 = Math.random();\n\t\tvar h = Math.sqrt(-2*Math.log(u2))\n\n//\t\tvar z = h*Math.cos(u1*2*Math.PI);\n\t\tvar z = h*cos(u1);\n\n\t\treturn [fac*x,fac*y,fac*z];\n\n\t\t//return [gaussian(),gaussian(),gaussian()];\n\t\t\n\t}\n\n\n\tfunction getDisplacementAniso(C,alpha)\n\t{\n\t\tvar u1 = Math.random();\n\t\tvar u2 = Math.random();\n\t\tvar h = Math.sqrt(-2*Math.log(u2))\n\n\t\tvar x = h*cos(u1)*alpha;\n\t\tvar y = h*sin(u1)*alpha;\n\t\t\t\t\n\t\tvar u1 = Math.random();\n\t\tvar u2 = Math.random();\n\t\tvar h = Math.sqrt(-2*Math.log(u2))\n\n\t\tvar z = h*cos(u1)*alpha;\n\n\t\treturn [ C[0]*x +  C[3]*y +  C[6]*z , \n\t\t\t\t C[1]*x +  C[4]*y +  C[7]*z ,\n\t\t\t\t C[2]*x +  C[5]*y +  C[8]*z ];\n\n\t}\n\n\n\n\tfunction getStartPoint()\n\t{\n\t\tif (elecGeometry.multipolar.length > 0)\n\t\t{\n\t\t\tvar m = elecGeometry.multipolar\n\t\t\tvar p = Math.random();\n\t\t\tvar a = 0\n\t\t\tvar k;\n\t\t\tfor (k = 0; k < m.length;k++)\n\t\t\t{\n\t\t\t\tif (p <= (a+m[k].current))\n\t\t\t\t\tbreak;\n\t\t\t\ta+=m[k].current;\t\t\t\t\n\t\t\t}\n\n\t\t\tvar c = Math.random();\n\t\t\tvar x = radius*Math.cos(2*Math.PI*c);\n\t\t\tvar y = radius*Math.sin(2*Math.PI*c);\n\n\t\t\tvar r = m[k].min + (m[k].max-m[k].min)*Math.random();\n\n\t\t\treturn {p:[ tip[0] + r*n[0] + x*nx[0] + y*ny[0],\n\t\t\t\t\t tip[1] + r*n[1] + x*nx[1] + y*ny[1],\t\n\t\t\t\t\t tip[2] + r*n[2] + x*nx[2] + y*ny[2] ] ,s:m[k].sign};\n\n\n\n\t\t}\n\t\telse\n\t\t{\t\t\n\t\t\tvar c = Math.random();\n\t\t\tvar x = radius*Math.cos(2*Math.PI*c);\n\t\t\tvar y = radius*Math.sin(2*Math.PI*c);\n\n\t\t\tvar r = min + (max-min)*Math.random();\n\n\n\t\t\treturn {p:[ tip[0] + r*n[0] + x*nx[0] + y*ny[0],\n\t\t\t\t\t tip[1] + r*n[1] + x*nx[1] + y*ny[1],\t\n\t\t\t\t\t tip[2] + r*n[2] + x*nx[2] + y*ny[2] ],s:1};\n\t\t}\t\t\n\t}\n\n\tfunction getStartPointSphere()\n\t{\n\n\t\tvar r = (min+max)*0.5;\n\n\t\treturn [ tip[0] + r*n[0],\n\t\t\t\t tip[1] + r*n[1],\n\t\t\t\t tip[2] + r*n[2] ];\n\t\t\n\t}\n\n\n\tfunction isNeumann(p)\n\t{\n\t\tvar dif = [p[0]-tip[0],p[1]-tip[1],p[2]-tip[2]];\n\t\tvar proj = dif[0]*n[0]+dif[1]*n[1]+dif[2]*n[2];\n\t\tif (proj > 0)\n\t\t{\n\t\t\tvar dif2 = dif[0]*dif[0] + dif[1]*dif[1] + dif[2]*dif[2];\n\t\t\tif (dif2 -proj*proj < r2)\n\t\t\t\treturn true;\n\t\t}\n\t\treturn false;\n\t}\n\n\tfunction probround(x)\n\t{\n\t\tvar xi = Math.floor(x);\n\t\tif (Math.random() < (x-xi))\n\t\t\treturn xi+1;\n\t\telse\n\t\t\treturn xi;\n\t}\n\n\tfunction accumulate_interp(p2,p1,sign)\n\t{\n\t\tvar n = [p1[0]-p2[0],p1[1]-p2[1],p1[2]-p2[2]];\n\n\t    var i0 = Math.round(p1[0])\n\t\tvar i1 = Math.round(p1[1])\n\t\tvar i2 = Math.round(p1[2])\n\t\tvar idx = wh*i2 + w*i1 + i0;\n\t\tbuffer[idx]+=sign\n\n\t\tvar i0 = Math.round((p1[0]+p2[0])*0.5);\n\t\tvar i1 = Math.round((p1[1]+p2[1])*0.5);\n\t\tvar i2 = Math.round((p1[2]+p2[2])*0.5);\n\t\tvar idx = wh*i2 + w*i1 + i0;\n\t\tbuffer_current[idx] += n[0]*sign\n\t\tbuffer_current[idx+whd] += n[1]*sign\n\t\tbuffer_current[idx+2*whd] += n[2]*sign\n\n\t}\n\n\tfunction mult(M,e)\n\t{\n\t\treturn [ M[0][0]*e[0]+M[0][1]*e[1]+M[0][2]*e[2],\n\t\t\t\t M[1][0]*e[0]+M[1][1]*e[1]+M[1][2]*e[2],\n\t\t\t     M[2][0]*e[0]+M[2][1]*e[1]+M[2][2]*e[2] ];\n\t}\n\n\tfunction mult4(M,e)\n\t{\n\t\treturn [ M[0][0]*e[0]+M[0][1]*e[1]+M[0][2]*e[2]+M[0][3]*e[3],\n\t\t\t\t M[1][0]*e[0]+M[1][1]*e[1]+M[1][2]*e[2]+M[1][3]*e[3],\n\t\t\t     M[2][0]*e[0]+M[2][1]*e[1]+M[2][2]*e[2]+M[2][3]*e[3] ];\n\t}\n\n\n\tfunction det3(a)\n\t{\n\t\treturn a[0] * (a[4] * a[8] - a[5] * a[7]) + a[1] * (a[5] * a[6] - a[3] * a[8]) + a[2] * (a[3] * a[7] - a[4] * a[6]);\n\t}\n\n\n\n\n\tvar p;\n\tvar proposal;\n\tvar current_sigma;\n\tvar default_sigma = 1;\n\tvar drawDisplacement = function(current_sigma,alpha) { return getDisplacement(current_sigma*alpha); }\n\tvar doProp = function() { return 0};\n\n\n\n\t if (params.analytical)\n\t {\n\n\n\n\n\t\tif (elecGeometry.multipolar.length > 0)\n\t\t{\n\t\t\tvar m = elecGeometry.multipolar\n\t\t\tvar slist = [];\n\t\t\tfor (var k = 0; k < m.length;k++)\n\t\t\t{\n\t\t \t    var r = m[k].min + (m[k].max-m[k].min)*0.5;\n\t\t\t\tslist.push ([ tip[0] + r*n[0] ,\n\t\t\t\t\t\t tip[1] + r*n[1],\t\n\t\t\t\t\t\t tip[2] + r*n[2],m[k].current*m[k].sign ]  ) ;\n\t\t\t}\n\n\n\t\t}\n\t\telse\n\t\t{\t\t\n\n\n\t\t\t var r = min + (max-min)*0.5;\n\t\t\t var slist =   [[ tip[0] + r*n[0] ,\n\t\t\t\t\t\t tip[1] + r*n[1],\t\n\t\t\t\t\t\t tip[2] + r*n[2],1 ]]\n\t\t}\n\n\n\t\tvar fac = 1/(Math.PI*4);\n\n\t\tfor (var x = 0; x < w ; x++)\n\t\tfor (var y = 0; y < h ; y++)\n\t\tfor (var z = 0; z < d ; z++)\n\t\t{\n\t\t\tvar p = mult4(ie._data,[x,y,z,1])\n\t\t\tvar idx = wh*z + w*y + x;\n\t\t\tbuffer[idx]=0;\n\t\t\tbuffer_current[idx]=0;\n\t\t\tbuffer_current[idx+whd]=0;\n\t\t\tbuffer_current[idx+whd*2]=0;\n\n\t\t\tfor (var k = 0; k < slist.length;k++)\n\t\t\t{\n\t\t\t\tvar s = slist[k];\n\t\t\t\tvar r = [p[0]-s[0],p[1]-s[1],p[2]-s[2]];\t\t\n\t\t\t\tvar absr =Math.sqrt(r[0]*r[0]+r[1]*r[1]+r[2]*r[2]);\n\n\t\t\t\tbuffer[idx]+=s[3]*fac/(absr+0.00001);\n\t\t\t\tvar env = s[3]*fac/(absr*absr*absr+0.00001);\n\t\t\t\tbuffer_current[idx]+=env*r[0];\n\t\t\t\tbuffer_current[idx+whd]+=env*r[1];\n\t\t\t\tbuffer_current[idx+whd*2]+=env*r[2];\n\t\t\t}\n\n\t\t}\n\t\treturn 1;\n\t }\n\n\n\tif (conductivity)\n\t{\n\t\tif (conductivity.sizes[3] == 1)\n\t\t{\n\t\t\tdoProp = function()\n\t\t\t{\n\n\t\t\t\tvar new_sigma = Math.sqrt(trilinInterp(conductivity,proposal[0],proposal[1],proposal[2],e2c,0));\n\n\t\t\t\tif (isNaN(new_sigma) | new_sigma==0)\n\t\t\t\t\treturn -1;  // break;\n\n\t\t\t\tvar dx2 = (dx[0]*dx[0]+dx[1]*dx[1]+dx[2]*dx[2])/(current_sigma*current_sigma);\n\t\t\t\tif (current_sigma != new_sigma)\n\t\t\t\t{\n\t\t\t\t\tvar sig_ratio = current_sigma/new_sigma;\n\t\t\t\t\tvar sig_ratio2 = sig_ratio*sig_ratio;\n\t\t\t\t\tvar R = Math.exp(0.5*dx2 * (1 - sig_ratio2   ) ) * sig_ratio*sig_ratio2;\n\n\t\t\t\t\tif (R < 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (R < Math.random())\n\t\t\t\t\t\t\treturn 1; // continue;\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tcurrent_sigma = new_sigma;\n\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\tdefault_sigma = [1,0,0,0,1,0,0,0,1,1,1,1,1];\n\n\t\t\tdrawDisplacement = function(current_sigma,alpha)\n\t\t\t{\n\t\t\t\treturn getDisplacementAniso(current_sigma,alpha);\n\t\t\t}\n\n\t\t\tdoProp = function()\n\t\t\t{\n\t\t\t\tvar slope = conductivity.datascaling.slope;\n\t\t\t\tvar e1 = trilinInterp3_signcorrected(conductivity,proposal[0],proposal[1],proposal[2],e2c,whd_cond,0);\n\t\t\t\tvar e2 = trilinInterp3_signcorrected(conductivity,proposal[0],proposal[1],proposal[2],e2c,whd_cond,whd_cond*3);\n\t\t\t\tvar e3 = trilinInterp3_signcorrected(conductivity,proposal[0],proposal[1],proposal[2],e2c,whd_cond,whd_cond*6);\n\t\t\t\te1 = mult(conductivity.edges._data,e1);\n\t\t\t\te2 = mult(conductivity.edges._data,e2);\n\t\t\t\te3 = mult(conductivity.edges._data,e3);\n\n\t\t\t\t//var new_sigma =  [e1[0]*slope,e1[1]*slope,e1[2]*slope,e2[0]*slope,e2[1]*slope,e2[2]*slope,e3[0]*slope,e3[1]*slope,e3[2]*slope];\n\t\t\t\tvar new_sigma =  [e1[0]*slope,e1[1]*slope,e1[2]*slope,e2[0]*slope,e2[1]*slope,e2[2]*slope,e3[0]*slope,e3[1]*slope,e3[2]*slope];\n\t\t\t\t\n\t\t\t\tnew_sigma[9] = 1/(new_sigma[0]*new_sigma[0]+new_sigma[1]*new_sigma[1]+new_sigma[2]*new_sigma[2]);\n\t\t\t\tnew_sigma[10] = 1/(new_sigma[3]*new_sigma[3]+new_sigma[4]*new_sigma[4]+new_sigma[5]*new_sigma[5]);\n\t\t\t\tnew_sigma[11] = 1/(new_sigma[6]*new_sigma[6]+new_sigma[7]*new_sigma[7]+new_sigma[8]*new_sigma[8]);\n\t\t\t\tnew_sigma[12] = Math.abs(det3(new_sigma));\n\t\t\t\t\n\t\t\t\tvar q = [ (new_sigma[0]*dx[0] + new_sigma[1]*dx[1] + new_sigma[2]*dx[2])*new_sigma[9],\n\t\t\t\t\t\t  (new_sigma[3]*dx[0] + new_sigma[4]*dx[1] + new_sigma[5]*dx[2])*new_sigma[10],\n\t\t\t\t\t\t  (new_sigma[6]*dx[0] + new_sigma[7]*dx[1] + new_sigma[8]*dx[2])*new_sigma[11] ];\n\t\t\t    var q2 = q[0]*q[0] + q[1]*q[1] + q[2]*q[2];\n\n\t\t\t\tvar r = [ (current_sigma[0]*dx[0] + current_sigma[1]*dx[1] + current_sigma[2]*dx[2])*current_sigma[9],\n\t\t\t\t\t\t  (current_sigma[3]*dx[0] + current_sigma[4]*dx[1] + current_sigma[5]*dx[2])*current_sigma[10],\n\t\t\t\t\t\t  (current_sigma[6]*dx[0] + current_sigma[7]*dx[1] + current_sigma[8]*dx[2])*current_sigma[11] ];\n\t\t\t    var r2 = r[0]*r[0] + r[1]*r[1] + r[2]*r[2];\n\n\t\t\t\tvar R = Math.exp(0.5*(-q2+r2)/(alpha*alpha)) * current_sigma[12]/new_sigma[12];\n\n\t\t\t\tif (R < 1)\n\t\t\t\t{\n\t\t\t\t\tif (R < Math.random())\n\t\t\t\t\t\treturn 1; // continue;\n\n\t\t\t\t}\n\n\t\t\t\tcurrent_sigma = new_sigma;\n\n\t\t\t\treturn 0;\n\t\t\n\n\t\t\t}\n\n\n\n\t\t\t\n\t\t}\n\n\t}\n\n\n\n\n\n\n\n\n\n\n\tvar t = 0;\n\tfor (var k = 0; k < num_particles;k++)\n\t{\n\t\t//var p = getStartPointSphere();\n\t\tvar sp = getStartPoint();\n\t\tvar p = sp.p;\n\t\tvar sign = sp.s;\n\t\t\n\t\tvar pv_old = [ e[0][0]*p[0] + e[0][1]*p[1] + e[0][2]*p[2] + e[0][3],   // in voxel coordinates of simulation grid\n\t\t\t              e[1][0]*p[0] + e[1][1]*p[1] + e[1][2]*p[2] + e[1][3],\n\t\t\t              e[2][0]*p[0] + e[2][1]*p[1] + e[2][2]*p[2] + e[2][3] ];\n\n\t\tvar steps = 0;\n\t\tcurrent_sigma = default_sigma;\n\t\twhile(steps < num_steps)\n\t\t{\n\n\t\t\tsteps++;\n\n\t\t\tvar dx = drawDisplacement(current_sigma,alpha);\n\t\t\tproposal = [p[0] + dx[0],p[1] + dx[1],p[2] + dx[2]]\n\t\t\tvar proposal_between = [p[0] + 0.5*dx[0],p[1] + 0.5*dx[1],p[2] + 0.5*dx[2]]\n\t\t\tif (isNeumann(proposal) | isNeumann(proposal_between))\n\t\t\t{\n\t\t\t\t//if (pv_old != undefined)\t\t\t\n\t\t\t\t//\taccumulate_interp(pv_old,proposal,Math.sqrt(norm));\n\t\t\t\tcontinue;\n\t\t\t}\n\n\t\t\tvar action = doProp();\n\t\t\tif (action == -1)\n\t\t\t\tbreak;\n\t\t\telse if (action == 1)\n\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\n\n\t\t\tp = proposal;\n\n\t\t\tvar p_v =   [ e[0][0]*p[0] + e[0][1]*p[1] + e[0][2]*p[2] + e[0][3],   // in voxel coordinates of simulation grid\n\t\t\t              e[1][0]*p[0] + e[1][1]*p[1] + e[1][2]*p[2] + e[1][3],\n\t\t\t              e[2][0]*p[0] + e[2][1]*p[1] + e[2][2]*p[2] + e[2][3] ];\n\n\t\t\tif (pv_old != undefined)\t\t\t\n\t\t\t\taccumulate_interp(pv_old,p_v,sign);\n\n\t\t\tif  ( (p_v[0]-w2)*(p_v[0]-w2) + (p_v[1]-h2)*(p_v[1]-h2) + (p_v[2]-d2)*(p_v[2]-d2) > domsq)\n\t\t\t\tbreak;\n\n\t\n\t\t\tt++;\n\n\t\t\tpv_old = p_v;\n\n\t\t}\n\t}\n\treturn t/num_particles/domsq;\n\n}\n\n\n\nfunction KSimulationPanel(electrode)\n{\n\n    var panel = KPanel($(document.body),electrode.uuid + electrode.name,"VAT simulation");\n    panel.closeOnCloseAll = true\n\tvar $container = panel.$container;\n    $container.addClass("DBSpanel")\n\n\tvar cid = -1;\n    var $fileRow = $("<div ></div>").appendTo(panel.$container);\n    var $fileRow2 = $("<div class=\'panel\'></div>").appendTo(panel.$container);\n\n\n    var filePotential;\n    var fileCurrent;\n\n\tvar swarm;\n\n\tvar $name = $("<div class=\'DBS_name\'></div>").appendTo($fileRow);\n\n\t$fileRow.append($("<hr>")).append($("<i class=\'flexspacer\'></i>"));\n\n    var $simulate = $("<a style=\'width:80px;\' class=\'KViewPort_tool\'> Simulate </a>").appendTooltip("dosim").click(\n\t\tfunction(e)\n\t\t{\n\n\t\t\tif (swarm == undefined)\n\t\t\t{\n\t\t\t\tdoSimulation()\n\t\t\t\t$simulate.text("Stop");\n\t\t\t\tpanel.progressSpinner("simulating");\n\t\t\t\t$container.find(".panel").addClass("inactive");\n\t\t\t\tKViewer.markerTool.$container.addClass("inactive")\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\t\t\t\tif (swarm.ishold && filePotential.content.sizes[0] != simParams.numvox)\n\t\t\t\t\t{\n\t\t\t\t\t\talertify.error("Parameters changed, clear simulation first!");\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\tif (!swarm.toggle())\n\t\t\t\t{\n\t\t\t\t\t\n\t\t\t\t\t$simulate.text("Stop");\n\t\t\t\t\tpanel.progressSpinner("simulating");\n\t\t\t\t\t$container.find(".panel").addClass("inactive");\n\t\t\t\t\tKViewer.markerTool.$container.addClass("inactive")\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$simulate.text("Continue");\n\t\t\t\t\t$clearsim.removeClass("inactive");\n\t\t\t\t\tpanel.progressSpinner("simulating");\n\t\t\t\t\t$container.find(".panel").removeClass("inactive");\n\t\t\t\t\tKViewer.markerTool.$container.removeClass("inactive")\n\n\n\t\t\t\t}\n\t\t\t}\n\t\t}\n    )\n    $fileRow.append($simulate).append($("<i class=\'flexspacer\'></i>"));\n\n    var $clearsim = $("<a style=\'width:80px;\' class=\'KViewPort_tool\'> Clear </a>").appendTooltip("clearsim").click(\n\t\tfunction(e)\n\t\t{\n\t\t\t\tif (swarm != undefined)\n\t\t\t\t{\n\t\t\t\t\tswarm.kill();\n\t\t\t\t    $clearsim.addClass("inactive");\n\t\t\t\t   // clear();\n\t\t\t\t}\n\t\t\t\t$simulate.text("Simulate");\n\t\t\t\tpanel.progressSpinner();\n\t\t}\n    )\n    $clearsim.addClass("inactive");\n    $fileRow.append($clearsim).append($("<i class=\'flexspacer\'></i>"));\n\n\n\tvar simParams = {};\n\n\tfunction inputParam(name,defaultval,unit,$div)\n\t{\n\t\tif (unit == undefined)\n\t\t\tunit = "";\n\t\telse\n\t\t\tunit = "("+unit+")";\n\n\t\tif ($div == undefined)\n\t\t\t$div = $fileRow2;\n\n\t\tvar $param = $("<span class=\'DBS_paramname\'> "+name+" </span> <input class=\'DBS_paraminput\'  min=0 step=1 type=\'number\' value=\'"+defaultval+"\'> "+unit+"<br>")\n\t\t$div.append($param).append($("<i class=\'flexspacer\'></i>"));\n\t\tsimParams[name] = defaultval;\n\t\t$($param[2]).on("change",function(){\n\t\t\tsimParams[name] = parseFloat($(this).val());\t\t\t\n\t\t});\n\t}\n\n\n\t$fileRow2.append($("<hr>"))\n\t//inputParam("Voltage",5);\n\t//inputParam("Impedance",1000);\n\n\tvar $analytical = $("<div><span class=\'DBS_paramname\'>Analytical</span> <input class=\'DBS_paraminput\' type=\'checkbox\' value=\'0\'> </div>").appendTo($fileRow2);\n\t$analytical.find("input").on("change",function(e)\n\t{\n\t\tsimParams.analytical = this.checked;\n\t});\n\n\tinputParam("Current",5,"mA");\n\tinputParam("Conductivity",0.2,"S/m");\n\n\tvar $thresholdCurrent = $("<div><span class=\'DBS_paramname\'>Current threshold</span> <input class=\'DBS_paraminput\' type=\'number\' value=\'0.1\' step=\'0.05\' min=\'0\' max=\'1\'> </div>").appendTo($fileRow2);\n\telectrode.threshold = 0.1; \n\t$thresholdCurrent.find("input").on("change",function(e)\n\t{\n\t\telectrode.threshold = parseFloat($(this).val());\n\t\tfor (var x in electrode.onupdate)\n\t\t\telectrode.onupdate[x]();\n\n\t});\n\n\n\n\tvar $wrap = $("<div class=\'annotation_tool_elemDIV\' ></div>").appendTo($fileRow2);\n\tvar $dragarea = $("<div dragover=\'return false\'; class=\'annotation_tool_droparea\' style=\'height:40px !important;\'><span>drop nifti to define conductivity</span></div>").appendTo($wrap);\n\tpanel.$container.on("dragover", function(ev){ev.preventDefault();ev.stopPropagation();return false;});\n\tpanel.$container.on("dragleave", function(ev){ev.preventDefault();ev.stopPropagation();return false;});\n\tpanel.$container.on("drop",ondrop);\n\tpanel.$container.width(300);\n\n\n\tvar $detailparam_head = $("<div class=\'DBS_simparams_head\'> ... more simulation parameters</div>").appendTo($fileRow2);\n\tvar $detailparam = $("<div class=\'DBS_simparams\'></div>").appendTo($detailparam_head);\n\tinputParam("alpha",1,null,$detailparam);\n\tinputParam("boxlen",25,"mm",$detailparam);\n\tinputParam("numvox",50,null,$detailparam);\n\tinputParam("num_particles",500000,null,$detailparam);\n\tinputParam("num_steps",5000,null,$detailparam);\n\tinputParam("num_workers",2,null,$detailparam);\n\tinputParam("num_chunks",10,null,$detailparam);\n\n\n\n\t$fileRow2.append($("<hr>"))\n\n\tvar $fileDivs = $("<div class=\'DBS_filedivs\'></div>").appendTo($fileRow2)\n\tvar $currentFile = $("<div></div>").appendTo($fileDivs);\n\tvar $potentialFile = $("<div></div>").appendTo($fileDivs);\n\tvar $fileButtons = $("<div class=\'DBS_buttons\'></div>").appendTo($fileRow2).hide();\n\tvar $progress = $("<span>0% </span>").appendTo($fileButtons);\n\tvar $closeFiles = $("<i class=\'KViewPort_tool fa fa-trash\'> </i>").appendTo($fileButtons);\n\n\t$closeFiles.click(function(){\n\t\tclear();\n\t\tKViewer.dataManager.delFile(getDBSid("current"));\n\t\tKViewer.dataManager.delFile(getDBSid("potential"));\n\t\tKViewer.dataManager.delFile(getDBSid("sigma"));\n\t    var active = electrode.getActive();\n\t    active.pts.sim_indicator.hide();\n\t\tactive.pts.voltage_indicator.show();\n\t\tKViewer.cacheManager.update();\n\t\tfor (var x in electrode.onupdate)\n\t\t\telectrode.onupdate[x]();\n\t\tactive.pts.select();\n\t\t\t\t\n\n\n\t});\n\n\n\tfunction getDBSid(which)\n\t{\n\t\t var active = electrode.getActive();\t\t\n\t\t return "DBS_"+electrode.name+"_"+active.pts.p.name +"_" + which;\n\t}\n\tfunction getDBSfile(which)\n\t{\n\t\t return KViewer.dataManager.getFile(getDBSid(which));\n\t}\n\n\n\n\n\tpanel.updateActive = function()\n\t{\n\t\t clear();\n    \t if (getDBSfile("current") != undefined)\n    \t {\n\t  \t\tshowFileinfo("current",getDBSfile("current"),$currentFile);\n\t  \t\tshowFileinfo("potential",getDBSfile("potential"),$potentialFile);\n    \t }\n\n\t\t var active = electrode.getActive();\n\t\t $name.text(electrode.name + "/" + active.pts.p.name);\n\t\t //$clearsim.trigger(\'click\');\n\n\n\t}\n\tpanel.updateActive();\n\n\n\n\tpanel.conduct_nii = undefined\n\n\n    function ondrop(e) {\n\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tvar params = getloadParamsFromDrop(e.originalEvent,{});\n\t\t\tfor (var k = 0;k < params.length;k++)\n\t\t\t{\n\t\t\t\tif (!params.patient_study_drop)\n\t\t\t\t{\n\t\t\t\t\tparams[k].callback = function(fobj) {\n\t\t\t\t\t\tif (fobj.contentType == \'nii\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpanel.conduct_nii = fobj;\n\t\t\t\t\t\t\tupdate_conduct_nii();\n\t\t\t\t\t\t}\n\t\t\t     \t\telse \n\t\t\t     \t\t\talertify.error("only niftis allowed");\n\n\t\t\t\t\t\tthis.progressSpinner();\n\t\t\t\t\t}\n\t\t\t\t\tparams[k].progressSpinner = panel.progressSpinner;\n\t\t\t\t\tKViewer.dataManager.loadData(params[k]);\t\t\n\n\t\t\t\t}\n\t\t\t}\n     }\n\n\t function update_conduct_nii()\n\t {\n\t\t\t$dragarea.children().remove();\t\t\t\n\t\t\tvar fobj = panel.conduct_nii;\n\t\t\tif (fobj != undefined)\n\t\t\t{\n\t\t\t\tvar dragstuff = "draggable=\'true\' data-type=\'file\' data-piz=\'\' data-sid=\'\' data-tag=\'"+fobj.fileinfo.Tag+"\' data-filename=\'"+fobj.filename+"\' data-subfolder=\'\' data-fileID=\'"+fobj.fileID+"\' data-mime=\'"+fobj.contentType+"\'";\n\t\t\t\tdragstuff = dragstuff + " ondragstart=\'setdragstart(event);\' ondragend=\'setdragend(event);\' ondblclick=\'loadDataOndblClick(event);\'";\t \t\n\t\t\t\tvar $close = $("<i class=\'fa fa-fw fa-close\'></i>").click(function() { delete panel.conduct_nii; update_conduct_nii();   } );\n\t\t\t\t$("<div> <div "+dragstuff+">" + fobj.filename + "</div>  </div>").append($close).appendTo($dragarea);\n\t\t\t}\n\t\t\telse\n\t\t\t   $("<span>drop nifti to define conductivity </span>").appendTo($dragarea);\n\n\t }\n\n\t function computeCurrent(current,potential,sigma)\n\t {\n\t\t var w = current.wid;\n\t\t var wh = current.widhei;\n\t\t var sig;\n\t\t if (sigma == undefined)\n\t\t \tsig = function() {return 1};\n\t\t else\n\t\t {\n\t\t \tvar nii = sigma.content;\n\t\t \tvar A = math.multiply(math.inv(nii.edges),potential.edges)._data;\n\t\t \tsig = function(x,y,z) { \n\t\t \t\tvar s = trilinInterp(nii,x,y,z,A,0);\n\t\t \t \treturn s*s;\n\t\t \t}\n\t\t }\n\t\t var  pot = potential.data;\n\n\t\t for (var z = 0;z < current.sizes[2];z++)\n\t\t\t for (var y = 0;y < current.sizes[1];y++)\n\t\t\t\t for (var x = 0;x < current.sizes[0];x++)\n\t\t\t\t {\n\t\t\t\t \tvar idx = x+w*y+wh*z;\n\t\t\t\t \tvar d = [pot[idx+1] - pot[idx],pot[idx+w]-pot[idx],pot[idx+wh]-pot[idx]];\n\t\t\t\t \tcurrent.data[idx] = sig(x,y,z)*\n\t\t\t\t \t\t\t\t\t\tMath.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);\n\t\t\t\t \t \n\t\t\t\t }\n\n\n\t }\n\n\t function computeSigma(current,potential,sigma)\n\t {\n\t\t var w = current.wid;\n\t\t var wh = current.widhei;\n\t     var whd = current.sizes[0]*current.sizes[1]*current.sizes[2];\n\t\t var vsize = simParams.boxlen/simParams.numvox;\n\t\t var  pot = potential.data;\n\t\t var current_data = current.data;\n\n\t\t var fac = vsize*2;\n\n\t\t for (var z = 0;z < current.sizes[2];z++)\n\t\t\t for (var y = 0;y < current.sizes[1];y++)\n\t\t\t\t for (var x = 0;x < current.sizes[0];x++)\n\t\t\t\t {\n\t\t\t\t \tvar idx = x+w*y+wh*z;\n\t\t\t\t \tvar d = [pot[idx+1] - pot[idx-1],pot[idx+w]-pot[idx-w],pot[idx+wh]-pot[idx-wh]];\n\t\t\t\t \tvar i = [current_data[idx],current_data[idx+whd],current_data[idx+whd*2]];\n\t\t\t\t \tsigma.data[idx] = fac*\n\t\t\t\t\t\t\t\t\t\tMath.sqrt(i[0]*i[0]+i[1]*i[1]+i[2]*i[2]) /\n\t\t\t\t\t\t\t\t\t\tMath.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);\n\t\t\t\t \t \n\t\t\t\t }\n\n\n\t }\n\n\t function clear()\n\t {\n\t\t$clearsim.trigger(\'click\')\n\t\t$potentialFile.children().remove();\n\t\t$currentFile.children().remove();\n\t\t$fileButtons.hide();\n\t }\n\n\t signalhandler.attach("close",function(){\n\t \tpanel.conduct_nii = undefined;\n\t \tupdate_conduct_nii();\n\t \tpanel.close();\n\t\tclear();\n\t//\tpanel.hide();\n\t });\n\n\n\t var center;\n\t function showFileinfo(name,fobj,$div)\n\t {\n\t \t$fileButtons.show();\n\t \t$div.children().remove();\n\t\tvar dragstuff = "draggable=\'true\' data-type=\'file\' data-piz=\'\' data-sid=\'\' data-tag=\'"+fobj.fileinfo.Tag+"\' data-filename=\'"+fobj.filename+"\' data-subfolder=\'\' data-fileID=\'"+fobj.fileID+"\' data-mime=\'"+fobj.contentType+"\'";\n\t\tdragstuff = dragstuff + " ondragstart=\'setdragstart(event);\' ondragend=\'setdragend(event);\'";\t \t\n\t \tvar $fi = $("<div class=\'DBS_result\' "+dragstuff+">"+name+"</div>");\n\t \t$div.append($fi);\n\t \t$fi.on("click",function(e)\n\t \t{\n\t \t\tloadDataOndblClick(e,function(){\n\t \t\t\tKViewer.currentPoint = math.matrix([center[0],center[1],center[2],1]);\n\t \t\t\tsignalhandler.send("centralize positionChange");\n\t \t\t})\n\t \t});\n\t }\n\n\tfunction showSimInfo(e)\n\t{\n\t\tvar active = electrode.getActive()\n\t\tvar pts = electrode.getPoints();\n\t\tvar str = "<br> tip:(" + active.pts.last_simtip + ")";\n\t    if (pts[1].p.coords.slice(0,3).toString() != active.pts.last_simtip)\n\t    \tstr += "<br> (electrode location not consistent)"\n\t\tvar $info = $("<div class=\'DBS_siminfo\'> progress:"+active.pts.progress+ str+" </div>").appendTo($(document.body));\n\t\t$info.css(\'top\',e.clientY).css(\'left\',e.clientX+10);\n\t\treturn $info;\n\t}\t\n\n\tfunction doSimulation()\n\t{\n\n\t\t\t function getSimDomain(name,fobj,tdim,$div)\n\t\t\t {\n\t\t\t\t  var fileObject = getDBSfile(name);\n\t\t\t\t  if (fileObject == undefined\n\t\t\t\t\t  || (fobj.content.sizes[0] != fileObject.content.sizes[0]))\n\t\t\t\t  {\n\n\t\t\t\t\t  fileObject =  cloneNifti(fobj,getDBSid(name),"float",tdim);\n\t\t\t\t\t  fileObject.content.bbox = fobj.content.bbox;\n\t\t\t\t\t  fileObject.fileID = getDBSid(name);\n\t\t\t\t\t  fileObject.modified = true;\n\t\t\t\t\t  fileObject.filename += ".nii";\n\t\t\t\t\t  KViewer.dataManager.setFile(fileObject.fileID,fileObject);\n\t\t\t\t\t  KViewer.cacheManager.update();\n\t\t\t\t  }\n\t\t\t\t  fileObject.content.edges = fobj.content.edges;\t\t\t  \n\t\t\t\t  fileObject.content.voxSize = fobj.content.voxSize;\t\t\t  \n\t\t\t\t  signalhandler.send("updateFilelink",{id:fileObject.fileID});\n\n\t\t\t\t  if ($div != undefined)\n\t\t\t\t  {\n\t\t\t\t\t showFileinfo(name,fileObject,$div);\n\t\t\t\t\t active.pts.sim_indicator.show();\n\t\t\t\t\t active.pts.voltage_indicator.hide();\n\t\t\t\t\t active.pts.showSimInfo = showSimInfo;\n\t\t\t\t  }\n\n\t\t\t\t  return fileObject;\n\t\t\t }\n\n\n\n\t\t\t var pts = electrode.getPoints();\n\t\t\t var active = electrode.getActive();\n\t\t\t var active_pos =  active.pos;\n\n\t\t\t var size_contact = 0.1;\n\n\t\t\t var elecGeometry = {\n\t\t\t\ttip : pts[1].p.coords.slice(0,3),\n\t\t\t\tend : pts[0].p.coords.slice(0,3),\n\t\t\t\tc_min : active_pos-size_contact/2,\n\t\t\t\tc_max : active_pos+size_contact/2,\n\t\t\t\tradius : 1\n\t\t\t };\n\n\n\t\t\t  elecGeometry.multipolar = [];\n\t\t\t  for (var k = 2; k < pts.length; k++)\n\t\t\t  {\n\t\t\t  \tif (pts[k].p.voltage != undefined && pts[k].p.voltage != 0)\n\t\t\t  \t{\n\t\t\t  \t\tvar pos = electrode.electrode_properties.contacts[k-2]\n\t\t\t  \t\tvar vol = pts[k].p.voltage;\n\t\t\t\t\telecGeometry.multipolar.push({min: pos-size_contact/2 , max: pos+size_contact/2, vol : vol });\n\t\t\t\t\t\n\t\t\t  \t}\n\t\t\t  }\n\t\t\t  var impedance = 1000;\n\t\t\t  if (elecGeometry.multipolar.length > 0)\n\t\t\t  {\n\t\t\t  \t  var m = elecGeometry.multipolar;\n\t\t\t  \t  var abssum = 0;\n\t\t\t\t  for (var k = 0 ; k < m.length; k++)\n\t\t\t\t\t  abssum += Math.abs(m[k].vol);\n\t\t\t\t  for (var k = 0 ; k < m.length; k++)\n\t\t\t\t  {\n\t\t\t\t  \t  m[k].current =  Math.abs(m[k].vol)/abssum;\n\t\t\t\t  \t  m[k].sign = Math.sign(m[k].vol);\n\t\t\t\t  }\n\n\t\t\t\t  elecGeometry.total_current = abssum/impedance*1000; // (mA)\n\n\t\t\t  }\n\n\n\n\n\n\n\n\t\t\t  var tip = elecGeometry.tip;\n\t\t\t  var end = elecGeometry.end;\n\t\t\t  var n = [end[0]-tip[0],end[1]-tip[1],end[2]-tip[2]];\n\t\t\t  var norm = Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);\n\t\t\t  n[0] /= norm; n[1] /= norm; n[2] /= norm;\n\t\t\t  center = [ tip[0] + active_pos*n[0],\n\t\t\t\t\t\t   tip[1] + active_pos*n[1],\t\n\t\t\t\t\t\t   tip[2] + active_pos*n[2]];\n\n\t\t\t  var boxlen = simParams.boxlen; //mm\n\t\t\t  var numvox = simParams.numvox;\n\n\t\t\t  var sizes = [numvox,numvox,numvox,1];\n\t\t\t  var voxsz = [boxlen/numvox,boxlen/numvox,boxlen/numvox,1];\n\t\t\t  var bbox = {max: [center[0] + boxlen,center[1] + boxlen,center[2] + boxlen],\n\t\t\t\t\t\t  min: [center[0] - boxlen,center[1] - boxlen,center[2] + boxlen]};\n\n\t\t\t  var edges = math.matrix(math.diag(voxsz)); \t  \n\t\t\t  for (var i = 0;i < 3;i++)\n\t\t\t\t   edges._data[i][3] = -sizes[i]/2*voxsz[i] + center[i];\t  \t\n\t\t\t  var fobj ={ content : {\n\t\t\t\t\t\t\t\t  edges: edges,\n\t\t\t\t\t\t\t\t  bbox: bbox,\n\t\t\t\t\t\t\t\t  voxSize: voxsz,\n\t\t\t\t\t\t\t\t  sizes: sizes },\t\t\t\t\n\t\t\t\t\t   };\n\t\t\t  if (panel.conduct_nii)\n\t\t\t\t  fobj.fileinfo = panel.conduct_nii.fileinfo;\n\n\t\t\t  filePotential = getSimDomain("potential",fobj,1,$potentialFile);\n\n\t\t\t  fileCurrent = getSimDomain("current",fobj,3,$currentFile);\n\n\t\t\t  fileSigma = getSimDomain("sigma",fobj,1);\n\n\n\t\t\t  function packForTransfer(obj,nodata)\n\t\t\t  {\n\t\t\t\t  if (obj == undefined)\n\t\t\t\t\treturn undefined;\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t\t var thedata = nodata?undefined:obj.data;\n\t\t\t\t\t return {data:thedata,\n\t\t\t\t\t\t\t   edges:obj.edges,\n\t\t\t\t\t\t\t   invedges:math.inv(obj.edges)._data,\n\t\t\t\t\t\t\t   sizes:obj.sizes,\t\t\n\t\t\t\t\t\t\t   datascaling:{slope:obj.datascaling.slope,offset:obj.datascaling.offset},\n\t\t\t\t\t\t\t   wid:obj.wid,\t\t  \t\t\t   \n\t\t\t\t\t\t\t   widhei:obj.widhei,\n\t\t\t\t\t\t\t   widheidep:obj.widheidep};\n\t\t\t\t  }\n\n\t\t\t  }\n\n\n\n\t\t\t  var chunks = simParams.num_chunks;\n\t\t\t  simParams.num_particles_ =\n\t\t\t\t  Math.floor(simParams.num_particles/simParams.num_workers/chunks);\n\n\t\t\t  var accumVol_potential = new Float32Array(filePotential.content.data.length);\n\t\t\t  for (var k = 0; k < filePotential.content.data.length; k++)\n\t\t\t\t accumVol_potential[k] = 0;\n\t\t\t  var accumVol_current = new Float32Array(fileCurrent.content.data.length);\n\t\t\t  for (var k = 0; k < fileCurrent.content.data.length; k++)\n\t\t\t\t accumVol_current[k] = 0;\n\n\n\t\t\t  var accumCnt = 0;\n\t\t\t  var accumResistance = 0;\n\n\t\t\t  var numworkers = simParams.num_workers;\n\n\n\n\t\t\t  if (simParams.analytical)\n\t\t\t  {\n\t\t\t\t\tchunks = 1;\n\t\t\t\t\tnumworkers = 1;\n\t\t\t  }\n\n\n\t\t\t  swarm = {workers:[],ishold:false};\n\n\t\t\t  var worker_cnt = 0;\n\t\t\t  var cid = setInterval(function()\n\t\t\t  {\n\t\t\t\tif (swarm == undefined)\n\t\t\t\t{\t\n\t\t\t\t\tclearInterval(cid)\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tif (!swarm.ishold )\n\t\t\t\t{\n\t\t\t\t\tswarm.workers.push(inititateWorker(worker_cnt++))\n\t\t\t\t\tif (worker_cnt >= numworkers)\n\t\t\t\t\t\tclearInterval(cid);\n\t\t\t\t}\n\t\t\t  },500);\n\n\n\t\t\t  swarm.kill = function()\n\t\t\t  {\n\t\t\t\t  for (var k = 0; k < numworkers;k++)\n\t\t\t\t\tif (swarm.workers[k] != undefined)\n\t\t\t\t\t\tswarm.workers[k].kill();\t  \t\n\t\t\t  }\n\t\t\t  swarm.toggle = function()\n\t\t\t  {\n\t\t\t\t  var laststate;\n\t\t\t\t  for (var k = 0; k < numworkers;k++)\n\t\t\t\t  {\n\t\t\t\t\tif (swarm.workers[k] != undefined)\n\t\t\t\t\t\tlaststate = swarm.workers[k].toggle();\t  \n\t\t\t\t  }\n\t\t\t\t  swarm.ishold = laststate;\n\t\t\t\t  return laststate;\t\n\t\t\t  }\n\n\n\t\t\t  swarm.done = function()\n\t\t\t  {\n\t\t\t\t  var alldone = true;\n\t\t\t\t  for (var k = 0; k < numworkers;k++)\n\t\t\t\t\t  alldone = alldone && (swarm.workers[k] == undefined);\n\t\t\t\t  if (alldone)\n\t\t\t\t  {\n\t\t\t\t\t\t$container.find(".panel").removeClass("inactive");\n\t\t\t\t\t\tKViewer.markerTool.$container.removeClass("inactive")\t\t\t\t\t\t\n\t\t\t\t\t\tif (accumCnt/chunks/numworkers >= 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tactive.pts.progress = "done";\n\t\t\t\t\t\t\t$progress.text("done");\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\tpanel.progressSpinner();\n\t\t\t\t\t\t$simulate.text("Simulate");\t\t\t\t\n\t\t\t\t\t\t$clearsim.addClass("inactive");\n\n\t\t\t\t\t\tswarm = undefined;\n\t\t\t\t  }\n\t\t\t  }\n\n\n\t\t\t  function accumulateVol(file,vol,data,fac)\n\t\t\t  {\n\t\t\t\t\tvar len = file.content.data.length;\n\n\t\t\t\t\tfor (var k = 0; k < len; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvol[k] += data[k];\n\t\t\t\t\t\t\tfile.content.data[k] = vol[k] * fac;\n\t\t\t\t\t\t}\n\t\t\t  }\n\n\t\t\t  function inititateWorker(workerid)\n\t\t\t  {\n\t\t\t\t\tvar worker = new Worker(\'KTools/DBSsimulation_worker.js\');\n\t\t\t\t\tworker.workerid = workerid;\n\t\t\t\t\tworker.postMessage = worker.webkitPostMessage || worker.postMessage;\n\t\t\t\t\tworker.addEventListener(\'message\', function(e) {\n\n\n\t\t\t\t\t\tfunction updateImages()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tif (filePotential.content == undefined || filePotential.content.data == undefined)\n\t\t\t\t\t\t\t\t\treturn;\n\n\t\t\t\t\t\t\t\tfor (var x in electrode.onupdate)\n\t\t\t\t\t\t\t\t\telectrode.onupdate[x]();\n\n\n\t\t\t\t\t\t\t\tfilePotential.content.histogram = comphisto(0, 1, 50, filePotential.content.data, filePotential.content.data.length, 5000);\n\t\t\t\t\t\t\t\tfileCurrent.content.histogram = comphisto(0, 0.3, 50, fileCurrent.content.data, filePotential.content.data.length, 5000);\n\t\t\t\t\t\t\t\tfileSigma.content.histogram = comphisto(0, 3, 50, fileSigma.content.data, fileSigma.content.data.length, 5000);\n\t\t\t\t\t\t\t\tsignalhandler.send("updateImage",{id:filePotential.fileID});\n\t\t\t\t\t\t\t\tsignalhandler.send("updateImage",{id:fileCurrent.fileID});\t\t\t\t\t\n\t\t\t\t\t\t\t\tsignalhandler.send("updateImage",{id:fileSigma.fileID});\t\t\t\t\t\n\t\t\t\t\t\t\t\tsignalhandler.send(\'layoutHisto\');\t\t\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\te = e.data;\n\t\t\t\t\t\tif (e.msg == \'progress\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar prc = Math.round(100*accumCnt/chunks/numworkers) + "%";\n\t\t\t\t\t\t\tpanel.progressSpinner("simulating " +prc );\n\t\t\t\t\t\t\tactive.pts.progress = prc;\n\t\t\t\t\t\t\tactive.pts.last_simtip = elecGeometry.tip.toString();\n\t\t\t\t\t\t\t$progress.text(prc );\n\n\t\t\t\t\t\t\taccumCnt++\n\n\t\t\t\t\t\t\taccumResistance += e.meanResistance;\n\n\n\t\t\t\t\t\t\tvar v = voxsz[0];\n\t\t\t\t\t\t\tvar pixvol = v*v*v;\n\n\t\t\t\t\t\t\tvar R0 = accumResistance/accumCnt/(v*v);\n\t\t\t\t\t\t\t//console.log(R0);\n\n\n\t\t\t\t\t\t\tvar I0 = (accumCnt * simParams.num_particles_ );\n\n\t\t\t\t\t\t\tvar spec_cond = simParams.alpha*simParams.alpha/2;\n\n\t\t//\t\t\t\t\tvar facU = spec_cond*simParams.Voltage / I0                     /pixvol;\n\t\t//\t\t\t\t\tvar facI = simParams.Voltage/simParams.Impedance/( I0)*     1000/ (v*v);\n\n\n\t\t\t\t\t\t\tvar facU = spec_cond/simParams.Conductivity*simParams.Current / I0 /pixvol;\n\n\t\t\t\t\t\t\tvar facI = simParams.Current /( I0)  / (v*v);\n\n\nif (simParams.analytical)\n{\n\tfacI = simParams.Current;\n\tfacU = 1/simParams.Conductivity*simParams.Current;\n}\n\n\n\t\t\t\t\t\t\taccumulateVol(filePotential,accumVol_potential,e.potential_data,facU);\n\t\t\t\t\t\t\tfilePotential.content.descrip = \'unit:V\';\n\n\n\n\t\t\t\t\t\t\taccumulateVol(fileCurrent,accumVol_current,e.current_data,facI)\n\t\t\t\t\t\t\tfileCurrent.content.descrip = \'unit:mA/mm^2\';\n\n\t\t\t\t\t\t\tcomputeSigma(fileCurrent.content,filePotential.content,fileSigma.content);\n\t\t\t\t\t\t\tfileSigma.content.descrip = \'unit:S/m\';\n\n\n\t\t\t\t\t\t\tif (this.workerid == 0)\n\t\t\t\t\t\t\t\tupdateImages()\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (e.msg == \'paused\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpanel.progressSpinner("paused");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (e.msg == \'done\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tupdateImages()\n\t\t\t\t\t\t\tdelete swarm.workers[workerid];\n\t\t\t\t\t\t\tswarm.done();\n\t\t\t\t\t\t}\n\t\t\t\t\t}, false);\n\n\t\t\t\t\tworker.kill = function()\n\t\t\t\t\t{\n\t\t\t\t\t\tworker.postMessage({message:\'kill\'},[]);\n\n\t\t\t\t\t}\n\n\t\t\t\t\tvar sigma;\n\t\t\t\t\tif (panel.conduct_nii)\n\t\t\t\t\t\tsigma = panel.conduct_nii.content;\n\n\t\t\t\t\tworker.start = function() {\t\t\t\n\n\t\t\t\t\t\tworker.postMessage({message:\'startSim\',\n\t\t\t\t\t\t\telecGeometry:elecGeometry,\n\t\t\t\t\t\t\tsimParams:simParams,\n\t\t\t\t\t\t\tchunks:chunks,\n\t\t\t\t\t\t\tpotential:packForTransfer(filePotential.content,true),\n\t\t\t\t\t\t\tcurrent:packForTransfer(fileCurrent.content,true),\n\t\t\t\t\t\t\tsigma:packForTransfer(sigma,false)  } \t,[]);\n\t\t\t\t\t}\n\n\t\t\t\t\tworker.ishold = false;\n\t\t\t\t\tworker.toggle = function() {\t\t\t\n\t\t\t\t\t\tif (worker.ishold)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tworker.postMessage({message:\'continue\'}\t,[]);\n\t\t\t\t\t\t\tworker.ishold = false;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tworker.postMessage({message:\'hold\'}\t,[]);\n\t\t\t\t\t\t\tworker.ishold = true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\treturn worker.ishold;\n\t\t\t\t\t}\n\n\n\t\t\t\t\tworker.start();\n\t\t\t\t\treturn worker;\n\n\t\t\t  }\n\n\t}\n\n\n\n\treturn panel;\n\n}\n\n\n\nfunction KPickingPanel(mset)\n{\n\n    var panel = KPanel($(document.body),mset.uuid + mset.name,"Picking Panel: " + mset.name);\n    panel.closeOnCloseAll = true\n\tvar $container = panel.$container;\n\n\n\tvar cid = -1;\n    var $contrastsRow = $("<div ></div>").appendTo(panel.$container);\n\n    var $fileRow2 = $("<div class=\'panel\'></div>").appendTo(panel.$container);\n\n\n\n\n\n    panel.contrasts = {};\n\tvar $wrap = $("<div class=\'annotation_tool_elemDIV\' ></div>").appendTo($fileRow2);\n\n\tvar $dragarea = $("<div dragover=\'return false\'; class=\'annotation_tool_droparea\' style=\'height:40px !important;\'><span>drop nifti to for sensing</span></div>").appendTo($wrap);\n\tpanel.$container.on("dragover", function(ev){ev.preventDefault();ev.stopPropagation();return false;});\n\tpanel.$container.on("dragleave", function(ev){ev.preventDefault();ev.stopPropagation();return false;});\n\tpanel.$container.on("drop",ondrop);\n\tpanel.$container.width(400);\n\n    panel.objectify = function()\n    {\n    \treturn {contrasts:panel.contrasts};\n    }\n    panel.load = function(state)\n    {\n        panel.contrasts = {};\n        var cs = Object.keys(state.contrasts)\n\n        for (var k = 0;k < cs.length;k++)\n        {\n        \tpanel.contrasts[cs[k]] = cs[k]\n            KViewer.dataManager.loadData({\n                URLType: \'serverfile\',\n                fileID: cs[k],\n                callback: update_contrasts\n            });\n        }\n    \t\n\t\n    }\n\n    function ondrop(e) {\n\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tvar params = getloadParamsFromDrop(e.originalEvent,{});\n\t\t\tfor (var k = 0;k < params.length;k++)\n\t\t\t{\n\t\t\t\tif (!params.patient_study_drop)\n\t\t\t\t{\n\t\t\t\t\tparams[k].callback = function(fobj) {\n\t\t\t\t\t\tif (fobj.contentType == \'nii\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tpanel.contrasts[fobj.fileID] = fobj.fileID;\n\t\t\t\t\t\t\tupdate_contrasts();\n\t\t\t\t\t\t}\n\t\t\t     \t\telse \n\t\t\t     \t\t\talertify.error("only niftis allowed");\n\n\t\t\t\t\t\tthis.progressSpinner();\n\t\t\t\t\t}\n\t\t\t\t\tparams[k].progressSpinner = panel.progressSpinner;\n\t\t\t\t\tKViewer.dataManager.loadData(params[k]);\t\t\n\n\t\t\t\t}\n\t\t\t}\n     }\n\n     function getVals(c)\n     {\n     \tvar nii = c.content;\n     \tvar invedges = math.inv(nii.edges);\n     \tvar volsz =  nii.sizes[0]*nii.sizes[1]*nii.sizes[2];\n     \n        var points = mset.getPoints();\n        var res = [];\n        for (var j = 0; j < points.length;j++)\n        {\n        \tif (points[j].p.name != "tip" & points[j].p.name != "end" )\n        \t{\n\t\t\t\tvar point = points[j].p.coords;\n\t\t\t\tvar vals = [];\n\t\t\t\tfor (var k = 0;k < nii.numTimePoints;k++)\n\t\t\t\t\t   vals.push(Math.abs(trilinInterp(nii, point[0], point[1], point[2], invedges._data, volsz*k)))\n\t\t\t\tres.push({name:points[j].p.name,vals:vals})\n        \t}\n        }\n        return res;\n     }\n\n     panel.cid = -1;\n\n     function update_contrasts()\n     {\n     \tif (panel.cid != -1)\n     \t    clearTimeout(panel.cid);\n     \tpanel.cid = setTimeout(function() {\n\n     \t panel.cid  = -1;\n\n     \t $contrastsRow.children().remove()\n     \t var contrasts = Object.keys(panel.contrasts);\n         for (var k = 0; k < contrasts.length;k++)\n         {\n         \tvar fobj = KViewer.dataManager.getFile(contrasts[k])\n         \tif (fobj != undefined)\n         \t{\n\t\t\t\tvar name =fobj.filename;\n\n\t\t\t\tvar $c = $("<div class=KPickerPanelLargeHead><span>"+name+"</span></div>");\n\t\t\t\t$c.append( $("<i class=\'KPickerPanelDrop fa fa-trash\'> </i>").click(function(id) { return function() { \n\t\t\t\t\tdelete panel.contrasts[id]; update_contrasts(); }} (fobj.fileID) ) );\n\n\t\t\t\tvar res = getVals(fobj)\n\t\t\t\tfor (var j = 0; j < res.length;j++)\n\t\t\t\t{\n\t\t\t\t\tvar str = "<span  class=KPickerPanelSmallHead>" + res[j].name + ": </span>";\n\t\t\t\t\tif (res[j].vals.length == 1)\t\n\t\t\t\t\t{\t\t\t\n\t\t\t\t\t\tstr += "<span>" + res[j].vals[0]+ "</span>";\n\t\t\t\t\t\t$("<div class=KPickerPanelSmallRow>" + str + "</div").appendTo($c);\n\t\t\t\t\t}\n\t\t\t\t\telse if (res[j].vals.length < 5)\t\n\t\t\t\t\t{\n\t\t\t\t\t\tvar maxi = math.sum(res[j].vals);\n\t\t\t\t\t\tfor (var l = 0; l < res[j].vals.length;l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar w = Math.abs(res[j].vals[l]/maxi*100).toFixed(0);\n\t\t\t\t\t\t\tstr += "<div class=KPickingPanelHist style=\'height:"+w+"%\'>" +w+ "</div>";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$("<div class=KPickerPanelRow>" + str + "</div").appendTo($c);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tvar maxi = math.max(res[j].vals);\n\t\t\t\t\t\tfor (var l = 0; l < res[j].vals.length;l++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar w = Math.abs(res[j].vals[l]/maxi*100).toFixed(0);\n\t\t\t\t\t\t\tstr += "<div class=KPickingPanelHistDense style=\'height:"+w+"%\'></div>";\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$("<div class=KPickerPanelRow>" + str + "</div").appendTo($c);\n\t\t\t\t\t}\n\n\n\n\n\t\t\t\t}\n\n\n\t\t\t\t$c.appendTo($contrastsRow)\n         \t}\n         }\n\n     \t},100);\n\n     }\n\n     mset.onupdate[\'pickerpanel\'] = function(){\n\t\t var arr = mset.getPoints()\n\t\t for (var k = 0; k < arr.length;k++)\n\t\t     arr[k].onupdate[\'pickerpanel\'] = update_contrasts;\n\n     }\n\n     mset.onupdate[\'pickerpanel\']();\n\n     return panel;\n\n}'},function(t,n){t.exports="\n\n\n\n\n\nfunction KMarkerTool(master,toolname)\n{\n  /** Drawing annotations \n\t * @class \n\t * @alias KAnnotationTool\n\t * @augments KToolWindow\n\t */   \n  var that = new KToolWindow(master,\n  $(\"<div class='KView_tool '><i class='fa fa-comment-o fa-1x'></i></div>\")\n  .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Markers</li>\") ))\n  );\n \n  that.name = toolname;\n\t\n\tif( markerProxy == undefined)\n    \tmarkerProxy = new KMarkerProxy();\n  \n  // choose the default markerPanel\n//  var markerPanel = KMarkerPanel();\n\n\n  function createMarkerSet(type, name)\n  {\n//  \t\tif(name==undefined)\n//  \t\t///\n//\t\t\talertify.prompt(\"Name of marker set:\", function(e,str) { if (e)   that.newSet(str,type); }, 'untitled');\n//\t\telse\n\t\t\treturn that.newSet(\"undefined \" + type,type);\n  }\n  that.createMarkerSet = createMarkerSet;\n\n  var $menu = $(\"<ul ></ul>\");\n  $(\"<li><a>pointset</a></li>\").click(function() { createMarkerSet('pointset') } ).appendTo($menu);\n  $(\"<li><a>freeline</a></li>\").click(function() { createMarkerSet('freeline') } ).appendTo($menu);\n  $(\"<li><a>surface</a></li>\").click(function() { createMarkerSet('surface') } ).appendTo($menu);\n\n  $(\"<li><a>electrode</a></li>\").click(function() { createMarkerSet('electrode') } ).appendTo($menu);\n  $(\"<li><a>pointROI</a></li>\").click(function() { createMarkerSet('pointROI') } ).appendTo($menu);\n  $(\"<li><a>rectangles</a></li>\").click(function() { createMarkerSet('rectangles') } ).appendTo($menu);\n\n  that.$topRow.append( $(\"<li class='menu_generic_labelname'><a>MarkerTool</a></li>\").append($menu) );\n  that.$topRow.append( $(\"<li><a><i class='fa fa-plus'></i>New</a></li>\").append($menu) );\n\n\n\n  //that.$topRow.append(  $(\"<li><a><i class='fa fa-plus'></i> New markerset</a></li>\").click(function(){ alertify.prompt(\"Name of marker set:\", function(e,str) { if (e)   that.newSet(str); }); }  ) );\n  that.$topRow.append(  $(\"<li><a><i class='fa fa-save'></i> Save</a></li>\").click(function(){ \n\n\n      var finfo = patientTableMirror.getCurrentUniquePSID()\n      if (finfo == false)\n          alertify.error('Please select a unique patient for saving')\n      else\n      {\n      \t  var strr = \"subject \" + finfo.patients_id\n      \t  if (finfo.studies_id != undefined)\n      \t      strr = \"study \" + finfo.patients_id + finfo.studies_id \n\n\t\t  alertify.prompt({msg:'Name of marker collection for '+strr+':',opt:finfo.potential_studies, optMsg:\"Study to save\"},\t\t\t\t  \n\t\t\t  function(e,val)\n\t\t\t\t\t{ \n\t\t\t\t\t   if (e) { \n\t\t\t\t\t\tif (val.option != undefined)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tmarkerProxy.save(val.str,undefined,{piz:finfo.patients_id, study:\"#\"+val.option}); \n\t\t\t\t\t\t\tKViewer.markerTool.lastMarkerCollName = val.str; \n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{                    \n\t\t\t\t\t\t\tmarkerProxy.save(val); \n\t\t\t\t\t\t\tKViewer.markerTool.lastMarkerCollName = val; \n\t\t\t\t\t\t}\n\t\t\t\t\t  }\n\n\t\t\t\t\t},KViewer.markerTool.lastMarkerCollName);  \n      }\n   }  ) );\n      \t\t\t\t\t\n   that.$topRow.append(  $(\"<li><a><i class='fa fa-trash'></i> Clear</a></li>\").click(function(){ \n\t\t  function clear() {\n\t\t  \t\tmarkerProxy.delAll(); \n\t\t  \t\tthat.update();\n\t\t  \t\t};\n\t\t  if (markerProxy.modified)\n\t\t\talertify.confirm(\"Delete all modifcations on current annotations?\",function(e) { if (e) { clear();} })\n\t\t  else \n\t\t\tclear();\n\t\t\t }\t));\n \n\n\n\tvar btns = that.btns = {};\n\n\tvar $toolsRow    = $(\"<div class='anno_panel_tools'></div>\").appendTo(that.$container);\n   \t$toolsRow.append($(\"<i class='flexspacer'></i>\"));\n\t\n\tbtns.$showall = $(\"<i class='KViewPort_tool fa fa-refresh'></i>\").appendTooltip('show all markers').click(showAll ).appendTo($toolsRow);\n\tbtns.$locked = $(\"<i class='KViewPort_tool fa fa-lock'></i>\").appendTooltip('lockmarkers').click( function(){ \n\n\t\tvar dest = !markerProxy.currentSet.state.locked;\n\t\tfor (var s in markerProxy.markersets)\n\t\t\t markerProxy.markersets[s].toggleStateVar('locked',dest);\n\n\n\t} ).appendTo($toolsRow);\n\tbtns.$createonclick = $(\"<i class='KViewPort_tool fa fa-pencil'></i>\").appendTooltip('markercreateonclick').click( function(){ markerProxy.currentSet.toggleStateVar('createonclick')} ).appendTo($toolsRow);\n\tbtns.$cyclecolors = $(\"<i class='KViewPort_tool KViewPort_tool_enabled fa fa-recycle'></i>\").appendTooltip('cyclecolors').click( function(){ markerProxy.currentSet.toggleStateVar('cyclecolors') } ).appendTo($toolsRow);\n\tbtns.$hoverdetails = $(\"<i class='KViewPort_tool KViewPort_tool_enabled fa fa-info'></i>\").click( function(){ markerProxy.currentSet.toggleStateVar('hoverdetails')} ).appendTooltip('markerdetailsonhover').appendTo($toolsRow);\n\n\n\tfunction showAll()\n\t{\n\t\tmarkerProxy.showAll();\n\t}\n\n\n\n\tvar markersets =  markerProxy.markersets;\n\n\tthat.newSet = function(name,type)\n\t{\n\t\tvar opts = {name:name, \n\t\t\t\ttype:type,\n\t\t\t\tshowPanel: false,\n\t\t\t\thideOtherPanels: true\n\t\t\t\t}\n\t\tvar mset = markerProxy.newSet( opts );\n\t\tthat.update();\n\t\treturn mset;\n\n\t}\n\n\n\n\t// here is the list of annotations\n\tvar $annotationListDIV = $(\"<div class='annotation_tool_listDIV'></div>\").appendTo(that.$container);\n\tthat.resize = function(hei)\n\t{\n\t\tthat.$container.height(hei);\n\t\t$annotationListDIV.height(hei-that.$container.find('.KToolsTopMenu').height());\n\t}\n\n  that.update = function()\n  {\n  \t$annotationListDIV.children().remove();\n  \tvar ks = Object.keys(markersets).reverse()\n\tfor (var i=0;i< ks.length;i++)\n\t{\n\t   var k = ks[i];\n\t   //setTimeout(function(k) { return function() {\n\t   var $setrow = $(\"<div  id='markerset_uuid_\"+ markersets[k].uuid + \"' class='markerset_row'></div>\")\n\t   var $titlerow = $(\"<div></div>\").appendTo($setrow);\n\t   var $name = $(\"<span>\" + markersets[k].name + \"</span>\").appendTo($titlerow);\n\t\n\t   if (markerProxy.currentSet != undefined && k == markerProxy.currentSet.uuid)\n\t   \t  $titlerow.addClass(\"markerset_row_active\")\n\n\t   makeEditableOnDoubleClick($name);  \n\t   $name.on(\"keyup\",function(k) { return function(){\n\t   \t  markersets[k].name = $(this).text();\n\t   \t  if(markersets[k].markerPanel)\n\t   \t  \tmarkersets[k].markerPanel.updateName();\n\t   } }(k));   \n\n\t   $titlerow.append( $(\"<i class='fa fa-trash'></i> \").click(function(k) { return function() {markerProxy.delSet(k); that.update()}}(k)) )\n\t   $titlerow.append( $(\"<i class='fa fa-eye'></i> \").click(function(k) {\n\t   \t return function(ev) {\n\t   \t \tvar $vis = $(this);\n\t   \t \tif (markersets[k].togglePointsVisibility())\n\t\t\t\t$vis.addClass(\"fa-eye\").removeClass(\"fa-eye-slash\");\n\t\t\telse\n\t\t\t\t$vis.removeClass(\"fa-eye\").addClass(\"fa-eye-slash\");\n\t\t\t\tev.stopPropagation(); return false}}(k)) )\n\n\t   $titlerow.append( $(\"<i class='fa fa-dot-circle-o'></i> \").click(function(k) { return function() {\n              var set = markersets[k];\n\t\t   \t  if (set.pickpanel == undefined)\n\t\t\t\tset.pickpanel = KPickingPanel(set);\n\t\t\t  else\n\t\t\t  \tset.pickpanel.toggle();\n\t   \t\n\t   }}(k)) )\n\t   \n\n\t   $titlerow.append( $(\"<i class='fa fa-copy'></i> \").click(function(k) { return function() {\n\t\t\t\t   \t\n\t\t\tvar set = createMarkerSet( \tmarkerProxy.markersets[k].type,\tmarkerProxy.markersets[k].name+\"(copy)\");\n\t\t\tvar pts = markerProxy.markersets[k].getPoints();\n\t\t\tfor (var j = 0; j < pts.length;j++)\n\t\t\t{\n\t\t\t\tvar c = pts[j].p.coords;\n\t\t\t\tvar p = set.addpoint([c[0],c[1],c[2],c[3]]);\n\t\t\t\tp.setsize(pts[j].p.size)\n\n\t\t\t}\n\t\t\tthat.update();\n\t\n\n\n\t   }\n\n\t   \t}(k)) )\n\t   $titlerow.append( $(\"<i class='fa fa-save'></i> \").click(function(k) { return function() {markerProxy.save(undefined,k); that.update()}}(k)) )\n\t   if (markersets[k].type != 'electrode')\n\t   \t  $titlerow.append( $(\"<i class='fa fa-plus'></i> \").click(function(k) { return function() {markerProxy.createMarker(undefined, markersets[k] );  \n\t   \t  markerProxy.setCurrentSet(k, true); that.update()}}(k)) )\n\t   if (markersets[k].type == 'electrode')\n\t   \t  $titlerow.append( $(\"<i class='fa fa-mars-stroke-v'></i> \").click(function(k) { return function() {markerProxy.markersets[k].Rectifytransform();}}(k)) )\n\t   if (markersets[k].type == 'pointset')\n\t   {\n\t   \t  $titlerow.append( $(\"<i class='fa fa-cube'></i> \").appendTooltip(\"defineMCPsystem\").click(function(k) { return function() {markerProxy.markersets[k].MCPtransform();}}(k)) )\n\t   \t  $titlerow.append( $(\"<i class='fa fa-cubes'></i> \").appendTooltip(\"defineRECTsystem\").click(function(k) { return function() {markerProxy.markersets[k].RECTtransform();}}(k)) )\n\t   }\n\n\t\tvar colors = KColorSelectorSimple('getcolors');\n\n \t\tvar $colselector = KColorSelector(colors,\n        function(c) {\n        \tif (c.getCSS)\n            \treturn \"background:\" + c.getCSS() +\"\";\n        },\n        function(k) { return function(col,colidx) {\n        \tvar x =  markerProxy.markersets[k];\n        \tfor (var j in x.markerpoints)\n        \t{\n        \t\tx.markerpoints[j].setcolor(col);\n        \t}\n        \tx.updateLine()\n          \n        }}(k),markerProxy.markersets[k]);\n\n/*\t  \n\t  var $colorselector = KColorSelectorSimple($(\"<div class='markerpointrow_colorselector'></div>\"), function() { \n\t\tmarkersets[k];\n\t  }, {color:1});\n*/\n\t  $titlerow.append($colselector);\n\t  $colselector.addClass(\"markerset_colselector\");\n\n\n\t   $titlerow.append( $(\"<i class='fa fa-building-o'></i> \").click(function(k) { \n\t   return function() {markersets[k].showPanel() }}(k)) )\n\n\t   var $typecombo = $(\"<select> <option value='pointset'> point set </option>\" + \n\t   \t\t\t\t\t\t\t  \" <option value='freeline'> free line </option>\" + \n\t   \t\t\t\t\t\t\t  \" <option value='surface'> surface </option>\" + \n\t   \t\t\t\t\t\t\t  \" <option value='electrode'> electrode </option> \" + \n\t   \t\t\t\t\t\t\t  \" <option value='pointROI'> pointROI </option> \" + \n\t   \t\t\t\t\t\t\t  \" <option value='rectangles'> rectangles </option> \" + \n\t   \t\t\t\t\t\t\t  \"</select>\").appendTo($titlerow).\n\t   \t\t\t\ton('change',function(k) { return function(e)\n\t   \t\t\t\t{\n\t   \t\t\t\t\tmarkersets[k].setType(e.target.value);\n  \t\t\t\t\t    that.update();\n\n\t   \t\t\t\t}}(k));\n       $typecombo.val( markersets[k].type);\t   \t\t\t\t\n\n\n\n\t   var $setinfo;\n\t   if (markersets[k].type == 'freeline' || markersets[k].type == 'surface' )\n\t   {\n\t   \t   $setinfo = $(\"<div class='annotation_info'> ???: </div>\").appendTo($setrow);\n\t\t   markersets[k].setInfo = function(text)\n\t\t   {\n\t\t\t\t$setinfo.text(text);\n\t\t   }\n\t\t   markersets[k].computeInfo();\n\t   }\n\t   else if (markersets[k].type == 'electrode')\n\t   {\n\t\t   $setinfo = $(\"<div class='annotation_info'> </div>\").appendTo($setrow);\n\n\n\t\t   var elecs = Object.keys(electrodes);\n\t\t   var str = \"\";\n\t\t   for (var j = 0; j < elecs.length;j++)\n\t\t   \tstr += \"<option value='\"+elecs[j]+\"'> \"+elecs[j]+\" </option>\";\n\t\t   var $combo = $(\"<select> \"+str +\"</select>\").appendTo($setinfo).\n\t   \t\t\t\tclick(function(set) { return function(e)\n\t   \t\t\t\t{\n\t   \t\t\t\t\tmarkerProxy.updateElectrode(set,e.target.value);\n\t   \t\t\t\t\tif (set.markerPanel)\n\t   \t\t\t\t\t\tset.markerPanel.update();\n\t   \t\t\t\t\tKViewer.markerTool.update();\n\t   \t\t\t\t\tset.pointChanged();\n\t   \t\t\t\t}}(markersets[k]));\n   \t\t   $combo.val( markersets[k].elecmodel);\t   \t\t\t\t\t   \t\t\t\t\n   \t\t   markersets[k].$elecmodel_combo = $combo;\n\n\n\t\t   var $ohm = $(\"<span>current (mA): </span>\").appendTo($setinfo);\n\t\t   $ohm.append($(\"<input> \").val(markersets[k].electrode_properties.impedance).on(\"change\",function(set) { return function(e)\n\t\t   {\n\t\t   \t\tset.electrode_properties.impedance = parseFloat(e.target.value);\n\t\t   \t\tset.electrode_properties.impedance = parseFloat(e.target.value);\n\t\t   }  }(markersets[k]) ));\n\n\n\t\t   var $simpanel = $(\"<button> Simulation Panel </button>\").appendTo($setinfo).click(function(set) { return function(e)\n\t\t   {\n\t\t   \t  if (set.simpanel == undefined)\n\t\t\t  \tset.simpanel = KSimulationPanel(set);\n\t\t\t  else\n\t\t\t  \tset.simpanel.toggle();\n\t\t   }  }(markersets[k]) );\n\n\n\n\n\t\t   $(\"<br>\").appendTo($setinfo);\n\t   }\n\n\n\t   $annotationListDIV.append($setrow);\n\t   \n\t   //markersets[k].markerPanel.$annotationListDIV = $annotationListDIV;\n\t   //markersets[k].$titlerow = $titlerow;\n\n\t   $titlerow.click(function(k,$name,$titlerow) { return function() {\n\t   \t\tsetTimeout(function(){ \n\t   \t\t \tif ($name.attr(\"contentEditable\"))\n\t   \t\t \t\treturn;\n\t   \t\t \telse\n\t   \t\t \t{\n\t   \t\t\t\tmarkerProxy.setCurrentSet(k, true);  \n\t   \t\t\n\t   \t\t \t}\n\t   \t\t\t\t},0);  } }(k,$name,$titlerow));\n\n\t   var ps = markersets[k].getPoints();\n\n\n\t\t// these are the things to show in the markerTool rows\n\t\tvar thingstoshow;\n\t\tif (markersets[k].type == 'electrode')\n\t\t{\n\t\t\tthingstoshow = {economy:1, colorsel:1, id:1, name:1, toggle:0, search:1,  coords:1};\n\t\t}\n\t\telse if (markersets[k].type == 'freeline')\n\t\t{\n\t\t\tthingstoshow = {economy:1, colorsel:0, name:0,id:1, delete:1,search:1,  coords:1};\n\t\t}\n\t\telse if (markersets[k].type == 'surface')\n\t\t{\n\t\t\tthingstoshow = {economy:1, colorsel:0, name:0,id:1, delete:1,search:1,  coords:1};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthingstoshow = {colorsel:1, id:1, name:1, toggle:1, search:1, delete:1,  coords:1,coords_transformed:1};\n\t\t}\n\n\n  \t   for (var j=0;j< ps.length;j++)\n  \t   {\n  \t\t\tvar p = ps[j];\n  \t\t\tif (markersets[k].type == 'electrode')\n  \t\t\t{\n\t\t\t\tthingstoshow.active = (j>=2);\n\t\t\t\tthingstoshow.radius = (j>=2);\n  \t\t\t}\n  \t\t\tvar $div = p.createMarkerRepresentation(\"tool\", thingstoshow );\n\t\t    $setrow.append($div )\n\t\t    if (markersets[k].type == 'pointset')\n\t\t      $div.append($(\"<hr width='100%'> \"))\t  \t\t\t\n  \t   }\n \t//  } }(k) ,0);\n  \t}\n  }\n\n  that.customToggle = function(enabled)\n  {\n  \t var mset = markerProxy.currentSet;\n\t enabled = enabled | (mset != undefined && mset.markerPanel && mset.markerPanel.panelvisible);\n  \t if (mset != undefined)\n  \t {\n\t\t if (enabled)\n\t\t\tmset.drawAllPoints();\n  \t }\n\n  \t if (!enabled)\n  \t     markerProxy.hideAll()\n  }\n\n  that.$container.on(\"dragover\",function(ev){ ev.preventDefault() });\n  $annotationListDIV.on(\"drop\",function(e)\n  {\n    var params = getloadParamsFromDrop(e.originalEvent,undefined);\n  \tif (params.length > 0)\n  \t{\n\t\tparams[0].progressSpinner = that.progressSpinner;\n\t\tparams[0].callback = function(fileObject)\n\t\t{        \n\t\t  that.hideSpinner();\n\t\t  if ((fileObject.fileinfo.tag && fileObject.fileinfo.tag.search(\"ANO\") >= 0) | \n\t\t      (fileObject.fileinfo.Tag && fileObject.fileinfo.Tag.search(\"ANO\") >= 0) | \n\t\t      fileObject.filename.search(\"\\\\.ano.json\") != -1 )\n            markerProxy.loadAnnotations(fileObject);\n\t\t}\n\n\t\tKViewer.dataManager.loadData(params[0]);\n\n  \t}\n  });\n\n\n\n  return that;\n \n\n}\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= markerProxy\n// ======================================================================================\n// ======================================================================================\nKMarkerProxy = function()\n{\n\tvar that = new Object();\n\t\n\t/******************************************************************************\n\t  markerSets is key valued list\n\t*******************************************************************************/\n\t//var markersets = that.markersets = [];\n\tvar markersets = that.markersets = {};\n\tvar markersetIDs = that.markersetIDs = [];\n\n\tthat.modified = false;\n\n\n    function to_transformed(c)\n\t  {\n\t\treturn math.multiply((KViewer.reorientationMatrix.matrix),  c  )\n\t  }\n\t  that.to_transformed = to_transformed;\n\n\t/******************************************************************************\n\t  updateElectrode\n\t*******************************************************************************/\n\tthat.updateElectrode = function(set,model)\n\t{\n\t\t   while (Object.keys(set.markerpoints).length > 2)\n\t\t   {\n\t\t   \t\tvar ps = Object.keys(set.markerpoints);\n\t\t   \t\tvar key = ps[ps.length-1];\n\t\t   \t\tset.markerpoints[key].deletepoint();\t\t   \t\t\n\t\t   \t\tdelete set.markerpoints[key];\n\t\t   }\n\n\t\t   if (Object.keys(set.markerpoints).length < 2)\n\t\t   {\n\t\t\t\tvar point = set.addpoint(); \n\t\t\t\tpoint.movepoint([0,0,80,1])\n\t\t\t\tvar point2 = set.addpoint();\n\t\t\t\tpoint2.movepoint([0,0,-10,1])\n\t\t   }\n\n\t\t   var ps = set.getPoints();\n\t\t   var end = ps[0];\n\t\t   var tip = ps[1];\n\t\t   end.p.name = \"end\";\n\t\t   end.setsize(1);\n\t\t   end.visible = true;\n\t\t   end.setcolor(new KColor([155,0,0,20]));\n   \t\t   end.isElectrodeEnd = tip;\n\t\t   tip.p.name = \"tip\";\n\t\t   tip.setsize(1);\n\t\t   tip.visible = true;\n\t\t   tip.setcolor(new KColor([155,0,0,20]));\n\n\n\n\t\t\tset.color = 10;\n\t\t   set.electrode_properties = $.extend(true,{},electrodes[model]);\n\t\t   set.electrode_properties.impedance = 1000;\n\t\t   set.elecmodel = model;\n\n\t\t   var contacts = set.electrode_properties.contacts;\n\t\t   var cnt = 1;\n\t\t   while (Object.keys(set.markerpoints).length < contacts.length+2)\n\t\t   {\n\t\t\t\tvar point = set.addpoint();\n\t\t\t\tpoint.p.name = \"contact \" + cnt ;\n\t\t\t\tpoint.setsize(1);\n\t\t\t\tpoint.visible = true;\n\t\t\t\tfor (x in point.glmesh)\n\t\t\t\t\tpoint.glmesh[x].isPickable = false;\n\t\t\t\tpoint.pickable = false;\n\t\t\t\tpoint.isContact = true;\n\t\t\t\tpoint.setcolor(new KColor([50,50,50,0]));\n\t\t\t\tcnt++;\n\t\t   }\n\t\t   var ps = set.getPoints();\n\t\t   for (var j = 0; j < ps.length;j++)\n\t\t\t ps[j].active = false;\n\t\t   ps[2].active = true;\n\n\n\t\t   set.pointChanged();\n\t\t   set.drawLine();\n\t}\n\n\n\n\t/******************************************************************************\n\t  delAll\n\t*******************************************************************************/\n\tthat.delAll = function(force)\n\t{\n\t\tfor (var k in markersets)\n\t\t{\n\t\t\tif(!markersets[k].state.keepalive || force)\n\t\t\t{\n\t\t\t\tmarkersets[k].deletePanel();\n\t\t\t\tmarkersets[k].deleteAllPoints();\n\t\t\t\tdelete markersets[k];\n\t\t\t}\n\t\t}\n\t\tthat.markersetIDs = Object.getOwnPropertyNames(markersets);\n\t\tif(markerProxy.currentSet && markersets[markerProxy.currentSet.uuid] == undefined )\n\t\t\tmarkerProxy.currentSet = undefined;\t\t\n\t\tthat.modified = false;\n\t}\n\n\t/******************************************************************************\n\t  objectify\n\t*******************************************************************************/\n\tthat.objectify = function(key)\n\t{\n\t\t  var content = [];\n\t\t  for (var k in markersets)\n\t\t  {\n\t\t\tif (key == undefined || key==k)\n\t\t\t\tcontent.push(markerProxy.markersets[k].objectify());\n\t\t  }\n\t\t  return content;\n\t}\n\n\n\n\t/******************************************************************************\n\t  save\n\t*******************************************************************************/\n\tthat.save = function(name,key,finfo)\n\t{\n          if (finfo == undefined)\n              finfo = {};\n\n\t\t// if key is given, only corresponding set is saved, otherwise all sets\n\t\t// in this case, name can differ (overall name for collection of sets)\n\t\t  if(typeof key =='object')\t\n\t\t  \tkey = key.uuid;\n\t\t  \t\n\t\t  var content = that.objectify(key);\n\t\t  \n\t\t  // save just one markerset\n\t\t  if (key != undefined)\n\t\t  {\n\t\t\tname = content[0].name;\n\t\t\t\n\t\t\t// is performed below\n\t\t\t//that.markersets[key].modified = false;\n\t\t  }\n\n\t\t\n\t\t  var subfolder = 'annotations';\n\t\t  var splitname = name.split(\"/\")\n\t\t  if (splitname.length>1)\n\t\t  {\n\t\t  \t subfolder = splitname.slice(0,splitname.length-1).join(\"/\");\n\t\t  \t name  = splitname[splitname.length-1];\n\t\t  }\n\n\n\t\t  name = name + \".json\";\n\n\n\t\t  var content = {annotations:content};\n\t\t  function onsuccess()\n\t\t  {\n\t\t  \t  for(var m in markersets)\n\t\t\t  {\n\t\t\t\t  if(key==undefined || key==m)\n\t\t\t\t  {\t\n\t\t\t\t\t  that.markersets[m].modified = false;\n\t\t\t\t\t  // set all pointrois of this set to undmodified, otherwise he will ask for unsaved rois\n\t\t\t\t\t  var ps =  markersets[m].getPoints();\n\t\t\t\t\t  for(var k=0; k<ps.length; k++)\n\t\t\t\t\t  {\n\t\t\t\t\t\t  if(ps[k].roinii && ps[k].roinii.fileObject)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\tps[k].roinii.fileObject.modified = false;\n\t\t\t\t\t\t  }\n\n\t\t\t\t\t  }\n\t\t\t\t  }\n\t\t\t  }\n\t\t     markerProxy.modified = false;\n\t\t  }\n\t\t  uploadJSON(name,content,$.extend({subfolder:'annotations',tag:'ANO/MCP'},finfo), onsuccess);  \t \n\t\t  \n\n\n\t}\n\n\n\t/******************************************************************************\n\t  import\n\t*******************************************************************************/\n\tthat.import = function(a, replaceIntoSet)\n\t{\n\t\tvar current = 0;\n\t\tif (a.length == 0)\n\t\t\treturn replaceIntoSet;\n\t\tfor(var k=0; k<a.length; k++)\n\t\t{\n\t\t\n\t\t  if( replaceIntoSet!= undefined )\n\t\t  {\n\t\t\t  var n = that.newSet(replaceIntoSet,true);\n\t\t\t  n.name = a[k].name;\n\t\t  }\n\t\t  else\t\n\t\t  {\n\t\t\t  args = {name: a[k].name,   type: a[k].type, dontupdate:true};\n\t\t\t  var n = that.newSet(args,true);\n\t\t  }\n\t\t  \n\t\t  n.deleteAllPoints();\n\t\t  if (a[k].isCurrent)\n\t\t  \tcurrent = k;\n\n\t\t  if (n.electrode_properties != undefined && a[k].electrode_properties != undefined)\n\t\t\t  n.electrode_properties = $.extend(n.electrode_properties,a[k].electrode_properties)\n\n\t\t  if(a[k].state !=undefined)\n\t\t  {\n\t\t  \tn.setState(a[k].state )\n\t\t  }\n\n\n\t\t  //n.visible = false;\n\n\t\t  for(var p=0; p<a[k].points.length; p++)\n\t\t  {\n\t\t\tvar point = n.addpoint(a[k].points[p].coords);\n\t\t\tpoint.p.name = a[k].points[p].name;\n\t\t\tpoint.p.comment = a[k].points[p].comment;\n\t\t\tif (a[k].color)\n\t\t\t\tpoint.setcolor(new KColor(a[k].color));     \n\t\t\tif (a[k].points[p].color)\n\t\t\t\tpoint.setcolor(new KColor(a[k].points[p].color));    \n\t\t\tif (a[k].points[p].visible != undefined && a[k].points[p].visible == false)\n\t\t\t\tpoint.togglepoint();\n\t\t\tif (a[k].points[p].dir)\n\t\t\t\tpoint.setdir(a[k].points[p].dir);\n\n\t\t\tif (a[k].points[p].size)\n\t\t\t\tpoint.setsize(a[k].points[p].size)\n\t\t\telse\n\t \t\t\tpoint.setsize( n.state.defaultradius );\t\n\t\t\t\n\t\t\tif (a[k].points[p].subpoints)\n\t\t\t\tpoint.subpoints = a[k].points[p].subpoints;\n\n\t \t\tif (a[k].points[p].active != undefined && n.electrode_properties != undefined)\n\t \t\t{\n\t \t\t\tpoint.active = a[k].points[p].active;\n\t \t\t\tif (point.active)\n\t\t\t\t\tpoint.setcolor(new KColor([255,255,0]));     \t \t\t\t\n\t \t\t}\n\t \t\tif (a[k].points[p].voltage != undefined)\n\t \t\t\tpoint.p.voltage = a[k].points[p].voltage;\n\t \t\tif (a[k].points[p].isContact != undefined)\n\t \t\t\tpoint.isContact = a[k].points[p].isContact;\n\t \t\tif (a[k].points[p].pickable != undefined)\n\t \t\t\tpoint.pickable = a[k].points[p].pickable;\n\t \t\tif (a[k].points[p].referencedImageFilename != undefined)\n\t \t\t\tpoint.referencedImageFilename = a[k].points[p].referencedImageFilename;\n\t \t\tif (a[k].points[p].referencedImageFileID != undefined)\n\t \t\t\tpoint.referencedImageFileID = a[k].points[p].referencedImageFileID;\n\t \t\t\n\t \t\t// set the roi nii to not modified, otherwise will ask on save\n\t \t\tif(point.roinii && point.roinii.fileObject)\n\t\t\t  \tpoint.roinii.fileObject.modified = false;\n\t \t\t\t\n\t\t\tif (a[k].points[p].formcontent)\n\t\t\t\tpoint.formcontent = a[k].points[p].formcontent\n\t\t\tif (a[k].points[p].thresh != undefined )\n\t\t\t{\n\t\t\t\tpoint.thresh = a[k].points[p].thresh\n\t\t\t\tpoint.onupdate.pointROI()\n\t\t\t}\n\n\t\t  }\n\t\t\t/*\n\t\t\t ask to load corresponding image:\n\t\t\t only makes sense if we check whether image is already loaded and if we implement it in the end\n\n\t\t\tif (a[k].points.length > 0 && a[k].points[0].pointROI != undefined)\n\t\t\t{\n\t\t\t\tif(a[k].points[0].pointROI.refimagefileID != undefined)\n\t\t\t\t{\n\t\t\t\t\talertify.confirm(\"You are loading a pointROI which was drawn on image id '\"+a[k].points[0].pointROI.refimagefileID +\"'. Do you want to load that image?\",\n\t\t\t\t\tfunction(e) { if (e) \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\talertify.error(\"Feature not implemented yet. Please load the reference image manually.\")\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\t*/\n\n\n\t\t\t\n\t\t  if (a[k].type == 'electrode')\n\t\t  {\n\t\t\t   if (a[k].elecmodel == undefined)\n\t\t\t   {\n\t\t\t\t   \tthat.updateElectrode(n,\"Medtronic3389\");\n\t\t\t   }\n\t\t\t   else\n\t\t\t   {\n\t\t\t\t  var pts = n.getPoints();\n\t\t\t\t  if (pts.length == 2)\t\t\t   \t\n\t\t\t\t   \tthat.updateElectrode(n,a[k].elecmodel);\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t  \t  n.electrode_properties = $.extend(true, n.electrode_properties ,electrodes[a[k].elecmodel]);\n\t\t\t\t  \t  n.elecmodel = a[k].elecmodel;\n\t\t\t\t  \t  if (n.$elecmodel_combo)\n\t\t\t\t  \t  \tn.$elecmodel_combo.val(a[k].elecmodel);\n\t\t\t\t\t  n.pointChanged();\n\t\t\t\t\t  n.markerpoints[Object.keys(n.markerpoints)[0]].p.color.color[3] = 10;\n\t\t\t\t\t  n.markerpoints[Object.keys(n.markerpoints)[1]].p.color.color[3] = 10;\n\t\t\t\t\t  n.markerpoints[Object.keys(n.markerpoints)[0]].p.size = 1\n\t\t\t\t\t  n.markerpoints[Object.keys(n.markerpoints)[1]].p.size = 1\n\t\t\t\t\t  //n.setActive();\n\t\t\t\t\t  pts[0].isElectrodeEnd = pts[1];\n\t\t\t\t  }\n\t\t\t   }\n\t\t\t   n.toggleStateVar('locked')\n\n\t\t  }\n\t\t  \n\t\t  // addPoint above changed modified to true, we do not want that\n\t\t  n.modified = false;\n\n\n \t      if (n && n.state && n.state.pickpanel)\n\t\t  {\n\t\t\t\tn.pickpanel = KPickingPanel(n);\n\t\t\t\tn.pickpanel.load(n.state.pickpanel);\n\t\t  }\n\n\t\t  if (n && n.state && n.state.panel_visible)\n\t\t\t  n.showPanel();\n\n\t\t  if(n.markerPanel)\n\t\t  \tn.markerPanel.update();\t\n\n\t\t}\n\t\tmarkerProxy.modified = false;\n\n\n\n\t\treturn n || replaceIntoSet;\n\t}\n\n\n\n\n\n\t/******************************************************************************\n\t  loadAnnotations\n\t*******************************************************************************/\n\tthat.loadAnnotations  = function(fileObject,replaceIntoSet)\n\t{\n\t\tvar append = false;\n\t\tif (that.markersetIDs.length > 0)\t\t\n\t\t\talertify.confirm(\"Append to existing annotations?\",function(e) { \n\t\t\t\tif (e) \n\t\t\t\t\tappend = true;\n\t\t\t\tif (!append & markerProxy.modified)\n\t\t\t\t\talertify.confirm(\"Are you sure to delete all annotations?\",function(e) { if (e) { load(); } })\n\t\t\t\telse\n\t\t\t\t\treturn load();\n\t\t\t});\n\t\telse\n\t\t{\n\t\t\tif (markerProxy.modified)\n\t\t\t\talertify.confirm(\"Are you sure to delete all annotations?\",function(e) { if (e) { load(); } })\n\t\t\telse\n\t\t\t\treturn load();\t\t\t\n\t\t}\n\t    function load()\n\t    {\n\t\t\tvar a = fileObject.content;\n\t\t\tif (typeof a == \"string\")\n\t\t\t\ta = JSON.parse(a);\n\t\t\tif (a.content != undefined)\n\t\t\t  a = a.content;\n\t\t\tif (a.annotations != undefined)\n\t\t\t  a = a.annotations;\n\n\t\t\tif (!append)\n\t\t\t\tmarkerProxy.delAll();\n\n\t\t\tvar sets = that.import(a,replaceIntoSet);\n\n            that.hideAll()\n\t\t\tthat.setCurrentSet( that.markersetIDs[0] )\n\n\t\t\tKViewer.markerTool.lastMarkerCollName = fileObject.filename.replace(\".json\",\"\").replace(\".ano\",\"\");\n\n\t\t\treturn sets;\n\t\t//\tif (KViewer.markerTool.isinstance)\n\t\t//\t\tKViewer.markerTool.update();\n\n\t    }\n\t}\n\n\t/******************************************************************************\n\t  newSet\n\t*******************************************************************************/\n\tthat.newSet = function(args,donotsetcurrentset) //  name, type, uuid, options)\n\t{\n\n\t\t// uuid already exists, try to take from list of markerset\n\t\tif(args && args.uuid != undefined && that.markersets[args.uuid])\n\t\t{\n\t\t\tif(args.showPanel)\n\t\t\t\tthat.markersets[args.uuid].showPanel()\n\t\t\treturn that.markersets[args.uuid];\n\t\t}\n\t\t\n\t\t// markerset already exists. Keep \n\t\tif(args && args.markerpoints)\n\t\t\tvar mset = args;\n\t\telse\n\t\t\tvar mset = new KMarkerset( args || {} );\n\n\t    that.markersets[mset.uuid] = mset;\n\t    that.markersetIDs = Object.getOwnPropertyNames(markersets);\t\n\n\t    \n\t    if (mset.type == 'electrode')\n\t     \tthat.updateElectrode(mset,mset.elecmodel);\n\n\t    if(mset.type !== 'ruler' && !donotsetcurrentset)\n\t    \tthat.setCurrentSet( mset, (args && args.hideOtherPanels),(args && args.dontupdate) );\n\n\t    return mset;\n\t}\n\n\t/******************************************************************************\n\t  delSet\n\t*******************************************************************************/\n\tthat.delSet = function(key)\n\t{\n\t\tif (that.markersets[key] == that.currentSet)\n\t\t\tthat.currentSet = undefined;\n\n\t\tif( that.markersets[key] == undefined)\n\t\t\treturn;\n\n\t\tthat.markersets[key].disposeLine();\n\t\tthat.markersets[key].deleteAllPoints();\n\t\tthat.markersets[key].deletePanel();\n\t\tthat.markersetIDs = Object.getOwnPropertyNames(that.markersets);\n\t\tif (that.markersets[key].updateLine_sid)\n\t\t{\n\t\t\tsignalhandler.detach('positionChange',that.markersets[key].updateLine_sid);\n\t\t\tthat.markersets[key].updateLine_sid = undefined;\n\t\t}\n\t\tdelete that.markersets[key];\n\n\t\tthat.markersetIDs = Object.getOwnPropertyNames(markersets);\t\n\n\t\tif (KViewer.markerTool.isinstance)\n\t\t\t\tKViewer.markerTool.update();\n\t}\n\n\t/******************************************************************************\n\t append an existing set (and make current)\n\t*******************************************************************************/\n\tthat.appendSet = function(mset,makecurrent) //  name, type, uuid, options)\n\t{\n\t    that.markersets[mset.uuid] = mset;\n\t    that.markersetIDs = Object.getOwnPropertyNames(that.markersets);\t\n\t    if(makecurrent)\n\t\t\tthat.currentSet = mset ;\n\t    return mset;\n\t}\n   \n\n\t/******************************************************************************\n\t get a set\n\t*******************************************************************************/\n    that.getSets = function()\n    {\n\t\tvar keys = Object.keys(that.markersets);\n\t\tvar p = [];\n\t\tfor (var k = 0;k < keys.length;k++)\n\t\t\tp.push(that.markersets[keys[k]]);\n\t\treturn p; \n    }\n\t/******************************************************************************\n\t get a set by name\n\t*******************************************************************************/\n    that.getSetByName = function(name)\n    {\n\t\tfor (var k in that.markersets)\n\t\t\tif(that.markersets[k].name == name)\n\t\t\t\treturn that.markersets[k]; \n    }\n\n\n\n\t/******************************************************************************\n\t  create a new maker (by click into canvas, or directly)\n\t  --\x3e this should go to the markerset itself ..?\n\t*******************************************************************************/\n\tvar runnigPointID = -1;\n\tfunction createMarker(ev, mset, medviewer, coords)\n\t{\n/*\n\t\tif ( !KViewer.globalCoordinates && medviewer == undefined)\n\t\t{\n\t\t\talertify.confirm(\"You are currently in non-global coordinate mode.<br> In this mode, you can only create markers by drag / drop into a specific viewport.\");\n\t\t\treturn;\n\t\t}\n */\t\t\n \t\tif(ev !== undefined && !(ev instanceof DragEvent) && ( ev.button != 0   |  !( $(ev.target).hasClass('KViewPort_canvas') |  $(ev.target).hasClass('markerpoint') )  )   )\n \t\t\treturn ;\n\n\t\tmset  = mset || that.currentSet;\n\n\t\t// for the scribble, insert a new SUBPOINT if a scribble is already in this slice\n\t\tif(mset.type == \"scribble\"  && ev.coords == undefined)\n\t\t{\n\t\t\tfor(var k in mset.markerpoints)\n\t\t\t{\n\t\t\t\tvar fpoint = mset.markerpoints[k]\n\t\t\t\tvar temp = medviewer.getCanvasCoordinates(fpoint.coords);\n\t\t\t\tif(math.round(temp.z_mm * 100) == math.round(medviewer.getCurrentSliceInMM()*100 ))\n\t\t\t\t{\n\t\t\t\t\tvar realworldcoords = medviewer.getRealWorldCoordinatesFromMouseEvent(ev)._data;\n\t\t\t\t\t// find closest segment\n\t\t\t\t\tif(fpoint.isclosed)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar plinear = [];\n\t\t\t\t\t\tfor(var j=0; j<fpoint.subpoints.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttemp = medviewer.getCanvasCoordinates(fpoint.subpoints[j]);\n\t\t\t\t\t\t\tplinear.push(temp.x_pix);\n\t\t\t\t\t\t\tplinear.push(temp.y_pix);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar canvascoords = medviewer.getCanvasCoordinates(realworldcoords)\n\t\t\t\t\t\tvar xind = PolyK.ClosestEdge(plinear, canvascoords.x_pix, canvascoords.y_pix);\n\n\t\t\t\t\t\t// insert the point\n\t\t\t\t\t\tfpoint.subpoints.splice(xind.edge+1, 0, realworldcoords);\n\t\t\t\t\t\tfpoint.lastInsertedPointInd = xind.edge+1\n\t\t\t\t\t\tfpoint.movedirection = 0;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfpoint.subpoints.push(realworldcoords);\n\t\t\t\t\t}\n\n\t\t\t\t\tmset.drawAllPoints();\n\t\t\t\t\treturn fpoint\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\t\n\t\trunnigPointID++;\n\n\t\t// points can be created by click into canvas, drag and drop a template or load annotations, or ...\n\t\t// create on click or on drag template\n\t\tif( coords==undefined && ev)\n\t\t{\n\t\t\tif(ev.coords==undefined)\n\t\t\t\tcoords = medviewer.getRealWorldCoordinatesFromMouseEvent(ev)._data;\n\t\t\telse\n\t\t\t\tcoords = ev.coords;\n\t\t}\n\n      \t//var point = mset.addpoint( ev?ev.coords:undefined );\n      \tvar point = mset.addpoint( coords,undefined,undefined,{master:Object.keys(mset.markerpoints).length == 0} );\n      \t\n\t\t// find the referencedImageFileID\n\t\ttviewer = medviewer\n\t\tif(medviewer == undefined)\n\t\t{\n\t\t\ttlist = [];\n\t\t\tKViewer.iterateMedViewers(function(mv){if(mv.currentFileinfo)tlist.push(mv)  })\n\t\t\tif(tlist.length != 1)\n\t\t\t\t//alertify.error(\"could not find a referenced file image\");\n\t\t\t\tvar dummy = 1;\n\t\t\telse\n\t\t\t\ttviewer = tlist[0];\n\t\t}\n\n\t\tif(tviewer && tviewer.currentFileinfo )\n\t\t{\n\t\t\tif(tviewer.currentFileinfo.SubFolder!==\"\")\n\t\t\t\tpoint.referencedImageFilename =  tviewer.currentFileinfo.SubFolder + \"/\" +  tviewer.currentFileinfo.Filename;\n\t\t\telse\n\t\t\t\tpoint.referencedImageFilename =  tviewer.currentFileinfo.Filename;\n\n\t\t\tpoint.referencedImageFileID =  tviewer.currentFileID;\n\t\t}\n\t\t\t\n\t\tvar colors = KColorSelectorSimple('getcolors');\n\t\tif(mset.state.cyclecolors)\n\t\t\tpoint.setcolor(colors[runnigPointID % colors.length]);\n\t\telse\n\t\t\tpoint.setcolor(colors[0]);\n\t\t\n\t\t\n \t\tpoint.setsize(  mset.state.defaultradius  );\n\t\tpoint.sethover({locked: mset.state.locked, hoverdetails: mset.state.hoverdetails });\n\n\t\tif( mset.markerPanel )\n\t\t\tmset.markerPanel.update();\n \n\t\tif (KViewer.markerTool.isinstance)\n\t\t\tKViewer.markerTool.update();\n\n\t\treturn point;\n\t\t\n\t}\n\tthat.createMarker = createMarker;\n\n\n\n\t/******************************************************************************\n\treset all\t  \n\t*******************************************************************************/\n    that.reset = function()\n\t{\n\t\tthat.delAll();\n\n\t\tif (KViewer.markerTool.isinstance)\n\t\t\tKViewer.markerTool.update();\n\t\t\n\t}\n\n\t/******************************************************************************\n\tset current markerset (in markerTool and select markerPanel) \n\t*******************************************************************************/\n\tthat.setCurrentSet = function(mset, hideOtherPanels, dontupdate)\n\t{\n\t\tif (mset == -1)\n\t\t\treturn;\n\n\n\t\tif(typeof mset !== \"object\")\n\t\t{\n\t\t\tif (typeof mset == 'number')\n\t\t\t\tmset = markersets[Object.keys(markersets)[mset]];\t\t\t\t\n\t\t\telse\n\t\t\t\tmset = markersets[mset];\n\t\t}\n\t\t\n\n\t\t\n\t\t// hide all other set\n\t\tif(hideOtherPanels)\n\t\t{\n\t\t\tfor(var k in markersets)\n\t\t\t{\n\t\t\t\tcset = markersets[k];\n\t\t\t\tif (cset != mset)\n\t\t\t\t{\n\t\t\t\t\tcset.visible = false;\n\t\t\t\t\tif(cset.markerPanel)\n\t\t\t\t\t\tcset.markerPanel.$container.hide();\n\t\t\t\t\tcset.clearAllPoints();\t\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tthat.currentSet = mset;\n\t\tmset.visible = true;\n\t\tmset.drawAllPoints()\n\n\t\tif(KViewer.markerTool.isinstance && !dontupdate)\n\t\t{\n\t\t\tKViewer.markerTool.update();\n\t\t}\n \t\tif(mset.markerPanel)\n \t\t{\n \t\t\tif(mset.markerPanel.panelvisible)\n \t\t\t\tmset.markerPanel.show();\n\n\t\t\tthat.activePanel = mset.markerPanel;\n\t\t\t$(\".markerPanel\").removeClass('markerPanel_active');\n\t\t\tmset.markerPanel.$container.addClass('markerPanel_active');\n\t\t\tbringToFront(mset.markerPanel.$container);\n\t\t\tmset.markerPanel.update();\n \t\t}\n \t\tmset.broadcastStateVars();\n\n\t\tKViewer.iterateMedViewers(function(viewer)\n\t\t{\n\t\t\tif (viewer.getCurrentFiberView)\n\t\t\t{\n\t\t\t  var fv = viewer.getCurrentFiberView();\n\t\t\t  if (fv != undefined && fv.associated_annotation != -1)\n\t\t\t  {\n\t\t\t  \t fv.setAnnotationAssoc(mset.uuid);\n\t\t\t  }\n\t\t\t}\n\t\t});\n\t\t//setAnnotationAssoc \t\t\n\n\n\t}\n\n\n\tthat.showAll = function()\n\t{\n\t\tfor(var k in markersets)\n\t\t{\n\t\t\tcset = markersets[k];\n\t\t\tcset.visible = true;\n\t\t\tcset.drawAllPoints();\t\n\t\t}\n\t}\n\n\n\tthat.hideAll = function()\n\t{\n\t\tfor(var k in markersets)\n\t\t{\n\t\t\tcset = markersets[k];\n\t\t\tif (cset != markerProxy.currentSet)\n\t\t\t   cset.visible = false;\n\t\t\tcset.clearAllPoints();\t\n\t\t}\n\t}\n\n\n\t/******************************************************************************\n\truler set\t  \n\t*******************************************************************************/\n\tthat.rulerSet = new KMarkerset('rulers', 'rulers');\n\tthat.addRuler = function()\n\t{\n\t\tthat.rulerSet.addpoint(undefined,'ruler');\t\t\n\t}\n\n\n\t/******************************************************************************\n\t  signalhandler\n\t*******************************************************************************/\n\tsignalhandler.attach(\"setZoom\",function()\n\t{\n\t\t\n\t\t\tfor(var k in markersets)\n\t\t\t\tmarkersets[k].drawAllPoints();\n\t\t\n\t});\n\n\n\tsignalhandler.attach(\"canvasLayoutChanged\", function()\n\t{\n\t\tfor(var k in markersets)\n\t\t\t\tmarkersets[k].drawAllPoints();\n\t\t\n\t\t\n\t});\n\n\t/******************************************************************************\n\t  setDraggedPoint:\n\t  save the currently dragged (= resized) point as temporary object\n\t*******************************************************************************/\n\tthat.setDraggedPoint = function(point, wasMouseDown)\n\t{\n\t\tif(point == undefined)\n\t\t{\n\t\t\tthat.draggedPoint = undefined;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthat.draggedPoint = \n\t\t\t{\n\t\t\t\tobj: point,\n\t\t\t\trefprops: $.extend(true, {}, point.p)\n\t\t\t}\n\t\t\tif(wasMouseDown)\n\t\t\t\tif(point.parentmarkerset.type == 'pointROI' && point.roinii.fileObject)\n\t\t\t\t\tpoint.roinii.setThisPointInto3DView();\n\t\t\t\n\t\t}\n\t}\n\tthat.setDraggedPoint();\n\n\n\t/******************************************************************************\n\t  return\n\t*******************************************************************************/\n\n\treturn that;\n\n}\n\n\nvar markerPanelList = {};\n\n\n// ======================================================================================\n// Special Panels\n// ======================================================================================\n\nKPointRoiTool = function()\n{\n\treturn markerProxy.newSet({name: 'pointROI', type: 'pointROI', showPanel: 1, state:{delSetOnPanelClose:1, showThroughSlice:false,hoverdetails:false }});\n}\n\n\nKMarkerSet_default = function()\n{\n\treturn markerProxy.newSet({uuid: 'default', name: 'default', showPanel: 1, delSetOnPanelClose:0, state: {showresizer: false} });\n}\n\n\nKMarkerPanel_points = function()\n{\n\treturn markerProxy.newSet({uuid: 'default', name: 'point', showPanel: 1, delSetOnPanelClose:0, state: {showresizer: false} });\n}\n\n\nKMarkerPanel_lines = function()\n{\n\tvar templates = {\n\t\t\"AP_Wrist\":{\"color\":'#00AAAA', \"radius\":4},\t\n\t\t\"LR_Wrist\":{\"color\":'#AA0000', \"radius\":4},\n\t}\n\n\treturn markerProxy.newSet({name: 'test',  type: 'freeline', showPanel: 1, templates: templates, state:{hoverdetails:false, createonclick: true, delSetOnPanelClose: true, showOnAllImages:1} });  \n}\n\nKMarkerPanel_circles = function()\n{\n\n\treturn markerProxy.newSet({name: 'circles',  type: 'circles', showPanel: 1, state:{hoverdetails:false, createonclick: true, delSetOnPanelClose: true, showOnAllImages:1, showresizer: true } });  \n}\n\n\nKMarkerPanel_outline = function()\n{\n\n\tvar mset =  markerProxy.newSet({name: 'roioutlines',  type: 'freeline', showPanel: 1, showTrash:true,\n\toptionalFunction:{icon:\"fa-pencil\",\n\toperation: function (mset)\n\t\t{\n\t\t\tif (KViewer.roiTool.getCurrentGlobal())\n\t\t\t{\n\t\t\t\tvar roi = KViewer.roiTool.getCurrentGlobal();\n\t\t\t\tvar nii = roi.content\n\t\t\t\tfillPolygon(mset.getPointsAsArray(),nii);\n                signalhandler.send(\"positionChange\");//,{id:roi.fileID});\n\n\t\t\t\tmarkerProxy.delSet(mset.uuid)\n\n\n\t\t\t}\n\t\t\telse\n\t\t\t\talertify.error(\"Select some ROI imprint poylgon\");\n\t\t}\n\t},\t\n\tstate:{hoverdetails:false, createonclick: true, delSetOnPanelClose: true, fixedsize:true, showOnAllImages:0, showresizer: false,cyclecolors:false,defaultradius:1 } });  \n\tmset.markerPanel.$container.css('display','none');\n}\n\nKMarkerPanel_boxes = function()\n{\n\tvar templates = {\n\t\t\"Marker01\":{\"color\":'#AA0000', \"radius\":40},\t\n\t\t\"Marker02\":{\"color\":'#00AAFF', \"radius\":40},\t\n\t}\n//\tvar templates = {};\n\n\treturn markerProxy.newSet({name: 'boxes',  type: 'boxes', showPanel: 1, templates: templates, state:{hoverdetails:false, createonclick: true, delSetOnPanelClose: true, showOnAllImages:1} });  \n}\n\n\nKMarkerPanel_3Drulers = function()\n{\n\treturn markerProxy.newSet({name:'3Drulers', type: '3druler', showPanel: 1, state:{hoverdetails:false, createonclick: false, delSetOnPanelClose: true, showresizer: false, keepalive: true, ignoremodified: true} });\n}\n\nKMarkerPanel_scribble = function()\n{\n\treturn markerProxy.newSet({name:'scribble', type: 'scribble', showPanel: 1, state:{hoverdetails:false, defaultradius: 5, createonclick: true, delSetOnPanelClose: true, showresizer: false, showThroughSlice:false, keepalive: false, ignoremodified: false} });\n}\n\n\nKMarkerPanel_roiScribble = function()\n{\n\treturn markerProxy.newSet({name:'scribble', type: 'scribble', showPanel: 1, \n\t\toptionalFunction:{icon:\"fa-pencil\",\n\t\t\t\toperation: function (mset)\n\t\t\t\t\t{\n                        mset.map_to_ROI();\n\t\t\t\t\t}\n\t\t\t\t},\t\n\tstate:{hoverdetails:false, defaultradius: 5, createonclick: true, delSetOnPanelClose: false, showresizer: false, showThroughSlice:false, keepalive: false, ignoremodified: true} });\n}\n\nKMarkerPanel_test = function()\n{\n\treturn markerProxy.newSet({name: 'test', showPanel: 1, delSetOnPanelClose:0, state:{hoverdetails:true} });\n}\n\nKMarkerPanel_2Drulers = function()\n{\n\tvar mset = markerProxy.newSet({name:'\"2Drulers', type: 'ruler', showPanel: 1, state:{hoverdetails:false, createonclick: false, delSetOnPanelClose: true, showresizer: false, keepalive: true, ignoremodified: true} });\n}\n\nKMarkerPanel_midplane = function()\n{\n\tvar templates = {\n\t\t\"DragMe\":{\"color\":'#AA0000', \"radius\":3},\t\n\t}\n\treturn markerProxy.newSet({uuid:'_midplane_', name: 'midplane',  type: 'freeline', showPanel: 1, templates__: templates, state:{hoverdetails:false, createonclick: false, defaultradius: 3, showresizer: false, delSetOnPanelClose: true, showOnAllImages:1, ignoremodified: true} });  \n}\n\n\n// ======================================================================================\n// Helper Tool for customizing panels\n// ======================================================================================\n\n\n\n/***************************************************************************************\n*  Show a search help\n****************************************************************************************/\nfunction KMarkerPanel_configurator()\n{\n\tvar that = new dialog_generic();\n\tthat.$frame.width(680).height(800);\n\tthat.$frame.css({left:10, top:40} );\n\tthat.$frame .css('z-index', 100000); \n\tthat.$frame.show();\n\tthat.$menu.append(\"<li>Annotation Panel Configurator</li>\");\n\tthat.$frame.attr('id', 'KMarkerPanel_configurator');\n\n\tthat.deleteonclose = true;\n\n\tvar helptext =\"\"\nhelptext += `<b>\nIn readings and in autoloaders you can use customized Annotation Panels.\n<br>They can be configured with the following structure:\n</b>\n`\n\n\tvar paneldef = {\n\t\tcontent: \n\t\t{type: 'circles', name:'noname', showPanel: 1, state:{\n\t\thoverdetails:0, \n\t\tcreateonclick: 0, \n\t\tcyclecolors: 1,\n\t\tdefaultradius:20,\n\t\tshowOnAllImages:1, \n\t\tshowresizer: 1, \n\t\tdelSetOnPanelClose: 1, \n\t\tignoremodified: 0,\n\t\tkeepalive: 1, \n\t\t},\n\t\ttemplates :{\n\t\t\t\"Marker01\":{\"color\":'#AA0000', \"radius\":40},\t\n\t\t\t\"Marker02\":{\"color\":'#00AAFF', \"radius\":20},\t\n\t\t}\n\t}};\n\n\n\tvar $middlebar = $(\"<div class='' style='margin:10px;line-height:20px;'></div>\").appendTo(that.$container).html(helptext);\n\tvar $lowerbar  = $(\"<div class='' style='margin:0px 10px;height:90%;'></div>\").appendTo(that.$container);\n\t\n\tvar editor = new KJSONEditor(paneldef, \"content\",  {type:'json', log:1, parseonblur:1});\n\teditor.$container.appendTo($lowerbar).height(300).css('position', 'relative')\n\teditor.$textarea.parent().height(editor.$textarea.get(0).scrollHeight+30)\n\nvar docutxt = `Available types are \n circles \t\t\t\tsphere\n boxes \t\t\t\t\tboxes. Radius is 3-fold array in world coordinates\n 2drulers\t\t\t\trulers (2D) to display a diameter on screen\n 3drulers\t\t\t\trulers (3D) to displays lengths in all projection planes\n scribble\t\t\t\tFreeline\n pointROI\t\t\t\tMarker with connectet ROI inside based on a threshold\n\nname:\"3Drulers\",\t\nshowPanel:1\t\t\t\tshow the marker panel \n\t\t\t\t\t\t(otherwise accessible via AnnoTool)\nstate:\n{\n hoverdetails:0,  \t\tshow marker details on hover\n createonclick:0, \t\tcreate new marker when clicking on image\n cyclecolors:1,   \t\tgive every marker a different color\n showresizer:1,   \t\tshow a resizer at the marker lower right side\n defaultradius:20,\t\tdefault marker size\n showOnAllImages:1, \tshow markers on all images or drop target only\n delSetOnPanelClose:1, \tdelete all marker when panel is closed\n ignoremodified:0, \t\tdo not check for unsaved changes\n keepalive:1\t\t \t\tkeep panel open when patient is switched\n},\n\ntemplates: \t\t\t\tpredefined markers (for dragdrop usage)`\n\t\nvar $preview= $(\"<div class='modernbutton small green' style='position:absolute;top:0;right:10px'> preview <i class='fa fa-arrow-right'></i></div>\");\n$preview.appendTo(editor.$container).click(function()\n\t{\n\t\tvar mset = markerProxy.newSet(paneldef.content);\n\t})\n\n\tvar $xbar  = $(\"<div class='KJSONEditor' style=''></div>\").appendTo($lowerbar);\n\n\tvar $textarea = $(\"<textarea readonly autocorrect='off' autocapitalize='off' spellcheck='false' style='height:auto'></textarea>\").appendTo($xbar).val(docutxt)\n\t$textarea.parent().height($textarea.get(0).scrollHeight+50)\n\n\treturn that;\n\n}\n\n\n\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= markerPanel\n// ======================================================================================\n// ======================================================================================\nKMarkerPanel = function(markerset_in)\n{\n\t\n    var $body = $(document.body)\n\t// if called without an associated markerset, create one\n\tif(markerset_in != undefined)\n\t\tvar panel_id = markerset_in.uuid;\t\n\telse\n\t\tmarkerset_in = markerProxy.newSet();\n\t\n\t// if panel already exists, just show.\n\tif(markerset_in.markerPanel !== undefined)\n\t{\n\t\tvar that = markerset_in.markerPanel; \n\t\tthat.$container.show();\n\t\treturn that;\n\n\t}\n\telse\n\t{\n\t\tvar that = new Object();\n\t\tmarkerset_in.markerPanel = that;\n\n\t}\n\n\n\t// there is only one markerset per panel. \n\tvar markerset = that.markerset = markerset_in; \n\n\n\tthat.panel_id = panel_id;\n\n\n\t\n\t/******************************************************************************\n\t  customize --\x3e these values actually come from the markerset!!\n\t*******************************************************************************/\n\tvar state = that.state = \n\t{\n\t\tvisible:true, // this is the markerset visibility!\n\t\tlocked: false,\n\t\thoverdetails: false,\n\t\tcreateonclick: true,\n\t\tcyclecolors: true,\n\t\tdefaultradius: 5,\n\n\t}\n\n\n\t/******************************************************************************\n\t  show / hide / toggle\n\t*******************************************************************************/\n\tthat.show = function()\n\t{\n\t\tthat.panelvisible = true;\n\t\t$container.show();\n\t\tmarkerset.drawAllPoints();\n\t\tthat.update();\t\n\t}\n\t\n\tthat.close = function()\n\t{\n\t\t// panel is the only access to the set, so ask to save before deletion\n\t\tif(markerset.state.delSetOnPanelClose) \n\t\t{\n\t\t\tif( markerset.modified )\n\t\t\t\talertify.confirm('This markerset was modfied, but not saved.<br> Are you sure to close it without saving? ', function(a){if(a) markerProxy.delSet(markerset.uuid) })\n\t\t\telse\n\t\t\t{\n\t\t\t\tmarkerProxy.delSet(markerset.uuid);\n\t\t\t}\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthat.hide();\n\t\t}\n\t}\n\n\n\tthat.hide = function()\n\t{\n\t\tthat.panelvisible = false;\n\t\t$container.hide();\n\t\tif ( KViewer.markerTool.enabled == false)\n\t\t{\n\t\t\tmarkerset.clearAllPoints();\n\t\t}\n\t}\n\n\n\n\tthat.deletePanel = function()\n\t{\n\t\tthat.hide();\n\t\t$container.remove();\n\t\t// free view from point ROIs\n\t\tif(that.freeView)\n\t\t\tthat.freeView.kill();\n\n\t\tmarkerset.markerPanel = undefined;\n\t}\n\n\n\tthat.toggle = function(force)\n\t{\n\t\tthat.panelvisible = typeof(force)!==\"boolean\"?(that.panelvisible?false:true):force;\n\t\tif(that.panelvisible) \n\t\t\tthat.show();\n\t\telse \n\t\t\tthat.hide();\n\t}\t\n\n\n\tthat.currentSetVisible = function ()\n\t{\n\t\talert('TBD currentSetVisible');\n// \t\tif (markerProxy.markersets[that.currentSet] != undefined)\t\t\n// \t\t\treturn markerProxy.markersets[that.currentSet].visible;\n// \t\telse\n// \t\t\treturn false;\n\t}\n\n\n\t/******************************************************************************\n\t  the panel itself\n\t*******************************************************************************/\n\tthat.panelvisible = true;\n\n\tvar $target= $(document.body);\n\t//$(\"div[id='markerPanel*']\").remove();\n\tvar $container = $(\"<div id='markerPanel\"+panel_id+\"' class='markerPanel movableWindows panel_floatable__ panel__' ></div>\");\n\t$container.click(function(ev)\n\t{ \n\t\tif (ev.originalEvent && $(ev.originalEvent.target).attr(\"contentEditable\"))\n\t\t\treturn;\n\t\tif (markerProxy.currentSet != markerset)\n\t\t\tmarkerProxy.setCurrentSet(markerset)\n\t});\n\n\tthat.$container = $container.appendTo($target);\n\n\tvar pp = getPixelPosition($body);\n\tvar np = $(\".markerPanel\").length;\n\t$container.css(\"right\", np*20)\n\t$container.css(\"top\", np*20+70  );\n\n\n\t/******************************************************************************\n\t  tools\n\t*******************************************************************************/\n\tvar $topRow    = that.$topRow = $(\"<div class='roiTool_panel_flex persistent ' ></div>\").appendTo($container);\n\t$mover = $(\"<i class='KViewPort_tool fa fa-hand-paper-o '></i>\");\n\tvar $caption = $(\"<span>markerset: </span>\");\n\tvar $markersetname = $(\"<span>\"+ markerset.name + \"</span>\").appendTo($caption);\n\tvar $close = that.$close = $(\"<i class='KViewPort_tool fa fa-close'></i>\").click( that.close );\n\t$topRow.append($mover).append($caption).append($(\"<i class='flexspacer'></i>\")).append($close);\n\t\n\n\t$topRow.mousedown( function(ev) {\n\t\t movableWindowMousedownFn(ev, that.$container)\n\t\t } );\n\n\n\tvar $fileRow   = $(\"<div class='roiTool_panel_flex persistent'></div>\").appendTo($container);\n    var $newMarker=   $(\"<a class='KViewPort_tool' draggable=true><i class='fa fa-plus' ></i><span> New Marker </span></a>\").appendTooltip(\"createnNewMarker\").click( \n    \tfunction()\n    \t{\n\t\t\tif(that.state.showOnAllImages == 0) \n\t\t\t{\n\t\t\t\talertify.alert(\"'showOnAllImages' is disabled. Enable, or drag this button into a viewer to create marker.\");\n\t\t\t}\n\t\t\telse\n\t\t\t\tmarkerProxy.createMarker(undefined, markerset); \n    \t});\n    \t\n\t\t// allow to create marker on drag / drop\n\t\t$newMarker[0].ondragstart = dragstarter( function(x,name)\n \t\t\t\t{ \n \t\t\t\t\treturn function()\n \t\t\t\t\t{\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: 'markertemplate',\n\t\t\t\t\t\t\tcallback: dropCallback,\n\t\t\t\t\t\t\tobj:x,\n\t\t\t\t\t\t\tnamexx:name\n\t\t\t\t\t\t}\n \t\t\t\t\t}\n        \t\t}({}), 0)\n        \n\t\n\tif(that.type == 'scribble' )\n\t{\n\t\t$fileRow.append($(\"<span style='font-size:12px' > &nbsp Use mouse to draw  &nbsp</span>\"));\n\t\t$newMarker.hide();\n\t}\n\n    var $saveMarkers = that.$saveMarkers = $(\"<a class='KViewPort_tool'><i class='fa fa-save'></i><span> Save </span></a>\").appendTooltip(\"savemarkerset\")\n    \t\t.click( function(){\n\t\t\t\t\tif (markerset.name == \"untitled\")\n\t\t\t\t\t     \n\t\t\t\t\t\t alertify.prompt(\"Name of marker set:\", function(e,str) { if (e) {  \n\t\t\t\t\t\t \t\tmarkerset.name=str;  \n\t\t\t\t\t\t \t\tKViewer.markerTool.lastMarkerSetName = str;\n\t\t\t\t\t\t \t\tthat.update(); \n\t\t\t\t\t\t \t\tif (KViewer.markerTool.isinstance)\n\t\t\t\t\t\t \t\t\tKViewer.markerTool.update()\n\t\t\t\t\t\t\t\tmarkerProxy.save(undefined, markerset)\n\t\t\t\t\t\t } },KViewer.markerTool.lastMarkerSetName);\n\t\t\t\t\telse\n\t\t\t\t\t\tmarkerProxy.save(undefined,markerset)\n    \t\t \t }\n\n    \t\t );\n    $fileRow.append($newMarker).append($saveMarkers).append($(\"<i class='flexspacer'></i>\"));\n\tthat.$fileRow = $fileRow;\n\n\n\t/******************************************************************************\n\t  switch the icons\n\t*******************************************************************************/\n\tfunction switch_enabled(prop, force, invert)\n\t{\n\t\t// we do not want to start the KMarkerTool if not present, so check for isInstance\n\t\tmarkerset.state[prop] = typeof(force)!==\"boolean\"?(markerset.state[prop]?false:true):force;\n\t\tvar togglefcn = markerset.state[prop]?\"addClass\":\"removeClass\";\t\n\t\n\t\tif(that.markerPanel)\n\t\t\tbtns[\"$\"+prop][togglefcn]('KViewPort_tool_enabled');\n\t\tif (KViewer.markerTool.isinstance && KViewer.markerTool[\"$\"+prop])\n\t\t\tKViewer.markerTool[\"$\"+prop][togglefcn]('KViewPort_tool_enabled');\n\n\t\treturn markerset.state[prop];\n\t}\n\t\n\n\t/******************************************************************************\n\t  toolbar\n\t*******************************************************************************/\n\tvar btns = that.btns =  {};\n\n\t$(\"<div class='roiTool_panel_caption'></div>\").appendTo($container);\n\tvar $toolsRow    = $(\"<div class='roiTool_panel_flex'></div>\").appendTo($container);\n\t\tbtns.$locked = $(\"<i class='KViewPort_tool fa fa-lock'></i>\").appendTooltip('lockmarkers').click( function(){ markerset.toggleStateVar('locked')} ).appendTo($toolsRow);\n\t\tbtns.$createonclick = $(\"<i class='KViewPort_tool fa fa-pencil'></i>\").appendTooltip('markercreateonclick').click( function(){ markerset.toggleStateVar('createonclick')} ).appendTo($toolsRow);\n\t\t\n\n\t    btns.$cyclecolors = $(\"<i class='KViewPort_tool KViewPort_tool_enabled fa fa-recycle'></i>\").appendTooltip('cyclecolors').click( function(){ markerset.toggleStateVar('cyclecolors') } ).appendTo($toolsRow);\n\t    btns.$hoverdetails = $(\"<i class='KViewPort_tool KViewPort_tool_enabled fa fa-info'></i>\").click( function(){ markerset.toggleStateVar('hoverdetails')} ).appendTooltip('markerdetailsonhover').appendTo($toolsRow);\n\t    btns.$showOnAllImages = $(\"<i class='KViewPort_tool KViewPort_tool_enabled fa fa-adn'></i>\").click( function(){ markerset.toggleStateVar('showOnAllImages')} ).appendTooltip('markershowOnAllImages').appendTo($toolsRow);\n\t\tbtns.$showThroughSlice = $(\"<i class='KViewPort_tool KViewPort_tool_enabled fa fa-lightbulb-o'></i>\").click( function(){ markerProxy.currentSet.toggleStateVar('showThroughSlice'); markerProxy.currentSet.drawAllPoints();} ).appendTooltip('showThroughSlice').appendTo($toolsRow);\n\t    btns.$visible = $(\"<i class='KViewPort_tool KViewPort_tool_enabled fa fa-eye'></i>\").click( function(){ markerset.togglePointsVisibility();   }).appendTooltip('showhideallmarkers').appendTo($toolsRow);\n\n   \t$toolsRow.append($(\"<i class='flexspacer'></i>\"));\n\t\tbtns.$defaultradius =  $(\" <input type = 'text' min='0' max='100' value='\"+markerset.state.defaultradius+\"' /> \").on('change', changedefaultsize).appendTo($toolsRow);\n\t\tfunction changedefaultsize(ev) {  markerset.toggleStateVar('defaultradius',  parseFloat( btns.$defaultradius.val()) )    }\n\t\t\n\t\tKMouseSlider( btns.$defaultradius, {min:0, incrementPerPixel: .2 });\n\tthat.$toolsRow = $toolsRow;\n\t\n\n\t/******************************************************************************\n\tpointROI \n\t*******************************************************************************/\n\n\tthat.pointROITool = {};\n\t\t\t\t\t\t\t\n\tvar $pointROIRow   = $(\"<div class='roiTool_panel_flex'></div>\").appendTo($container).hide();\n\tvar $caption   = $(\"<span class='label'>Threshold: </span>\").appendTo($pointROIRow);\n\t\n\tthat.pointROITool.$thresh =  $(\"<input type = 'text' min='0' step=1 value='\"+markerset.state.pointROIthresh+\"' /> \").on('change', function (ev) { \n\t\t\t// do NOT update all points every time, thresh is now pointwise\n\t\t\t//updatePointROIthresh();\n\t\t\tmarkerset.toggleStateVar('pointROIthresh',  parseFloat( that.pointROITool.$thresh.val() ) ); \n\t\t}).appendTo($pointROIRow);\n\tKMouseSlider( that.pointROITool.$thresh, {min:-Infinity, incrementPerPixel: 2,  updateonmove: 0, updateonrelease: 1});\n\n\t/******   upper / lower      ***/\n\tthat.pointROITool.threspen = 1;\n\tthat.pointROITool.$thresBtn = $(\"<i class='RoiPen KViewPort_tool fa fa-arrow-circle-up'></i>\").appendTo($pointROIRow).click(\n\t\tfunction(ev)\n\t\t{\n\t\t\tif (that.pointROITool.threspen == 1) \n\t\t\t{\n\t\t\t\tthat.pointROITool.threspen = 2;\n\t\t\t\tthat.pointROITool.$thresBtn.removeClass('fa-arrow-circle-up').addClass('fa-arrow-circle-down');\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tthat.pointROITool.threspen = 1;\n\t\t\t\tthat.pointROITool.$thresBtn.removeClass('fa-arrow-circle-down').addClass('fa-arrow-circle-up');\n\t\t\t}\n\t\t\tupdatePointROIthresh();\n\t\t});\n\n\n\t/******   only from center of circle      ***/\n\tthat.pointROITool.$regionGrowRestrict = $(\"<i class='RoiPen KViewPort_tool KViewPort_tool_enabled fa fa-fw fa-map-marker'></i>\").click( function(ev){selectPen('regionGrowRestrict', 'toggle')} ).appendTooltip(\"regionfillwithinpen\").appendTo($pointROIRow);\n\tthat.pointROITool.pen = 'regionGrowRestrict';\n\n\tfunction selectPen( pen, toggle )\n    {\n\t\tif( pen == undefined)\n\t\t\tpen = 'default';\n\t\n        if( (toggle !=undefined & pen == that.pointROITool.pen)  )\n\t\t\tpen = 'default'\n        \n        that.pointROITool.pen = pen;\n\n        // first, toggle everything always to false\n        $pointROIRow.find('.RoiPen').removeClass('KViewPort_tool_enabled');\n        if( pen == 'regionGrowRestrict' )\n        {\n        \tthat.pointROITool.$regionGrowRestrict.addClass('KViewPort_tool_enabled');\n        }\n\t\tupdatePointROIthresh();\n    }\n\n\t$pointROIRow.append($(\"<i class='flexspacer'></i>\"));\n\tvar $pointROI = $(\"<i class='fa KViewPort_tool'>3D</i>\").appendTooltip('showpointroias3D').appendTo($pointROIRow).click( function(){\n\t\tif(that.freeView){ \n\t\t\tthat.freeView.panel.$container.show();}\n\t\t});\n\t\t \n\n\t/******************************************************************************\n\tdirect synchronisation of pointroi with threshold\n\t*******************************************************************************/\n\tfunction updatePointROIthresh()\n\t{\n\t\tfor(var k in  markerset.markerpoints )\n\t\t{\n\t\t\tmarkerset.markerpoints[k].onupdate.pointROI();\n\t\t}\n\n\t}\n\n\n\t/******************************************************************************\n\tscribble things\n\t*******************************************************************************/\n\tthat.scribbleTool = {};\n\t\t\t\t\t\t\t\n\tvar $scribbleRow = that.$scribbleRow  = $(\"<div class='roiTool_panel_flex'></div>\").appendTo($container).hide();\n\tvar $caption   = $(\"<span class='label'>sLength: </span>\").appendTo($scribbleRow);\n\tthat.scribbleTool.lengthPerSegment = 5;\n\tthat.scribbleTool.$lps =  $(\"<input type = 'text' min='1' step=1 value='\"+ (that.scribbleTool.lengthPerSegment) +\"' /> \").on('change', function (ev) \n\t\t{ \n\t\t\tthat.scribbleTool.lengthPerSegment = parseFloat( that.scribbleTool.$lps.val()  ) \n\t\t}).appendTo($scribbleRow);\n\tKMouseSlider( that.scribbleTool.$lps, {min:0, incrementPerPixel: .1,  updateonmove: 0, updateonrelease: 1, logScaling:10});\n\n\t$scribbleRow.append($(\"<i class='flexspacer'></i>\"));\n\n\tif(that.markerset.type == 'scribble')\n\t{\n\t\tthat.scribbleTool.sPenRadius = 50;\n\t\t\n\t\tvar $dummy = $(\"<i class='KViewPort_tool fa fa-fw fa-trash'></i>\").click( markerset.deleteAllPoints ).appendTooltip(\"delete all points\").appendTo($scribbleRow);\n\t\tvar $dummy = $(\"<i class='KViewPort_tool fa fa-fw fa-clone'></i>\").click( markerset.interplate_scribbles ).appendTooltip(\"interpolate\").appendTo($scribbleRow);\n\t\tvar $dummy = $(\"<i class='KViewPort_tool fa fa-fw fa-pencil'></i>\").click( markerset.map_to_ROI ).appendTooltip(\"mapToActiveROI\").appendTo($scribbleRow);\n\n\t\t$scribbleRow.show()\n\n\t\n\t\t/******************************************************************\n\t\tmodify a scribble using a circle\n\t\t******************************************************************/\n\t\tvar spen_enabled = false;\n\t\tfunction toggleModifyScribble( force)\n\t\t{\n\t\t\t/****************************************************/\n\t\t\tfunction mousedown(ev)\n\t\t\t{\n\t\t\t\tisMouseDown = 1;\n\t\t\t\t$mmt.on('mouseleave mouseup', function(){isMouseDown= 0;  $mmt.off('mouseleave mouseup')});\n\t\t\t\tmousemove(ev); ev.stopPropagation();  return false;\n\t\t\t}\n\t\t\tvar mousemove = moveUnlagger(function mousemove(ev)\n\t\t\t{\n\t\t\t\t/*var radius = parseFloat(that.scribbleTool.lengthPerSegment)*3;\n\t\t\t\tvar max_extent_perc = medViewer.computeMaxExtentFac() / 300\n\t\t\t\tvar fac = medViewer.embedrelfac * medViewer.zoomFac;\n\t\t\t\tvar r = (2 * (radius)) * fac * max_extent_perc;\n\t\t\t\t*/\n\t\t\t\tvar r = (that.scribbleTool.sPenRadius); // use pixels for now\n\t\t\t\tvar left = window.pageXOffset+ev.clientX - r / 2 - 1;\n\t\t\t\tvar top  = window.pageYOffset+ev.clientY - r / 2 - 1;\n\n\t\t\t\t//$spen.offset({left: left,top: top}).css({left: left,top: top,width: r,height: r});\n\t\t\t\t$spen.css({left: left,top: top,width: r,height: r});\n\n\t\t\t\tif(isMouseDown)\n\t\t\t\t\tKMarkerScribble_modify_with_pen(ev, medViewer, r/2)\n\n\t\t\t\treturn true;\n\t\t\t});\n\t\t\tthat.scribbleTool.updateSpenRadius = function(e)\n\t\t\t{\n\t\t\t\tvar amount = (e.wheelDelta || -e.detail);\n\t\t\t\tvar sstep = 10;\n\t\t\t\tthat.scribbleTool.sPenRadius += (amount>0?sstep:-sstep);\n\t\t\t\tmousemove(e);\n\t\t\t\te.stopPropagation();  e.preventDefault(); return false;\n\t\t\t}\n\n\n\t\t\t$('#scribble_pencil').remove();\n\t\t\t//btns.$createonclick.trigger('click');\n\t\t\tspen_enabled = (force==undefined)?!spen_enabled:force;\n\t\t\tvar $spen;\n\t\t\tvar medViewer = KViewer.viewports[0].getCurrentViewer();\n\t\t\tvar $mmt  = medViewer.$canvas;\n\t\t\t// first switch everything off\n\t\t\t$mmt.off('mousedown mousemove mouseup mouseleave');\n\n\t\t\tif(spen_enabled)\n\t\t\t{\n\t\t\t\tvar $spen = $(\"<div class='scribble_pencil roiTool_pencil'></div>\").append($(\"<div class='roiTool_pencil_haircross left'></div>\")).append($(\"<div class='roiTool_pencil_busy'><i class='fa fa-spinner fa-spin'></i></div>\")).append($(\"<div class='roiTool_pencil_haircross right'></div>\")).appendTo(document.body);\n\t\t\t\tvar r = (that.scribbleTool.sPenRadius);\n\t\t\t\t$spen.css({left: \"500px\",top:\"500px\", width: r,height: r});\n\t\t\t\t$mmt.on('mousedown', mousedown);\n\t\t\t\t$mmt.on('mousemove', mousemove);\n\t\t\t\tvar isMouseDown = 0;\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$('.scribble_pencil').remove();\n\t\t\t}\n\n\t\t}\n\t\tthat.toggleModifyScribble = toggleModifyScribble;\n\n\t\tKMarkerScribble_modify_with_pen = function(ev, medViewer, r)\n\t\t{\n\t\t\t/* modify a scribble with circle tools \n\t\t\t\t\toriginally, could modify it, now lets only delete points inside circle\n\t\t\t \n\t\t\t*/\n\t\t\tvar medViewer = KViewer.viewports[0].getCurrentViewer();\n\t\t\tif(!medViewer)\n\t\t\t\treturn;\n\t\t\t//var mset = markerProxy.currentSet;\n\t\t\tvar points = markerset.getPoints();\n\n\n\t\t\tfor(var k=0; k<points.length; k++)\n\t\t\t{\n\t\t\t\tvar point = points[k];\n\t\t\t\tvar to_rem = [];\n\t\t\t\tvar voxoords = kmath.multiply(medViewer.nii.invedges, point.coords);\n\t\t\t\tif( kmath.abs(voxoords[medViewer.getSlicingDimOfArray] - medViewer.getCurrentSlice()) > .1)\n\t\t\t\t\tcontinue\n\t\t\t\t\t\n\t\t\t\tfor(var s=0; s<point.subpoints.length; s++) // exclude last point? no.\n\t\t\t\t{\n\t\t\t\t\tvar coords = point.subpoints[s];\n\t\t\t\t\tvar pixc = medViewer.getCanvasCoordinates(coords);\n\t\t\t\t\t//console.log(pixc)\n\t\t\t\t\tvar px = pixc.x_pix;\n\t\t\t\t\tvar py = pixc.y_pix;\n\n\t\t\t\t\tvar cx = ev.clientX-medViewer.$canvas.offset().left;\n\t\t\t\t\tvar cy = ev.clientY-medViewer.$canvas.offset().top;\n\t\t\t\t\t// project all points to pencil center\n\t\t\t\t\tvar dx = -(cx - px);\n\t\t\t\t\tvar dy = -(cy - py);\n\t\t\t\t\tvar dist = Math.sqrt(dx*dx +dy*dy);\n\t\t\t\t\t//r = dist*.8;\n\t\t\t\t\tif(dist < r)\n\t\t\t\t\t{\n\t\t\t\t\t\tto_rem.push(s)\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// run over all points, remove close ones or add a new one \n\t\t\t\tvar newpoints = [];\n\t\t\t\tfor(var x=0; x < point.subpoints.length; x++)\n\t\t\t\t{\n\t\t\t\t\tvar pp = point.subpoints[x]\n\t\t\t\t\tif(to_rem.indexOf(x) == -1)\n\t\t\t\t\t\tnewpoints.push(pp)\n\t\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tpoint.subpoints = newpoints;\n\t\t\t\tif(newpoints.length > 0)\n\t\t\t\t\tpoint.coords = point.subpoints[0];\n\t\t\t\telse\n\t\t\t\t\tpoint.deletepoint();\n\t\t\t}\n\t\t\tmarkerset.drawAllPoints();\n\n\t\t}\n\n\t}// end scribble specialities\n\n\n\n\n\t/******************************************************************************\n\tpre-defined items\n\t*******************************************************************************/\n\tvar $templatesDIV   =  $(\"<div class='roiTool_panel_flex'></div>\").appendTo($container);\n\tvar $templatesList  =  $(\"<div class='markerTemplates'></div>\").appendTo($templatesDIV);\n\t\n\tvar $templatesButton \t\t=  $(\"<div class='roiTool_panel_flex' style='align-items:center;'></div>\").appendTo($container).hide();\n\t//var $autocreate =  $(\"<div class='modernbutton small black' style='width:100%;'>autocreate all</div>\").appendTo($templatesButton).click(function(){that.autocreate_templates()});\n\t$templatesDIV.hide();\n\n\tthat.templates = {};\n\n\tthat.setTemplates = function(items)\n\t{\n\t\tthat.templates = items;\n\t\tfor(var k in items)\n\t\t{\n\t\t\tvar $temp = $(\"<div class='markerTemplates_item' draggable=true>\"+ k +\"</div>\").appendTo($templatesList);\n \t\t\tif(items[k].color != undefined)\n \t\t\t\t$temp.css('background', items[k].color );\n\n\t\t\titems[k].name = k;\t\n\n \t\t\t$temp[0].ondragstart = dragstarter( function(x,name)\n \t\t\t\t{ \n \t\t\t\t\treturn function()\n \t\t\t\t\t{\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: 'markertemplate',\n\t\t\t\t\t\t\tcallback: dropCallback,\n\t\t\t\t\t\t\tobj:x,\n\t\t\t\t\t\t\tnamexx:name\n\t\t\t\t\t\t}\n \t\t\t\t\t}\n        \t\t}(items[k]), k)\n        \t\n\t\t}\n\t\tif(that.templates && Object.getOwnPropertyNames(items).length > 0 )\n\t\t{\n\t\t\t$templatesDIV.show()\n\t\t\t$templatesButton.show();\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$templatesDIV.hide();\n\t\t\t$templatesButton.hide();\n\t\t}\n\t}\n\n\tfunction dropCallback(ev, params,viewport)\n\t{\n\t\tvar v = viewport.getCurrentViewer();\n\t\tif(v && v.viewerType == 'medViewer')\n\t\t{\n\t\t\tif (v.isGLenabled())\n\t\t\t\tev.coords = v.gl.getRealWorldCoordinateFromEvent(ev)._data;\n\t\t\telse\n\t\t\t\tev.coords = v.getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY)._data;\n\t\t\t\n\t\t\tvar point = markerProxy.createMarker(ev, that.markerset, v);\n\t\t\tif(point == undefined)\n\t\t\t\treturn false\n\t\t\t\t\n\t\t\tthat.template_setpros(params.obj, point)\n\t\t\t\n\t\t\tif(point.type=='pointROI')\n\t\t\t\twindow.setTimeout(function(){ point.roinii.setThisPointInto3DView(); }, 0);\n\n\t\t}\n\t}\n\n\tthat.template_setpros = function(obj, point)\n\t{\n\t\t\tif(obj.name != undefined)\n\t\t\t\tpoint.p.name = obj.name;\n\t\t\tif(obj.color != undefined)\n\t\t\t{\n\t\t\t\tpoint.p.color = ( new KColor(obj.color) );\n  \t    \t \tpoint.setcolor(point.p.color);\n\t\t\t}\n\t\t\tpoint.runcallbacks('changeProps');\n\n\t\t\tif(obj.radius != undefined)\n\t\t\t\tpoint.setsize( obj.radius );\n\t}\n\n\t/******************************************************************************\n\tauto-create template markers\n\t*******************************************************************************/\n\tthat.autocreate_templates = function(ev)\n\t{\n\t\tfor(var k in that.templates)\n\t\t{\n\t\t\tvar obj = that.templates[k];\n\t\t\tvar medViewer;\n\t\t\tif(obj.viewport != undefined)\n\t\t\t{\n\t\t\t\tvar v = KViewer.viewports[obj.viewport].getCurrentViewer()\n\t\t\t\tif(v && v.viewerType == 'medViewer')\n\t\t\t\t\tmedViewer = v;\n\t\t\t}\n\n\t\t\tvar point = markerProxy.createMarker(ev, that.markerset, medViewer);\n\t\t\tthat.template_setpros(obj, point)\n\n\t\t}\n\t}\n\n\t/******************************************************************************\n\texample of templates\n\t*******************************************************************************/\n\tvar templates = {\n\t\tAP_Wrist:{color:'#00FFFF', radius:40, viewport: 0},\t\n\t\tLR_Wrist:{color:'#00FFFF', radius:40, viewport: 1},\n\t\tAP_Frac: {color:'#FF0000', radius:20, viewport: 0},\n\t\tLR_Frac: {color:'#FF0000', radius:20, viewport: 1},\n\t}\n\t\n\t//that.setTemplates(templates);\n\tthat.setTemplates(that.markerset.templates);\n\n\n\n\t/******************************************************************************\n\tthe marker List\n\t*******************************************************************************/\n\t//$(\"<div class='roiTool_panel_caption'>Marker List</div>\").appendTo($container);\n\tvar $markerListDIV    =  $(\"<div class='roiTool_panel_flex'></div>\").appendTo($container);\n\tvar $markerListTable  =  $(\"<table class='markerTable'></table>\").appendTo($markerListDIV);\n\tthat.$markerListTable = $markerListTable;\n\n\t/******************************************************************************\n\tcallbacks\n\t*******************************************************************************/\n\tthat.callbacks = \n\t{\n\t\tcreate: {},\n\t\tdelete: {},\n\t\ttoggle: {},\n\t\tchangeProps: {},\n\t\tmove: {},\n\t\tcreateinfobox: {},\n\n\t};\n\t\n\n\t/******************************************************************************\n\tupdate the list  \n\t*******************************************************************************/\n\tthat.update = function()\n\t{\n\t\t$markerListTable.children().remove();\n\n\t\tif (markerset != undefined)\n\t\t{\n\t\t\tvar thingstoshow = {colorsel:1, id:1, name:1, toggle:1, search:1, delete:1,  coords:0};\n\t\t\tvar pts = markerset.getPoints();\n\t\t\tfor (var k=0; k< pts.length;k++)\n\t\t\t{\n\t\t\t\tvar point = pts[k];\n\t\t\t\tif(point.type == 'pointROI')\n\t\t\t\t\tthingstoshow.pointROI = 1;\n\t\t\t\telse \t\n\t\t\t\t\tthingstoshow.pointROI = 0;\n\n\t\t\t\tvar $row = point.createMarkerRepresentation('panel', thingstoshow);\n\t\t\t\t$row.attr('marker_uuid', point.uuid)\n\t\t\t\t$markerListTable.append($row);\n\t\t\t\tif(point.hideMarkerRepresentation)\n\t\t\t\t{\n\t\t\t\t\t$row.hide();\n\t\t\t\t}\n\n\t\t\t}\n\t\t\t$container.width($markerListTable.width());\n\t\t\tthat.updateName();\n\t\t}\n\t}\n\n\tthat.updateName = function()\n\t{\n\t\t$container.width($markerListTable.width());\n\t\t$markersetname.html(\"<b>\"+markerset.name+\"</b>\");\n\t\n\t}\n\tthat.updateName();\n\n\n\n\n\t/******************************************************************************\n\t getState \n\t*******************************************************************************/\n\tthat.getState = function()\n\t{\n\t\treturn state;\n\t}\n\n\t/******************************************************************************\n\t  setState\n\t*******************************************************************************/\n\tfunction setState(state_new)\n\t{\t\t\n\t\t\n\t\tif(markerset.type == 'pointROI')\n\t\t\t$pointROIRow.show()\n\t\telse\n\t\t\t$pointROIRow.hide();\n\n\t\t// there might follow other general state variables (for the panel itself ) again\n\t}\n\tthat.setState = setState;\n\n \n\t/******************************************************************************\n\t set markerset after everything is here again\n\t*******************************************************************************/\n\tthat.setCurrentSet = function(mset)\n\t{\n\t\tmarkerset = that.markerset = mset;\n\t\tsetState( mset.state )\n\t}\n\t\n\tthat.setCurrentSet(markerset_in)\n\n\n\treturn that;\n\n}\n\n\n\n\n\n\n\n\nvar electrodes = \n{\n   Medtronic3387: {\n\t\tcontacts:[ 2.25, 5.25, 8.25, 11.25],\n\t\tapprox_maedler: [ 0.2991,-1.2654 , 0.000341, 0.2784, 0.001217, -6.49E-07]\t   \n   },\n   Medtronic3389: {\n\t\tcontacts:[ 2.25, 4.25, 6.25, 8.25],\n\t\tapprox_maedler: [ 0.2991,-1.2654 , 0.000341, 0.2784, 0.001217, -6.49E-07]\t   \n   },\n   BostonOctopolar: {\n\t\tcontacts:[ 2.25, 4.25, 6.25, 8.25, 10.25, 12.25, 14.25, 16.25],\n\t\tapprox_maedler: [ 0.2991,-1.2654 , 0.000341, 0.2784, 0.001217, -6.49E-07]\t   \n   },\n   Atech: {\n\t\t\tcontacts:[ 2.25, 5.25, 8.25, 11.25],\n\t\tapprox_maedler: [ 0.2991,-1.2654 , 0.000341, 0.2784, 0.001217, -6.49E-07]\t   \n   },\n\n   Dixi: {\n\t\t\tcontacts:[ 2.25, 5.25, 8.25, 11.25],\n\t\tapprox_maedler: [ 0.2991,-1.2654 , 0.000341, 0.2784, 0.001217, -6.49E-07]\t   \n   }\n\n}\n\n\n// ======================================================================================\n// ============= a marker set\n// ======================================================================================\nfunction KMarkerset( args  )\n{\n\t// args:\n\t// \tuuid\n\t//  name\n\t//  type\n\t//  showPanel\n\t//  delSetOnPanelClose\n\n    var that = new Object();\n\n\tthat.uuid = args.uuid || \"M\" + (KMarkerset.runningSetID++);;\n\tthat.name = args.name || \"noname\";\n\tthat.type = args.type || \"pointset\";\n\tthat.showTrash = args.showTrash;\n\tthat.optionalFunction = args.optionalFunction;\n\t\n\tthat.templates = args.templates || undefined;\n\t\n\t// went to state \n\t//that.delSetOnPanelClose = false;\n// \tif(args.delSetOnPanelClose != undefined)\n// \t\tthat.delSetOnPanelClose = args.delSetOnPanelClose;\n\n\t// showPanel: show/create on markerset creation\n\tvar showPanel = args.showPanel || false;\n\n\n\n\n\tthat.description = '';\n\tthat.visible = true;\n\n\n\tthat.showPanel = function()\n\t{\n\t\tKMarkerPanel(that);\n\t\tthat.markerPanel.show();\n\t\tthat.broadcastStateVars();\n\t\treturn that.markerPanel;\n\t}\n\tthat.deletePanel = function()\n\t{\n\t\tif(that.markerPanel)\n\t\t\tthat.markerPanel.deletePanel();\n\t}\n\n    var defaultradius = parseFloat(ViewerSettings.defaultsizemarker);\n    if (defaultradius == undefined)\n        defaultradius = 5;\n\n\t/******************************************************************************\n\tdefault settings for this markerset\n\t*******************************************************************************/\n\tvar state = that.state = \n\t{\n\t\tvisible: true,\n\t\tlocked: false,\n\t\thoverdetails : false,\n\t\tcreateonclick : false,\n\t\tcyclecolors   : true,\n\t\tdefaultradius : defaultradius,\n\t\tdelSetOnPanelClose: false,\n\t\tpointROIthresh: 300,\n\t\tshowThroughSlice:true,\n\t\tshowOnAllImages:true,\n\n\t}\n\n\t/******************************************************************************\n\tcustom callbacks for point creation and deletion\n\t*******************************************************************************/\n\tthat.callbacks =\n\t{\n\t\taddpoint:{},\n\t\tdeletepoint:{},\n\t}\n\n\n\t/******************************************************************************\n\tsetType\n\t*******************************************************************************/\n\tthat.setType = function(type)\n\t{\n\t\tthat.type = type || that.type;\n\n\t\tfor (var x in that.onupdate)\n\t\t\tthat.onupdate[x]();\n\n\t\t//that.cleanFiberAssoc();\n\t\tif (that.type == 'electrode')\n\t\t  markerProxy.updateElectrode(that,that.elecmodel);\n\t\tthat.pointChanged();\n\n\t\tif(that.type == 'pointROI')\n\t\t\t$.extend(true,  state, {hoverdetails: false})\n\t\telse if (that.type == 'electrode')\n\t\t\t$.extend(true,  state, {hoverdetails:false,cyclecolors:false,createonclick:false})\n\t\telse if (that.type == 'freeline')\n\t\t\t$.extend(true,  state, {hoverdetails:false,cyclecolors:false,defaultradius:2,createonclick:true})\n\t\telse if (that.type == 'surface')\n\t\t\t$.extend(true,  state, {hoverdetails:false,cyclecolors:false,defaultradius:2,createonclick:true})\n\t\telse\n\t\t\t$.extend(true,  state, {locked:false,cyclecolors:true,defaultradius:5,createonclick:false,hoverdetails:true})\n\n\t\tif (that.updateLine_sid != undefined)\n\t\t\tsignalhandler.detach('positionChange',that.updateLine_sid)\n\t    if (that.type == 'electrode' | that.type == 'freeline' | that.type == 'surface')\n\t\t\tthat.updateLine_sid = signalhandler.attach(\"positionChange\",that.updateLine)\n\n\t\tthat.broadcastStateVars();\n\n\t}\n\n\t\n\t/******************************************************************************\n\tset a variable in panel and markerTool\n\t*******************************************************************************/\n\tthat.toggleStateVar = function( x, force, donotsethover )\n\t{\n\t\tstate[x] =  force==undefined ? (state[x]?false:true):force;\n\t\tvar togglefcn = state[x]?\"addClass\":\"removeClass\";\n\t\tvar btns = [];\n\t\tif (KViewer.markerTool && KViewer.markerTool.isinstance) \n\t\t\tbtns.push(KViewer.markerTool.btns);\n\t\tif (that.markerPanel) \n\t\t\tbtns.push(that.markerPanel.btns);\n\n\t\tfor(var k=0;k<btns.length; k++)\n\t\t{\n\t\t\tvar btn = btns[k];\n\t\t\tif(btn[\"$\"+x])\n\t\t\t{\n\t\t\t\tif(btn[\"$\"+x].is('input') )\n\t\t\t\t\tbtn[\"$\"+x].val( state[x] );\n\t\t\t\telse\t\n\t\t\t\t\tbtn[\"$\"+x][togglefcn]('KViewPort_tool_enabled');\n\t\t\t}\n\t\t}\n\t\t\n\t\tif(donotsethover == undefined && (x=='locked' || x=='hoverdetails'))\n\t\t\tthat.sethover({locked:state.locked, hoverdetails: state.hoverdetails });\n\t\t\n\t\tif(x=='locked' && state.locked)\n\t\t\t$('.markerpoint_trash').hide();\n\t\tif(x=='locked' && !state.locked)\n\t\t\t$('.markerpoint_trash').show();\n\n\t\treturn state[x];\n\t}\n\n\tthat.broadcastStateVars = function()\n\t{\n\t\tfor(var k in state)\n\t\t{\n\t\t\tthat.toggleStateVar(k, state[k], 1);\n\t\t}\n\t\t// set hover only once here.\n\t\tthat.sethover({locked:state.locked, hoverdetails: state.hoverdetails });\n\t}\n\n\t// normall only needed after loading?\n\tthat.setState = function(state_new)\n\t{\n\t\t$.extend(true, that.state, state_new);\n\t\tthat.broadcastStateVars();\n\t}\n\n\n\n   that.electrode_properties = undefined;\n   that.elecmodel = \"Medtronic3389\";\n\n\n\n   that.color = [255,0,0];\n   that.glmesh = {};\n   that.mesh2d = {};\n\n   that.markerpoints = {};\n   that.runningID = 0;\n\n   that.onupdate = {};\n   that.removeupdater = {};\n\n\n\n\n   function toggleSomeToMain()\n   {\n        KViewer.iterateMedViewers(function(m)\n\t\t{\n\t\t\tif (KViewer.mainViewport == -1)\n\t\t \t\tKViewer.toggleMainViewport(m.viewport.viewPortID);\t\t\t\n\t\t});\n\n\t    if (KViewer.mainViewport == -1)\n\t\t\t   KViewer.navigationTool.worldMaster();\n\n   }\n\n\n\n   that.Rectifytransform = function()\n   {\n\t   var points = that.getPoints();\n\t   for (var k = 0; k < KViewer.viewports.length ;k++)\n\t   {\n\t   \t\tif (KViewer.viewports[k] != undefined && KViewer.viewports[k].medViewer != undefined && KViewer.viewports[k].medViewer.nii != undefined)\n\t\t   \t\tvar iedges = math.inv(KViewer.viewports[k].medViewer.nii.edges);\n\t   }\n\t   if (iedges == undefined)\n\t   \t return;\n\t   var p0 = points[0].coords\n\t   var p1 = points[1].coords\n\n\t   var diff   = math.add(p1, math.multiply(p0, -1) );\n\t   diff._data[3] = 0;\n\t   var diffnorm = math.multiply(diff,1/math.norm(diff._data));\n//\t   var origin = math.matrix(math.multiply(math.add(p1, p0), 0.5));\n\t   var origin = math.matrix(p1);\n\n\n\t   var y_vector =iedges._data[2];\n\t   y_vector = math.multiply(y_vector, -Math.sign(y_vector[0]*diff._data[0]+y_vector[1]*diff._data[1]+y_vector[2]*diff._data[2])) \n\t  \n\n\t   \n\t   var rotmat = calcRotmatForVectors(diffnorm._data,y_vector);\n\t   var T = math.matrix([ [1, 0, 0, origin._data[0]],[0, 1, 0, origin._data[1]],[0, 0, 1, origin._data[2] ],[0, 0, 0, 1] ]);\n\t   var E =  math.multiply(T,rotmat);\n\n\n\n\t   KViewer.currentPoint = math.matrix(p1);\n\t   KViewer.reorientationMatrix.notID = true;\n\t   KViewer.reorientationMatrix.matrix =  E;\n\n   \t   if (KViewer.navigationMode == 0)\n\t\t   KViewer.navigationTool.switchToNavimode(2);\n\t   toggleSomeToMain();\n\t   \n\t\tsignalhandler.send(\"reslice positionChange\");\n\n\n   }\n  \n   that.RECTtransform = function()\n   {\n\n           var points = that.getPoints();\n           if(points.length !== 3)\n           { alertify.alert(\"Must select 2 or 3 points\");    return;    }\n\t\t \n\t\t   var p0 = points[0].p.coords;\n\t\t   var p1 = points[1].p.coords;\n\t\t   var p2 = points[2].p.coords;\n\n  \t\t   var e0   = (math.add(p1, math.multiply(p0, -1) ));\n  \t\t   math.normalize(e0); e0 = e0._data;\n  \t\t   var e1   = math.add(p2, math.multiply(p0, -1) )._data;\n\t\t   var dot = (e0[0]*e1[0]+e0[1]*e1[1]+e0[2]*e1[2]);\n\t\t   e1[0] = e1[0] - dot*e0[0];\n\t\t   e1[1] = e1[1] - dot*e0[1];\n\t\t   e1[2] = e1[2] - dot*e0[2];\n\t\t   e1 = math.matrix(e1)\n\t\t   math.normalize(e1);         \n\t\t   var e2 = math.cross(e0,e1);\n\t\t   e2._data.push(0);\n\t\t   var rotmat = math.transpose(math.matrix([e0,e1._data,e2._data,[0,0,0,1]]));\n\t\t   var origin =p0;\n\n\n         var T = math.matrix([ [1, 0, 0, -origin[0]],[0, 1, 0, -origin[1]],[0, 0, 1, -origin[2] ],[0, 0, 0, 1] ]);\n            var E =  math.multiply(math.inv(rotmat),T);\n\n            KViewer.reorientationMatrix.notID = true;\n            KViewer.reorientationMatrix.matrix =  E;\n\n\t\t\t\n\n       \t /*   if (KViewer.navigationMode == 0)\n\t\t\t   KViewer.navigationTool.switchToNavimode(2);\n\t  \t    toggleSomeToMain();*/\n            setTimeout(function() {\n               signalhandler.send(\"positionChange\"); \n\t\t\tKViewer.markerTool.update()\n               },10);\n\n\n   }\n\n   that.MCPtransform = function()\n   {\n\n           var points = that.getPoints();\n           if(points.length !== 2  &  points.length !== 3)\n           { alertify.alert(\"Must select 2 or 3 points\");    return;    }\n\n           if(KViewer.mainViewPort == -1)    { alertify.alert(\"To see the ACPC Line horizontally, go into master mode.\");      }\n\n           ////// GENERAL COMMENT:    IN LEKSELL system back top right is negative. Do the same for MCP??\n\n           // 2 point mode\n           if(points.length == 2)\n           {\n             if(points[1].coords[1] > points[0].coords[1])       {  var p0 = points[0].coords;     var p1 = points[1].coords;   }\n             else                                  {  var p0 = points[1].coords;     var p1 = points[0].coords;   }\n\n              var diff   = math.add(p1, math.multiply(p0, -1) );\n              diff[3] = 0;\n              var diffnorm = math.multiply(diff,1/math.norm(diff));\n              var origin = math.matrix(math.multiply(math.add(p1, p0), 0.5))._data;\n\n              // search for the AP (y) axis for a nifit and aling the line there. It will then appear horizontally in coupled mode ??\n              var y_vector = [0,0,0,0];\n              y_vector[1]= 1;\n              var rotmat = calcRotmatForVectors(y_vector,diffnorm);\n            }\n            else if(points.length == 3 )\n            {\n              // greatest Z\n              var order = [0,1,2];\n\n              var arr = [ points[0].coords[2], points[1].coords[2], points[2].coords[2]   ];\n              var gz  = arr.indexOf(Math.max.apply(Math, arr));\n              var p2 = points[gz].coords;\n              order.splice(gz,1);\n              // greatest X --\x3e AP\n              if(points[order[1]].coords[1] > points[order[0]].coords[1])       {  var p0 = points[order[0]].coords;     var p1 = points[order[1]].coords;   }\n              else                                  {  var p0 = points[order[1]].coords;     var p1 = points[order[0]].coords;   }\n\n              p0 = p0.slice(0,3);\n              p1 = p1.slice(0,3);\n              p2 = p2.slice(0,3);\n              var diffX   = math.add(p1, math.multiply(p0, -1) );\n              var origin = math.multiply(math.add(p1, p0), 0.5);\n              var diffZ   = math.add(origin, math.multiply(p2, -1) );\n              var newX  = math.multiply(diffX,1/math.norm(diffX._data));\n              var newY = math.cross(diffZ,diffX); newY  = math.multiply(newY,1/math.norm(newY._data));\n              var newZ = math.cross(newY,newX); newZ  = math.multiply(newZ,1/math.norm(newZ._data));\n              newX = newX._data;\n              newY = newY._data;\n              newZ = newZ._data;\n              newX.push(0);              newY.push(0);              newZ.push(0);\n              var rotmat  = (math.transpose([  newY, newX, newZ, [0,0,0,1] ]));\n             // rotmat = math.multiply(rotmat, math.diag([1,1,-1,1])  );\n\n            }\n\n\n\t\t\tif (origin._data)\n\t\t\t\torigin = origin._data;\n\t\t\t\t\n\n            var T = math.matrix([ [1, 0, 0, origin[0]],[0, 1, 0, origin[1]],[0, 0, 1, origin[2] ],[0, 0, 0, 1] ]);\n            var E =  math.multiply(T,rotmat);\n\n            KViewer.reorientationMatrix.notID = true;\n            KViewer.reorientationMatrix.matrix =  E;\n            signalhandler.send(\"reslice positionChange\");\n\n       \t   if (KViewer.navigationMode == 0)\n\t\t   KViewer.navigationTool.switchToNavimode(2);\n\t  \t   toggleSomeToMain();\n\n\n  }\n\n   that.objectify = function()\n   {\n   \t  \tvar pts = that.getPoints();\n   \t\tvar p = [];\n   \t\tfor (var k = 0;k < pts.length;k++)\n   \t\t{\n             var point = pts[k];\n\t\t\t var temp = {\n\t\t\t \t\tcoords : point.p.coords,\n\t\t\t\t\tcoords_transformed : markerProxy.to_transformed( point.p.coords  )._data,   \t   \n\t\t\t\t\tcomment :point.p.comment,\n\t\t\t\t\tsize:point.p.size,\n\t\t\t\t\tactive:point.active,\n\t\t\t\t\tvoltage:point.p.voltage,\n\t\t\t\t\tisContact:point.isContact,\n\t\t\t\t\tdir:point.dir,\n\t\t\t\t\tpickable:point.pickable,\n\t\t\t\t\tvisible : point.visible,\n\t\t\t\t\tname:point.p.name,\n\t\t\t\t\tcolor:  point.p.color.getHEX(),\n\t\t\t\t\treferencedImageFilename: point.referencedImageFilename,\n\t\t\t\t\treferencedImageFileID: point.referencedImageFileID,\n\t\t\t\t\tsubpoints:point.subpoints,\n\t\t\t\t\tformcontent:point.formcontent,\n\t\t\t\t\tthresh:point.thresh\n\n\t\t\t }\n\t\t\t if(1)//point.shape == 'box')\n\t\t\t {\n\t\t\t\t// calculate the projections in voxels on a certain image\n\t\t\t\tif(point.referencedImageFileID !== undefined)\n\t\t\t\t{\n\t\t\t\t\tvar nii = KViewer.dataManager.getFile(point.referencedImageFileID);\n\t\t\t\t\tif (nii != undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tnii = nii.content;\n\t\t\t\t\t\tif (nii.invedges == undefined)\n\t\t\t\t\t\tnii.invedges = math.inv(nii.edges);\n\t\t\t\t\t\tvar pcc = math.multiply( nii.invedges , point.p.coords)._data; // the center point\n\t\t\t\t\t\tvar prr = math.multiply( nii.invedges , point.p.size)._data; // the radius\n\n\t\t\t\t\t\ttemp.coords_vox = math.round(pcc).slice(0,3).map(Math.abs);\n\t\t\t\t\t\ttemp.size_vox   = math.round(prr).slice(0,3).map(Math.abs);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t }\n\t\t\t \n\t\t\t // if pointROI, save the underlying contrast file and the statistics\n\t\t\t if(point.roinii)\n\t\t\t {\n\t\t\t \tvar r = point.roinii;\n\t\t\t \ttemp.pointROI = \n\t\t\t \t{\n\t\t\t\t\trefimagefileID: r.refimagefileID,\n\t\t\t\t\tstats: r.stats\n\t\t\t\t}\n\n\t\t\t }\n\t\t\t p.push(temp);\n\n\n   \t \t}   \t \n   \t \tvar ret = {name:that.name, points:p, type:that.type,  state:that.state};\n\n        if (that.pickpanel)\n        {\n        \tret.state.pickpanel = that.pickpanel.objectify();\n        }\n\n\t\tif (that.markerPanel && that.markerPanel.panelvisible)\n\t\t\tret.state.panel_visible = true;\n\t\telse\n\t\t\tret.state.panel_visible = false;\n\n\t\tif (that.type == \"electrode\")\n\t\t{\n\t\t\tret.isCurrent = that.isCurrent;\n\t\t\tret.elecmodel = that.elecmodel;\n\t\t\tret.electrode_properties = that.electrode_properties;\n\t\t}\n\t\treturn ret;\n   }\n\n\n\n  that.getPointsByName = function()\n   {\n   \t\tvar keys = Object.keys(that.markerpoints).sort();\n   \t\tvar p = {};\n   \t\tfor (var k = 0;k < keys.length;k++)\n   \t\t\tp[that.markerpoints[keys[k]].p.name] = that.markerpoints[keys[k]];\n   \t\treturn p; \n   }\n\n   that.getPoints = function()\n   {\n   \t\tvar keys = Object.keys(that.markerpoints).sort();\n   \t\tvar p = [];\n   \t\tfor (var k = 0;k < keys.length;k++)\n   \t\t\tp.push(that.markerpoints[keys[k]]);\n   \t\treturn p; \n   }\n\n   that.getPointsAsArray = function()\n   {\n   \t   var pts = that.getPoints()\n   \t   var ps = [];\n   \t   for (var k = 0 ; k < pts.length;k++)\n   \t   {\n   \t   \t  var p = pts[k].p.coords;\n   \t   \t  ps.push(p);\n   \t   }\n\t   return ps;\n   }\n\n   that.insertpoint = function(coords,type,after,params)\n   {\n\t\tvar id = after.uuid+\"_9\";\n\t\tvar i = 8;\n\t\twhile (that.markerpoints[id] != undefined)\n\t\t\tid = after.uuid+\"_\"+(i--);\n\n  \t\treturn that.addpoint(coords,type,id,params);\n   }   \n\n   that.addpoint = function(coords,type,id,params)\n   {\n\n   \t\tif(type == undefined)\n   \t\t\ttype = that.type;\n\n\t\tif (id == undefined)\n        \tid = that.uuid + \"P\" +  ('00000'+(that.runningID++)).slice(-5) ;\n        \t\n        var x = KMarkerpoint(that, id);\n        that.markerpoints[id] = x;\n\n\t\t/* these two types can be removed in future */\n\t\tif (type =='ruler')\n\t\t{\n\t\t\tx.type = 'ruler';\n\t\t\tx.dir = [-50,90];\n\t\t\tx.getLength = function() { return  Math.sqrt(this.dir[0]*this.dir[0]+this.dir[1]*this.dir[1]) }\n\t\t}\n\t\telse if (type =='rectangles')\n\t\t{\n\t\t\tx.type = 'rectangles';\n\t\t\tx.dir = [20,20];\n\t\t}\n\n        \n        if(that.type == 'pointROI'  )\n        {\n\t\t\tx.type = 'pointROI';\n       \t\tx.roinii = createPointROI(x);\n       \t\tif(coords == undefined)\n       \t\t\tx.roinii.setThisPointInto3DView();\n        }\n        else if(that.type == 'boxes' )\n        {\n\t\t\tx.type  = 'point';\n\t\t\tx.shape = 'box';\n        }\n        else if(that.type == '3druler'  )\n        {\n\t\t\tx.type  = '3druler';\n\t\t\tx.shape = 'box';\n        }\n        else if(that.type == 'scribble'  )\n        {\n\t\t\tx.type  = 'scribble';\n\t\t\tx.shape = 'scribble';\n\t\t\t//x.shape = 'box';\n\t\t\tx.subpoints  = [];\n\n        }\n\t\t\n\t\tif(x.shape && x.shape == 'box')\n        \tx.p.size  = [x.p.size,x.p.size,x.p.size,0 ]; // box has 3D size\n\n\n\t\tif (params)\n\t\t{\n\t\t\tif (params.size)\n\t\t\t\tx.p.size = params.size;\n\t\t\tif (params.master)\n\t\t\t\tx.master = true;\n\t\t\tif (params.hideMarkerRepresentation)\n\t\t\t\tx.hideMarkerRepresentation = 1;\n\t\t}\n\n        if (coords)\n\t\t\tx.movepoint(coords)\n        else\n        {\n\t\t\t{\t\n\t\t\t\tif(KViewer.currentPoint)\n\t\t\t\t\tx.movepoint(KViewer.currentPoint._data)\n\t\t\t}\n        }\n\n\n\n\t\tif (type =='ruler')// || type =='rectangles')\n\t\t{\n\t\t\tif (x.$markers[Object.keys(x.$markers)[0]] == undefined)\n\t\t\t\treturn  that.markerpoints[id];\n\t\t\tvar mv = x.$markers[Object.keys(x.$markers)[0]].medViewer;\n\t\t\tvar fac = -0.2*mv.computeMaxExtentFac()/mv.zoomFac;\n\t\t\tx.dir = [fac,0];\n\t\t\tx.drawpoint();\n\t\t}\n\n\n        for (var x in that.onupdate)\n            that.onupdate[x]();\n        \n\t\tif(!that.state.ignoremodified)\n\t\t{\n\t\t\tmarkerProxy.modified = true;\n\t\t\tthat.modified = true;\n\t\t}\n\t\tfor(var k in that.callbacks.addpoint)\n\t\t{\n\t\t\tthat.callbacks.addpoint[k](x);\n\t\t}\n\t\tfor(var k in that.callbacks.deletepoint)\n\t\t{\n\t\t\tx.callbacks.delete[k] = that.callbacks.deletepoint[k];\n\t\t}\n\t\t\n        return that.markerpoints[id];\n   }\n\n\n\n\tfunction iteratePoints(fun)\n\t{\n       for(var id in that.markerpoints)\n       {\n          fun(that.markerpoints[id]);\n       }\t\t\n\t}\n\n   // this draws all points of a markerset\n    that.drawAllPoints = function() { \n     if (KViewer.markerTool && that.state.visible && that.visible)//|| KViewer.markerTool.enabled != 0))\n     {\n    \titeratePoints(function(x) {x.drawpoint() }); that.drawLine();\n     } }\n   // clear all points from the viewports\n\tthat.clearAllPoints = function() { \n\t\titeratePoints(function(x) {x.clearpoint() }); \n\t\tthat.disposeLine(); \n\t\tthat.cleanFiberAssoc();\n\t\t}\n   // really delete all points\n \tthat.deleteAllPoints = function() { \n\t\tthat.cleanFiberAssoc();\n \t\titeratePoints(function(x) {x.deletepoint() }); \n \t\tthat.disposeLine(); \n \t\t}\n   // this toggles movability and hoverdetails of all points of a markerset\n    that.sethover = function(state) { iteratePoints(function(x) {x.sethover(state )}) }\n   // this toggles visibility all points of a markerset\n    that.togglePointsVisibility = function(state) \n    { \n    \tif(state == undefined)\n    \t\tstate = !that.state.visible;\n\n\t\tthat.toggleStateVar('visible', state)\n\t\n\t\titeratePoints(function(x) {x.togglepoint(state )\n\t\tif (!state)\n\t\t\tthat.disposeLine(); \n\t\telse\t\t\n\t\t\tthat.drawLine();\n\t\t} ) \n\t\treturn that.state.visible;\n    }\n\n   that.drawLine = function()   \n    { \n\t\tKViewer.iterateMedViewers( function(medViewer)\n\t\t{\n\t\t  var viewport = medViewer.viewport;\n\t\t  if (viewport == undefined)\n\t\t  \treturn;\n\t\t  if (that.visible && that.state.visible && !medViewer.mosaicview.active && (KViewer.markerTool.enabled != 0  || ( that.markerPanel &&  that.markerPanel.panelvisible ) ))\n\t\t  {\n\t\t\t  var colors = KColorSelectorSimple('getcolors');\n\t\t\t  var col;\n\t\t\t  if (that.color != undefined)\n\t\t\t\tcol = colors[that.color]\n\n\t\t\t  var lid = 'LINE_' + viewport.viewPortID  + \"_\" + that.uuid ;\n\t\t\t  if ( medViewer.gl != undefined && medViewer.isGLenabled() )\n\t\t\t  {\n\n\t\t\t\t  if (that.glmesh[lid] != undefined)\n\t\t\t\t\tthat.glmesh[lid].dispose();\n\t\t\t\t  if (that.type == 'electrode')\n\t\t\t\t\tthat.glmesh[lid] = medViewer.gl.createTrace(that,{width:1,color:new KColor([1,1,1])});\n\t\t\t\t  if ( that.type == 'freeline')\n\t\t\t\t  {\n\t\t\t\t  \tvar wid = 1;\n\t\t\t\t  \tif (KViewer.defaultFOV_mm != \"\")\n\t\t\t\t  \t wid = KViewer.defaultFOV_mm/100;\n\t\t\t\t\tthat.glmesh[lid] = medViewer.gl.createTrace(that,{width:wid,color:col});\n\t\t\t\t  }\n\t\t\t\t  else if (that.type == 'surface')\n\t\t\t\t  {\n\t\t\t\t\tthat.glmesh[lid] = medViewer.gl.createFreeSurf(that,{width:1});\n\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t   if (that.mesh2d[lid] != undefined)\n\t\t\t\t\t\tthat.mesh2d[lid].remove()\n\t\t\t\t  if ((that.type == 'electrode' | that.type == 'freeline' )&& medViewer.nii != undefined)\n\t\t\t\t\tthat.mesh2d[lid] = medViewer.createTrace(that,{color:col});\n\n\t\t\t  }\n\t\t  }\n\t\t});\n\n    }\n\n  \n   that.updateLine = function()   {\n\t\tthat.disposeLine();\n\t\tthat.drawLine(); \n   }\n   if (that.type == 'electrode' | that.type == 'freeline' | that.type == 'surface')\n   {\n   \t\tif (that.updateLine_sid == undefined)\n   \t\t\tthat.updateLine_sid = signalhandler.attach(\"positionChange\",that.updateLine)\n   }\t\t\n    \n   that.disposeLine = function()   \n    {\n    \tif (KViewer.iterateMedViewers)\n\t\t\tKViewer.iterateMedViewers( function(medViewer)\n\t\t\t{\n\t\t\t  var viewport = medViewer.viewport;\n\t\t\t  if (viewport == undefined)\n\t\t\t  \t return;\n\t\t\t  var lid = 'LINE_' + viewport.viewPortID  + \"_\" + that.uuid ;\n\t\t\t  if (medViewer.gl != undefined )\n\t\t\t  {\n\t\t\t\t  if (that.glmesh[lid] != undefined)\n\t\t\t\t  {\n\t\t\t\t\tthat.glmesh[lid].dispose();\n\t\t\t\t\tdelete that.glmesh[lid];\n\t\t\t\t  }\n\t\t\t  }\n\t\t\t   if (that.mesh2d[lid] != undefined)\n\t\t\t\t\tthat.mesh2d[lid].remove()\n\t\t\t\t  //if (that.type == 'freeline')\n\t\t\t\t\t//that.mesh2d[lid] = medViewer.createTrace(that);\n\n\t\t\t});\n    }\n\n    that.computeInfo = function()\n    {\n\t\t\tif (that.type == 'freeline')\n\t\t\t{\n\t\t\t\tvar points = that.getPoints();\n\t\t\t\tvar dist = 0;\n\t\t\t\tvar lastdir;\n\t\t\t\tvar ang = \"\";\n\t\t\t\tfor (var k =0;k <points.length-1;k++)\n\t\t\t\t{\t\n\t\t\t\t\tvar n = [ points[k].p.coords[0]-points[k+1].p.coords[0],\n\t\t\t\t\t\t\t\tpoints[k].p.coords[1]-points[k+1].p.coords[1],\n\t\t\t\t\t\t\t\tpoints[k].p.coords[2]-points[k+1].p.coords[2] ];\n\t\t\t\t\tvar d = Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);\n\t\t\t\t\tdist += d;\n\t\t\t\t\tn = [n[0]/d,n[1]/d,n[2]/d];\n\t\t\t\t\tif (lastdir != undefined)\n\t\t\t\t\t\tang += (180-Math.round(Math.acos(lastdir[0]*n[0]+lastdir[1]*n[1]+lastdir[2]*n[2])/Math.PI*180))+\";\";\n\t\t\t\t\tlastdir = n;\n\n\t\t\t\t}\n\t\t\t\tif (that.setInfo)\n\t\t\t\t\tthat.setInfo(\"length: \" + dist.toFixed(1) + \" mm  degs:\" + ang);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (that.setInfo)\n\t\t\t\t\tthat.setInfo(\"area: \" + (that.surfacearea/100).toFixed(4) + \" cm^2\");\n\t\t\t}\n    }\n\n\tthat.pointChanged = function()\n\t{\n\n\t\tvar was_updated = false; // to do not interfere with single point updates for fiberselection\n\t\tif (that.type == 'electrode' && that.electrode_properties != undefined)\n\t\t{\n\t\t\tvar keys = Object.keys(that.markerpoints);\n\t\t\tif (keys.length >= 2)\n\t\t\t{\n\t\t\t\tvar p1 = that.markerpoints[keys[0]].p.coords;\n\t\t\t\tvar p2 = that.markerpoints[keys[1]].p.coords;\n\t\t\t\tvar n = [p1[0]-p2[0],p1[1]-p2[1],p1[2]-p2[2]];\n\t\t\t\tvar norm = Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);\n\t\t\t\tn = [n[0]/norm,n[1]/norm,n[2]/norm];\n\t\t\t\tfor (var k = 2; k < keys.length;k++)\n\t\t\t\t{\n\t\t\t\t\tvar dist = that.electrode_properties.contacts[k-2];\n\t\t\t\t\tthat.markerpoints[keys[k]].p.coords = [p2[0]+n[0]*dist,p2[1]+n[1]*dist,p2[2]+n[2]*dist,1];\n\t\t\t\t\tthat.markerpoints[keys[k]].drawpoint();\n\t\t\t\t}\n\t\t\t}\n\t\t\tvar points = that.getPoints();\n\n\t\t\tvar funs = [];\n\t\t\tfor (var k =0;k <points.length;k++)\n\t\t\t{\t\n\t\t\t\tfor (j in points[k].onupdate)\n\t\t\t\t\tfuns.push(points[k].onupdate[j])\n\t\t\t}\n\n\t\t\titerateSync2(0,funs.length,\n\t\t\t\tfunction(j,ondone) { \n\t\t\t\tfuns[j](ondone);\n\t\t\t\t  });\t\t\n\n\t\t\twas_updated\t= true;\n\n\t\t} \n\t\telse if (that.type == 'surface')\n\t\t{\n\t\t\tvar points = that.getPoints();\n\t\t\tif (points.length >= 3)\n\t\t\t{\n\n\t\t\t\tvar pts = new Float32Array(3*points.length*2)\n\t\t\t\tvar p2 = [];\n\t\t\t\tvar phi = [];\n\t\t\t\tvar cxx = 0;\n\t\t\t\tvar cyy = 0;\n\t\t\t\tvar czz = 0;\n\t\t\t\tvar cxy = 0;\n\t\t\t\tvar cxz = 0;\n\t\t\t\tvar cyz = 0;\n\t\t\t\tvar m = [0,0,0];\n\t\t\t\tfor (var k = 0; k < points.length;k++)\n\t\t\t\t{\n\t\t\t\t\tvar q = points[k].p.coords; \n\t\t\t\t\tm[0]+= q[0];\n\t\t\t\t\tm[1]+= q[1];\n\t\t\t\t\tm[2]+= q[2]\n\t\t\t\t}\n\t\t\t\tm[0] /= points.length;\n\t\t\t\tm[1] /= points.length;\n\t\t\t\tm[2] /= points.length;\n\t\t\t\tfor (var k = 0; k < points.length;k++)\n\t\t\t\t{\n\t\t\t\t\tvar q = points[k].p.coords; \n\t\t\t\t\tcxx += (q[0]-m[0])*(q[0]-m[0]);\n\t\t\t\t\tcyy += (q[1]-m[1])*(q[1]-m[1]);\n\t\t\t\t\tczz += (q[2]-m[2])*(q[2]-m[2]);\n\t\t\t\t\tcxy += (q[0]-m[0])*(q[1]-m[1]);\n\t\t\t\t\tcyz += (q[2]-m[2])*(q[1]-m[1]);\n\t\t\t\t\tcxz += (q[0]-m[0])*(q[2]-m[2]);\n\t\t\t\t}\n\t\t\t\tvar ev = math.EV3(math.matrix([[cxx,cxy,cxz],[cxy,cyy,cyz],[cxz,cyz,czz]]));\n\t\t\t\t\n\t\t\t\tfor (var k = 0; k < points.length;k++)\n\t\t\t\t{\n\t\t\t\t\tvar q = points[k].p.coords; \n\t\t\t\t\tvar x_ =    (q[0]-m[0])*ev[0].v[0] + (q[1]-m[1])*ev[0].v[1] + (q[2]-m[2])*ev[0].v[2];\n\t\t\t\t\tvar y_ =  (q[0]-m[0])*ev[1].v[0] + (q[1]-m[1])*ev[1].v[1] + (q[2]-m[2])*ev[1].v[2];\n\t\t\t\t\tvar n = Math.sqrt(x_*x_+y_*y_);\n\t\t\t\t\tphi[k] = {d:points[k].p.size,a:[x_,y_],i:k,p: Math.atan2(x_/n,y_/n),q:q.slice(0)};\n\n\t\t\t\t}\n                phi.sort(function(a,b) { \n                return a.p-b.p \n                });\n                for (var k = 0; k < points.length;k++)\n                {\n                \tp2[2*k] = phi[k].a[0];\n                \tp2[2*k+1] = phi[k].a[1];\n\t\t\t\t\tpts[3*k] = phi[k].q[0];\n\t\t\t\t\tpts[3*k+1] = phi[k].q[1];\n\t\t\t\t\tpts[3*k+2] = phi[k].q[2];\n                }\n\n\t\t\t\tvar trigs = earcut(p2,null,2);\n\n\n\t\t\t\tvar normals = new Float32Array(3*points.length*2)\n\t\t\t\tvar area = 0;\n\t\t\t\tfor (var k = 0;k < trigs.length/3;k++)\n\t\t\t\t{\n\t\t\t\t\tvar a = [pts[3*trigs[3*k]]  ,pts[3*trigs[3*k]+1],pts[3*trigs[3*k]+2]];\n\t\t\t\t\tvar b = [pts[3*trigs[3*k+1]],pts[3*trigs[3*k+1]+1],pts[3*trigs[3*k+1]+2]];\n\t\t\t\t\tvar d = [pts[3*trigs[3*k+2]],pts[3*trigs[3*k+2]+1],pts[3*trigs[3*k+2]+2]];\n\t\t\t\t\tvar n =     [(b[1]-a[1])*(d[2]-a[2]) - (b[2]-a[2])*(d[1]-a[1]), \n\t\t\t\t\t\t\t\t (b[2]-a[2])*(d[0]-a[0]) - (b[0]-a[0])*(d[2]-a[2]),\n\t\t\t\t\t\t\t\t (b[0]-a[0])*(d[1]-a[1]) - (b[1]-a[1])*(d[0]-a[0])];\n\t\t\t\t\tarea += Math.sqrt(n[0]*n[0]+n[1]*n[1]+n[2]*n[2]);\n\t\t\t\t\tfor (var j=0;j<3;j++)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tnormals[3*trigs[3*k+j]+0] += n[0];\n\t\t\t\t\t\tnormals[3*trigs[3*k+j]+1] += n[1];\n\t\t\t\t\t\tnormals[3*trigs[3*k+j]+2] += n[2];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\t\t\t\tvar sgc = 0;\n\t\t\t\tfor (var k = 0; k < points.length;k++)\n\t\t\t\t{\n\t\t\t\t\tvar no = math.sqrt(normals[3*k]*normals[3*k] +normals[3*k+1]*normals[3*k+1] +normals[3*k+2]*normals[3*k+2]);\n\t\t\t\t\tnormals[3*k] /= no;\n\t\t\t\t\tnormals[3*k+1] /= no;\n\t\t\t\t\tnormals[3*k+2] /= no;\n\t\t\t\t\tsgc += normals[3*k]*ev[2].v[0]+normals[3*k+1]*ev[2].v[1]+normals[3*k+2]*ev[2].v[2];\n\n\t\t\t\t}\n\t\t\t\tsgc = Math.sign(sgc);\n\n\t\t\t\tvar offs = points.length*3;\n                for (var k = 0; k < points.length;k++)\n                {\n\t\t\t\t\tvar thck =  phi[k].d*0.4;\n\t\t\t\t\tpts[3*k+offs] = pts[3*k] + ev[2].v[0]*thck;\n\t\t\t\t\tpts[3*k+1+offs] = pts[3*k+1] + ev[2].v[1]*thck;\n\t\t\t\t\tpts[3*k+2+offs] = pts[3*k+2] + ev[2].v[2]*thck;\n\t\t\t\t\tpts[3*k] = pts[3*k] - ev[2].v[0]*thck;\n\t\t\t\t\tpts[3*k+1] = pts[3*k+1] - ev[2].v[1]*thck;\n\t\t\t\t\tpts[3*k+2] = pts[3*k+2] - ev[2].v[2]*thck;\n\n\t\t\t\t\tnormals[3*k+offs] = sgc*normals[3*k];\n\t\t\t\t\tnormals[3*k+1+offs] = sgc*normals[3*k+1];\n\t\t\t\t\tnormals[3*k+2+offs] = sgc*normals[3*k+2];\n\t\t\t\t\tnormals[3*k] = -sgc*normals[3*k];\n\t\t\t\t\tnormals[3*k+1] = -sgc*normals[3*k+1];\n\t\t\t\t\tnormals[3*k+2] = -sgc*normals[3*k+2];\n                }\n                var l = trigs.length;\n\t\t\t\tfor (var k = 0; k < l; k++)\n\t\t\t\t\ttrigs[k+l] = trigs[k]+points.length;\n\n\n\t\t\t\tthat.resorted = phi;\n\t\t\t\tthat.points =  pts;\n\t\t\t\tthat.indices = new Float32Array(trigs);\n\t\t\t\tthat.normals = normals;\n\t\t\t\tthat.surfacearea = area/2;\n\t\t\t}\n\t\t\tthat.computeInfo()\n\n\t\t}\n\t\telse if (that.type == 'freeline' )\n\t\t{\n\t\t\tthat.computeInfo()\n\t\t}\n\n\t\tthat.disposeLine();\t\n\t\tif ( markerProxy && markerProxy.currentSet && markerProxy.currentSet.visible && that.type != 'pointset')\n\t\t{\n\t\t\tthat.drawLine();\n\t\t}\n\n\t\treturn was_updated;\n\t}\n\n    that.cleanFiberAssoc = function()\n    {\n    \tif ( KViewer.findAllViews)\n    \t{\n\t\t\tvar tcks = KViewer.findAllViews('fibers');\n\t\t\tfor (var k = 0 ;k < tcks.length;k++)\n\t\t\t\tif (tcks[k].associated_annotation == that.uuid)\n\t\t\t\t{\n\t\t\t\t\ttcks[k].removeAnnotationAssoc();\n\t\t\t\t}\n    \t}\n    }\n\n\tthat.setActive = function()\n\t{\n\t\t var ps = that.getPoints();\n\t\t for (var j = 0; j < ps.length;j++)\n\t\t \tif (ps[j].active)\n\t\t \t\tps[j].select();\n\t}\n\n\tthat.getActive = function()\n\t{\n\t\tif(that.type != 'electrode')\n\t\t\treturn;\n\n\t\tvar pts = that.getPoints();\n\t\tfor (var k = 2;k  < pts.length;k++)\n\t\t{\n\t\t\tif (pts[k].active)\n\t\t\t{\n\t\t\t\treturn {pts:pts[k],pos:that.electrode_properties.contacts[k-2]}\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\t}\n\n\t/******************************************************************************\n\tscribble specific\n\t*******************************************************************************/\n\tthat.interplate_scribbles = function()\n\t{\n\t\tKMarkerScribble_interpolate_slices(that);\n\t}\n\t\n\tthat.map_to_ROI = function()\n\t{\n\t\t$(document.body).addClass(\"wait\");\n        setTimeout(function()\n        {\n\t\t\tvar roi = KViewer.roiTool.getCurrentGlobal();\n\t\t\tif(roi == undefined\t)\n\t\t\t{\n\t\t\t\troi = KViewer.roiTool.lastCurrentROIID;\n\t\t\t\tif(roi != undefined\t)\n\t\t\t\t\troi = KViewer.dataManager.getFile(roi)\n\t\t\t}\n\t\t\tif(roi == undefined\t)\n\t\t\t{\n\t\t\t\talertify.error(\"Please create or activate a ROI for filling!\")\n\t\t\t\t$(document.body).removeClass(\"wait\");\n        \t\treturn false\n\t\t\t}\n\n\t\t\tvar nii = roi.content\t\n\t\t\tvar points = that.getPoints()\n\t\t\tvar changedPoints = [];\n\t\t\tfor(var k=0; k<points.length; k++)\n\t\t\t{\n\n\t\t\t\tvar ret = fillPolygon(points[k],roi.content, false);\n\t\t\t\tchangedPoints = changedPoints.concat(ret.changedPoints)\n\n\t\t\t}\n\t\t\tif(changedPoints.length>0)\n\t\t\t{\n\t\t\t\tKViewer.roiTool.history.record('startRecording', undefined, roi,'use_as_last');\n\t\t\t\tKViewer.roiTool.history.add(changedPoints, 1, roi);\n\t\t\t\tKViewer.roiTool.history.record('stopRecording');\n\t\t\t}\n\t\t\tsignalhandler.send(\"positionChange\");//,{id:roi.fileID});\n    \t\t$(document.body).removeClass(\"wait\");\n\t\t\t\n        },50);\n\t}\n\n\n\tif(args.delSetOnPanelClose != undefined)\n \t\tstate.delSetOnPanelClose = args.delSetOnPanelClose;\n \tif(args.showThroughSlice != undefined)\n \t\tstate.showThroughSlice = args.showThroughSlice;\n\t\n\t/******************************************************************************\n\tallow to override all state vars with args.state\n\t*******************************************************************************/\n\tif(args.state !=undefined)\n\t{\n\t\t$.extend(true, state, args.state)\n\t}    \n\n\n    /***************************************************************************************\n    * finalise\n    ****************************************************************************************/\n\t// show panel on creation ?\n\tif(showPanel)\n\t\tthat.showPanel();\n\t\n\t\n\n\n\n    return that;\n}\nKMarkerset.runningSetID = 0;\n\n\n\n\n\n\nfunction iterateSync2(current,end,fun)\n{\nif (current < end)\n\tfun(current,function() {iterateSync2(current+1,end,fun) });\n}\n\n\n\n\n\n\n// ======================================================================================\n// ============= global variable to define point callbacks\n// ======================================================================================\nvar KMarkerpoint_callbacks = \n{\n\t\tcreate:{},\n\t\tdelete: {},\n\t\ttoggle: {},\n\t\tchangeProps: {},\n\t\tmove:{},\n\t\tactive:{},\n\t\tjumptopoint:{},\n\t\tmousedown:{},\n\t\tcreateinfobox: {}\n\n}\n\n\n\n// ======================================================================================\n// ============= a single marker point\n// ======================================================================================\n\nfunction KMarkerpoint(parentmarkerset, id)\n{\n    var that = new Object();\n\n\tvar markerPanel = parentmarkerset.markerPanel; \n\n\tvar recreateInfoBoxOnHover = false;\n\n\tthat.type = \"point\";\n\n    that.visible = true;\n\tthat.locked = false;\n\tthat.active = true;\n\n\tthat.shape = 'sphere';\n\t//that.shape = 'box';\n\n\n\n    // relevant public properties to save\n    that.p = {};\n    that.p.uuid = id;\n    that.p.name = 'noname';\n    that.p.coords = [0,0,0,0];\n    that.p.comment = \"\";\n    that.p.color = new KColor('#FF0000');\n\tthat.p.parentviewport = 0;\n    \n    if(that.shape == 'sphere')\n\t\tthat.p.size = 5; // size in mm. single number for spheres, 3 numbers for box\n    else if(that.shape == 'box')\n\t\tthat.p.size = [5,5,5,0]; // size in mm. single number for spheres, 3 numbers for box\n\t\n\t\n\tthat.__defineGetter__('uuid', function() { return this.p.uuid; });\n\tthat.__defineGetter__('coords', function() { return this.p.coords; });\n\tthat.__defineGetter__('size', function() { return this.p.size; });\n\n\tthat.onupdate = {};\n\tthat.removeupdater = {};\n\n    \n    that.parentmarkerset = parentmarkerset; \n\n    var $markers = {};\n    that.$markers = $markers;\n\n\n    that.movepoint = function(coords, medViewer, ev)\n    {\n        that.p.coords = coords; \n\t\n\t    that.drawpoint();\n    \n    \n    \tif (that.parentmarkerset.pointChanged)\n\t\t\tif (!that.parentmarkerset.pointChanged())\n\t\t\t{\n\t\t\t   for (var x in that.onupdate)\n\t\t\t\t that.onupdate[x](medViewer, ev); \t\t\t\n\t\t\t}\n\t\n\t\tif(!that.parentmarkerset.state.ignoremodified)\n\t\t{\n\t\t\tmarkerProxy.modified = true;\n\t\t\tthat.parentmarkerset.modified = true;\n\t\t}\n\n             \n    }\n\n    that.setdir = function(dir)\n    {\n\t\tthat.dir = dir;\n        that.drawpoint();\n\n    }\n   \n\n    that.point = that.movepoint;\n\n\tthat.incsize = function(amount, medViewer)\n\t{\n\t\tif(that.shape == 'sphere')\n\t\t\tvar newsize = that.p.size + amount\n\t\telse if(that.shape == 'box')\n\t\t\tvar newsize = [0,0,0,0];  newsize[0] = that.p.size[0]+amount; newsize[1] = that.p.size[1]+amount; newsize[2] = that.p.size[2]+amount;\n\n\t\tthat.setsize(newsize, medViewer);\n\t}\n\n\n    that.setsize = function(siz, medViewer, ev)\n    {\n\t\t\n    \tif(that.shape == 'sphere' | that.shape == 'scribble')\n    \t{\n    \t\tthat.p.size = siz;\n\t\t\tif(that.p.size < 0.1) that.p.size = 0.1;\n    \t}\n    \telse if(that.shape == 'box')\n    \t{\n    \t\tif( typeof(siz) == 'number')\n    \t\t{\n\t\t\t\tthat.p.size[0] = siz; that.p.size[1] = siz; that.p.size[2] = siz;\n    \t\t}\n    \t\telse\n    \t\t{\n    \t\t\tthat.p.size = siz;\n    \t\t\tthat.p.size[3] = 0;\n    \t\t}\n\t\t\t//if(that.p.size[0] < 0.1) that.p.size[0] = 0.1; if(that.p.size[1] < 0.1) that.p.size[1] = 0.1; if(that.p.size[2] < 0.1) that.p.size[2] = 0.1;\n    \t}\n\n\t\tthat.drawpoint();\n \t\tfor (var x in that.onupdate)\n           that.onupdate[x](medViewer, ev);\n    \n    }\n\n\tthat.getsubpoint = function(index, t)\n\t{\n\t\tif( index<0)\n\t\t\tindex = that.subpoints.length + index;\n\t\tvar index = index % that.subpoints.length;\n\t\treturn that.subpoints[index];\n\t}\n\n    that.setsizeFromMouseEvent = function(edgeindex,refpoint, newpoint, medViewer, donotrecalcflag)\n    {\n\t\tif (that.parentmarkerset.state.fixedsize)\n\t\t\treturn;\n\n\t\tif(refpoint == undefined || refpoint[0] == undefined || newpoint == undefined || newpoint[0] == undefined)\n\t\t\treturn;\n\n\n    \t// calc the size from a mouse event (in pixel coordinates)\n     \tvar rwpos_ref = medViewer.getRealWorldCoordinatesFromMouseEvent(refpoint[0], refpoint[1]);\n     \tvar rwpos_new = medViewer.getRealWorldCoordinatesFromMouseEvent(newpoint[0], newpoint[1]);\n\t\tvar refsize = markerProxy.draggedPoint.refprops.size ;\n\t\tvar refpos  = markerProxy.draggedPoint.refprops.coords ;\n\n\t\tvar rw_diff = ( math.add(rwpos_ref, math.multiply(rwpos_new,-1) ) );\n\n\t\t// we want to have the resizer always on lower right edge. So must deal\n\t\t// with different view orientations (readdirection etc)...\n\t\t// Like this ? seems to work so far\n\n\t\tvar po = KMedViewer.getPermutationOrder();\n\t\tvar flips = po.flips;\n \t\trw_diff._data[0] *= flips[0];\n \t\trw_diff._data[1] *= flips[1];\n \t\trw_diff._data[2] *= flips[2];\n\n\n\t\tif(that.shape == 'sphere')\n\t\t{\n\t\t\tvar newsize = refsize + rw_diff._data[ findIndexOfGreatest(rw_diff._data) ];\n\t\t}\n\t\telse if(that.shape == 'box')\n\t\t{\n\t\t\t// unfortunately must deal with read direction etc\n\t\t\t/*\n\t\t\tvar po = medViewer.nii.permutationOrder;\n\t\t\tvar rd = medViewer.nii.readdirection;\n\t\t\trw_diff._data[0] *= rd[0];\n\t\t\trw_diff._data[1] *= rd[1];\n\t\t\trw_diff._data[2] *= rd[2];\n*/\n\t\n\t\t\t// we have a somewhat strange convention: box center point is in corner, 3druler center point is in center ...\n\t\t\tif(1 || that.type == '3druler')\t\n\t\t\t\tvar posshift =   math.multiply(rw_diff, -.50);\n\t\t\telse\n\t\t\t\tvar posshift =   math.multiply(rw_diff, 0);\n\n\t\t\tvar newpos = ( math.add(refpos, posshift ) );\n\t\t\t\n\t\t\t// check if lower right or upper left resizer\n\t\t\tif(edgeindex==0 )\n\t\t\t\tvar dir = .5;\n\t\t\telse if(edgeindex==1 )\n\t\t\t\tvar dir = -.5;\n\t\t\tvar newsize = math.add(refsize , math.multiply(rw_diff, dir))._data;\n\t\t\t\n\t\t\tthat.p.coords = newpos._data;\n\t\t}\n\n\n\t\tif(that.shape == 'scribble')\n\t\t{\n\t\t\t//var lengthPerSegment = 5; // in mm\n\t\t\tvar lengthPerSegment = that.parentmarkerset.markerPanel.scribbleTool.lengthPerSegment\n\t\t\tvar tlen = that.subpoints.length\n\t\t\tif(tlen == 0 )\n\t\t\t{\n\t\t\t\tthat.subpoints.push(that.p.coords);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif(!that.isclosed)\n\t\t\t\t\tvar lastpoint = that.getsubpoint(tlen-1); // .length ist costly, save in future!\n\t\t\t\telse\n\t\t\t\t\tvar lastpoint = that.getsubpoint(that.lastInsertedPointInd); // .length ist costly, save in future!\n\n\t\t\t\tvar difftolastpoint = ( math.add(lastpoint, math.multiply(rwpos_new,-1) ) );\n\t\t\t\tvar difftolastpoint_norm =  math.norm(difftolastpoint);\n\t\t\t\t// add new point\n\t\t\t\tif(difftolastpoint_norm > lengthPerSegment)\n\t\t\t\t{\n\n\t\t\t\t\tvar newcoords = rwpos_new._data ;\n\n\t\t\t\t\tif(that.isclosed)\n\t\t\t\t\t{\n\t\t\t\t\t\t/* if polygon is already closed, and we start dragging  need smart way to improve / correct polygon \n\t\t\t\t\t\t\t1) remove any point which closer than segment length than the newly inserted point\n\t\t\t\t\t\t\t2) keep polygon tight: search closest point to inserted one. remove all points between (clip the path)\n\t\t\t\t\t\t*/\n\t\t\t\t\t\t// set the move directon after first anchor point\n\n\t\t\t\t\t\tif(that.movedirection == 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// from the lastInsertedPointInd, in which direction did we move ?\n\t\t\t\t\t\t\t// check left and right from lastInsertedPoint: in which direction did we move\n\t\t\t\t\t\t\tvar dLastL = math.norm(kp_vsum(that.getsubpoint(that.lastInsertedPointInd-1), that.subpoints[that.lastInsertedPointInd], -1));\n\t\t\t\t\t\t\tvar dLastR = math.norm(kp_vsum(that.getsubpoint(that.lastInsertedPointInd+1), that.subpoints[that.lastInsertedPointInd], -1));\n\t\t\t\t\t\t\tvar dNewL  = math.norm(kp_vsum(that.getsubpoint(that.lastInsertedPointInd-1), newcoords, -1));\n\t\t\t\t\t\t\tvar dNewR  = math.norm(kp_vsum(that.getsubpoint(that.lastInsertedPointInd+1), newcoords, -1));\n\n\t\t\t\t\t\t\t// are we going forward or backward along the path?\n\t\t\t\t\t\t\t//if(dLastL/dNewL > dLastR / dNewR)\n\t\t\t\t\t\t\t//if(Math.abs(dLastL-dNewL) < Math.abs(dLastR - dNewR))\n\t\t\t\t\t\t\tif( dLastL-dNewL  > dLastR - dNewR )\n\t\t\t\t\t\t\t\tthat.movedirection = -1\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tthat.movedirection = 1;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// insert new point\n\t\t\t\t\t\tvar insertionInd = that.lastInsertedPointInd + (that.movedirection==1?1:0);\n\t\t\t\t\t\tthat.subpoints.splice(insertionInd, 0, newcoords );\n\t\t\t\t\t\tthat.lastInsertedPointInd  = insertionInd;\n\n\t\t\t\t\t\t// find the closest point to the one which was just inserted\n\t\t\t\t\t\tvar dists = [];\n\t\t\t\t\t\tvar looksteps = 8;\n\t\t\t\t\t\tlooksteps = (tlen>looksteps*2)*looksteps\n\n\t\t\t\t\t\tfor(var k=0; k < looksteps; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar uind = that.lastInsertedPointInd + (k+1)*that.movedirection;\n\t\t\t\t\t\t\tdists.push( math.norm(kp_vsum( that.getsubpoint(uind)  , newcoords, -1) ) );\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar toremove = kp_vec_min(dists).ind;\n\t\t\t\t\t\t//console.log(\"removing points: \" + themin.ind + \" starting from: \" + that.lastInsertedPointInd)\n\n\t\t\t\t\t\t// take the shortes way, remove points\n\n\t\t\t\t\t\tif(that.movedirection == 1)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthat.subpoints.splice(that.lastInsertedPointInd+1, toremove);\n\t\t\t\t\t\t\tif(that.lastInsertedPointInd+1+toremove > tlen  )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar fromzeroind =  toremove - (tlen - that.lastInsertedPointInd)\n\t\t\t\t\t\t\t\tthat.subpoints.splice(0, fromzeroind);\n\t\t\t\t\t\t\t\tthat.lastInsertedPointInd -= fromzeroind;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// walked over first point?\n\t\t\t\t\t\t\tif(that.lastInsertedPointInd-toremove < 0  )\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar toremove2 = (toremove-that.lastInsertedPointInd)\n\t\t\t\t\t\t\t\tthat.subpoints.splice(tlen - toremove2+1, toremove2);\n\t\t\t\t\t\t\t\ttoremove-=toremove2;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthat.subpoints.splice(that.lastInsertedPointInd-toremove, toremove);\n\t\t\t\t\t\t\tthat.lastInsertedPointInd -= toremove;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthat.subpoints.push( newcoords );\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// close the scribble-polygon\n\t\t\tif(donotrecalcflag == 'recalc' && !that.isclosed)\n\t\t\t{\n\t\t\t\t//that.isclosed = 1;\n\t\t\t\tthat.drawpoint();\n\t\t\t}\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthat.setsize( newsize, undefined, donotrecalcflag);\n\t\t}\t\n\n    }\n\n    \n    that.setcolor = function(color)\n    {\n        that.p.color = color || that.p.color;\n        for(var mid in $markers)\n        {\n        \tvar css = that.p.color.getCSS();\n\t\t  // $markers[mid].css('border-color', css);\n\t\t   $markers[mid].find('.markerpoint_haircross_x').css('background', css);\n\t\t   $markers[mid].find('.markerpoint_haircross_y').css('background', css);\n\t\t   $markers[mid].find('.markerpoint_resizer').css('background', css);\n\n\t\t   if( that.shape == 'box')\n\t\t\t\t$markers[mid].find('line').css('stroke', css);\n// \t\t   if( that.shape == '3druler')\n// \t\t\t   $markers[mid].find('.markerpoint_3Druler_text').css('background', \"rgba(\" + that.p.color.color.slice(0,3).join(\",\") + \",.25)\" );\n\t\t   if( that.shape == 'scribble')\n\t\t   {\n\t\t\t   var opac = that.p.color.length==4?that.p.color[3]/255:1;\n\t\t\t   $markers[mid].find('polyline').css('stroke', \"rgba(\" + that.p.color.color.slice(0,3).join(\",\") + \",\"+opac+\")\" );\n\t\t   }\n        }\n        that.drawpoint()\n        that.runcallbacks('changeProps')\n\n        if( that.parentmarkerset.type == 'pointROI' && that.roinii.fileObject) \n        {\n\t\t\t// we have this mess with colors being indices or rga or whatever\n\t\t\t// here, we need an index (a color number), so find it if necessary\n            //var color = KColor.findColorIndex(that.p.color.color) ;    \n            // --\x3e check moved to setColorGlobal\n\t\t\tKViewer.roiTool.setColorGlobal(that.roinii.fileObject.fileID ,  that.p.color )\n        }\n\n    }\n\n    /***************************************************************************************\n    * set additional callbacks, for example from markerPanel for synchronity\n    ****************************************************************************************/\n\t// no extension, direct pointer\n\tthat.callbacks = $.extend(true, {}, KMarkerpoint_callbacks);\n\t\n\tthat.setcallbacks = function(callbacks)\n\t{\n\t\tthat.callbacks = $.extend(true, that.callbacks, callbacks)\n\t}\n\t\n\t// run a specified callback\n\tthat.runcallbacks = function(c, varargin)\n\t{\n\t\t//var dummy = 1;\n\t\t//console.log(c);\n \t\tfor(var p in that.callbacks[c])\n \t\t{\n \t\t\tthat.callbacks[c][p](that, varargin);\n \t\t}\n\t}\n\n\n    /***************************************************************************************\n    * toggle visibility of this point\n    ****************************************************************************************/\n    that.togglepoint = function(state)\n\t{\n\t\tif(state !== undefined)\n\t\t\tthat.visible = state;\n\t\telse\n\t\t\tthat.visible = that.visible?false:true;\n\t\t\n\t\tif(that.visible) \n\t\t\t that.drawpoint();\n\t    else\n  \t\t\t that.clearpoint();\n\n        for (var x in that.onupdate)\n            that.onupdate[x]();\n\n  \t\n\t\tthat.runcallbacks('toggle');\n\t}\n\n    that.select = function()\n\t{\n\t\tvar ps = parentmarkerset.getPoints();\n\n\n\t\tvar tcks = KViewer.findAllViews('fibers');\n\t//\tfor (var k = 0 ;k < tcks.length;k++)\n\t//\t\ttcks[k].setAnnotationAssoc(parentmarkerset.uuid);\n\n\t    that.active = (that.active+2)%3 -1 ;\n\t    that.runcallbacks('active');\n\n/*\t\tfor (var k = 0; k < ps.length;k++)\n\t\t{\n\t\t\tps[k].active = (that==ps[k]);\n\t\t\tps[k].runcallbacks('active');\n\t\t}\n*/\t\n\t\tif (parentmarkerset.simpanel)\n\t\t\tparentmarkerset.simpanel.updateActive()\n\n\t    for (var x in parentmarkerset.onupdate)\n           parentmarkerset.onupdate[x]();\n\t    for (var x in that.onupdate)\n           that.onupdate[x]();\n\n\t}\n\n\n\t/***************************************************************************************\n\t* draw this point in a all viewports, if they have a valid nifti\n\t****************************************************************************************/\n\tthat.indrawing = -1;\n\tthat.drawpoint = function()\n\t{\n\t\tif (that.parentmarkerset != undefined && Object.keys(that.parentmarkerset.markerpoints).length>10)\n\t\t{\n\t\t\tif (that.indrawing != -1)\n\t\t\t{\n\t\t\t \tclearTimeout(that.indrawing);\n\t\t\t //   for (var x in that.$markers) that.$markers[x].css('display','none');\n\t\t\t}\n\t\t\tthat.indrawing = setTimeout(draw,0);\n\t    }\n\t    else\n\t    \tdraw();\n\n\t\tfunction draw()\n\t\t{\n\n\t\t\tif (KViewer.viewports == undefined)\n\t\t\t\treturn\n\t\t\tif (that.parentmarkerset.visible == false)\n\t\t\t\treturn\t\n\n\t\t\t\n\t\t\tKViewer.iterateMedViewers(function(medViewer)\n\t\t\t{\n\t\t\t\tif( medViewer.nii !== undefined && ( \n\t\t\t\t\t\t     !medViewer.mosaicview.active && \n\t\t\t\t\t\t\t that.parentmarkerset.state.visible &&\n\t\t\t\t\t\t\t that.visible &&\n\t\t\t\t\t\t\t (KViewer.markerTool.enabled != 0  || ( that.parentmarkerset.markerPanel &&  that.parentmarkerset.markerPanel.panelvisible ) ) \n\t\t\t\t\t\t)\t\n\t\t\t\t\t\t|| that.type == 'ruler' \n\n\t\t\t\t\t)\n\t\t\t\t\t{\n\t\t\t\t\t\tthat.drawpoint_singleVP(medViewer.viewport);\n\n\t\t\t\t\t}\n\n\t\t\t});\n\t\t\tthat.runcallbacks('move'); \n\t\t\tfor (var x in that.$markers) that.$markers[x].css('display','block')\n\n\t\t\tthat.indrawing = -1;\n\t\t}\n\t\n    }\n\n\n    /***************************************************************************************\n    * update name \n    ****************************************************************************************/\n    that.changeName = function($e)\n    {\n\t\t  that.p.name = $e.html();\n\t\t  if(that.p.name.replace(/\\s*[<br\\s*/>]/g, '') == \"\")\n\t\t\t that.p.name = \"noname\";\n\n\t\t  //for(var mid in $markers)   {   $markers[mid].$name.html(that.p.name);      }\n\t\t  //that.callbacks.name.forEach( function(callback) {callback(that);} );\n\t\t  that.runcallbacks('changeProps');\n\n    }\n\n\n\n\n    /***************************************************************************************\n    * draw this point in a single viewport: check if is there, if not create, else update\n    ****************************************************************************************/\n    that.drawpoint_singleVP = function(viewport)\n    {\n    \t\tif (viewport != undefined)\n    \t\t{\n\t\t\t\tvar medViewer = viewport.medViewer;\n\t\t\t\t// a unique marker id\n\t\t\t\tvar mid = 'MARKER_' + viewport.viewPortID  + \"_\" +  that.uuid;\n\n\t\t\t\tif ( !medViewer.isGLenabled() )\n\t\t\t\t{\n\t\t\t\t\tdrawpoint_2D(medViewer, mid)\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tdrawpoint_3D(medViewer, mid)\n\t\t\t\t}\n    \t\t}\n    }\n\n \t/***************************************************************************************\n    * point in 2D VP\n    ****************************************************************************************/\n\t\n    function drawpoint_2D(medViewer, mid)\n    {\n\t\n\t    var canvascoords = medViewer.getCanvasCoordinates(that.p.coords);\n\n        // must create a new marker one if not exists\n        if($markers[mid] === undefined )\n        {\n\t\t\t//var $a;\n\t\t\tif(that.parentmarkerset.state.zIndex)\n\t\t\t\tvar addstyle =\"style='z-index: \" + that.parentmarkerset.state.zIndex + \"'\";\n\t\t\telse\n\t\t\t\tvar addstyle = \"\";\n\t\t\t\n\t\t\tvar $a = $(\"<div uid='\" + mid + \"' \"+addstyle+\" class=''></div>\"); \n            \n            // special \"OLD\" classes ruler and rectangles\n            if (that.type == 'ruler' | that.type == 'rectangles')\n            {\n\t\t\t\tif (that.type == 'ruler')\n\t\t\t\t{\n\t\t\t\t\t//var $a = $(\"<div uid='\" + mid + \"' class='markerruler'></div>\");\n\t\t\t\t\t$a.addClass(\"markerruler\") \n\t\t\t\t\t$a.$term_a = $(\"<div class='markerruler_terminal markerruler_terminal_a'  ></div>\").appendTo($a)\n\t\t\t\t\t$a.$term_b = $(\"<div class='markerruler_terminal markerruler_terminal_b'  ></div>\").appendTo($a)\n\t\t\t\t\t$a.$text = $(\"<div class='markerruler_text' > <span></span> <i class='fa fa-trash'></i></div>\").appendTo($a)\n\t\t\t\t\t$a.$textspan = $a.$text.find(\"span\");\n\t\t\t\t\t$a.$trash = $a.$text.find(\"i\");\n\t\t\t\t\t$a.$trash.on(\"click\",function()\t{ that.deletepoint(); });\n\n\t\t\t\t}\n\t\t\t\telse if (that.type == 'rectangles')\n\t\t\t\t{\n\t\t\t\t\t//var $a = $(\"<div uid='\" + mid + \"' class='markerrectangle'></div>\"); \n\t\t\t\t\t$a.addClass(\"markerrectangle\") \n\t\t\t\t\t$a.$term_a = $(\"<div class='markerruler_terminal markerruler_terminal_a rect_term' ></div>\").appendTo($a)\n\t\t\t\t\t$a.$term_b = $(\"<div class='markerruler_terminal markerruler_terminal_b rect_term' ></div>\").appendTo($a)\n\t\t\t\t\t$a.$rect = $(\"<div class='markerrectangle_rectborder' ></div>\").appendTo($a)\n\t\t\t\t}\n\n\t\t\t\tattachRulerHandlers($a);\n\t\t\t}\n            else // the normal generic class\n            {\n\t            if(that.shape == 'sphere')\n\t            {\n\t\t\t\t\t$a.addClass(\"markerpoint\") \n\t\t\t\t\t$a.append(  $(\"<div class='markerpoint_haircross_x' style='background:\"+ that.p.color.getCSS() +\"'></div>\") );\n\t\t\t\t\t$a.append(  $(\"<div class='markerpoint_haircross_y' style='background:\" + that.p.color.getCSS() + \"; '></div>\") );\n\t\t\t\t\t\n\t\t\t\t\tif (that.master && that.parentmarkerset.showTrash)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (that.parentmarkerset.showTrash)\n\t\t\t\t\t\t\t$a.append( $(\"<span><i class='markerpoint_trash fa fa-trash'></i></span>\").click(function(){\n\t\t\t\t\t\t\tmarkerProxy.delSet(that.parentmarkerset.uuid)\n\t\t\t\t\t\t\t} ));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (that.parentmarkerset.optionalFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\t$a.append( $(\"<span><i class='markerpoint_trash fa \"+that.parentmarkerset.optionalFunction.icon+\"'></i></span>\").click(function(){\n\t\t\t\t\t\tthat.parentmarkerset.optionalFunction.operation(that.parentmarkerset);\n\t\t\t\t\t\t} ));\n\t\t\t\t\t}\n\n\n\n\t\t\t\t\tif(that.type=='pointROI' || that.parentmarkerset.state.showresizer)\n\t\t\t\t\t\t$a.$resizerB = $(\"<div class='markerpoint_resizer_sphere' style=''></div>\").appendTo($a);\n\t\t\t\t\tif(that.type=='pointROI')\n\t\t\t\t\t{\n\t\t\t\t\t\t//that.parentmarkerset.markerPanel.clone().appendTo($a)\n\t\t\t\t\t\t$a.$resizerZ = $(\"<div class='markerpoint_thresh_slider' style=''></div>\").appendTo($a);\n\t\t\t\t\t\t attachMouseSlider($a.$resizerZ, {\n\t\t\t\t\t\t\t\tmousedown: function(ev, dx, dy, mousedownvar) { return {startval: that.thresh  } },\n\t\t\t\t\t\t\t\tmousemove: function(ev, dx, dy, mousedownvar) {\n\t\t\t\t\t\t\t\t   var newval = (mousedownvar.startval + 1 * -dy *200);\n\t\t\t\t\t\t\t\t   newval = math.round(newval)\n\t\t\t\t\t\t\t\t   that.thresh = newval;\n\t\t\t\t\t\t\t\t   return {wasinrange:1, value: newval }\n\t\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\t\tmouseup: function(){\n\t\t\t\t\t\t\t\t\tthat.onupdate.pointROI();\n\t\t\t\t\t\t\t\t\tif(that.parentmarkerset.markerPanel)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar dummy = that.parentmarkerset.markerPanel.$markerListTable.children('[marker_uuid=\"'+that.uuid+'\"]');\n\t\t\t\t\t\t\t\t\t\tif(dummy.length>0 && dummy.find('input').length > 0)\n\t\t\t\t\t\t\t\t\t\t\tdummy.find('input').val(that.thresh);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} } \n\t\t\t\t\t\t\t);\t\t\t\t\t\t\n\t\t\t\t\t}\n\n\t            }\n\t            else if(that.shape == 'box' && that.type != '3druler')\n\t            {\n\t\t\t\t\t$a.addClass(\"markerrectangle markerpoint_box\") \n\t\t\t\t\t$a.$resizerB = $(\"<div class='markerpoint_resizer_box' style=''></div>\").appendTo($a);\n\t            }\n\t            \n\t            if(that.type == '3druler')\n\t            {\n\t\t\t\t\t$a.addClass(\"markerpoint markerpoint_3Druler\") \n\t\t\t\t\t$a.$resizerA = $(\"<div class='markerpoint_resizer markerpoint_3Druler_resizer'></div>\").appendTo($a);\n\t\t\t\t\t$a.$resizerB = $(\"<div class='markerpoint_resizer markerpoint_3Druler_resizer markerpoint_resizer_other'></div>\").appendTo($a);\n\t\t\t\t\t\n\t\t\t\t\t$a.$rulertext = $(\"<div class='markerpoint_3Druler_text'></div>\").appendTo($a);\n\t\t\t\t\t$a.$rulertextInner = $(\"<span class=''></span>\").appendTo($a.$rulertext);\n\t\t\t\t\t$a.$delete = $(\"<span><i class='markerpoint_trash fa fa-trash'></i></span>\").appendTo($a.$rulertext).click(function(){that.deletepoint()});\n\t\t\t\t\tif(that.parentmarkerset.state.locked)\n\t\t\t\t\t\t$a.$delete.hide();\n\n\t\t\t\t\tif (that.parentmarkerset.optionalFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\t$a.append( $(\"<span><i class='markerpoint_trash fa \"+that.parentmarkerset.optionalFunction.icon+\"'></i></span>\").click(function(){\n\t\t\t\t\t\tthat.parentmarkerset.optionalFunction.operation(that.parentmarkerset);\n\t\t\t\t\t\t} ));\n\t\t\t\t\t}\n\n\n\t\t\t\t\t$a.$rulersvg = $(\"<svg version='1.1' viewBox='-1 -1  1 1' preserveAspectRatio='none'><line x1='-1' x2='1' y1='-1' y2='1' style=''></svg>\").appendTo($a);\n\t            }\n\n\t            if(that.type == 'scribble')\n\t            {\n\t\t\t\t\t$a.addClass(\"markerpoint markerpoint_scribble\") \n\t\t\t\t\t$a.$comment = $(\"<div class='markerpoint_comment'></div>\").appendTo($a);\n\t\t\t\t\t$a.$delete = $(\"<span><i class='markerpoint_trash fa fa-trash'></i></span>\").appendTo($a).click(function(){that.deletepoint()});\n\t\t\t\t\t$a.$closescribble = $(\"<span><i class='markerpoint_trash fa fa-circle-o'></i></span>\").appendTo($a).click(function(){that.closescribble()});\n\n\t\t\t\t\tif (that.parentmarkerset.optionalFunction)\n\t\t\t\t\t{\n\t\t\t\t\t\t$a.append( $(\"<span><i class='markerpoint_trash fa \"+that.parentmarkerset.optionalFunction.icon+\"'></i></span>\").click(function(){\n\t\t\t\t\t\tthat.parentmarkerset.optionalFunction.operation(that.parentmarkerset);\n\t\t\t\t\t\t} ));\n\t\t\t\t\t}\n\n\t\t\t\t\tif(that.parentmarkerset.state.locked)\n\t\t\t\t\t\t$a.$delete.hide();\n\n\t\t\t\t\tvar pstr = '0,0,1,1';\n\t\t\t\t\tvar childstr = \"<polyline id='scribblepolygon' points='\" + pstr + \"' />\";\n\n\t\t\t\t\tvar cstr = \"<g class='scribble_circles' ></g>\";\n\t\t\t\t\tchildstr +=  cstr;\n\n\t\t\t\t\tvar gaussblur = 1;\n\t\t\t\t\tvar defs = \"<defs><filter id='svg_blur'> <feGaussianBlur stdDeviation='\"+gaussblur +\"' /> </filter> </defs>\";\n\t\t\t\t\t//$a.$scribblesvg = $(\"<svg version='1.1' viewBox='-1 -1  1 1' preserveAspectRatio='none'>\" + defs + childstr + \"</svg>\").appendTo($a);\n\t\t\t\t\t$a.$scribblesvg = $(\"<svg version='1.1' _viewBox='-1 -1  1 1' _preserveAspectRatio='none'>\" + defs + childstr + \"</svg>\").appendTo($a);\n\t\t\t\t\t$a.$scribblepolyline = $a.$scribblesvg.find('polyline');\n\t\t\t\t\t$a.$scribblecirclegroup = $a.$scribblesvg.find('.scribble_circles');\n\t\t\t\t\n\t            }\n\n\n\n\n\t\t\t\t// version with creation hover elements on demand: perform creation in hover function\n\t\t\t\tif( !recreateInfoBoxOnHover)\n\t\t\t\t{\n\t\t\t\t\t var $props = $(\"<div class='markerpoint_props' style='visibility:hidden'></div>\");\n\t\t\t\t\t var thingstoshow = {colorsel:1, id:1, name:1, toggle:0, search:0, delete:1,  coords:1,comment:1};\n\t\t\t\t \t $props.append( that.createMarkerRepresentation('self' + mid, thingstoshow ) ).appendTo($a);\n\t\t\t\t\t that.runcallbacks('createinfobox', $props);\n\t\t\t\t}\n\n\t\t\t\t// ?? sethover_singleVP is also set in createMarker  but probably we need, this, eg if new viewport is created\n\t\t\t\tsethover_singleVP($a, {locked: that.parentmarkerset.state.locked, hoverdetails:that.parentmarkerset.state.hoverdetails });\n       \t    }\n\t\t\n\t\t\t\n            \n    \n    \t\t$a.medViewer = medViewer;\n\t\t\t\n            medViewer.$canvascontainer.append($a);\n            $markers[mid] = $a;\n\n\n        }\n\n    \t// calc apparent size in this slice\n    \tif(that.shape == 'sphere')\n    \t{\n    \t\tvar size_true_x =  that.p.size;\n    \t\tvar size_true_y =  that.p.size;\n\t\t\tvar size_apparent_x  = math.sqrt(math.pow(size_true_x,2) - math.pow(canvascoords.z_mm - medViewer.getCurrentSliceInMM(),2) ) *canvascoords.x_pixPerMM * 2;\n\t\t\tvar size_apparent_y  = size_apparent_x;\n\t\t\t\n\t\t\tvar isInside = size_apparent_y >0;\n\t\t\t\n\t\t\tif(!isInside && that.shape != 'scribble')\n\t\t\t{\n\t\t\t\tvar minrad = 2;\n\t\t\t\tvar size_apparent_x = math.min(size_true_x, minrad) ;\n\t\t\t\tvar size_apparent_y = math.min(size_true_y, minrad) ;\n\t\t\t}\n\n    \t}\n    \telse if(that.shape == 'box' )\n    \t{\n    \t\tvar plu = medViewer.getCanvasCoordinates( math.add(that.p.coords, that.p.size)._data );\n    \t\tvar prd = medViewer.getCanvasCoordinates( math.add(that.p.coords, math.multiply(that.p.size, -1))._data );\n\n    \t\tvar size_true_x =  math.abs(plu.x_pix - prd.x_pix)*1;\n\t\t\tvar size_true_y =  math.abs(plu.y_pix - prd.y_pix)*1;\n    \t\t\n    \t\tvar size_apparent_x = size_true_x;\n    \t\tvar size_apparent_y = size_true_y;\n\n\t\t\tvar zz = medViewer.getCurrentSliceInMM();\n\t\t\tvar isInside  =  zz > Math.min(plu.z_mm, prd.z_mm) && zz < Math.max(plu.z_mm, prd.z_mm)\n\n\t\t\t\n\t\t\tvar dy = (plu.y_pix-prd.y_pix)/plu.y_pixPerMM ;\n\t\t\tvar dx = (plu.x_pix-prd.x_pix)/plu.x_pixPerMM;\n\t\t\tvar yf = dy>0?-1:1;\n\t\t\tvar xf = dx>0?-1:1;\n\t\t\tvar ss = 50;\n\t\t\t//var ss = 0;\n\t\t\t$markers[mid].css('transform','scale('+xf+','+yf+') translate('+(-xf*ss)+'%,'+(-yf*ss)+'%)');\n  \t\t\tif(that.type == '3druler')\n\t\t\t{\n\t\t\t\tif($markers[mid].$rulertext)\n\t\t\t\t{\n\t\t\t\t\t$markers[mid].$rulertext.css('transform','scale('+xf+','+yf+') translate('+(-xf*ss)+'%,'+(-yf*0)+'%)');\n\t\t\t\t\tvar inPlaneLength = Math.sqrt( dy*dy + dx*dx );\n\t\t\t\t\t$markers[mid].$rulertextInner.text(inPlaneLength.toFixed(1) + ' mm');\n\t\t\t\t}\n\t\t\t\t// ruler:show always\n\t\t\t\tisInside  = true;\n\t\t\t}\n    \t}\n    \telse if(that.shape == 'scribble')\n    \t{\n    \t\tsize_true_x = .1;\n\t\t\t//var test  = math.sqrt(math.pow(size_true_x,2) - math.pow(canvascoords.z_mm - medViewer.getCurrentSliceInMM(),2) ) *canvascoords.x_pixPerMM * 2;\n\t\t\tvar test  = math.abs(canvascoords.z_mm - medViewer.getCurrentSliceInMM()) \n\t\t\tvar isInside = test < medViewer.nii.voxSize[medViewer.getSlicingDimOfArray()]*.3;    \t\t\n\t\t\tsize_apparent_x = 3;\n\t\t\tsize_apparent_y = 3;\n    \t}\n    \t\n\t\t// this should go down, firstcondition etc\n    \tif(that.parentmarkerset.type == 'scribble')\n    \t{\n\n\t\t\tvar pstr = \"\";\n\t\t\t\n\t\t\t$markers[mid].$scribblecirclegroup.empty();\n\t\t\tvar cstr = \"\";\n\n\t\t\tfor (var i = 0; i < that.subpoints.length; i++)\n\t\t\t{\n\t\t\t\tvar cc = medViewer.getCanvasCoordinates(that.subpoints[i]); \n\t\t\t\tvar dx =cc.x_pix- canvascoords.x_pix;\n\t\t\t\tvar dy =cc.y_pix- canvascoords.y_pix;\n\t\t\t\tpstr +=  dx.toFixed(2) + ',' + dy.toFixed(2) + \" \" \n\t\t\t\tvar circleradius = 5;\n\t\t\t\tcstr = cstr + \"<circle class='polygonCircle' ind =\" + i + \" cx=\" + dx.toFixed(2) + \" cy=\" + dy.toFixed(2) + \" r=\" + circleradius + \" fill='\"+that.p.color.getCSS()+\"' stroke-width=\" + 0 + \"/>\";\n\t\t\t}\n\t\t\t// add very first point to close scribble\n\t\t\tif(that.subpoints.length > 0 && that.isclosed )\n\t\t\t{\n\t\t\t\tvar cc = medViewer.getCanvasCoordinates(that.subpoints[0]); \n\t\t\t\tvar dx =cc.x_pix- canvascoords.x_pix; var dy =cc.y_pix- canvascoords.y_pix;\n\t\t\t\tpstr +=  dx.toFixed(2) + ',' + dy.toFixed(2) + \" \" \n\t\t\t}\n\n\t\t\t$markers[mid].$scribblecirclegroup.html(cstr)\n\t\t\t\n\t\t\t/**************************/\n\t\t\t// subpoint handling\n\t\t\tvar $circles = $markers[mid].$scribblecirclegroup.children();\n\n\t\t\tfor (var k = 0; k < $circles.length; k++)\n\t\t\t\t$circles.eq(k).mousedown(cmousedown).mouseover(cmouseover).mouseout(cmouseout)\n\n\t\t\t// mouse handler for the single points\n\t\t\tfunction cmouseover(ev) { ev.target.setAttribute('r', circleradius * 1.3); }\n\t\t\tfunction cmouseout(ev) { ev.target.setAttribute('r', circleradius); }\n\n\t\t\tfunction cmousedown(ev, ev2)\n\t\t\t{\n\t\t\t\tif (ev2 !== undefined)\n\t\t\t\t\tev = ev2;\n\t\t\t\t// delete with right click\n\t\t\t\tif (ev.button == 2)\n\t\t\t\t{\n\t\t\t\t\tvar pindex = parseInt(this.getAttribute('ind'))\n\t\t\t\t\t// cannot delet first point\n \t\t\t\t\tif(pindex == 0)//that.subpoints.length-1)\n \t\t\t\t\t{\n \t\t\t\t\t\talertify.error('cannot delete first point')\n \t\t\t\t\t\treturn false\n \t\t\t\t\t}\n\n\t\t\t\t\tthat.subpoints.splice(pindex, 1);\n\n\t\t\t\t\tcmouseup(ev);\n\t\t\t\t\tthat.drawpoint();\n\t\t\t\t\tev.stopPropagation(); return false;\n\t\t\t\t}\n\n\t\t\t\tvar pindex = parseInt(this.getAttribute('ind'));\n\t\t\t\t//var startpos = [parseInt(this.getAttribute('cx')) - ev.clientX, parseInt(this.getAttribute('cy')) - ev.clientY];\n\t\t\t\tvar $a = $markers[mid];\n\t\t\t\tvar cc = medViewer.getCanvasCoordinates(that.subpoints[pindex]);\n\t\t\t\tvar startpos = [ev.clientX - $a.offset().left - 0*cc.x_pix, ev.clientY - $a.offset().top - cc.y_pix ];\n\n\t\t\t\t$(document).on(\"mousemove\", function(ev) { cmousemove(ev, pindex, startpos)  });\n\t\t\t\t$(document).on(\"mouseup mouseleave\", cmouseup);\n\t\t\t\t$circles = $markers[mid].$scribblecirclegroup.children();\n\t\t\t\tev.stopPropagation(); \n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\tfunction cmousemove(ev, pindex, startpos)\n\t\t\t{\n\n\t\t\t\tvar newX = startpos[0] + ev.clientX;\n\t\t\t\tvar newY = startpos[1] + ev.clientY;\n\t\t\t\t//var p = medViewer.getRealWorldCoordinatesFromMouseEvent(ev.clientX - startpos[0]  , ev.clientY - startpos[1]);\n\t\t\t\tvar p = medViewer.getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY);\n\n\t\t\t\tthat.subpoints[pindex] = p._data;\n\t\t\t\t//that.drawpoint();\n\t\t\t\tvar cc = medViewer.getCanvasCoordinates(that.subpoints[pindex]); \n\t\t\t\tvar dx =cc.x_pix- canvascoords.x_pix;\n\t\t\t\tvar dy =cc.y_pix- canvascoords.y_pix;\n\t\t\t\t$circles.eq(pindex).attr('cx', dx).attr('cy', dy);\n\n\t\t\t\tvar pstr = \"\";\n\t\t\t\tvar tlen = that.subpoints.length;\n\t\t\t\tvar cc, dx\n\t\t\t\tfor (var i = 0; i < tlen; i++)\n\t\t\t\t{\n\t\t\t\t\tcc = medViewer.getCanvasCoordinates(that.subpoints[i]); \n\t\t\t\t\tdx =cc.x_pix- canvascoords.x_pix; var dy =cc.y_pix- canvascoords.y_pix;\n\t\t\t\t\tpstr +=  dx.toFixed(2) + ',' + dy.toFixed(2) + \" \" \n\t\t\t\t}\n\t\t\t\t// add very first point to close scribble\n\t\t\t\tif(tlen > 0 && that.isclosed )\n\t\t\t\t{\n\t\t\t\t\tcc = medViewer.getCanvasCoordinates(that.subpoints[0]); \n\t\t\t\t\tdx =cc.x_pix- canvascoords.x_pix; var dy =cc.y_pix- canvascoords.y_pix;\n\t\t\t\t\tpstr +=  dx.toFixed(2) + ',' + dy.toFixed(2) + \" \" \n\t\t\t\t}\n\t\t\t\t\n\t\t\t\t$markers[mid].$scribblepolyline.attr('points', pstr);\n\t\t\t\tif(pindex == that.subpoints.length-1)\n\t\t\t\t\tcmousemove(ev, 0, startpos);\n\t\t\t\tev.stopPropagation(); return false;\n\t\t\t}\n\n\t\t\tfunction cmouseup(ev) { $(document).off(\"mousemove mouseup mouseleave\"); ev.stopPropagation(); return false; }\n\n\t\t\t/**************************/\n\n\t\t\t\n\t\t\t$markers[mid].$scribblepolyline.attr('points', pstr);\n\t\t\tvar opacity = (isInside)?that.p.color.getOpacity():0.4;\n\t\t\t$markers[mid].$scribblepolyline.css({stroke: that.p.color.getCSS(), opacity:opacity })\n\n    \t}\n\n\n\t\tvar firstcondition = true;\n\n\t\tif( that.parentmarkerset.state.showOnAllImages == 0 && that.referencedImageFilename != medViewer.getFullFilename())\n\t\t\tfirstcondition = false;\n\n\t\t\n\t\n\t    //if(  firstcondition && ( ( size_apparent_x >= 0  && size_apparent_y >= 0   ) ) | that.parentmarkerset.state.showThroughSlice)\n\t    if(  firstcondition &&  ( isInside | that.parentmarkerset.state.showThroughSlice) )\n\t    {\n\t    \tif( isInside )\n\t    \t{\n\t\t\t\tvar opac = 1; //siz_apparent / siz_true;\n\t\t\t\tvar thick = (1 + 3 * (opac>.95));\n\t    \t}\n\t    \telse\n\t    \t{\n\t\t\t\tvar opac = 0.3;\n\t\t\t\tvar thick = 3;\n\t    \t}\n\n\t\t\t$markers[mid].css( {\n\t\t\t\tleft:canvascoords.x_pix+'px', \n\t\t\t\ttop:canvascoords.y_pix+'px', \n\t\t\t\tborderColor: that.p.color.getCSS(), \n\t\t\t\topacity:opac, \n\t\t\t\tborderWidth:thick \n\t\t\t\t} );\n\t\t\t\n\t\t\t// unfortunately, must reset color here every time, due to drawing with timeouts\n\t\t\tif($markers[mid].$resizerA)\n\t\t\t\t$markers[mid].$resizerA.css('background', that.p.color.getCSS());\n\t\t\tif($markers[mid].$resizerB)\n\t\t\t\t$markers[mid].$resizerB.css('background', that.p.color.getCSS());\n\n\t\t    \n\t\t    if(that.type == 'ruler' | that.type == 'rectangles')\n\t\t    {\n\t\t    \tvar dir = that.dir;\n\t\t\t\tvar l = Math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]);\n\t\t\t\tvar deg = Math.atan2(-dir[1],-dir[0])/Math.PI*180;\n\t\t    \t$markers[mid].css( {width:l*canvascoords.x_pixPerMM+\"px\", transform:\"translate(-50%,-50%) rotate(\"+deg+\"deg)\" });\n\t\t    \tif (that.type == 'ruler')\n\t\t    \t{\n\t\t    \t\t$markers[mid].$textspan.text(l.toFixed(1)+\"mm\")\n\t\t    \t\t$markers[mid].css( {background:  that.p.color.getCSS(),\n\t\t\t\t\t\t\t\t\t\t\t  borderColor: that.p.color.getCSS()});\n\t\t    \t\t$markers[mid].$term_a.css( {background:  that.p.color.getCSS(),\n\t\t\t\t\t\t\t\t\t\t\t  borderColor: that.p.color.getCSS()});\n\t\t    \t\t$markers[mid].$term_b.css( {background:  that.p.color.getCSS(),\n\t\t\t\t\t\t\t\t\t\t\t  borderColor: that.p.color.getCSS()});\n\t\t    \t}\n\t\t    \telse if (that.type == 'rectangles')\n\t\t    \t{\n\t\t\t\t\tdeg = 90-deg;\n\t\t\t\t\t$markers[mid].$rect.css( {width:Math.abs(canvascoords.x_pixPerMM*dir[1])+\"px\",\n\t\t\t\t\t\t\t\t\t\t\t  height:Math.abs(canvascoords.x_pixPerMM*dir[0])+\"px\",\n\t\t\t\t\t\t\t\t\t\t\t  //background:  that.p.color.getCSS(),\n\t\t\t\t\t\t\t\t\t\t\t  borderColor: that.p.color.getCSS(),\n\t\t\t\t\t\t\t\t\t\t\t  left:(-Math.abs(dir[1])+l)*canvascoords.x_pixPerMM/2+\"px\",\n\t\t\t\t\t\t\t\t\t\t\t  top:-Math.abs(dir[0])*canvascoords.x_pixPerMM/2+\"px\",\n\t\t\t\t\t\t\t\t\t\t\t  transform:\"translate(0%,0%) rotate(\"+deg+\"deg)\"});\n\t\t\t\t\t$markers[mid].$term_a.css({ background: that.p.color.getCSS()  });\n\t\t\t\t\t$markers[mid].$term_b.css({ background: that.p.color.getCSS()  });\n\t\t    \t}\n\n\t\t    }   \n\t\t    else\n\t\t    {\n\t\t    \t$markers[mid].css( {width: size_apparent_x , height:  size_apparent_y })\n\t\t    }\n\n\t    }\n\t    else\n\t    {\n\t\t\tvar siz = -2;\n\t\t\tvar opac = 0;\n\t\t\tcanvascoords.x_norm = -1000;               canvascoords.y_norm = -1000;\n\t\t\t$markers[mid].css( {left:canvascoords.x_norm*100+'%', top:canvascoords.y_norm*100+'%', width:siz, height:siz, borderColor: that.p.color.getCSS()} );\n\t    }\n\n        \n    }\n\n\n    /***************************************************************************************\n    * a general marker representation (coordinates, properties, callbacks)\n    ****************************************************************************************/\n\tthat.createMarkerRepresentation = function(targetid, thingstoshow)\n\t{\n\t\tvar point = that;\n\n\t\t// the shown fields for this representation can be set here.\n\t\tvar fields = {radius:1,economy:0, colorsel:1, id:1, name:1, pointROI: 0, toggle:1, search:1, delete:0, active:0, coords:1,coords_transformed:0};\n\t\t$.extend(true, fields, thingstoshow )\n\n\t\tvar $box  = $(\"<div class='markerpointrow'></div>\").on('onmouseenter', point.onHoverEnter ).on('onmouseleave', point.onHoverLeave );\n\t\tvar $row1  = $(\"<div class='markerpointrow_info'></div>\").appendTo($box);\n\n\n\t\t///////////////// the coordinates fields ////////////////////////////////////\n\t\tif(fields.coords)\n\t\t{\t\t\n\t\t\tfunction updateInputsC(which)\n\t\t\t{\n\t\t\t\treturn function(ev) { updateInputs(which); ev.stopPropagation();return false; }\n\t\t\t}\n\n\t\t\tvar $row2;\n\t\t\tif (fields.economy)\n\t\t\t\t$row2 = $row1;\n\t\t\telse\n\t\t\t    $row2  = $(\"<div class='markerpointrow_coords'></div>\").appendTo($box);\n\t\t\tvar $coords = $(\"<div class='markerpoint_coords' ></div>\").appendTo($row2);\n\t\t\t\t //var $innercords = $(\"<div class='' ></div>\").appendTo($coords);\n\t\t\t\t var $innercords = $coords;\n\t\t\t\t $innercords.append( $(\"<div><input type = 'number' value='\"+ point.p.coords[0].toFixed(1) +\"' /></div>\").on('change', updateInputsC(0)) );\n\t\t\t\t $innercords.append( $(\"<div><input type = 'number' value='\"+ point.p.coords[1].toFixed(1) +\"' /></div>\").on('change', updateInputsC(0)) );\t\t\t\t\t\t\n\t\t\t\t $innercords.append( $(\"<div><input type = 'number' value='\"+ point.p.coords[2].toFixed(1) +\"' /></div>\").on('change', updateInputsC(0)) );\n\t\t\tif (fields.radius)\n\t\t\t{\n\t\t\t\tif(that.shape =='sphere')\n\t\t\t\t{\n\t\t\t\t\tvar sizestring = point.p.size.toFixed(1);\n\t\t\t\t \t$innercords.append( $(\"<div><input type = 'number' value='\"+ sizestring +\"' /></div>\").on('change', updateInputsC(3)) );\n\t\t\t\t}\n\t\t\t\telse if(that.shape == 'box')\n\t\t\t\t{\n\t\t\t\t\tvar sizestring = point.p.size[0].toFixed(1) + \",\" + point.p.size[1].toFixed(1) + \",\" + point.p.size[2].toFixed(1);\n\t\t\t\t \t$innercords.append( $(\"<div><input type = 'text' value='\"+ sizestring +\"' /></div>\").on('change', updateInputsC(3)) );\n\t\t\t\t}\n\n\t\t\t}\n\t\t    if (fields.coords_transformed && KViewer.reorientationMatrix.notID)\n\t\t    {\n\t\t\t\t $coords.append( $(\"<br>\") );\n\t\t\t\t //var $inner = $(\"<div class='' ></div>\").appendTo($coords);\n\t\t\t\t var coords = markerProxy.to_transformed(point.p.coords  )._data\n\t\t\t\t var $inner = $coords;\n\t\t\t\t $inner.append( $(\"<div><input type = 'number' value='\"+ coords[0].toFixed(1) +\"' /></div>\").on('change', updateInputsC(1)) );\n\t\t\t\t $inner.append( $(\"<div><input type = 'number' value='\"+ coords[1].toFixed(1) +\"' /></div>\").on('change', updateInputsC(1)) );\n\t\t\t\t $inner.append( $(\"<div><input type = 'number' value='\"+ coords[2].toFixed(1) +\"' /></div>\").on('change', updateInputsC(1)) );\n\t\t    }\n\t\t    if (fields.comment)\n\t\t    {\n\t\t\t\t $coords.append( $(\"<br>\") );\n\t\t\t\t //var $inner = $(\"<div class='' ></div>\").appendTo($coords);\n\t\t\t\t var $inner = $coords;\n\t\t\t\t $inner.append( $(\"<div><input class='pointcomment' type = 'text' placeholder='a comment' value='\"+ point.p.comment +\"' /></div>\").on('change', updateInputsC(2)) );\t\t    \t\n\t\t    }\n\t\t\tvar $inputs = $coords.find(\"input\");  \n\n\t\t\tfunction updateInputs(which)\n\t\t\t{\n\t\t\t\t var coords;\n\t\t\t\t if (which == 0)\n\t\t\t\t {\n\t\t\t\t    coords = [ parseFloat( $inputs[0].value), parseFloat( $inputs[1].value ), parseFloat( $inputs[2].value ),1   ];\n\t\t\t  \t    point.movepoint(coords);\n\t\t\t\t }\n\t\t\t\t else if (which == 1)\n\t\t\t\t { \n\t\t\t\t    coords = [ parseFloat( $inputs[4].value), parseFloat( $inputs[5].value ), parseFloat( $inputs[6].value ),1   ];\n\t\t\t\t    coords = markerProxy.to_transformed(coords)._data\n\t\t\t  \t    point.movepoint(coords);\n\t\t\t\t }\n\t\t\t\t else if (which == 3)\n\t\t\t\t\t point.setsize( parseFloat( $inputs[3].value)  );\n\t\t\t\t else if (which == 2)\n\t\t\t\t {\n\t\t\t\t \t   point.p.comment = $coords.find(\".pointcomment\").eq(0).val();\n\t\t\t\t \t   that.runcallbacks('changeProps')\n\t\t\t\t }\n\n\t\t\t\tif(!point.parentmarkerset.state.ignoremodified)\n\t\t\t\t{\n\t\t\t\t\t markerProxy.modified = true;\n\t\t\t\t\t point.parentmarkerset.modified = true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t\tpoint.callbacks.move[targetid] = function()\n\t\t\t{     \n\t\t\t\t\tif(that.shape =='sphere')\n\t\t\t\t\t\tvar sizestring = point.p.size.toFixed(1);\n\t\t\t\t\telse if(that.shape =='box')\n\t\t\t\t\t\tvar sizestring = point.p.size[0].toFixed(1) + \",\" + point.p.size[1].toFixed(1) + \",\" + point.p.size[2].toFixed(1);\n\n\t\t\t\t  $inputs.eq(0).val(point.p.coords[0].toFixed(1))\n\t\t\t\t  $inputs.eq(1).val(point.p.coords[1].toFixed(1))\n\t\t\t\t  $inputs.eq(2).val(point.p.coords[2].toFixed(1))\n\t\t\t\t  $inputs.eq(3).val( sizestring )\n \t\t\t\t  if (fields.coords_transformed &&  KViewer.reorientationMatrix.notID)\n\t\t\t\t  {\n\t\t\t\t\t  var coords_transformed =  markerProxy.to_transformed(point.p.coords   );\n\t\t\t\t\t  $inputs.eq(4).val(coords_transformed._data[0].toFixed(1))\n\t\t\t\t\t  $inputs.eq(5).val(coords_transformed._data[1].toFixed(1))\n\t\t\t\t\t  $inputs.eq(6).val(coords_transformed._data[2].toFixed(1))\n\t\t\t\t\t  /*if (KViewer.reorientationMatrix.notID)\n\t\t\t\t\t  {\n\t\t\t\t\t  \t$inputs.eq(4).show();\n\t\t\t\t\t  \t$inputs.eq(5).show();\n\t\t\t\t\t  \t$inputs.eq(6).show();\n\t\t\t\t\t  }\n\t\t\t\t\t  else\n\t\t\t\t\t  {\n\t\t\t\t\t  \t$inputs.eq(4).hide();\n\t\t\t\t\t  \t$inputs.eq(5).hide();\n\t\t\t\t\t  \t$inputs.eq(6).hide();\n\n\t\t\t\t\t  }*/\n\n\t\t\t\t  }\n\t\t\t\t//  markerProxy.modified = true;\n\t\t\t}\n\n\t\t\tif (that.parentmarkerset.type == 'electrode' && that.isContact)\n\t\t\t{\n\t\t\t\t\n\t\t\t\tvar voltage = (point.p.voltage == undefined)?\"\":point.p.voltage.toFixed(2);\n\t\t\t\t$coords.append( $(\"<div class='DBS_simindicator'> simulation </div><input class='DBS_nosimindicator' value='\"+voltage+\"' type = 'number' placeholder='voltage' min=0 max=50 />\").on('change',function(e)\n\t\t\t\t{\n\t\t\t\t\tvar voltage = parseFloat(e.target.value)\n\t\t\t\t\tif (isNaN(voltage))\n\t\t\t\t\t{\n\t\t\t\t\t\tpoint.p.voltage = undefined\n\t\t\t\t\t\tpoint.setsize( 1);\n\t\t\t\t\t}\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t\t\tvar impedance = that.parentmarkerset.electrode_properties.impedance;\n\t\t\t\t\t\tvar k = that.parentmarkerset.electrode_properties.approx_maedler;\n\t\t\t\t\t\tfunction approx(r,imp)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\treturn k[0]*0 + k[1]*r + k[4]*r*imp + k[3]*r*r + k[2]*imp + k[5]*imp*imp;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (voltage > 0 && voltage < 20)\n\t\t\t\t\t\t\tvar radius = binsearch(function(x) { return approx(x,impedance)},Math.abs(voltage),0,20,0.01);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tvar radius = 1;\n\t\t\t\t\t\tpoint.p.voltage = voltage\n\t\t\t\t\t\tpoint.setsize( radius );\n\t\t\t\t    }\n\t\t\t\t\te.stopPropagation();\n\t\t\t\t\treturn false;\n\t\t\t\t}));\n\t\t\t\tthat.sim_indicator = $innercords.find(\".DBS_simindicator\").hide();\n\t\t\t\tthat.voltage_indicator = $innercords.find(\".DBS_nosimindicator\");\n\t\t\t\tthat.sim_indicator.on(\"mouseenter\",function(e)\n\t\t\t\t{\t\t\t\t\t\n\t\t\t\t\tif (that.showSimInfo != undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar $info = that.showSimInfo(e);\t\t\t\t\t\t\n\t\t\t\t\t\t$(this).on(\"mouseleave\",function($d) { return function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t$d.remove() } }($info));\n\t\t\t\t\t}\n\t\t\t\t});\n\t\t\t}\n\n\n\t\t}\n\n\n\n\n\t\tif(fields.colorsel)\t\t\n\t\t\tvar\t$colorselector = KColorSelectorSimple($(\"<div class='markerpointrow_colorselector'></div>\"), point.setcolor, point.p).appendTo($row1);\n\n\t\tif(fields.name)\n\t\t{\t\t\n\t\t\tvar $name = $(\"<div contenteditable='true'>\"+point.p.name+\"</div>\").appendTo($row1);\n\t\t\tKSetContentEditable( $name, point.changeName  );\n\t\t\t$name.click(function(){ document.execCommand(\"selectall\",null,false);});\n\t\t\tpoint.callbacks.changeProps[targetid] = function()\n\t\t\t{\n\t\t\t\t// only reset if default name was auto --reset\n\t\t\t\tif($name.html() != point.p.name)\n\t\t\t\t\t$name.html(point.p.name);\n\n\t\t\t\t// set color of selector\t\n  \t    \t \t$colorselector.css('background', point.p.color.getCSS());\n \t    \t \t\n  \t    \t \tvar $comment = $box.find(\".pointcomment\");\n  \t    \t \tif ($comment.length>0)\n  \t    \t \t\t$comment.eq(0).val(point.p.comment);\n\t\t\t}\n\t\t}\n\t\t\t\n\t\t// tools at the right hand side\n\t\tvar $tools = $(\"<div class='markerpointrow_tools'></div>\").appendTo($row1);\n\t\t\n\n\n\t   if (fields.active)\n\t\t{\t\t\n\t        var $active = $(\"<i class='fa fa-circle-o'></i>\").appendTooltip('activepoint')\n\t        \t.click(  function()\n\t        \t\t{\n\t        \t\t\t//that.markerPanel.setCurrentSet(point.parentmarkerset);\n\t        \t//\t\tmarkerProxy.setCurrentSet(that.parentmarkerset, true);\n\t        \t\t\tpoint.select()\n\n\t        \t\t}).appendTo($tools);\n\t\t\tpoint.callbacks.active[targetid] = function(point)\n\t\t\t{\n\t\t\t\tif(point.active == 0)\n\t\t\t\t\t $active.addClass(\"fa-circle-o\").removeClass(\"fa-circle\").css('color', 'white');\n\t\t\t\telse if(point.active == -1)\n\t\t\t\t\t $active.removeClass(\"fa-circle-o\").addClass(\"fa-circle\").css('color', 'yellow');\n\t\t\t\tif(point.active == 1)\n\t\t\t\t\t $active.removeClass(\"fa-circle-o\").addClass(\"fa-circle\").css('color', 'red');\n\t\t\t}\n\t\t\tpoint.callbacks.active[targetid](point);\n\t\t}\n\n\t\tif(fields.toggle)\n\t\t{\t\t\n\t        var $toggle = $(\"<i class='fa fa-eye'></i>\").appendTooltip('showhidemarkerpoint').click(  function(){point.togglepoint()}   ).appendTo($tools);\n\t\t\tpoint.callbacks.toggle[targetid] = function(point)\n\t\t\t{\n\t\t\t\tif(point.visible)\n\t\t\t\t\t $toggle.addClass(\"fa-eye\").removeClass(\"fa-eye-slash\").css('color', '');\n\t\t\t\telse\n\t\t\t\t\t $toggle.removeClass(\"fa-eye\").addClass(\"fa-eye-slash\").css('color', '');\n\t\t\t}\n\t\t\tpoint.callbacks.toggle[targetid](point);\n\t\t}\n\n\n\n\t\tif(fields.search)\t\t\n        \tvar $search = $(\"<i class='fa fa-binoculars'' style='font-size:12px'></i>\").appendTooltip(\"jumptopoint\").mousedown( point.jumpToPoint ).appendTo($tools); \n    \tif(fields.delete)\t\t\n\t        var $delete = $(\"<i class ='fa fa-trash '></i>\").appendTooltip('deletemarkerpoint').click( point.deletepoint   ).appendTo($tools);\n\t\t \n    \tif(point.type =='pointROI')\n    \t{\n    \t\tif(point.thresh != undefined)\n    \t\t\tvar thresh = point.thresh;\n    \t\telse\n    \t\t\tvar thresh = that.parentmarkerset.state.pointROIthresh;\n\n\t\t\tvar $thresh =  $(\"<input style='display:inline' type = 'text' min='0' step=1 value='\"+thresh+\"' /> \").appendTo($tools).on('change', \n\t\t\t\tfunction (ev) {\tpoint.onupdate.pointROI(undefined,undefined, parseFloat($thresh.val()) ) });\n\t\t\tKMouseSlider( $thresh, {min:-Infinity, incrementPerPixel: 1,  updateonmove: 0, updateonrelease: 1,  hideCurrentval: 0});\n    \t}\n\t\t\n\t\t\n\t\tpoint.callbacks.delete[targetid] = function()\n\t\t{\n\t\t\t$box.remove();\n\t\t}\n\n\t\treturn $box;\n\t}\n\n\n\n \n\n\n\n\n    /***************************************************************************************\n    * point in 3D VP\n    ****************************************************************************************/\n\tvar glmesh = {};\n\tthat.glmesh =glmesh;\n    function drawpoint_3D(medViewer, mid)\n    {\n    \t  if(medViewer.viewport.pointROIviewer == undefined)\n    \t  {\n\t\t\t  //var col = hexToRgb(that.p.color);\n\t\t\t  if (glmesh[mid] == undefined )\n\t\t\t  {\n\t\t\t\t\tglmesh[mid] = medViewer.gl.createMarkerMesh(that);\n\t\t\t\t\tglmesh[mid].viewer = medViewer;\n\t\t\t\t\tmedViewer.gl.activateRenderLoop();\n\n\t\t\t  }\n\t\t\t  else\n\t\t\t  {\n\t\t\t\t\tglmesh[mid].setpoint(that);\n\t\t\t  }\n    \t  }\n    \t  else\n    \t  {\n    \t  \t if (glmesh[mid] != undefined)\n    \t  \t {\n    \t  \t \tglmesh[mid].dispose();\n    \t  \t \tglmesh[mid] = undefined;\n    \t  \t }\n    \t  }\n    }\n            \n                        \n\n\n\n\n    /***************************************************************************************\n    * point jump\n    ****************************************************************************************/\n\n     that.jumpToPoint = function(ev)\n     {\n          // do not set to current set on point search.\n          //markerProxy.setCurrentSet( that.parentmarkerset, false )\n\n          KViewer.currentPoint = math.matrix(that.p.coords);\n          //signalhandler.send(\"positionChange\");\n\t\t  // on right click, center view around point\n\t\t  if(ev.button != 0)\n          \tsignalhandler.send(\"positionChange centralize\");\n          else\n          \tsignalhandler.send(\"positionChange\");\n          \n          that.runcallbacks('jumptopoint');\n     }\n\n\n\n    /***************************************************************************************\n    * event handlers\n    ****************************************************************************************/\n\n\tthat.sethover = function(state)\n\t{\n\t\t if (state.locked != undefined)\n\t\t \tthat.locked = state.locked;\n\t\t for(var mid in $markers)   \n\t\t {   \n\t\t \tsethover_singleVP($markers[mid], state)\n\t\t }\n\n\t}\n\t\n\tfunction sethover_singleVP($a, state)\n\t{\n\t\n\t\t//  no hover for the scribble, makes no sense\n\t\tif($a.$scribblesvg != undefined )\n\t\t\treturn;\n\n\t\tvar lastScrollEvent \n\t\t\n\t\tif(state.locked == false)\n\t\t{\n\t\t\tfunction MouseWheelHandler(ev)\n\t\t\t{\n\t\t\t\tev = ev.originalEvent || ev;\n\t\t\t\tif (!ev.shiftKey | that.parentmarkerset.state.fixedsize)\n\t\t\t\t\treturn;\n\t\t\t\tvar amount = (ev.wheelDelta || -ev.detail ) > 0?1:-1;\n\t\t\t\tthat.incsize( amount, $a.medViewer );\n\t\t\t\tthat.drawpoint();\n\t\t\t\t\n\t\t\t\t// should be done with timeout in order not\n\t\t\t\tif (that.roinii && that.roinii.fileObject)\n\t\t\t\t{\n\t\t\t\t\tlastScrollEvent = Date.now();\n\t\t\t\t\tvar deadtime = 300;\n\t\t\t\t\twindow.setTimeout(function(){\n\t\t\t\t\tif(Date.now() - lastScrollEvent >= deadtime-1) \n\t\t\t\t\t{\n\t\t\t\t   \t//\tsignalhandler.send(\"updateImage\",{id:that.roinii.fileObject.fileID});\n\t\t\t\t   \t//\tKViewer.roiTool.update3D(that.roinii.fileObject);\n\t\t\t\t\t}\n\n\t\t\t\t}, deadtime)\n\t\t\t\t}\n\n\t\t\t\tev.preventDefault();\n\t\t\t\tev.stopPropagation();\n\t\t\t\treturn false;\n\t\t\t}\n\n\t\t\t/* move handler to move point */\n\t\t\tfunction mousedown(ev) \n\t\t\t{\n\t\t\t\tif (state.locked == true)\n\t\t\t\t{\t\t\n\t\t\t\t\tKViewer.currentPoint = math.matrix(that.p.coords);\n\t\t\t\t\tsignalhandler.send(\"pointChanged\");   \n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// set the 3D roi so that surface is calculated in 3D roi is shown\n\t\t\t\tif(that.parentmarkerset.type == 'pointROI' && that.roinii && that.roinii.fileObject)\n\t\t\t\t{\n\t\t\t\t\tif(ev.which ==  1)\n\t\t\t\t\t\tthat.roinii.setThisPointInto3DView();\n\t\t\t\t}\n\n\t\t\t\tvar startdiff = [ev.clientX - $a.offset().left - $a.width()/2 - 4, ev.clientY - $a.offset().top - $a.height()/2 -4 ];\n\t\t\t\t\n\n\t\t\t\tvar worlddiff = math.add(math.multiply($a.medViewer.getRealWorldCoordinatesFromMouseEvent($a.offset().left + $a.width()/2 + 4,+ $a.offset().top + $a.height()/2 +4 ),-1),\n\t\t\t\t\t\t\t\t\tthat.p.coords);\n\n\n\n\t\t\t\t// shift key ==> change point size \n\t\t\t\tif(ev.shiftKey)\n\t\t\t\t{\n\t\t\t\t\t  var start = [ev.clientX ,  ev.clientY];\n\t\t\t\t\t  var startsize = that.p.size;\n\t\t\t\t\t  var canvascoords = $a.medViewer.getCanvasCoordinates(that.p.coords);\n\n\t\t\t\t\t  var mousemovehandler = moveUnlagger(function(ev2)\n\t\t\t\t\t  {\n\t\t\t\t\t\t\tvar diff = ev2.clientY - start[1];\n\t\t\t\t\t\t\tthat.setsize( startsize - diff / canvascoords.x_pixPerMM *1  );\n\t\t\t\t\t\t\tthat.drawpoint();\n\t\t\t\t\t\t\treturn false; \n\t\t\t\t\t  })\n\t\t\t\t\t  $(document.body).on('mousemove', mousemovehandler);\n\t\t\t\t\t  $(document.body).on('mouseup',   function(ev2){$(document.body).off('mouseup mousemove mouseleave',mousemovehandler) }  );\n\t\t\t\t\t  $(document.body).on('mouseleave',   function(ev2){$(document.body).off('mouseup mousemove mouseleave',mousemovehandler) }  );\n\t\t\t\t\t  return false; \n\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\t// right click delete\n   \t\t\t \tif(ev.buttons == 2)\t\n\t\t\t\t{\n\t\t\t\t\tthat.deletepoint();\n\t\t\t\t\tev.stopPropagation(); \n\t\t\t\t\treturn false;\n\t\t\t\t} \n\t\t\t\t//left click\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t var mousemovehandler = moveUnlagger(function(ev2)\n\t\t\t\t\t {\n\t\t\t\t\t\tif ($a.medViewer.nii)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar p = $a.medViewer.getRealWorldCoordinatesFromMouseEvent(ev2.clientX - startdiff[0]  , ev2.clientY - startdiff[1]);\n\t\t\t\t\t\t\tif (that.parentmarkerset.state.showThroughSlice)\n\t\t\t\t\t\t\t\tp = math.add(p,worlddiff);\n\t\t\t\t\t\t\tthat.movepoint( p._data, $a.medViewer, ev2 );\n\t\t\t\t\t\t\t ev2.stopPropagation();return false; \n\t\t\t\t\t\t}\n\t\t\t\t\t });\n\t\t\t\t\t var mouseuphandler =  function(ev2){\n\t\t\t\t\t\t \tif ( that.roinii && that.roinii.fileObject  )\n\t\t\t\t\t\t \t{\n\t\t\t\t\t\t \t\t\n\t\t\t\t\t\t \t\tthat.onupdate.pointROI( $a.medViewer )\n\t\t\t\t\t\t \t    //signalhandler.send(\"updateImage\",{id:that.roinii.fileObject.fileID});\n\t\t\t\t\t\t \t}\n\t\t\t\t\t\t \t$a.medViewer.$container.off('mousemove',mousemovehandler)\n\t\t\t\t\t\t \t$a.medViewer.$container.off('mouseup',mouseuphandler)\n\t\t\t\t\t\t \t$a.medViewer.$container.off('mouseleave',mouseuphandler)\n\t\t\t\t\t \t }  \n\t\t\t\t\t $a.medViewer.$container.on('mousemove', mousemovehandler);\n\t\t\t\t\t $a.medViewer.$container.on('mouseup',   mouseuphandler);\n\t\t\t\t\t $a.medViewer.$container.on('mouseleave',  mouseuphandler);\n\t\t\t\t\t \n\t\t\t\t\t that.runcallbacks('mousedown');\t\n\n\t\t\t\t\t ev.stopPropagation();\n\t\t\t\t\t ev.preventDefault();\n\t\t\t\t\t return false; \n\t\t\t\t }\n\t\t\t}// mousedown handler\t\n\n\t\t\t$a.find('.markerpoint_props').css('visibility', 'visible');\n\t\t\t\n\t\t\tif(that.type == '3druler')\n\t\t\t\tvar $target = $a.$rulertextInner;\n\t\t\telse\n\t\t\t\tvar $target = $a;\n\n\t\t\t$target.off('mouseenter mousedown mouseup mouseleave mousewheel DOMMouseScroll');\n\t\t\t$target.css('pointer-events', 'all');\n\t\t\t$target.on('mouseenter',  that.onHoverEnter );\n\t\t\t$target.on('mouseleave',  that.onHoverLeave);\n\t\t\t$target.on('mousedown',   mousedown);\n\t\t\t$target.on('dblclick',   function(ev2) {\n\t\t\t\tif (that.parentmarkerset.state.showThroughSlice)\n\t\t\t\t{\n\t\t\t\t\t\tvar p = $a.medViewer.getRealWorldCoordinatesFromMouseEvent(ev2.clientX, ev2.clientY);\n\t\t\t\t\t\tthat.movepoint( p._data, $a.medViewer );\n\t\t\t\t}\t\t\t\n\t\t\t});\n\t\t\t\n\t\t\t$a.on('mousewheel DOMMouseScroll',  MouseWheelHandler);\n\n\t\t\t// attach the resizer handlers\n\t\t\tif( $a.$resizerA != undefined )\n\t\t\t\tattachResizeHandlers(that, $a, $a.$resizerA, 1);\n\t\t\tif( $a.$resizerB != undefined )\n\t\t\t\tattachResizeHandlers(that, $a, $a.$resizerB, 0);\n\n\t\t} // end state.locked == false\n\n\t\tif(state.locked == true)\n\t\t{\n\t\t\t$a.css('pointer-events', 'none');\n\t\t\t$a.find('.markerpoint_props').css('visibility', 'hidden');\n\t\t\t$a.off('mouseenter');\n\t\t\t$a.off('mousedown' );\n\t\t}\n\t\t\n\t\tif(state.hoverdetails == true)\n\t\t{\n\t\t\t$a.find('.markerpoint_props').css('visibility', 'visible');\n\t\t}\n\t\t\n\t\tif(state.hoverdetails == false)\n\t\t{\n\t\t\t$a.find('.markerpoint_props').css('visibility', 'hidden');\n\t\t}\n\n\t}\n\n\n    that.onHoverEnter = function()\n    {\n        for(var mid in $markers)\n        {\n\t\t\t// version with recreating the objects on each hover --\x3e some strange synchro behaviour\n\t\t\tif(recreateInfoBoxOnHover)\n\t\t\t{\n\t\t\t\t var $props = $(\"<div class = 'markerpoint_props'></div>\");\n\t\t\t\t var thingstoshow = {colorsel:1, id:1, name:1, toggle:0, search:0, delete:1,  coords:1,comment:1};\n\t\t\t\t $props.append( that.createMarkerRepresentation('self' + mid, thingstoshow ) ).hide().fadeIn(100);\n\n\t\t\t\t $markers[mid].append($props)\n\t\t\t\t that.runcallbacks('createinfobox', $props);\n\t\t\t}\n\n           \t// glow effect\n           \t$markers[mid].addClass('annotation_point_hovered');\n\n        }\n    }\n\n    that.onHoverLeave = function(e)\n    {\n        for(var mid in $markers)\n        {\n           if( recreateInfoBoxOnHover )\n            \t$markers[mid].find('.markerpoint_props').fadeOut(100, function(){$markers[mid].find('.markerpoint_props').remove()});\n\n           \t// remove glow effect\n            \t$markers[mid].removeClass('annotation_point_hovered');\n        }\n    }                    \n\n\n\tfunction attachResizeHandlers(point, $a, $resizer, edgeindex)\n\t{\n\t\t// first remove all handlers, otherwise they will pile up!!!\n\t\t$resizer.off(\"mousedown mousemove mouseup mouseleave\");\n\t\t\n\t\t$resizer.on(\"mousedown\", function(ev)\n\t\t{\n\t\t\tif(ev.originalEvent.which != 1)\n\t\t\t\treturn;\n\n\t\t\tvar startMouse = [ev.clientX, ev.clientY];\n\t\t\tmarkerProxy.setDraggedPoint(  point, 1 );\n\t\t\tfunction mousemove(ev2)\n\t\t\t{\n\t\t \t\tpoint.setsizeFromMouseEvent(edgeindex,startMouse, [ev2.clientX,ev2.clientY], $a.medViewer, 'donotrecalc');\n\t\t\t\t//console.log(edgeindex)\n\t\t\t\tev2.preventDefault(); ev2.stopPropagation(); return false;\n\t\t\t}\n\n\t\t\tfunction mouseup(ev2)\n\t\t\t{\n\t\t \t\tpoint.setsizeFromMouseEvent(edgeindex,startMouse, [ev2.clientX,ev2.clientY], $a.medViewer, 'recalc' );\n\t\t\t\tmarkerProxy.setDraggedPoint();\n\t\t\t\t$a.medViewer.$container.off(\"mousemove\", mousemove)\n\t\t\t\t$a.medViewer.$container.off(\"mouseup mouseleave\",mouseup);\n\t\t\t}\n\n\t\t\t$a.medViewer.$container.on(\"mousemove\",mousemove);\n\t\t\t$a.medViewer.$container.on(\"mouseup mouseleave\",mouseup);\n\t\t\t\n\t\t\tev.preventDefault(); \t\t\tev.stopPropagation(); \t\t\treturn false;\n\t\t\t\n\n\t\t});\n\t}\n\n\n\tfunction attachRulerHandlers($a)\n\t{\n\n\n\n\t\t$a.on(\"mousedown\",mousedownbody);\n\t\t\n\t\tif($a.$text)\n\t\t\t$a.$text.on(\"mousedown\",mousedownbody);\n\n\t\tfunction mousedownbody(e){\n\t\t\tvar medViewer = $a.medViewer;\n\t\t\t//var startdiff = [e.clientX - $a.offset().left - $a.width()/2 - 4, e.clientY - $a.offset().top - $a.height()/2 -4 ];\n\t\t\tvar startMouse = [e.clientX, e.clientY];\n\t\t\tvar startOffs = medViewer.getCanvasCoordinates(that.p.coords );\n\t\t\tvar cpos  = getPixelPosition( medViewer.$canvascontainer );\n\t\t\tvar abspos = [startOffs.x_pix + cpos[0],  startOffs.y_pix + cpos[1] ]\n\n\t\t\t$(document.body).on(\"mousemove\",mousemove);\n\t\t\tfunction mousemove(e2)\n\t\t\t{\n// \t\t\t\tthat.movepoint(medViewer.getRealWorldCoordinatesFromMouseEvent(\n// \t\t\t\t\te2.clientX - startdiff[0],e2.clientY - startdiff[1]));\n\t\t\t\tthat.movepoint(medViewer.getRealWorldCoordinatesFromMouseEvent(\n\t\t\t\t\t(e2.clientX - startMouse[0]) + abspos[0],    (e2.clientY - startMouse[1]) + abspos[1]) );\n\n\t\t\t}\n\t\t\t$(document.body).on(\"mouseup mouseleave\",mouseup);\n\t\t\tfunction mouseup(e2)\n\t\t\t{\n\t\t\t\t$(document.body).off(\"mousemove\",mousemove)\n\t\t\t\t$(document.body).off(\"mouseup mouseleave\",mouseup);\n\t\t\t}\n\n\t\t}\n\n\t\t$a.$term_a.on('mousedown', mousedown(-1));\n\t\t$a.$term_b.on('mousedown', mousedown(1));\n\t\tfunction mousedown(sg) { return function(e)\n\t\t{\n\t\t\tvar medViewer = $a.medViewer;\n\t\t\tvar canvascoords = medViewer.getCanvasCoordinates(that.p.coords);\n\t\t\tvar dir = that.dir;\n\t\t\tvar tmp = medViewer.getCanvasCoordinates(that.p.coords);\n\t\t\tvar fac = canvascoords.x_pixPerMM; \n\n\t\t\tvar c = [(e.clientX - fac*sg*dir[0]),(e.clientY - fac*sg*dir[1])];\n\n\n\t\t\t$(document.body).on(\"mousemove\",mousemove);\n\t\t\tfunction mousemove(e2)\n\t\t\t{\n\t\t\t\tthat.dir = [-sg*(c[0]-e2.clientX)/fac , -sg*(c[1]-e2.clientY)/fac];\n\n\t\t\t\tthat.movepoint(medViewer.getRealWorldCoordinatesFromMouseEvent(\n\t\t\t\t\t0.5*(c[0]+e2.clientX),0.5*(c[1]+e2.clientY))._data);\n\n\t\t\t}\n\t\t\t$(document.body).on(\"mouseup mouseleave\",mouseup);\n\t\t\tfunction mouseup(e2)\n\t\t\t{\n\t\t\t\t$(document.body).off(\"mousemove\",mousemove)\n\t\t\t\t$(document.body).off(\"mouseup mouseleave\",mouseup);\n\t\t\t}\n\n\t\t\treturn false;\n\n\t\t} };\n\t}\n\n\n\n\n    // visual removement\n    that.clearpoint = function()\n    {\n        for(var mid in $markers)\n        {\n            $markers[mid].remove();\n            delete $markers[mid];\n        }\n\n        for(var mid in glmesh)\n        {\n       \t\tglmesh[mid].dispose()\n       \t\tif (glmesh[mid].viewer.gl)\n       \t\t\tglmesh[mid].viewer.gl.activateRenderLoop();\n            delete glmesh[mid];\n        }\n\n        if(that.type =='pointROI' && that.roinii && that.roinii.fileObject)\n        {\n\t\t\t// simply remove the representation on clearpoint\n\t\t\tKViewer.iterateMedViewers( function(medViewer) \n\t\t\t{\n\t\t\t\tfor(var k=0; k< medViewer.ROIs.length;  k++)\n\t\t\t\t{\n\t\t\t\t\tif(medViewer.viewport.pointROIviewer ==undefined &&  medViewer.ROIs[k].roi.fileID == that.roinii.fileObject.fileID )\n\t\t\t\t\t{\n\t\t\t\t\t\tmedViewer.ROIs.splice(k,1);\n\t\t\t\t\t\tmedViewer.drawSlice();\n\t\t\t\t\t\tbreak;\t\n\t\t\t\t\t}\n\t\t\t\t} \n\t\t\t});\n\t\t\t// could also redraw this way\n\t\t\t//signalhandler.send(\"updateImage\", {id: that.roinii.fileObject.fileID});\n        }\n\n\t    \n\n    }\n\n\n\n\t// true deletion of this point\n\tthat.deletepoint = function()\n    {\n        signalhandler.detachByIdList(sigIdList);\n        delete parentmarkerset.markerpoints[id];\n\n\t\tthat.clearpoint();\n        //that.callbacks.delete.forEach( function(callback) {callback();} );\n        that.runcallbacks('delete');\n\n        \n\n\t\tthat.visible = false;\n\t\tfor (var x in that.onupdate)\n\t\t\tthat.onupdate[x]();\n\n        for (var x in that.removeupdater)\n            that.removeupdater[x]();\n\n        for (var x in parentmarkerset.onupdate)\n            parentmarkerset.onupdate[x]();\n\n\n\t\tparentmarkerset.pointChanged();\n        that.parentmarkerset.drawLine();\n\n        \n    }\n\n\n\tthat.closescribble = function()\n    {\n    \tthat.isclosed = 1;\n    \tthat.drawpoint();\n    }\n\n\n\n    /***************************************************************************************\n    * signal handlers\n    ****************************************************************************************/\n\tvar sigIdList = [];\n\tsigIdList.push( signalhandler.attach(\"positionChange\",that.drawpoint) );\n    sigIdList.push( signalhandler.attach(\"setZoom\", that.drawpoint) );\n//    sigIdList.push( signalhandler.attach(\"canvasLayoutChanged\", that.drawpoint) );\n\n    //sigIdList.push( signalhandler.attach(\"close\", that.removepoint) );\n\n\n    return that;\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\nfunction earcut(data, holeIndices, dim) {\n\n    dim = dim || 2;\n\n    var hasHoles = holeIndices && holeIndices.length,\n        outerLen = hasHoles ? holeIndices[0] * dim : data.length,\n        outerNode = linkedList(data, 0, outerLen, dim, true),\n        triangles = [];\n\n    if (!outerNode) return triangles;\n\n    var minX, minY, maxX, maxY, x, y, size;\n\n    if (hasHoles) outerNode = eliminateHoles(data, holeIndices, outerNode, dim);\n\n    // if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox\n    if (data.length > 80 * dim) {\n        minX = maxX = data[0];\n        minY = maxY = data[1];\n\n        for (var i = dim; i < outerLen; i += dim) {\n            x = data[i];\n            y = data[i + 1];\n            if (x < minX) minX = x;\n            if (y < minY) minY = y;\n            if (x > maxX) maxX = x;\n            if (y > maxY) maxY = y;\n        }\n\n        // minX, minY and size are later used to transform coords into integers for z-order calculation\n        size = Math.max(maxX - minX, maxY - minY);\n    }\n\n    earcutLinked(outerNode, triangles, dim, minX, minY, size);\n\n    return triangles;\n\n\n// create a circular doubly linked list from polygon points in the specified winding order\nfunction linkedList(data, start, end, dim, clockwise) {\n    var i, last;\n\n    if (clockwise === (signedArea(data, start, end, dim) > 0)) {\n        for (i = start; i < end; i += dim) last = insertNode(i, data[i], data[i + 1], last);\n    } else {\n        for (i = end - dim; i >= start; i -= dim) last = insertNode(i, data[i], data[i + 1], last);\n    }\n\n    if (last && equals(last, last.next)) {\n        removeNode(last);\n        last = last.next;\n    }\n\n    return last;\n}\n\n// eliminate colinear or duplicate points\nfunction filterPoints(start, end) {\n    if (!start) return start;\n    if (!end) end = start;\n\n    var p = start,\n        again;\n    do {\n        again = false;\n\n        if (!p.steiner && (equals(p, p.next) || area(p.prev, p, p.next) === 0)) {\n            removeNode(p);\n            p = end = p.prev;\n            if (p === p.next) return null;\n            again = true;\n\n        } else {\n            p = p.next;\n        }\n    } while (again || p !== end);\n\n    return end;\n}\n\n// main ear slicing loop which triangulates a polygon (given as a linked list)\nfunction earcutLinked(ear, triangles, dim, minX, minY, size, pass) {\n    if (!ear) return;\n\n    // interlink polygon nodes in z-order\n    if (!pass && size) indexCurve(ear, minX, minY, size);\n\n    var stop = ear,\n        prev, next;\n\n    // iterate through ears, slicing them one by one\n    while (ear.prev !== ear.next) {\n        prev = ear.prev;\n        next = ear.next;\n\n        if (size ? isEarHashed(ear, minX, minY, size) : isEar(ear)) {\n            // cut off the triangle\n            triangles.push(prev.i / dim);\n            triangles.push(ear.i / dim);\n            triangles.push(next.i / dim);\n\n            removeNode(ear);\n\n            // skipping the next vertice leads to less sliver triangles\n            ear = next.next;\n            stop = next.next;\n\n            continue;\n        }\n\n        ear = next;\n\n        // if we looped through the whole remaining polygon and can't find any more ears\n        if (ear === stop) {\n            // try filtering points and slicing again\n            if (!pass) {\n                earcutLinked(filterPoints(ear), triangles, dim, minX, minY, size, 1);\n\n            // if this didn't work, try curing all small self-intersections locally\n            } else if (pass === 1) {\n                ear = cureLocalIntersections(ear, triangles, dim);\n                earcutLinked(ear, triangles, dim, minX, minY, size, 2);\n\n            // as a last resort, try splitting the remaining polygon into two\n            } else if (pass === 2) {\n                splitEarcut(ear, triangles, dim, minX, minY, size);\n            }\n\n            break;\n        }\n    }\n}\n\n// check whether a polygon node forms a valid ear with adjacent nodes\nfunction isEar(ear) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // now make sure we don't have other points inside the potential ear\n    var p = ear.next.next;\n\n    while (p !== ear.prev) {\n        if (pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.next;\n    }\n\n    return true;\n}\n\nfunction isEarHashed(ear, minX, minY, size) {\n    var a = ear.prev,\n        b = ear,\n        c = ear.next;\n\n    if (area(a, b, c) >= 0) return false; // reflex, can't be an ear\n\n    // triangle bbox; min & max are calculated like this for speed\n    var minTX = a.x < b.x ? (a.x < c.x ? a.x : c.x) : (b.x < c.x ? b.x : c.x),\n        minTY = a.y < b.y ? (a.y < c.y ? a.y : c.y) : (b.y < c.y ? b.y : c.y),\n        maxTX = a.x > b.x ? (a.x > c.x ? a.x : c.x) : (b.x > c.x ? b.x : c.x),\n        maxTY = a.y > b.y ? (a.y > c.y ? a.y : c.y) : (b.y > c.y ? b.y : c.y);\n\n    // z-order range for the current triangle bbox;\n    var minZ = zOrder(minTX, minTY, minX, minY, size),\n        maxZ = zOrder(maxTX, maxTY, minX, minY, size);\n\n    // first look for points inside the triangle in increasing z-order\n    var p = ear.nextZ;\n\n    while (p && p.z <= maxZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.nextZ;\n    }\n\n    // then look for points in decreasing z-order\n    p = ear.prevZ;\n\n    while (p && p.z >= minZ) {\n        if (p !== ear.prev && p !== ear.next &&\n            pointInTriangle(a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y) &&\n            area(p.prev, p, p.next) >= 0) return false;\n        p = p.prevZ;\n    }\n\n    return true;\n}\n\n// go through all polygon nodes and cure small local self-intersections\nfunction cureLocalIntersections(start, triangles, dim) {\n    var p = start;\n    do {\n        var a = p.prev,\n            b = p.next.next;\n\n        if (!equals(a, b) && intersects(a, p, p.next, b) && locallyInside(a, b) && locallyInside(b, a)) {\n\n            triangles.push(a.i / dim);\n            triangles.push(p.i / dim);\n            triangles.push(b.i / dim);\n\n            // remove two nodes involved\n            removeNode(p);\n            removeNode(p.next);\n\n            p = start = b;\n        }\n        p = p.next;\n    } while (p !== start);\n\n    return p;\n}\n\n// try splitting polygon into two and triangulate them independently\nfunction splitEarcut(start, triangles, dim, minX, minY, size) {\n    // look for a valid diagonal that divides the polygon into two\n    var a = start;\n    do {\n        var b = a.next.next;\n        while (b !== a.prev) {\n            if (a.i !== b.i && isValidDiagonal(a, b)) {\n                // split the polygon in two by the diagonal\n                var c = splitPolygon(a, b);\n\n                // filter colinear points around the cuts\n                a = filterPoints(a, a.next);\n                c = filterPoints(c, c.next);\n\n                // run earcut on each half\n                earcutLinked(a, triangles, dim, minX, minY, size);\n                earcutLinked(c, triangles, dim, minX, minY, size);\n                return;\n            }\n            b = b.next;\n        }\n        a = a.next;\n    } while (a !== start);\n}\n\n// link every hole into the outer loop, producing a single-ring polygon without holes\nfunction eliminateHoles(data, holeIndices, outerNode, dim) {\n    var queue = [],\n        i, len, start, end, list;\n\n    for (i = 0, len = holeIndices.length; i < len; i++) {\n        start = holeIndices[i] * dim;\n        end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n        list = linkedList(data, start, end, dim, false);\n        if (list === list.next) list.steiner = true;\n        queue.push(getLeftmost(list));\n    }\n\n    queue.sort(compareX);\n\n    // process holes from left to right\n    for (i = 0; i < queue.length; i++) {\n        eliminateHole(queue[i], outerNode);\n        outerNode = filterPoints(outerNode, outerNode.next);\n    }\n\n    return outerNode;\n}\n\nfunction compareX(a, b) {\n    return a.x - b.x;\n}\n\n// find a bridge between vertices that connects hole with an outer ring and and link it\nfunction eliminateHole(hole, outerNode) {\n    outerNode = findHoleBridge(hole, outerNode);\n    if (outerNode) {\n        var b = splitPolygon(outerNode, hole);\n        filterPoints(b, b.next);\n    }\n}\n\n// David Eberly's algorithm for finding a bridge between hole and outer polygon\nfunction findHoleBridge(hole, outerNode) {\n    var p = outerNode,\n        hx = hole.x,\n        hy = hole.y,\n        qx = -Infinity,\n        m;\n\n    // find a segment intersected by a ray from the hole's leftmost point to the left;\n    // segment's endpoint with lesser x will be potential connection point\n    do {\n        if (hy <= p.y && hy >= p.next.y && p.next.y !== p.y) {\n            var x = p.x + (hy - p.y) * (p.next.x - p.x) / (p.next.y - p.y);\n            if (x <= hx && x > qx) {\n                qx = x;\n                if (x === hx) {\n                    if (hy === p.y) return p;\n                    if (hy === p.next.y) return p.next;\n                }\n                m = p.x < p.next.x ? p : p.next;\n            }\n        }\n        p = p.next;\n    } while (p !== outerNode);\n\n    if (!m) return null;\n\n    if (hx === qx) return m.prev; // hole touches outer segment; pick lower endpoint\n\n    // look for points inside the triangle of hole point, segment intersection and endpoint;\n    // if there are no points found, we have a valid connection;\n    // otherwise choose the point of the minimum angle with the ray as connection point\n\n    var stop = m,\n        mx = m.x,\n        my = m.y,\n        tanMin = Infinity,\n        tan;\n\n    p = m.next;\n\n    while (p !== stop) {\n        if (hx >= p.x && p.x >= mx && hx !== p.x &&\n                pointInTriangle(hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y)) {\n\n            tan = Math.abs(hy - p.y) / (hx - p.x); // tangential\n\n            if ((tan < tanMin || (tan === tanMin && p.x > m.x)) && locallyInside(p, hole)) {\n                m = p;\n                tanMin = tan;\n            }\n        }\n\n        p = p.next;\n    }\n\n    return m;\n}\n\n// interlink polygon nodes in z-order\nfunction indexCurve(start, minX, minY, size) {\n    var p = start;\n    do {\n        if (p.z === null) p.z = zOrder(p.x, p.y, minX, minY, size);\n        p.prevZ = p.prev;\n        p.nextZ = p.next;\n        p = p.next;\n    } while (p !== start);\n\n    p.prevZ.nextZ = null;\n    p.prevZ = null;\n\n    sortLinked(p);\n}\n\n// Simon Tatham's linked list merge sort algorithm\n// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html\nfunction sortLinked(list) {\n    var i, p, q, e, tail, numMerges, pSize, qSize,\n        inSize = 1;\n\n    do {\n        p = list;\n        list = null;\n        tail = null;\n        numMerges = 0;\n\n        while (p) {\n            numMerges++;\n            q = p;\n            pSize = 0;\n            for (i = 0; i < inSize; i++) {\n                pSize++;\n                q = q.nextZ;\n                if (!q) break;\n            }\n            qSize = inSize;\n\n            while (pSize > 0 || (qSize > 0 && q)) {\n\n                if (pSize !== 0 && (qSize === 0 || !q || p.z <= q.z)) {\n                    e = p;\n                    p = p.nextZ;\n                    pSize--;\n                } else {\n                    e = q;\n                    q = q.nextZ;\n                    qSize--;\n                }\n\n                if (tail) tail.nextZ = e;\n                else list = e;\n\n                e.prevZ = tail;\n                tail = e;\n            }\n\n            p = q;\n        }\n\n        tail.nextZ = null;\n        inSize *= 2;\n\n    } while (numMerges > 1);\n\n    return list;\n}\n\n// z-order of a point given coords and size of the data bounding box\nfunction zOrder(x, y, minX, minY, size) {\n    // coords are transformed into non-negative 15-bit integer range\n    x = 32767 * (x - minX) / size;\n    y = 32767 * (y - minY) / size;\n\n    x = (x | (x << 8)) & 0x00FF00FF;\n    x = (x | (x << 4)) & 0x0F0F0F0F;\n    x = (x | (x << 2)) & 0x33333333;\n    x = (x | (x << 1)) & 0x55555555;\n\n    y = (y | (y << 8)) & 0x00FF00FF;\n    y = (y | (y << 4)) & 0x0F0F0F0F;\n    y = (y | (y << 2)) & 0x33333333;\n    y = (y | (y << 1)) & 0x55555555;\n\n    return x | (y << 1);\n}\n\n// find the leftmost node of a polygon ring\nfunction getLeftmost(start) {\n    var p = start,\n        leftmost = start;\n    do {\n        if (p.x < leftmost.x) leftmost = p;\n        p = p.next;\n    } while (p !== start);\n\n    return leftmost;\n}\n\n// check if a point lies within a convex triangle\nfunction pointInTriangle(ax, ay, bx, by, cx, cy, px, py) {\n    return (cx - px) * (ay - py) - (ax - px) * (cy - py) >= 0 &&\n           (ax - px) * (by - py) - (bx - px) * (ay - py) >= 0 &&\n           (bx - px) * (cy - py) - (cx - px) * (by - py) >= 0;\n}\n\n// check if a diagonal between two polygon nodes is valid (lies in polygon interior)\nfunction isValidDiagonal(a, b) {\n    return a.next.i !== b.i && a.prev.i !== b.i && !intersectsPolygon(a, b) &&\n           locallyInside(a, b) && locallyInside(b, a) && middleInside(a, b);\n}\n\n// signed area of a triangle\nfunction area(p, q, r) {\n    return (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);\n}\n\n// check if two points are equal\nfunction equals(p1, p2) {\n    return p1.x === p2.x && p1.y === p2.y;\n}\n\n// check if two segments intersect\nfunction intersects(p1, q1, p2, q2) {\n    if ((equals(p1, q1) && equals(p2, q2)) ||\n        (equals(p1, q2) && equals(p2, q1))) return true;\n    return area(p1, q1, p2) > 0 !== area(p1, q1, q2) > 0 &&\n           area(p2, q2, p1) > 0 !== area(p2, q2, q1) > 0;\n}\n\n// check if a polygon diagonal intersects any polygon segments\nfunction intersectsPolygon(a, b) {\n    var p = a;\n    do {\n        if (p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&\n                intersects(p, p.next, a, b)) return true;\n        p = p.next;\n    } while (p !== a);\n\n    return false;\n}\n\n// check if a polygon diagonal is locally inside the polygon\nfunction locallyInside(a, b) {\n    return area(a.prev, a, a.next) < 0 ?\n        area(a, b, a.next) >= 0 && area(a, a.prev, b) >= 0 :\n        area(a, b, a.prev) < 0 || area(a, a.next, b) < 0;\n}\n\n// check if the middle point of a polygon diagonal is inside the polygon\nfunction middleInside(a, b) {\n    var p = a,\n        inside = false,\n        px = (a.x + b.x) / 2,\n        py = (a.y + b.y) / 2;\n    do {\n        if (((p.y > py) !== (p.next.y > py)) && p.next.y !== p.y &&\n                (px < (p.next.x - p.x) * (py - p.y) / (p.next.y - p.y) + p.x))\n            inside = !inside;\n        p = p.next;\n    } while (p !== a);\n\n    return inside;\n}\n\n// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;\n// if one belongs to the outer ring and another to a hole, it merges it into a single ring\nfunction splitPolygon(a, b) {\n    var a2 = new Node(a.i, a.x, a.y),\n        b2 = new Node(b.i, b.x, b.y),\n        an = a.next,\n        bp = b.prev;\n\n    a.next = b;\n    b.prev = a;\n\n    a2.next = an;\n    an.prev = a2;\n\n    b2.next = a2;\n    a2.prev = b2;\n\n    bp.next = b2;\n    b2.prev = bp;\n\n    return b2;\n}\n\n// create a node and optionally link it with previous one (in a circular doubly linked list)\nfunction insertNode(i, x, y, last) {\n    var p = new Node(i, x, y);\n\n    if (!last) {\n        p.prev = p;\n        p.next = p;\n\n    } else {\n        p.next = last.next;\n        p.prev = last;\n        last.next.prev = p;\n        last.next = p;\n    }\n    return p;\n}\n\nfunction removeNode(p) {\n    p.next.prev = p.prev;\n    p.prev.next = p.next;\n\n    if (p.prevZ) p.prevZ.nextZ = p.nextZ;\n    if (p.nextZ) p.nextZ.prevZ = p.prevZ;\n}\n\nfunction Node(i, x, y) {\n    // vertice index in coordinates array\n    this.i = i;\n\n    // vertex coordinates\n    this.x = x;\n    this.y = y;\n\n    // previous and next vertice nodes in a polygon ring\n    this.prev = null;\n    this.next = null;\n\n    // z-order curve value\n    this.z = null;\n\n    // previous and next nodes in z-order\n    this.prevZ = null;\n    this.nextZ = null;\n\n    // indicates whether this is a steiner point\n    this.steiner = false;\n}\n\n// return a percentage difference between the polygon area and its triangulation area;\n// used to verify correctness of triangulation\nearcut.deviation = function (data, holeIndices, dim, triangles) {\n    var hasHoles = holeIndices && holeIndices.length;\n    var outerLen = hasHoles ? holeIndices[0] * dim : data.length;\n\n    var polygonArea = Math.abs(signedArea(data, 0, outerLen, dim));\n    if (hasHoles) {\n        for (var i = 0, len = holeIndices.length; i < len; i++) {\n            var start = holeIndices[i] * dim;\n            var end = i < len - 1 ? holeIndices[i + 1] * dim : data.length;\n            polygonArea -= Math.abs(signedArea(data, start, end, dim));\n        }\n    }\n\n    var trianglesArea = 0;\n    for (i = 0; i < triangles.length; i += 3) {\n        var a = triangles[i] * dim;\n        var b = triangles[i + 1] * dim;\n        var c = triangles[i + 2] * dim;\n        trianglesArea += Math.abs(\n            (data[a] - data[c]) * (data[b + 1] - data[a + 1]) -\n            (data[a] - data[b]) * (data[c + 1] - data[a + 1]));\n    }\n\n    return polygonArea === 0 && trianglesArea === 0 ? 0 :\n        Math.abs((trianglesArea - polygonArea) / polygonArea);\n};\n\nfunction signedArea(data, start, end, dim) {\n    var sum = 0;\n    for (var i = start, j = end - dim; i < end; i += dim) {\n        sum += (data[j] - data[i]) * (data[i + 1] + data[j + 1]);\n        j = i;\n    }\n    return sum;\n}\n\n\n}\n\n\n// turn a polygon in a multi-dimensional array form (e.g. as in GeoJSON) into a form Earcut accepts\nearcut.flatten = function (data) {\n    var dim = data[0][0].length,\n        result = {vertices: [], holes: [], dimensions: dim},\n        holeIndex = 0;\n\n    for (var i = 0; i < data.length; i++) {\n        for (var j = 0; j < data[i].length; j++) {\n            for (var d = 0; d < dim; d++) result.vertices.push(data[i][j][d]);\n        }\n        if (i > 0) {\n            holeIndex += data[i - 1].length;\n            result.holes.push(holeIndex);\n        }\n    }\n    return result;\n};\n\n\n\n\n\n\n\n\n\n// ======================================================================================\n// ============= create a roi around a centerpoint bounded to a radius\n// ======================================================================================\nfunction createPointROI(p)\n{\n\n\t// test setting\n// \tif(p == undefined)\n// \t\tvar p = markerProxy.markersets[0].getPoints()[0];\n\t\n\tvar markerPanel = p.parentmarkerset.markerPanel ||  p.parentmarkerset.showPanel() ;\n\n\tvar medViewer ;// =  KViewer.viewports[0].medViewer;\n\tvar niitemplate;\n\n\tvar that = new Object();\n\t\n\t// number of edge pixels in bounding box\n\tvar nr = 1;\n\n\t\n\tvar center = p.coords;\n\tvar radius = p.size;\n\t\n\t\n\tvar roi  = undefined;\n\tthat.fileObject = undefined;\n\tthat.refimagefileID = undefined;\n\n\tvar viewObject = that.viewObject = \n\t{\n            type: \"roi\",\n            roi: that.fileObject,\n            isCurrent: false,\n            color: 2,\n            visible: true,\n            close: function(){ \n            console.log('closing view')}\n    };\n\n\tvar roiname = \"pointROI\" + p.uuid ;\n\n\n\n\t//******************************************************\n\t// Create and customize a Free Viewer\n\t//******************************************************\n\tif(markerPanel.freeView == undefined)\n\t{\n\n\t\tvar fvpanel = KPanel($(document.body),'viewportpanel'+(KPanelView.runningID++), \"<b>\" + p.parentmarkerset.name + \"</b>   3D view\");\n\t\t\n\t\tvar pp = getPixelPosition( markerPanel.$container );\n\t\tvar w = 300;\n\n\t\t\n\t\tsetPixelPosition(fvpanel.$container, [pp[0]+pp[2] - w, pp[1]+pp[3] + 50 , 300, 300]);\t\n\t\tvar freeView =  new KFreeView(KViewer, fvpanel.$container);\n\t\tfreeView.panel = fvpanel;\n\t\tresizeTriangle(function() {},freeView.resize, fvpanel.$container ).appendTo(freeView.$container);\n\t \tfreeView.onsetContent = function()\n\t\t{\n\t\t\tif (freeView.medViewer )\n\t\t\t{\n\t\t\t\tfreeView.medViewer.hideControls( {toolbar: 1, timediv:1});\n\t\t\t\tfreeView.medViewer.histoManager.hide()\n\t\t\t\tfreeView.medViewer.histoManager.hidden = true;\n\t\t\t\tfreeView.medViewer.$infobar.hide();\n\t\t\t\tfreeView.medViewer.$infobar.hidden = true;\n// \t\t\t\tif(freeView.medViewer.gl)\n// \t\t\t\t\tfreeView.medViewer.gl.camera.getScene().clearColor = new BABYLON.Color3(0.02, 0.02, 0.02);\n\n\t\t\t\t//signalhandler.send(\"updateImage\",{id:that.fileObject.fileID});\t\n\t\t\t\t\t\n// \t  \t\t \tfunction loadSurfIntoViewport(fobj){\n// \t  \t\t \tvar surfView = medViewer.appendObject3D(fobj, {\n//                                 color: 2\n//                             });\n// \t  \t\t \t}\n// \t  \t\t \tif (fileObject.fileinfo.surfreference == undefined)\n// \t\t\t \t\tKViewer.obj3dTool.createSurfaceFromROI(fileObject, loadSurfIntoViewport);\n\t\t\t\t \t\n\t\t\t}\n\t\t}\n\t\tvar temp = $(\"<div class='markerROIStats'></div>\");\n\t\tfreeView.$container.append(temp)\n\t\tfreeView.$infobar = temp;\n    \tfreeView.pointROIviewer = true;\n\t\tfreeView.clearColors = [[0,0,0], [1,1,1]];\n\t\tfreeView.currentClearColor = 0;\n\n\t\tvar $colsel = $(\"<span style='width:20px;background:white;'>&nbsp;</span>\").prependTo(fvpanel.$topRow);\n\t\t$colsel.click(function()\n\t\t{\n\t\t\tfreeView.currentClearColor = (freeView.currentClearColor+1)%(freeView.clearColors.length);\n\t\t\tvar clearColor = freeView.clearColors[freeView.currentClearColor];\n\t\t\t$colsel.css('background', \"rgb(\"+clearColor[0]*255+\",\"+clearColor[1]*255+\",\"+clearColor[2]*255+\")\");\n\t\t\tfreeView.medViewer.gl.engine.scenes[0].clearColor =  new BABYLON.Color3(clearColor[0], clearColor[1], clearColor[2]);\n\t\t\tfreeView.medViewer.gl.engine.scenes[0].render();\n\t\t\tif(clearColor[0]==0)\n\t\t\t\tfreeView.$infobar.css('color', '', 'background', '');\n\t\t\telse\n\t\t\t\tfreeView.$infobar.css('color', 'black', 'background', 'red');\n\n\n// \t\t\tvar camera = freeView.medViewer.gl.engine.scenes[0].activeCamera\n// \t        camera.upVector = new BABYLON.Vector3(0, 1, 0);\n// \t\t\tfreeView.medViewer.gl.engine.scenes[0].activeCamera.setPosition( new BABYLON.Vector3(0, 0, 20));\n// \t\t\tfreeView.medViewer.gl.engine.scenes[0].render();\n\n\n\t\t});\n\n\n\t\tmarkerPanel.freeView = freeView;\n\n\t}\n\telse\n\t{\n\t\tmarkerPanel.freeView.panel.$container.show();\n\t}\n\n\n\n\n\t\t//var fv = KViewer.roiTool.createView(fileObject, KViewer.viewports[0].medViewer, {color:2, hideview:0 });\n\t\t// medViewer.ROIs.push(viewObject);\n\n\t\t// does not work, to be implemented\n\t\t//KViewer.obj3dTool.createSurfaceFromROI(fileObject, function(){});\n\n\t\n\n\tp.onupdate.pointROI = updateROI;\n\t//p.callbacks.move.pointROI = updateROI;\n\t\n\t//p.callbacks.delete.pointROI = function() {KViewer.roiTool.deleteROI(that.fileObject.fileID)};\n\tp.callbacks.delete.pointROI = function(){ KViewer.iterateMedViewers( function(medViewer) \n\t{\n\t\tfor(var k=0; k< medViewer.ROIs.length;  k++)\n\t\t{\n\t\t\tif(medViewer.viewport.pointROIviewer ==undefined &&  medViewer.ROIs[k].roi.fileID == that.fileObject.fileID )\n\t\t\t{\n\t\t\t\tmedViewer.ROIs.splice(k,1);\n\t\t\t\tsignalhandler.send('positionChange');\t\n\t\t\t\tbreak;\t\n\t\t\t}\n\t\t} \n\t\tif( markerPanel.freeView.medViewer)\n\t\t{\n\t\t\tif( markerPanel.freeView.medViewer.ROIs.length > 0 &&  markerPanel.freeView.medViewer.ROIs[0].roi.fileID == that.fileObject.fileID )\n\t\t\t{\n\t\t\t\t//markerPanel.freeView.medViewer.close();\n\t\t\t\tvar troi = markerPanel.freeView.medViewer.ROIs[0];\n\t\t\t\t\n\t\t\t\tif(troi.refSurfView && troi.refSurfView.surf)\n\t\t\t\t{\n\t \t\t\t\t\tKViewer.dataManager.delFile( troi.refSurfView.surf.fileID );\n\t\t\t\t}\n\t\t\t\ttroi.close();\n\t\t\t\tmarkerPanel.freeView.medViewer.currentFileID = undefined;\n\n \t\t\t\tif( markerPanel.freeView.medViewer.objects3D.length > 0 )\n \t\t\t\t{\n \t\t\t\t\t var fid = markerPanel.freeView.medViewer.objects3D[0].refRoiView.content.fileID;\n \t\t\t\t\t if(fid == that.fileObject.fileID)\n \t\t\t\t\t {\n//\t \t\t\t\t\tmarkerPanel.freeView.medViewer.objects3D[0].refRoiView.close();\n\t \t\t\t\t\tmarkerPanel.freeView.medViewer.objects3D[0].close();\n \t\t\t\t\t }\n \t\t\t\t}\n \t\n\t\t\t\tmarkerPanel.freeView.$infobar.html(\"no point selected\");\n\t\t\t} \n\t\t}\n\t\tif(that.fileObject)\n\t\t{\n\t\t\tKViewer.dataManager.delFile(that.fileObject.fileID);\n\t\t\tKViewer.cacheManager.update();\n\t\t}\n\n\n\t}) }\n\n\t\n\n\t//******************************************************\n\t// resize or move the roi\n\t//******************************************************\n\tfunction createROINii( )\n\t{\n\t\t// a valid pbject is already here, only update\n\t\tif(that.fileObject != undefined)\n\t\t{\n\t\t\tresizeROI( true );\n\t\t\treturn;\n\t\t}\n\n\t\tvar center = p.coords;\n\n\n\t\tvar voxSize = niitemplate.voxSize;\n\t\tvar edges = math.multiply(niitemplate.edges,1);\n\n\t\tvar cvox = math.round( math.multiply(math.inv(niitemplate.edges), center)._data );\n\t\tvar vv = [math.ceil(radius  / voxSize[0]) +nr, math.ceil(radius  / voxSize[1])+nr, math.ceil(radius  / voxSize[2])+nr, 0];\n\t\tvar sizes = [vv[0]*2,vv[1]*2,vv[2]*2, 1];\n\t\tvar spaceorigin = math.multiply(niitemplate.edges,  math.add(cvox, math.multiply(vv,-1) )  );\n\n\n\t\tedges._data[0][3] = spaceorigin._data[0];\n\t\tedges._data[1][3] = spaceorigin._data[1];\n\t\tedges._data[2][3] = spaceorigin._data[2];\n\n\n\t\tvar fobj = { content : { edges: edges,  bbox: undefined, voxSize: voxSize, sizes: sizes, pixdim: [3,voxSize[0],voxSize[1],voxSize[2]] } };\n\n\t\tthat.fileObject =  cloneNifti(fobj,roiname,\"uint8\",1);\n\t\tthat.fileObject.fileID = roiname;\n\t\tthat.fileObject.filename = roiname + \".nii\";\n\t\troi = that.fileObject.content;\n\t\tviewObject.roi = that.fileObject;\n\t\t\n\t\t// for some reason that should also be here\n\t\tviewObject.nii =  that.fileObject.content\n\t\t\n\t\tthat.fileObject.fileinfo = {Tag:'/mask/'};\n\n\t\t//attach the updater for 3D computeIsoDurface worker\n\t\t//this will then be forwarded to the surfreference and finally to its updater\n\t\tthat.fileObject.update = calcAndSetStatistics;\n\n\t\t// add to data manager --\x3e necessary beacuse of 3D view\n\t\tKViewer.dataManager.setFile(that.fileObject.fileID, that.fileObject);\n\t\tKViewer.cacheManager.update();\n\n\n\t}\n\n\n\t//******************************************************\n\t// resize or move the roi\n\t//******************************************************\n\tfunction resizeROI( force_resize )\n\t{\n\t\t\n\t// what can be changed:\n\t\t// shift -> edges only \n\t\t// radius -> sizes -> must recreate the buffer\n\n\t\tvar center = p.coords;\n\n\t\t// size has changed\n\t\tvar sizechanged = false;\n\n\t\tif( force_resize | radius != p.size)\n\t\t{\n\t\t\tradius = p.size;\n\t\t\tsizechanged = true;\n\t\t}\n\n\t\tvar voxSize = niitemplate.voxSize;\n\t\tvar edges = math.multiply(niitemplate.edges,1);\n\n\n\t\tvar cvox = math.round( math.multiply(math.inv(niitemplate.edges), center)._data );\n\t\tvar vv = [math.ceil(radius  / voxSize[0]) +nr, math.ceil(radius  / voxSize[1])+nr, math.ceil(radius  / voxSize[2])+nr, 0];\n\t\tvar sizes = [vv[0]*2,vv[1]*2,vv[2]*2, 1];\n\t\tvar spaceorigin = math.multiply(niitemplate.edges,  math.add(cvox, math.multiply(vv,-1) )  );\n\n\t\tedges._data[0][3] = spaceorigin._data[0];\n\t\tedges._data[1][3] = spaceorigin._data[1];\n\t\tedges._data[2][3] = spaceorigin._data[2];\n\n\t\tsizes = sizechanged?sizes:undefined\n\t\tresizeNifti(that.fileObject, edges,  sizes )\n\n\t\t\n\t\t/*\n\t\t\tvar center = p.coords;\n\n\t\t\tif( radius != p.size)\n\t\t\t{\n\t\t\t\tradius = p.size;\n\t\t\t\tvar voxSize = niitemplate.voxSize;\n\t\t\t\tvar cvox = math.round( math.multiply(math.inv(niitemplate.edges), center)._data );\n\t\t\t\tvar vv = [math.ceil(radius  / voxSize[0]) +nr, math.ceil(radius  / voxSize[1])+nr, math.ceil(radius  / voxSize[2])+nr, 0];\n\t\t\t\tvar sizes = [vv[0]*2,vv[1]*2,vv[2]*2, 1];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tvar voxSize = roi.voxSize;\n\t\t\t\tvar cvox = math.round( math.multiply(math.inv(niitemplate.edges), center)._data );\n\t\t\t\tvar vv = [math.ceil(radius  / voxSize[0]) +nr, math.ceil(radius  / voxSize[1])+nr, math.ceil(radius  / voxSize[2])+nr, 0];\n\t\t\t\tvar sizes = undefined;\n\t\t\t}\n\t\t\tvar spaceorigin = math.multiply(niitemplate.edges,  math.add(cvox, math.multiply(vv,-1) )  );\n\n\t\t\tresizeNifti(that.fileObject, spaceorigin,  sizes )\n\t\t*/\n\t}\n\n\n\n\t//******************************************************\n\t// calc content\n\t//******************************************************\n\tfunction updateROI(medViewer_clicked, ev, thresh)\n\t{\n\n\t\tif(thresh != undefined)\n\t\t\tp.thresh = thresh;\n\t\tif(thresh == undefined && p.thresh == undefined)\n\t\t\tp.thresh = parseFloat( markerPanel.pointROITool.$thresh.val() );\n\t\t\t\n\t\tif( !p.visible )\n\t\t\treturn\n\t\t\n\t\t// do NOT update on mousemoves, too expensive. Instead, print something else as info.\n\t\tif( ev != undefined && (ev == 'donotrecalc' || ev.type == 'mousemove') )\n\t\t{\n\t\t\tmarkerPanel.freeView.$infobar.html('waiting for mouse release ...')\n\t\t\treturn\n\t\t}\n\n\t\t// no specific medViewer clicked ... try to find an image\n\t\tif(niitemplate==undefined && medViewer_clicked == undefined )\n\t\t{\n\n\t\t\tKViewer.iterateMedViewers( function(medViewer) \n\t\t\t{\n\t\t\t\tif(medViewer.viewport.pointROIviewer ==undefined && medViewer.nii){\n\t\t\t\t\tmedViewer_clicked = medViewer; \n\t\t\t\t\t }\n\t\t\t});\n\t\t}\n\t\t\n\t\t// nothing to to do ...\n\t\tif( medViewer_clicked == undefined && niitemplate==undefined)\n\t\t{\n\t\t\tthat.fileObject = undefined;\n\t\t\treturn false\n\t\t}\n\n\n\t\tmarkerPanel.freeView.$infobar.html('modifying roi ...');\n\t\t\n\t\t// did the template nifti change? if yes, recreate the roi, otherwise just resize\n\t\tvar template_changed = false;\n\t\tif(medViewer_clicked != undefined && medViewer_clicked.nii !=undefined && niitemplate != medViewer_clicked.nii)\n\t\t{\n\t\t\tmedViewer = medViewer_clicked;\n\t\t\tniitemplate = medViewer_clicked.niiOriginal;\n\t\t\tthat.niitemplate = niitemplate;\n\t\t\tthat.refimagefileID = medViewer_clicked.currentFileID;\n\t\t\tcreateROINii();\n\t\t\ttemplate_changed = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tresizeROI();\n\t\t}\n\n\n\t\tvar roiPanel = KViewer.roiTool.roiPanel;\n\t\tvar roiTool = KViewer.roiTool;\n\n\t\tvar center = p.coords;\n\t\tvar radius = p.size;\n\n\t\t// prepare all necessary variables to use the \"modifyRoiInternal\" function from the roi tool from here\n\t\tvar state = $.extend(true, {}, roiPanel.getState());\n\n\n\t\t//state.threspen = 1;\n\n\t\tif( p.parentmarkerset.markerPanel.pointROITool.pen == 'regionGrowRestrict' )\n\t\t\tstate.regionGrowRestric = true;\n\n\n\t\t// for some reason, ther must be sqrt2 here ....!\n\t\tstate.pencil.radius   = radius ;\n\t\tstate.pencil.radius_z = radius ;\n\t\tstate.threspen = markerPanel.pointROITool.threspen;\n\n\t\t//state.pencil.thres = p.thresh;\n\t\t// we change thresh to low/high, could also implement this here, for now take only lower / higher\n\t\tif(state.threspen == 1)\n\t\t{\n\t\t\tstate.pencil.thres_high = 'off';\n\t\t\tstate.pencil.thres_low = p.thresh;\n\t\t}\n\t\telse if(state.threspen == 2)\n\t\t{\n\t\t\tstate.pencil.thres_high = p.thresh;\n\t\t\tstate.pencil.thres_low = 'off';\n\t\t}\n\n\n\n\t\tstate.nii = roi;\n\n\t\tvar points_wc = center;\n\t\tvar valtoset = 1;\n\t\t\n\t\t// empty the roi first\n\t\troi.data.fill(0)\n\n//////////////////////////////////////////\n\t\tfunction updateDistanceLine()\n\t\t{\n\t\t\tif( markerPanel.freeView.medViewer &&  markerPanel.freeView.medViewer.gl )\n\t\t\t{\n\t\t\t\tvar scene = markerPanel.freeView.medViewer.gl.scene;\n\n\t\t\t\tif(markerPanel.freeView.medViewer.distanceLine == undefined )\n\t\t\t\t{\n\t\t\t\t\t //[(new BABYLON.Vector3(\n\t\t\t\t\t var myPoints =[new BABYLON.Vector3(0, 0, 0),new BABYLON.Vector3(0, 0, 1)];\n\t \t\t\t\t var tube = BABYLON.MeshBuilder.CreateTube(\"tube\", {path: myPoints,radius:.3, sideOrientation: BABYLON.Mesh.DOUBLESIDE, updatable: true, tesselation:3}, scene); \n\t\t\t\t\t\ttube.material = new BABYLON.StandardMaterial(\"texture1\", scene);\n\t\t\t\t\t\ttube.material.diffuseColor  = new BABYLON.Color3(0.6, 0.6, 0.6);\n\t\t\t\t\t\ttube.material.backFaceCulling = false;\n\t\t\t\t\t markerPanel.freeView.medViewer.distanceLine = tube;\n\n//\t\t\t\t\t markerPanel.freeView.medViewer.distanceLine = BABYLON.MeshBuilder.CreateLines(\"lines\", {points: myPoints, updatable:true}, scene);\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif(that.stats.firstPoint ==undefined || that.stats.secondPointPoint ==undefined)\n\t\t\t\t\treturn;\n\n\t\t\t\tvar p1 = that.stats.firstPoint;\t\t\t\n\t\t\t\tp1 = math.multiply(roi.edges,[p1[0],p1[1],p1[2],1]);\n\t\t\t\tp1 = markerPanel.freeView.medViewer.gl.world2GL(p1._data); \t\n\t\t\t\t\n\t\t\t\tvar p2 = that.stats.secondPoint;\n\t\t\t\tp2 = math.multiply(roi.edges, [p2[0],p2[1],p2[2],1]); \n\t\t\t\tp2 = markerPanel.freeView.medViewer.gl.world2GL(p2._data); \n\n\t\t\t\tvar ssa = .2;\n\t\t\t\tvar ssb = 1+ssa;\n\t\t\t\tvar p2_2 = [0,0,0]; var vec1 = [p2[0]-p1[0], p2[1]-p1[1], p2[2]-p1[2],0]; \n\t\t\t\tp2_2[0] = p1[0]+ssb*vec1[0];  p2_2[1] = p1[1]+ssb*vec1[1]; p2_2[2] = p1[2]+ssb*vec1[2];\n\n\t\t\t\tvar p1_1 = [0,0,0]; p1_1[0] = p1[0]-ssa*vec1[0]; p1_1[1] = p1[1]-ssa*vec1[1]; p1_1[2] = p1[2]-ssa*vec1[2];\n\t\t\t\tvar myPath = [(new BABYLON.Vector3(p1_1[0],p1_1[1],-p1_1[2])),(new BABYLON.Vector3(p2_2[0],p2_2[1],-p2_2[2]))];\n\n//\t\t\t\tmarkerPanel.freeView.medViewer.distanceLine =  BABYLON.MeshBuilder.CreateLines(null, {points: myPath, instance: markerPanel.freeView.medViewer.distanceLine});\n\t\t\t\tmarkerPanel.freeView.medViewer.distanceLine =  BABYLON.MeshBuilder.CreateTube(null, {path: myPath, radius:.01*that.stats.diameter, instance: markerPanel.freeView.medViewer.distanceLine});\n\t\t\t\n\t\t\t}\n\t\t}\n\t\t//////////////////////////////////////////\n\t\t\n\n\t\tregionGrow.changedPoints = [];\n\t    roiTool.modifyRoiInternal(points_wc, valtoset, undefined, medViewer, state,function(changedPoints)\n\t    {\n\t\t\t//that.fileObject.modified = true;\n\n\t\t\t// create view in all viewports if necessary\n\t\t\tKViewer.iterateMedViewers( function(medViewer) \n\t\t\t\t{\n\t\t\t\t\tif( medViewer.viewport.pointROIviewer !=undefined )\n\t\t\t\t\t\treturn\n\n\t\t\t\t\tvar found = false;\n\n\t\t\t\t\tfor(var k=0; k< medViewer.ROIs.length;  k++)\n\t\t\t\t\t\tif( medViewer.ROIs[k].roi.fileID == that.fileObject.fileID )\n\t\t\t\t\t\t\tfound = true;\n\t\t\t\t\tif(!found)\n\t\t\t\t\t{\n\t\t\t\t\t\tviewObject.color  = KColor.findColorIndex(p.p.color.color) ;    \n\t\t\t\t\t\tmedViewer.ROIs.push(viewObject);\t\t\n\t\t\t\t\t\tsignalhandler.send('positionChange');\t\t\n\t\t\t\t\t}\n\t\t\t\t});\n\n\t\t\tsignalhandler.send(\"updateImage\",{id:that.fileObject.fileID});\n\t\t\tmarkerPanel.freeView.$infobar.html('calculating statistics ...');\n\t\t\t//window.setTimeout( calcAndSetStatistics,0 );\n\t\t\tupdateDistanceLine();\n\t    });\n\t}\n\tthat.updateROI = updateROI;\n\n\n\n\n\tthat.stats = {};\n\tfunction calcAndSetStatistics()\n\t{\n\t\t//return;\n\t\tvar stats = calcInertiaTensor( roi, that.niitemplate ) ;\n\n\t\tthat.stats = stats;\n\t\t//************** report  *********************\n\t\t// mL or microliters ??\n\t\tif( stats.volume < 1)\n\t\t\tvar volumestr = (stats.volume *1000).toFixed(1) + \" microL\";\n\t\telse\n\t\t\tvar volumestr = stats.volume.toFixed(1) + \" mL\";\n\n\n\t\tvar str = \"\";\n\t\tstr += \"<div class='markerROIStats_' ><div style='color:orange'>\" + p.p.name+ \" statistics</div><table >\";\n\t\t\n\t\tstr += \"<tr><td>volume:</td><td>\" + volumestr + \" </td></tr>\";\n\n\t\tif(stats.diameter !== false)\n\t\t\tstr += \"<tr><td>maxdiameter:</td><td> \" + stats.diameter.toFixed(1) + \" mm </td></tr>\"; \n\t\t\t\n\t\tstr += \"<tr><td>L1:</td><td> \" + stats.mainAx2.toFixed(1)  + \" mm </td></tr>\";\n\t\tstr += \"<tr><td>L2:</td><td> \" + stats.mainAx1.toFixed(1)  + \" mm </td></tr>\";\n\t\tstr += \"<tr><td>L3:</td><td> \" + stats.mainAx0.toFixed(1)  + \" mm </td></tr>\";\n\n\t\tif(that.fileObject.fileinfo.surfreference!=undefined)\n\t\t{\n\t\t\tvar surf = that.fileObject.fileinfo.surfreference.content.area || NaN;\n\n\t\t\tstr += \"<tr><td>surface:</td><td> \" + surf.toFixed(1)  + \" mm2 </td></tr>\";\n\t\t\tstr += \"<tr><td>vol/surf:</td><td> \" + (stats.volume*1000 / surf).toFixed(1)  + \" mm </td></tr>\";\n\n\t\t\t// compare surf/ vol with a sphere \n\t\t\t//     volume: 4/3*pi*r^3\n\t\t\t//     surf  :  4*pi*r^2\n\t\t\t// \t   vol / surf = 1/3 * r --\x3e scales with r, so not very descriptive\n\t\t\t// alternative: \"Sphericity (eg wikipedia\"):  surf of corresponding sphere divided by actual surf.\n\t\t\t// however, not very precise for few voxels\n\t\t\tvar radius_of_sphere__with_same_vol   = Math.pow( stats.volume*1000/ Math.PI / 4 * 3, 1/3);\n\t\t\tvar surf_of_sphere_with_same_vol = 4*Math.PI*radius_of_sphere__with_same_vol*radius_of_sphere__with_same_vol;\n\t\t\tvar ratio = surf_of_sphere_with_same_vol / surf;\n\t\t\tstr += \"<tr><td>sphericity:</td><td> \" + ratio.toFixed(2) + \" </td></tr>\";\n\n\t\t}\n\t\tstr += \"<tr><td>median</td><td> \" + stats.median.toFixed(0)  + \" HU  </td></tr>\";\n\t\t//str += \"<tr><td>mean</td><td> \" + stats.mean.toFixed(0)  + \"HU  </td></tr>\";\n\t\tstr += \"<tr><td>std</td><td> \" + stats.std.toFixed(0)  + \" HU  </td></tr>\";\n\n\n\t\tstr += \"</table></div>\";\n\t\t//************** report  *********************\n\n\n\t\t// append the info to all marker\n\t\tfor(var m in p.$markers)\n\t\t{\n\t\t\tif(p.$markers[m].$roiinfo == undefined)\n\t\t\t{\n\t\t\t\tvar $roiinfo = p.$markers[m].$roiinfo = $(\"<div style='__background:white'></div>\");\n\t\t\t\tp.$markers[m].find('.markerpoint_props').append($roiinfo);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t$roiinfo = p.$markers[m].$roiinfo; \n\t\t\t}\n\t\t\t$roiinfo.html(str);\n\t\t}\n\n\t\t// set the info in the 3D free View\n\t\tif(markerPanel.freeView.medViewer)\n\t\t\tmarkerPanel.freeView.$infobar.html(str);\n\t}\n\t\n\tthat.setThisPointInto3DView = function(forceshow)\n\t{\n\t\tif( !that.fileObject )\n\t\t\treturn false\n\n\t\t\t\n\t\tif( !markerPanel.freeView.medViewer || that.fileObject.fileID  !== markerPanel.freeView.medViewer.currentFileID )\n\t\t{\n\t\t\t\n \t\t\tif (markerPanel.freeView.medViewer)\n \t\t\t{\n\t\t\t\t// return if already in view\n\t\t\t\tif(markerPanel.freeView.medViewer.nii == that.fileObject.content)\t\n\t\t\t\t\treturn false\n\n \t\t\t\tmarkerPanel.freeView.medViewer.currentFileID = undefined;\n \t\t\t\tif (markerPanel.freeView.medViewer.ROIs && markerPanel.freeView.medViewer.ROIs.length>0)\n \t\t\t\t\tmarkerPanel.freeView.medViewer.ROIs[0].close();\n \t\t\t\t\n \t\t\t\tif (markerPanel.freeView.medViewer.objects3D && markerPanel.freeView.medViewer.objects3D.length>0)\n \t\t\t\t\tmarkerPanel.freeView.medViewer.objects3D[0].close();\n \t\t\t}\n\t\t\tp;\n\t\t\tvar intent = \n\t\t\t{\t\n\t\t\t\thideControls: {toolbar: 1, timediv:1},\n\t\t\t\tcolor:KColor.findColorIndex(p.p.color.color),\n\t\t\t\tgl: 1, \n\t\t\t\tgl_props:\n\t\t\t\t{\n\t\t\t\t\tradius: math.max(that.fileObject.content.sizes)*6,\n\t\t\t\t\tplanesVisibility: [0,0,0]\n\t\t\t\t},\n\t\t\t\tisosurf: (that.fileObject.fileinfo.surfreference==undefined),\n\t\t\t\troi: 1,\n\t\t\t};\n\t\t\t\n\t\t\tmarkerPanel.freeView.setContent( that.fileObject, {  intent: intent } );\n\t\t\t// would like to set the cuts here, but that is not so easy .... ideally, must go over the intent and implement properly\n\t\t\t//markerPanel.freeView.medViewer.objects3D.cuts;\n\t\t\twindow.setTimeout( calcAndSetStatistics,0 );\n\t\t}\n\n\t\tif(forceshow)\n\t\t\tmarkerPanel.freeView.$container.show();\n\n\n\t}\n\n\n\t// updateROI will take care of everything (create new if requested, put into viewports ...)\n\tupdateROI();\n\t// will be called later anyhow by movepoint / setsize\n\n//\tthat.setThisPointInto3DView();\n\n\n\treturn that;\n\n} // END OF KMarkerTool\n\n\n\n\n\n\n\n// ======================================================================================\n// calcInertiaTensor\n// ======================================================================================\nfunction calcInertiaTensor(nii, img)\n{\n\t// nii = the roi in this case, img is the background image\n\tif(img!=undefined)\n\t\tvar A = math.multiply(math.inv(img.edges), nii.edges);\n\n\t// center of mass\n\tvar sx = nii.sizes[0];\n\tvar sy = nii.sizes[1];\n\tvar sz = nii.sizes[2];\n\tvar volPerVox = nii.voxSize[0] * nii.voxSize[1] * nii.voxSize[2];\n\n\tvar currentIndex, val;\n\tvar center = [0,0,0];\n\tvar totsum = 0;\n\tfor(var x=0; x<sx; x++)\n\t{\n\t\tfor(var y=0; y<sy; y++)\n\t\t{\n\t\t\tfor(var z=0; z<sz; z++)\n\t\t\t{\n\t\t\t\tcurrentIndex = sx*sy*z +y*sx + x;\n                val = nii.data[currentIndex];\n\t\t\t\tcenter[0] += val* nii.voxSize[0]*x;\n\t\t\t\tcenter[1] += val* nii.voxSize[1]*y;\n\t\t\t\tcenter[2] += val* nii.voxSize[2]*z;\n\t\t\t\ttotsum += val; \n\t\t\t}\n\n\t\t}\n\t}\n\n\tcenter[0] /= totsum;\n\tcenter[1] /= totsum;\n\tcenter[2] /= totsum; \n\n\tvar calcmedian = true;\n    var values = [];\n\tvar imgtotsum0 = 0;\n\tvar imgtotsum2 = 0;\n\tvar median = 0;\n\tvar mean  = 0;\n\tvar std = 0;\n\n\t// inertie Tensor http://en.wikipedia.org/wiki/Tensoror\n\tvar T = new Float32Array(9);\n\tT.fill(0);\n\tvar dx,dy,dz;\n\t\n\t//diameter\n\tvar calcMaxDiameter = true;\n\tvar diameter = 0; \n\tvar firstPoint = [0,0,0]; \n\tvar secondPoint = [0,0,0];\n\t//set borderpixels: \n\tvar border = []; \n\tfor (var i = 0; i <sx*sy*sz; i++){\n\t\tborder[i] = new Array(3); \n\t}\n\tvar count = 0; \n\tvar voxcount = 0;\n\tvar biggestDistance = 0;\n\t// end diameter\n\n\tfor(var x=0; x<sx; x++)\n\t{\n\t\tfor(var y=0; y<sy; y++)\n\t\t{\n\t\t\tfor(var z=0; z<sz; z++)\n\t\t\t{\n\t\t\t\tcurrentIndex = sx*sy*z + y*sx + x;\n                val = nii.data[currentIndex];\n                \n                if(val<1)\n                \tcontinue\n\n                voxcount++;\n                \t\n\t\t\t\tdx = x*nii.voxSize[0] - center[0];\n\t\t\t\tdy = y*nii.voxSize[1] - center[1];\n\t\t\t\tdz = z*nii.voxSize[2] - center[2];\n                T[0] += val*(dy*dy + dz*dz );\n                T[1] += val*(-dx*dy );\n                T[2] += val*(-dx*dz );\n                T[3] += val*(-dy*dx );\n                T[4] += val*(dx*dx + dz*dz );\n                T[5] += val*(-dy*dz );\n                T[6] += val*(-dz*dx );\n                T[7] += val*(-dz*dy );\n                T[8] += val*(dx*dx + dy*dy );\n \t\t\t\t\n \t\t\t\tif(val> 0 && calcmedian)\n \t\t\t\t{\n\t\t\t\t\tvar v = NNInterp(img, x, y, z, A._data, 0);\n\t\t\t\t\tv = img.datascaling.e(v);\n\t\t\t\t\tif (!isNaN(v) && v !== 0 )\n\t\t\t\t\t{\n                \t\tvalues.push(v);\n                \t    imgtotsum0 += v; \n                \t    imgtotsum2 += v*v; \n\t\t\t\t\t}\n \t\t\t\t}\n\n\n\t\t\t\t// ******* diameter\n\t\t\t\tif(val> 0 && calcMaxDiameter)\n\t\t\t\t{\n\t\t\t\t\t// check for edge pixels\n\t\t\t\t\tif(nii.data[currentIndex -1] < 1 || \n\t\t\t\t\t\tnii.data[currentIndex + 1] <1 || \n\t\t\t\t\t\tnii.data[currentIndex - sx] <1 || \n\t\t\t\t\t\tnii.data[currentIndex + sx] <1 || \n\t\t\t\t\t\tnii.data[currentIndex + sx*sy] <1 || \n\t\t\t\t\t\tnii.data[currentIndex - sx*sy] <1)\n\t\t\t\t\t{\n\t\t\t\t\t\tborder[count][0] = x; \n\t\t\t\t\t\tborder[count][1] = y; \n\t\t\t\t\t\tborder[count][2] = z; \n\n\t\t\t\t\t\tvar vec = [border[count][0] * nii.voxSize[0] , border[count][1] * nii.voxSize[1] , border[count][2] * nii.voxSize[2] ]; \n\t\t\t\t\t\tfor(var k = 0; k < count; k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar vec2 = [border[k][0] * nii.voxSize[0] , border[k][1] * nii.voxSize[1] , border[k][2] * nii.voxSize[2] ]; \n\t\t\t\t\t\t\tvar distance = math.sqrt((vec[0] - vec2[0])*(vec[0] - vec2[0])+(vec[1] - vec2[1])*(vec[1] - vec2[1]) +(vec[2] - vec2[2])*(vec[2] - vec2[2])); \n\t\t\t\t\t\t\tif(distance > biggestDistance)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tbiggestDistance = distance;\n\t\t\t\t\t\t\t\tfirstPoint = border[count]; \n\t\t\t\t\t\t\t\tsecondPoint = border[k];  \n\t\t\t\t\t\t\t\t//TODO: check points \n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcount = count +1; \n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t\t// end diameter\n\t\t\t}\n\n\t\t}\n\t}\n\n\tif(calcmedian)\n\t{\n\t\tmedian = math.median(values);\n\t\tmean    = imgtotsum0/values.length;  \n\t\tstd    = math.sqrt( imgtotsum2/values.length -mean*mean ) ;  \n\t}\n\n\t//console.log(T);\n\n\tT = math.matrix( [ [T[0],T[1],T[2]], [T[3],T[4],T[5]], [T[6],T[7],T[8]]]);\n\tT = math.multiply(T, 1/totsum/1);\n\t\n\tvar EV = kmath.maxEV3(T);\n\n\t\n\t// the mass ellipsoid is defined as follows https://de.wikipedia.org/wiki/Tr%C3%A4gheitsellipsoid#Massenellipsoid\n\t// this would be the corresponding ellipsoid with the half axes 0,1,2, therefore times 2\n\tvar main0 = math.sqrt( 5/2* (EV[1].ev + EV[2].ev - EV[0].ev) ) * 2;\n\tvar main1 = math.sqrt( 5/2* (EV[0].ev + EV[2].ev - EV[1].ev) ) * 2;\n\tvar main2 = math.sqrt( 5/2* (EV[0].ev + EV[1].ev - EV[2].ev) ) * 2;\n\n\n\t// collect the results\n\tvar vol = voxcount * volPerVox / 1000; // in mL\n\t//var shortdiam = (main0+main1)/2; // this is the shortest diam\n\n\tif(calcMaxDiameter)\n\t\tdiameter = biggestDistance;\n\telse\n\t\tdiameter = false;\n\n\t//fobj.fileinfo.surfreference\n\n\tvar out = \n\t{\n\t\tvolume: vol,\n\t\tmainAx0: main0,\n\t\tmainAx1: main1,\n\t\tmainAx2: main2,\n\t\tdiameter:diameter,\n\t\tfirstPoint: firstPoint, \n\t\tsecondPoint: secondPoint,\n\t\t//border: border,\n\t\tmedian:median,\n\t\tmean:mean,\n\t\tstd:std \n\t};\n\n\n\tif(0)\n\t{\n\t\tconsole.log('........')\n\t\tconsole.log('C' + center);\n\t\tconsole.log(EV[0]);\n\t\tconsole.log(EV[1]);\n\t\tconsole.log(EV[2]);\n\t\tconsole.log('nvoxels' + totsum);\n\n\t}\n\treturn out;\n\n}\n\n\n// ======================================================================================\n// polygon functions\n// ======================================================================================\n\n// helper functions for polygon operations\nfunction kp_vsum(a,b,s)\n{\n\t/*\n\t*******************************************************/\n\t// add two vectors, one scaled by s. sets forth dim  to one (assume affine then)\n\t// can also add list of vectors, \n\tif(a==undefined || b==undefined)\n\t\tconsole.log(a);\n\tif(s==undefined)\n\t\ts=1;\n\n\tvar a_isArray = Array.isArray(a[0]);\n\tvar b_isArray = Array.isArray(b[0]);\n\n\tif(a_isArray && b_isArray)\n\t{\n\t\tvar is_affine = a[0].length ==4;\n\t\tvar vv = [];\n\t\tfor(var k=0; k<a.length; k++)\n\t\t{\n\t\t\tvar temp = [a[k][0] + s*b[k][0], a[k][1] + s*b[k][1], a[k][2] + s*b[k][2]];\n\t\t\t// affine?\n\t\t\tif(a.length ==4)\n\t\t\t\ttemp.push(1)\n\t\t\tvv.push(temp);\n\t\t}\n\n\t}\n\telse if(a_isArray &&  !b_isArray)\n\t{\n\t\tvar is_affine = a[0].length ==4;\n\t\tvar vv = [];\n\t\tfor(var k=0; k<a.length; k++)\n\t\t{\n\t\t\tvar temp = [a[k][0] + s*b[0], a[k][1] + s*b[1], a[k][2] + s*b[2]];\n\t\t\t// affine?\n\t\t\tif(is_affine)\n\t\t\t\ttemp.push(1)\n\t\t\tvv.push(temp);\n\t\t}\n\n\t}    \n\telse if(!a_isArray &&  !b_isArray)\n\t{\n\t\tvar is_affine = a.length ==4;\n\t\tvar vv = [a[0] + s*b[0], a[1] + s*b[1], a[2] + s*b[2]];\n\t\t// affine?\n\t\tif(is_affine)\n\t\t\tvv.push(1)\n\t}\n\telse\n\t{\n\t\tconsole.log(\"size mismatch\");\n\t}\n\n\treturn vv;\n}\n\n\n/********************************************************/\n// find min value of a vector (optional based on abs)\nfunction kp_vec_min(a, useabs)\n{\n\n\tif(useabs == 1)\n\t{\n\t\tvar b = [];\n\t\tfor (var k = 0; k < a.length; k++)\n\t\t{\n\t\t\tb.push(math.abs(a[k]));\n\t\t}\n\t\ta=b;\n\n\t}\n\tvar m=[a[0]];\n\tvar ind = 0;\n\tfor (var k = 1; k < a.length; k++)\n\t{\n\t\tif (m > a[k])\n\t\t{\n\t\t\tm = a[k];\n\t\t\tind = k;\n\t\t}\n\t}\n\treturn {val: m, ind: ind};\n}\n/********************************************************/\n\n\n\n/******************************************************************\ninterpolate a list of parallel polygons\n******************************************************************/\nKMarkerScribble_interpolate_slices = function( mset )\n{\n\n\tfunction calc_center_of_mass(vertices_in, normalvec)\n\t{\n\t\tvar vertices=[];\n\t\tfor(var k=0; k<vertices_in.length; k++)\n\t\t{\n\t\t\tvertices.push(vertices_in[k]);\n\t\t}\n\t\t// close polygon\n\t\tvertices.push(vertices[0]);\n\n        var s = [0,0,0];\n        var areaTotal = 0.0;\n\n        var p1 = vertices[0];\n        var p2 = vertices[1];\n        // quad sum of all vertices, for slice norm vec calculation\n        var ss = [0,0,0];\n\n        for (var i = 2; i < vertices.length; i++)\n        {\n            var p3 = vertices[i];\n            var edge1 = kp_vsum(p3, p1, -1);\n            var edge2 = kp_vsum(p3, p2, -1);\n\t\t\t\n            var crossProduct = kmath.cross(edge1, edge2)._data;\n            var area = kmath.norm(crossProduct)/2;\n\t\t\tvar enorm = math.norm(edge2)\n            ss[0] += math.abs(edge2[0]/enorm)\n            ss[1] += math.abs(edge2[1]/enorm)\n            ss[2] += math.abs(edge2[2]/enorm)\n\t\n            s[0] += area * (p1[0] + p2[0] + p3[0])/3;\n            s[1] += area * (p1[1] + p2[1] + p3[1])/3;\n            s[2] += area * (p1[2] + p2[2] + p3[2])/3;\n\n            areaTotal += area;\n            p2 = p3;\n            if(normalvec == undefined && math.norm(crossProduct) > 0.01)\n            \tnormalvec = math.multiply(crossProduct , 1/ math.norm(crossProduct) )._data;; \n        }\n\n        var com = [s[0]/areaTotal, s[1]/areaTotal, s[2]/areaTotal   ];\n\t\tvar vertices_cc = kp_vsum(vertices, com, -1); // center-of-mass free poly\n        var dist_to_origin = math.dot(normalvec, com );\n\n        return {com: com, area: areaTotal, vertices: vertices, vertices_cc, normalvec: normalvec, dist_to_origin: dist_to_origin};\n    \n\t}\n\t//return console.log( calc_center_of_mass([[0,0,0], [1,1,0], [1,-1,0]]) );\n\n\n\n\tvar that = {};\n\n    /******************************************************\n    Main function\n\t*******************************************************/\n\tmset =  mset || markerProxy.currentSet;\n\tvar points = mset.getPoints();\n\n\tif(points.length < 2)\n\t{\n\t\talert(\"must have a least 2 scribble - polygons\");\n\t\treturn\n\t}\n\t\n\t// prepares: calc center of mass of all polygons and find slice normal vectors\n\tvar tlist = []; // list of all polys\n\tvar dlist = [];\n\tfor(var k=0; k<points.length; k++)\n\t{\n\t\tif(k==0) // re-use the first normal vec of first slice, otherwise direction might change...\n\t\t\tvar temp = calc_center_of_mass(points[k].subpoints);\n\t\telse\n\t\t\tvar temp = calc_center_of_mass(points[k].subpoints, tlist[k-1].normalvec);\n\n\n\t\ttlist.push(temp);\n\t\tdlist.push(temp.dist_to_origin)\n\t}\n\tvar sortind = Array.from(Array(dlist.length).keys()).sort((a, b) => dlist[a] < dlist[b] ? -1 : (dlist[b] < dlist[a]) | 0)\t\n//\tvar sortind = Array.from(Array(dlist.length).keys()).sort((a, b) => dlist[a] < dlist[b] ? -1 : 1)\t\n\n\t// as nifti, choose the one it was created on\n\tvar fileobj = KViewer.dataManager.getFile(points[0].referencedImageFileID);\n\tnii = fileobj.content;\n\n\t\n\tfor(var k=1; k<sortind.length; k++)\n\t{\n\t\tdo_it(sortind[k], sortind[k-1])\n\t}\n\t\t\n\n\tfunction do_it( ind1, ind2 )\n\t{\n\n \t\tvar has_greater_area = tlist[ind1].area > tlist[ind2].area;\n \t\tif(!has_greater_area)\n \t\t\t{var dummy = ind1; ind1=ind2; ind2=dummy;}\n\n \t\tvar dist_to_last_slice = math.abs( tlist[ind1].dist_to_origin - tlist[ind2].dist_to_origin );\n\t\n\t\t\n\t\tvar poly0 = tlist[ind1].vertices;\n\t\tvar poly1 = tlist[ind2].vertices;\n\t\tvar poly0cc = tlist[ind1].vertices_cc;\n\t\tvar poly1cc = tlist[ind2].vertices_cc;\n\n\n\t\t/************************************\n\t\t \"Algorithm\" to interpolate between 2 polygons:\n\t\t - calc center of masses and subtract\n\t\t - choose poly with larger area as starting points\n\t\t - connect each point to COM of 2nd poly and find intersections.\n\t\t - choose intersection, or closest point to intersections\n\t\t - alternative: connect to closest point of 2nd polygon\n\t\t*/\n\t\tvar up_vector = tlist[ind1].normalvec;\n\n\t\tup_vector.push(1);\n\n\t\t/***************************************************/\n\t\t// iterate all points of source polygon\n\t\tvar len = poly0.length;\n\n\n\t\tvar method = \"closest\"\n\t\tvar method = \"centerofmass\"\n\n\t\tvar targetpoly = [];\n\n\t\tif(method == \"closest\")\n\t\t{\n\t\t\tfor(var k=0; k<poly0.length; k++)\n\t\t\t{\n\t\t\t\tvar dists = [];\n\t\t\t\tfor(var u=0; u< poly1.length; u++)\n\t\t\t\t{\n\t\t\t\t\tvar d0 = math.norm(kp_vsum(poly1cc[u]  , poly0cc[k], -1) );\n\t\t\t\t\tdists.push(d0);\n\t\t\t\t}\n\n\t\t\t\tvar themin = kp_vec_min(dists);\n\t\t\t\tvar bestpoint = poly1[themin.ind];\n\n\t\t\t\ttargetpoly.push(bestpoint)\n\t\t\t}\n\t\t}\n\t\telse // method 2: intercect with plane defined by point=>centerofmass\n\t\t{\n\t\t\tvar equalize_com = 1;\n\n\t\t\tif (equalize_com)\n\t\t\t{\n\t\t\t\tvar centerpoint = [0,0,0];\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tpoly0cc = poly0;\n\t\t\t\tpoly1cc = poly1;\n\t\t\t\tvar centerpoint = com1;\n\t\t\t}\n\n\n\t\t\tfor(var k=0; k<poly0cc.length; k++)\n\t\t\t{\n\t\t\t\t// calc normal vec for plane: current point => center of mass\n\t\t\t\tvar p0 = poly0cc[k];\n\t\t\t\tvar v1 = kp_vsum(p0, centerpoint, -1);\n\t\t\t\tvar n = math.cross(up_vector, v1, 1)._data;\n\n\t\t\t\tvar v1 = kp_vsum(p0,centerpoint, -1);\n\t\t\t\tvar dummy = k + math.round(len/2);\n\t\t\t\tif(dummy >= len)\n\t\t\t\t\tdummy -=len;\n\t\t\t\tvar v2 = kp_vsum(poly0cc[dummy],centerpoint, -1);\n\n\t\t\t\tvar up_vector = math.cross(v1, v2, 1)._data;\n\n\t\t\t\tvar n = math.cross(up_vector, v1, 1)._data;\n\n\t\t\t\t// now, intersect with all edges of second polygon, find closest points\n\t\t\t\tvar isec = {};\n\t\t\t\tisec.dists = [];\n\t\t\t\tisec.inds  = [];\n\t\t\t\tisec.secpoints = [];\n\t\t\t\t//isec.orients = [];\n\n\t\t\t\tfor(var u=1; u< poly1.length; u++)\n\t\t\t\t{\n\t\t\t\t\tvar d0 = math.dot(n, kp_vsum(poly1cc[u]  , centerpoint, -1) );\n\t\t\t\t\tvar d1 = math.dot(n, kp_vsum(poly1cc[u-1], centerpoint, -1) );\n\t\t\t\t\tif(d0*d1 <=0 ) // intersection means: both points are on different sides of plane\n\t\t\t\t\t{\n\t\t\t\t\t\tvar secpoint = kp_vsum(poly1cc[u], n, -d0)\n\t\t\t\t\t\t// calc dist to source point\n\t\t\t\t\t\tif(0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tisec.dists.push(math.abs(d0));\n\t\t\t\t\t\t\tisec.dists.push(math.abs(d1));\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar d0_tosourcepoint = kmath.norm(kp_vsum(poly1cc[u-1], p0, -1 ))\n\t\t\t\t\t\t\tvar d1_tosourcepoint = kmath.norm(kp_vsum(poly1cc[u], p0, -1 ))\n\t\t\t\t\t\t\tisec.dists.push(d0_tosourcepoint);\n\t\t\t\t\t\t\tisec.dists.push(d1_tosourcepoint);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// normally, there should be 2 +2*x intercections, one closer. \n\t\t\t\t\t\t// calc orientation of inercections with respect to plane perp to n\n\t// \t\t\t\t\tvar sec_n = math.cross(up_vector, n, 1)._data;\n\t// \t\t\t\t\tvar orient = math.dot(sec_n, kp_vsum(secpoint, centerpoint, -1) );\n\t// \t\t\t\t\tisec.orients.push(orient)\n\n\t\t\t\t\t\tisec.inds.push(u-1);\n\t\t\t\t\t\tisec.inds.push(u);\n\t\t\t\t\t\tisec.secpoints.push(secpoint);\n\t\t\t\t\t\tisec.secpoints.push(secpoint);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tif(isec.secpoints.length == 0)\n\t\t\t\t\tcontinue\n\n\t\t\t\t//console.log(\"orients: \" + isec.orients)\n\t// \t\t\tvar prod = 1;\n\t// \t\t\tvar mino = isec.orients[0]\n\t// \t\t\tvar maxo = isec.orients[0]\n\t// \t\t\tfor(var u=0; u<isec.orients.length; u++)\n\t// \t\t\t{\n\t// \t\t\t\tprod *= isec.orients[u];\n\t// \t\t\t}\n\t// \t\t\tconsole.log(\"prod = \"+ prod)\n\n\t// \t\t\tif(prod > 0)\n\t// \t\t\t\tvar themin = kp_vec_min(isec.dists);\n\t// \t\t\telse\n\t// \t\t\t\tvar themin = kp_vec_min(isec.dists);\n\n\t\t\t\t\tvar themin = kp_vec_min(isec.dists);\n\n\t\t\t\t// calculate /set  the target point\n\t\t\t\t// option 1: choose target\n\t\t\t\tvar bestpoint = poly1[isec.inds[themin.ind]]; // choose target\n\t\t\t\t// option 2: intersection point\n\t\t\t\t//var bestpoint =  isec.secpoints[themin.ind];\n\t// \t\t\tif(equalize_com)\n\t// \t\t\t\tbestpoint = kp_vsum(bestpoint, com1, 1);\n\t\t\t\ttargetpoly.push(bestpoint);\n\t\t\t}\n\n\t\t}\n\n\t\t/************************************\n\t\t add interpolated polygons\n\t\t************************************/\n\t\t// how many interpolation polys do we want to have? one for each slice\n\t\tzvec = [0,0,1,1];\n\t\tvar SS = nii.spaceDirections;\n\t\tvar n = tlist[ind1].normalvec;\n \t\tvar proj = math.multiply([ SS[0],SS[1],SS[2] ], n)._data;\n\t\tvar nsteps = dist_to_last_slice / math.norm(proj) ;\n\t\tnsteps = math.round(nsteps)-1;\n// \t\tconsole.log(proj);\n// \t\tconsole.log(nsteps);\n\n\t\tvar debug = 0;\n\t\tfor(var s=0; s<nsteps; s++)\n\t\t{\n\t\t\tvar temppoly = [];\n\t\t\tfor(var k=0; k<targetpoly.length; k++)\n\t\t\t{\n\t\t\t\tif(debug)\n\t\t\t\t\ttemppoly.push(poly0[k]);\n\t\t\t\tvar fac = (s+1)/(nsteps+1);\n\t\t\t\t\n\t\t\t\tvar newpoint = kp_vsum(poly0[k], kp_vsum(targetpoly[k], poly0[k], -1), fac);\n\t\t\t\t//newpoint = vsum(newpoint, proj, 1);\n\t\t\t\ttemppoly.push( newpoint );\n\t\t\t\t\n\n\t\t\t\tif(debug)\n\t\t\t\t\ttemppoly.push(poly0[k]);\n\t\t\t}\t\n\n\t\t\tvar p = mset.addpoint(temppoly[0], undefined, undefined,  {hideMarkerRepresentation: 1});\n\t\t\tp.referencedImageFileID = points[0].referencedImageFileID;\n\t\t\tp.subpoints = temppoly;\n\n\t\t}\n\t}\n\tmarkerProxy.currentSet.markerPanel.update();\n\tmarkerProxy.currentSet.drawAllPoints();\n\treturn false;\n\n\n}\n\n/******************************************************************\nfill a polygon (or a list of polygons) to a ROI\n******************************************************************/\nfunction fillPolygon(point,nii, addToHistory)\n{\n\n\tvar poly = point.subpoints;\n\n\t// for blocking mode, we need the medviewer to calculate other rois\n\t//if(point.$markers.length > 0 )\n\t\tvar medViewer = point.$markers[Object.getOwnPropertyNames(point.$markers)[0]].medViewer;\n// \telse\n// \t\tvar medViewer = undefined\n\n\n\tvar valtoset = 1;\n\n\n\tif (nii.invedges == undefined)\n\t\tnii.invedges = math.inv(nii.edges);\t\n\n\tvar polyvox = [];\n\tvar sums = [0,0,0];\n\tvar lastpvox;\n\tfor(var k=0; k<poly.length; k++)\n\t{\n\t\tvar pvox = math.multiply(nii.invedges, poly[k])._data;\n\t\tpolyvox.push([math.round(pvox[0]), math.round(pvox[1]), math.round(pvox[2])  ]  );\n\t\t//polyvox.push([(pvox[0]),(pvox[1]), (pvox[2])  ]  );\n\t\tif(k==0)\n\t\t\tlastpvox = pvox;\n\t\telse\n\t\t{\n\t\t\tsums[0] += (lastpvox[0]-pvox[0])*(lastpvox[0]-pvox[0]);\n\t\t\tsums[1] += (lastpvox[1]-pvox[1])*(lastpvox[1]-pvox[1]);\n\t\t\tsums[2] += (lastpvox[2]-pvox[2])*(lastpvox[2]-pvox[2]);\n\t\t\tlastpvox = pvox;\n\t\t}\n\t}\n\tpolyvox.push( polyvox[0] );\n\t// find the best slicing\n\t// find the poly normal vector\n\t\n\tvar temp = kp_vsum(polyvox[1], polyvox[0],-1);\n\tvar themin = kp_vec_min(sums, 1);\n\tvar minind = themin.ind;\n\tvar slicepos = polyvox[0][themin.ind]\n\n\tvar polyvox2DA \t = [];\n\tvar polyvox2DX \t = [];\n\tvar polyvox2DY \t = [];\n\tvar polyvox2DS = [];\n\n\tfor(var k=0; k<polyvox.length; k++)\n\t{\n\t\tif(minind==0)\n\t\t{\n\t\t\tpolyvox2DA.push([polyvox[k][1], polyvox[k][2]])\n\t\t\tpolyvox2DX.push(polyvox[k][1])\n\t\t\tpolyvox2DY.push(polyvox[k][2])\n\t\t\tpolyvox2DS.push(polyvox[k][1])\n\t\t\tpolyvox2DS.push(polyvox[k][2])\n\t\t}\n\t\telse if(minind==1)\n\t\t{\n\t\t\tpolyvox2DA.push([polyvox[k][0], polyvox[k][2]])\n\t\t\tpolyvox2DX.push(polyvox[k][0])\n\t\t\tpolyvox2DY.push(polyvox[k][2])\n\t\t\tpolyvox2DS.push(polyvox[k][0])\n\t\t\tpolyvox2DS.push(polyvox[k][2])\n\t\t}\n\t\telse if(minind==2)\n\t\t{\n\t\t\tpolyvox2DA.push([polyvox[k][0], polyvox[k][1]])\n\t\t\tpolyvox2DX.push(polyvox[k][0])\n\t\t\tpolyvox2DY.push(polyvox[k][1])\n\t\t\tpolyvox2DS.push(polyvox[k][0])\n\t\t\tpolyvox2DS.push(polyvox[k][1])\n\t\t}\n\t\t//polyvox.push(pvox);\n\t}\n\tvar minX = Math.min.apply(null, polyvox2DX)\n\tvar maxX = Math.max.apply(null, polyvox2DX)\n\tvar minY = Math.min.apply(null, polyvox2DY)\n\tvar maxY = Math.max.apply(null, polyvox2DY)\n\n\t// iterate voxel space\n\tvar changedPoints = [];\n\n\t//return false;\n\tvar tOffset = 0;\n\tif (nii.currentTimePoint)\n\t\t   tOffset = nii.currentTimePoint.t * nii.widheidep;\n\n    var f = PolyK.ContainsPointFast(polyvox2DS);\n\tfor (var x = minX; x < maxX; x += 1)\n\t{\n\t\tfor (var y = minY; y < maxY; y += 1)\n\t\t{\n\t\t\tvar isin = f(x, y);\n\t\t\tif (isin)\n\t\t\t{\n\t\t\t\tif(minind==0)\n\t\t\t\t\tvar currentVoxel = [slicepos,x,y,1];\n\t\t\t\telse if(minind==1)\n\t\t\t\t\tvar currentVoxel = [x,slicepos,y,1];\n\t\t\t\telse if(minind==2)\n\t\t\t\t\tvar currentVoxel = [x,y,slicepos,1];\n\n\t\t\t\tvar currentIndex = nii.sizes[0] * nii.sizes[1] * currentVoxel[2] + currentVoxel[1] * nii.sizes[0] + currentVoxel[0] + tOffset;\n \t\t\t\tif (nii.data[currentIndex] != valtoset)\n \t\t\t\t\tchangedPoints.push(currentIndex);\n\n\t\t\t\tnii.data[currentIndex] = valtoset;\n\t\t\t}\n\t\t\t//console.log(isin);\n\t\t}\n\t}\n\n\tKViewer.roiTool.keepExclusive(changedPoints,medViewer,{})\n\n\n\tif(addToHistory && changedPoints.length>0)\n\t{\n\t    KViewer.roiTool.history.record('startRecording');\n        KViewer.roiTool.history.add(changedPoints, valtoset);\n\t    KViewer.roiTool.history.record('stopRecording');\n\t}\n\t\n\treturn {changedPoints: changedPoints};\n}\n"},function(t,n){t.exports='\n// ======================================================================================\n// ======================================================================================\n// ============= KNAvigationTool\n// ======================================================================================\n// ======================================================================================\n \nfunction KNavigationTool(master) \n{\n  /** the tool to transform/rotate/translate images\n   * @class \n   * @alias KNavigationTool\n   * @augments KToolWindow\n   */\n  var that = new KToolWindow(master,\n  $("<div class=\'KView_tool \'><i class=\'fa fa-comment-o fa-1x\'></i></div>")\n  .append( $("<ul class=\'KView_tool_menu\'></ul>").append($("<li>Navigation</li>") ))\n  );\n  that.name = \'Navigation\';\n/*\n that.handleDrop = function(e)\n  {\n  \n    e.preventDefault();\n    e.stopPropagation();\n\n\tcreateLoadParamsFileDrop(e, function (loadparams)\n\t{\n\t\tfor (var k = 0; k < loadparams.length;k++)\n\t\t{\n\t\t  loadparams[k].progressSpinner = that.progressSpinner;\t\t \n  \t\t  loadparams[k].callback = function(fileObject) {\n     \t\tif(fileObject.contentType == \'json\')\n\t\t\t   if (fileObject.fileinfo.Tag.search("RO") >= 0)\n\t\t\t\t master.setReorientationMatrix(fileObject);\n\t\t\tKViewer.cacheManager.update();\n\t\t\tthat.transform.update();\n\t\t\tthat.progressSpinner();\n\t\t\t}\n\t\t  KViewer.dataManager.loadData(loadparams[k]);\n\t\t }\n\t },that.progressSpinner);\n  \n  }\n  */\n  that.$container[0].ondrop = ondrop;\n  that.$container.on("dragover",function(e)\n  {\n  \treturn false;\n  });\n\n  /***************************************************************************************\n   *  The navigation modes \n   ****************************************************************************************/\n\n  function naviMenu()\n  {\n       var modes = {solid:2,coreg:0,resl:1}; var keys = invertObject(modes);\n\t   var $menu = $("<ul>");\n       $menu.append($("<li onchoice=\'"+keys[2]+"\'><a>Rotation </a> <i class=\'"+keys[2]+" fa fa-check-square-o\'></i></li>"));\n       $menu.append($("<li onchoice=\'"+keys[0]+"\'><a>Coregister </a> <i class=\'"+keys[0]+" fa fa-check-square-o\'></i></li>"));\n       $menu.append($("<li onchoice=\'"+keys[1]+"\'><a>Reslice</a> <i class=\'"+keys[1]+" fa fa-check-square-o\'></i></li>"));\n\t   var selFun =  function(ev)\n\t   {\n\t\t\tev.preventDefault();\n\t\t\tev.stopPropagation();\n\t\t\tvar str = $(ev.target).parent().attr("onchoice");\n\t\t\tif (modes[str] != undefined)\n\t\t\t   that.switchToNavimode(modes[str]);\n\t\t\tif (str != undefined | ev.type == "mousedown")\n\t\t\t\t$(document.body).off("mouseup mousedown");\n\t   } \n\n\t   that.switchToNavimode = function (m)\n\t   {\n\t\t\t$menu.find(".fa").removeClass("fa-check-square-o").addClass("fa-square-o");\n\t\t\t$menu.find("." + keys[m]).addClass("fa-check-square-o").removeClass("fa-square-o");\n\t\t\tif (m==2 | m==1)\n\t\t\t{\n\t\t\t//\tdropapply.$dragarea.hide()\n\t\t\t\tif(that.$applybutton)\n\t\t\t\t\tthat.$applybutton.hide();\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tdropapply.$dragarea.show()\n\t\t\t\tthat.$applybutton.show();\n\t\t\t}\n\n\t\t\tif (m == 0 | m==2)\n\t\t\t{\n\t\t\t\tKViewer.currentTilts(0,0).v = 0;\n\t\t\t\tKViewer.currentTilts(0,1).v = 0;\n\t\t\t\tKViewer.currentTilts(1,0).v = 0;\n\t\t\t\tKViewer.currentTilts(1,1).v = 0;\n\t\t\t\tKViewer.currentTilts(2,0).v = 0;\n\t\t\t\tKViewer.currentTilts(2,1).v = 0;\n\n\t\t\t\tKViewer.reorientationMatrix.type = m;\n\t\t\t\tthat.toggleActive(true);\n\t\t\t}\n\t\t\telse\n\t\t\t\tthat.toggleActive(false);\n\t\t\tmaster.navigationMode = m;\n\t\t\tsignalhandler.send("positionChange");\n\t   }\n\n\t   $menu.on("mousedown", selFun);\n\t   return $menu;\n\t   \n\n  }\n\n\n\n  signalhandler.attach("close",function()\n  {\n\t  \tthat.movingObjs ={};\n  \t\tthat.updateMoving();\n\t\tresetTransform();\n\t\tif (KViewer.mainViewport == \'world\')\n\t\t    KViewer.toggleMainViewport(\'world\');\n\n  })\n\n\n\n  function resetTransform()\n  {\n\t  KViewer.reorientationMatrix.matrix =  math.matrix(math.diag([1,1,1,1]));\n  \t  signalhandler.send("reslice");\n\t  KViewer.resetCrossHair();\t\n  }\n\n  function saveTransform()\n\t{\n\t\t  alertify.prompt("Please enter a name",function (e,name) {\n\t\t\tif (e)\n\t\t\t{\n\t\t\t\tKViewer.reorientationMatrix.name = name;\n\t\t\t\tvar mat =math.inv(KViewer.reorientationMatrix.matrix)._data\n\t\t\t\tuploadJSON(name,{matrix: KViewer.reorientationMatrix.matrix._data},{subfolder: "transforms", tag:"RO"},function (fobj,saveobj)\n\t\t\t\t{\n\t\t\t\t   if (saveobj != undefined)\n\t\t\t\t   {\n\n                        var content = "#Insight Transform File V1.0\\n"+\n \t\t\t\t\t\t\t\t\t"#Transform 0\\n"+\n\t\t\t\t\t\t\t\t\t"Transform: AffineTransform_float_3_3\\n"+\n\t\t\t\t\t\t\t\t\t"Parameters: "+([mat[0][0],mat[0][1],-mat[0][2],\n\t\t\t\t\t\t\t\t\t                mat[1][0],mat[1][1],-mat[1][2],\n\t\t\t\t\t\t\t\t\t                -mat[2][0],-mat[2][1],mat[2][2],\n\t\t\t\t\t\t\t\t\t                -mat[0][3],-mat[1][3],mat[2][3]].join(" "))+"\\n"+"FixedParameters: 0 0 0\\n";\n\n\n\t\t\t\t\t\tvar finfo = \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t patients_id : saveobj.patients_id,\n\t\t\t\t\t\t\t studies_id : saveobj.studies_id,\n\t\t\t\t\t\t\t SubFolder:"transforms",\n\t\t\t\t\t\t\t Tag:"itk",\n\t\t\t\t\t\t\t permission:"rwp"\n\t\t\t\t\t\t};\n\n\t\t\t\t\t\tvar obj = {\n\t\t\t\t\t\t\tfilename: name+".itk.aff.txt",\n\t\t\t\t\t\t\tcontent: content ,\n\t\t\t\t\t\t\tfileID: "",\n\t\t\t\t\t\t\tfileinfo:finfo,\n\n\t\t\t\t\t\t}\t\t\t\t   \t\n\n         \t\t       uploadBinary(obj,{},function(){\n         \t\t       \t                    patientTableMirror.mirrorState();\n         \t\t       },that.progressSpinner);\t\t\t\t\n\t\t\t\t   }\n\n\n\t\t\t\t})\n\n \t\t\n\t\t\t}\n\t\t  } );\n\t}\n\n\n  /***************************************************************************************\n   *  The transform menu\n   ****************************************************************************************/\n\n\n  function reorientationMenu()\n  {\n\n\t   var $menu = $("<ul>");\n       $menu.append($("<li onchoice=\'flipx\'><a>Flip X </a></li>"));\n       $menu.append($("<li onchoice=\'flipy\'><a>Flip Y</a></li>"));\n       $menu.append($("<li onchoice=\'flipz\'><a>Flip Z</a></li>"));\n       $menu.append($("<li onchoice=\'cycle\'><a>Cycle permute</a></li>"));\n       $menu.append($("<li onchoice=\'pari\'><a>Change Parity</a></li>"));\n       $menu.append($("<li onchoice=\'invert\'><a>Invert</a></li>"));\n\n\n       $menu.append($("<li onchoice=\'reset\'><a>Reset Transformation</a></li>"));\n       $menu.append($("<li onchoice=\'save\'><a>Save Transformation</a></li>"));\n\n\t   var selFun = function() { return function(ev)\n\t\t\t   {\n\t\t\t\t\tev.preventDefault();\n\t\t\t   \t\tev.stopPropagation();\n\t\t\t\t\tvar str = $(ev.target).parent().attr("onchoice");\n\t\t\t\t\tif (str=="reset")\n                       resetTransform();\n\t\t\t\t\telse if (str=="save")\n\t\t\t\t\t    saveTransForm();\n\t\t\t\t\telse\n                    {\t\n  \t\t\t\t\t\t  var mnii = KViewer.viewports[KViewer.mainViewport].medViewer.nii;\n       \t\t\t\t\t  var edges = math.multiply(1,mnii.edges);\n\t\t\t\t\t\t  edges = math.multiply(edges,permMat(mnii));\n\n       \t\t\t\t\t  var T = transMat(math.multiply(math.inv(edges),math.multiply(math.inv(KViewer.reorientationMatrix.matrix), KViewer.viewcenter)));\t\t\t \n\t\t\t\t\t      var E = math.multiply(edges,T);\n\t\t\t\t\t\t\n\t\t\t\t\t\t  if (str == \'invert\')\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  KViewer.reorientationMatrix.matrix = math.inv(KViewer.reorientationMatrix.matrix);\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  else\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  var R;\n\t\t\t\t\t\t\t  if (str == \'flipx\')\n\t\t\t\t\t\t\t\t R = math.diag([-1,1,1,1]);\n\t\t\t\t\t\t\t  if (str == \'flipy\')\n\t\t\t\t\t\t\t\t R = math.diag([1,-1,1,1]);\n\t\t\t\t\t\t\t  if (str == \'flipz\')\n\t\t\t\t\t\t\t\t R = math.diag([1,1,-1,1]);\n\t\t\t\t\t\t\t  if (str == \'cycle\')\n\t\t\t\t\t\t\t\t R = math.matrix([[0,1,0,0],[0,0,1,0],[1,0,0,0],[0,0,0,1]]);\n\t\t\t\t\t\t\t  if (str == \'pari\')\n\t\t\t\t\t\t\t\t R = math.matrix([[0,0,1,0],[0,1,0,0],[1,0,0,0],[0,0,0,1]]);\n\n\t\t\t\t\t\t\t  KViewer.reorientationMatrix.matrix = math.multiply(KViewer.reorientationMatrix.matrix, math.inv(math.multiply(E,math.multiply(R,math.inv(E)))));\n\t\t\t\t\t\t  } \n                          signalhandler.send("reslice");\n                          signalhandler.send("positionChange");\n                         // KViewer.resetCrossHair();\n                    }\n                    \n\n\t\t\t\t\tif (str != undefined | ev.type == "mousedown")\n\t\t\t\t\t{\n\t\t\t\t\t\t$(document.body).off("mouseup mousedown");\n\t\t\t\t\t}\n\n\t\t\t   }\n\t   }();\n\n\t   $menu.on("mousedown", selFun);\n\t   return $menu;\n  }\n\n\n  /***************************************************************************************\n   *  are we in interpolation mode?\n   ****************************************************************************************/\n\n  that.toggleActive = function(on)\n  {\n  \t var fun;\n  \t if (on != undefined)\n \t\tfun = on?(function (x,c) { x.removeClass(c);}):(function (x,c) { x.addClass(c);});\n  \t else\n \t\tfun = function (x,c) { x.toggleClass(c);} \t\t\n  \t fun(that.$topRow.find(".turnable"),"menu_generic_disabled"); \t \n     fun(that.transform.$div,"inactive");\n    \n     that.updateMasterCaption();\n  }\n\n  that.updateMasterCaption = function()\n  {\n     if (master.mainViewport == -1)\n         mastercap.$master.text("gridding:");\n     else\n     {\n\t\t var master_ = master.viewports[master.mainViewport].medViewer;\n\t\t mastercap.$master.text("gridding: " + master_.currentFilename);\n     }\n  }\n\n  that.$topRow.append( $("<li ><a>Navigation</a></li>").append(naviMenu() ));\n  that.$topRow.append( $("<li class=\'menu_generic_disabled turnable\'><a>Transformations</a></li>").append(reorientationMenu() ));\n  var $listDIV = $("<div class=\'annotation_tool_listDIV\'></div>").appendTo(that.$container);\n\n \n\n  that.resize = function(hei)\n  {\n     that.$container.height(hei);\n  }\n\n\n  /***************************************************************************************\n   *  That\'s the crosshair\n   ****************************************************************************************/\n\n  var crosshair = function ()\n  {\n     var systemList = {\n         RAS: {mat: math.matrix( math.diag([1,1,1,1])), captions: [\'LR\', \'PA\', \'IS\']}      // this is the normal NIFTI System\n        ,LPI: {mat: math.matrix( math.diag([-1,1,-1,1])), captions: [\'RL\', \'PA\', \'SI\']} // this is the LEKSELL System: hinten oben rechts ist negativ\n      }\n     var currentSystem = systemList.RAS;  // default system for normal / alternative\n\n  \t var crosshair = {};\t  \n     crosshair.$captionBar = $("<div></div>").append( $("<div class=\'annotation_tool_caption\' style=\'flex-grow:1;font-weight:bold\'> current coordinate </div>") );\n\t crosshair.$div = $("<div class=\'annotation_tool_elemDIV\'></div>").appendTo($listDIV);\n     crosshair.$captionBar.appendTo(crosshair.$div)  ;\n     var $table  = $("<table></table>").appendTo(crosshair.$div);\n    \n\n      var $systemSelector = $(\'<select></select>\').on(\'change\', function()\n        { currentSystem = systemList[$(this).val()];\n        //  that.parent.annotations.forEach(function(e)  { if(e.points.length > 0)\n         // { \n         //   e.points.forEach(function(z,k){e.movepoint( z.coords, k)}); } \n         // } );\n         // setDirCaptions();\n        }  );\n      Object.keys(systemList).forEach( function(e)  {  $(\'<option>\'+e+\'</option>\').val( e ).appendTo($systemSelector)  } );\n      crosshair.$captionBar.append($("<div>").append($systemSelector) );\n\n        //var $sel =\n        $table.append( $("<tr></tr>")\n            .append( $("<th colspan=3></th>").append($(\'<span>&nbsp;&nbsp;Alternative  &nbsp;&nbsp;  System&nbsp;</span>\'))    )\n            .append("<th></th>")\n            .append( $("<th colspan=3></th>").append($(\'<span>World System</span>\'))  )\n          );\n\n        var $dirCaptionsTR = $("<tr></tr>").appendTo($table);\n        function setDirCaptions()\n        {\n            var captions = currentSystem.captions;\n            $dirCaptions =  $("<th>"+captions[0]+"</th><th>"+captions[1]+"</th><th>"+captions[2]+"</th><th></th><th>"+captions[0]+"</th><th>"+captions[1]+"</th><th>"+captions[2]+"</th>");   \n            $dirCaptionsTR.empty();\n            $dirCaptionsTR.append($dirCaptions).append( $("<th></th>") );\n       }\n        setDirCaptions();\n\n\n\n       var coords = [0,0,0,1];\n       var $row  = $("<tr></tr>");\n       for(var k=0;k<3;k++)\n          $("<td><input type = \'number\' value=\'"+ coords[k].toFixed(1) +"\' /></td>").appendTo($row).on(\'change\', onInputFieldChange);\n       coords = math.multiply( math.inv(master.reorientationMatrix.matrix), coords)._data ; // go to reoriented system\n       $("<td></td>").appendTo($row) ;\n       for(var k=0;k<3;k++)\n          $("<td><input type = \'number\' value=\'"+ coords[k].toFixed(1) +"\' /></td>").appendTo($row).on(\'change\', onInputFieldChange);\n       $("<td><input type=\'text\' class=\'KAnnotationTool_comment\' value=\'\' /></td>").appendTo($row) ;\n       var $tools = $("<div class=\'annotation_tool_elemDIV_toolbar\'></div>");\n       var inputs = $row.find("input");\n\n       $row.appendTo( $table );\n\n\n       function update()\n\t   {\n\t\t\tfunction setVals(inputs,coords,offs)\n\t\t\t{\n\t\t\t\tfor(var k=0;k<3;k++)   \n\t\t\t\t   inputs[k+offs].value =  coords._data[k].toFixed(3);   \t\t\t\t\n\t\t\t}\n\t\t\tvar mat = KViewer.reorientationMatrix.matrix;\n\t\t\tvar coords = math.multiply(math.inv( mat),master.currentPoint);\n\t\t\tsetVals(inputs,math.multiply(math.inv( mat),master.currentPoint),0)\n \t \t    setVals(inputs,master.currentPoint ,3)\n\t   }\n\t   signalhandler.attach("positionChange",update);\n\n\t   function onInputFieldChange(event)\n\t   {\t   \t  \n   \t\t   var coords = [ parseFloat( inputs[0].value), parseFloat( inputs[1].value ), parseFloat( inputs[2].value ),1   ];\n   \t\t   var mat = KViewer.reorientationMatrix.matrix;\n           coords = math.multiply(mat, coords ); // apply RAS or other\n           master.currentPoint = math.matrix( coords );\n           signalhandler.send("positionChange");\n\t   }\n\n\t   return crosshair;\n    }();\n\n\n /*****************************************************************************************\n  *  Show who the master is, or decide for world\n  ****************************************************************************************/\n\n\n  var mastercap = function ()\n  {\n  \t var mastercap = {};\t  \n //$("<div class=\'annotation_tool_elemDIV_tools\'></div>") \n     mastercap.$worldToggle =  $("<i class=\'fa fa fa-1x\'> <span>WORLD</span> </i>").click(worldMaster);\n     mastercap.$toolToggle =  $("<div class=\'annotation_tool_elemDIV_tools\' class=\'KViewPort_tool\'></div>").append(mastercap.$worldToggle);\n//     mastercap.$worldToggle =  $("<div myid=\'KViewPort_tool_toggleMainViewport\' class=\'KViewPort_tool\'><i class=\'fa fa fa-1x\'> WORLD </i></div>");\n   \n \t var voxsz = eval(state.viewer.worldVoxelsize); \t \n \t val = 1;\n \t if (voxsz != undefined && voxsz[0] != undefined)\n \t \tval = voxsz[0];\n \t \t\n     mastercap.$voxsz = $("<div class=\'annotation_tool_elemDIV_tools\' > world voxsz: <input style=\'width:40px;\' type = \'number\' value=\'"+val+"\' min=\'0.1\' max=\'2\' step=\'0.1\' /> </span>");\n     mastercap.$master = $("<div class=\'annotation_tool_caption\' style=\'flex-grow:1;font-weight:bold\'> gridding: </span>");\n     mastercap.$captionBar = $("<div></div>").append( mastercap.$master )\n     \t\t\t\t\t\t\t\t\t\t .append( mastercap.$voxsz )\n                                             .append( mastercap.$toolToggle);\n     mastercap.$voxsz.find("input").on("change",function(e)\n     {\n     \tvar v = parseFloat($(e.target).val());\n     \tstate.viewer.worldVoxelsize = [v,v,v];\n     \t worldMaster();\n     \t worldMaster();\n     \t \n    \tsignalhandler.send("reslice positionChange");\n     });\n\t mastercap.$div = $("<div class=\'annotation_tool_elemDIV\'></div>").appendTo($listDIV);\n     mastercap.$captionBar.appendTo(mastercap.$div)  ;\n\n     return mastercap;\n  }();\n\n\n  function worldMaster()\n  {\n    var navtool = that;\n\tKViewer.viewports[\'world\'] = function()\n\t{ \n\t  var that = {};\n\t  that.getCurrentViewer = function() { return that };\n\t  that.viewPortID = \'world\';\n\t  that.medViewer = {dummyViewer:true};\n\t  that.medViewer.currentFilename = "world";\n\t  that.medViewer.toolbar = {$mainViewportSelector: mastercap.$worldToggle };\n\t  that.viewPortID = \'world\';\n\n      var bbox_max = [-Infinity,-Infinity,-Infinity];\n      var bbox_min = [Infinity,Infinity,Infinity];\n       \n\t  if (typeof(state.viewer.worldVoxelsize[0]) == "string")\n\t  \tstate.viewer.worldVoxelsize = JSON.parse(state.viewer.worldVoxelsize);\n\n   \t  mastercap.$voxsz.find("input").val(state.viewer.worldVoxelsize[0]);\n\n\n      var files = KViewer.dataManager.getFileList();\n      for (var k = 0;k<files.length;k++)\n      {\n      \t var obj = KViewer.dataManager.getFile(files[k]);\n      \t navtool.movingObjs\n\t\t if (obj.contentType == \'nii\')\n\t\t {\n\t\t\tvar edges = obj.content.edges;\n\n\n        //    if ( navtool.movingObjs && navtool.movingObjs[files[k]])\n            {\n            \tedges = math.multiply(math.inv(KViewer.reorientationMatrix.matrix),edges);\n            }\n\n\t\t\tvar sz = obj.content.sizes;\n\t\t\tvar corners  = [[0,0,0,1],[sz[0]-1,0,0,1],[0,sz[1]-1,0,1],[0,0,sz[2]-1,1],\n\t\t\t\t\t\t\t[sz[0]-1,sz[1]-1,0,1],[sz[0]-1,0,sz[2]-1,1],[0,sz[1]-1,sz[2]-1,1], [sz[0]-1,sz[1]-1,sz[2]-1,1]];\n\n\t\t\tvar wcorners = math.multiply(edges,math.transpose(corners));\n\t\t\tfor (var i =0;i < 3;i++)\n\t\t\t{\n\t\t\t\tbbox_max[i] = math.max([bbox_max[i],math.max(wcorners._data[i])]);\n\t\t\t\tbbox_min[i] = math.min([bbox_min[i],math.min(wcorners._data[i])]);\n\t\t\t}\n\t\t }\n\n      }\n\n\t  var voxsz = eval(state.viewer.worldVoxelsize);\n\t  if (voxsz == undefined || voxsz.length < 3) \n\t  \t voxsz = [1,1,1];\n\t  voxsz[3] = 1;\n \t  var sizes = [];\n \t  for (var i=0; i< 3;i++)\n \t  \t sizes[i] = math.floor((bbox_max[i]-bbox_min[i])/voxsz[i]);\n\n\t  var voxsz = [0,0,0,1];\n \t  for (var i=0; i< 3;i++)\n \t  \t voxsz[i] = (bbox_max[i]-bbox_min[i])/sizes[i];\n\n\n      var Order = KMedViewer.getPermutationOrder();\n      var perm = Order.perm;\n  \n\t  var edges = math.matrix(math.diag(voxsz));\n \t  \n\n      for (var i = 0;i < 3;i++)\n\t\t   edges._data[i][3] = +bbox_min[i];\n\t  \t\n\n\t  that.medViewer.nii = {\n\t\t  edges: edges,\n\t\t  voxSize: voxsz,\n\t\t  pixdim: [1,voxsz[0],voxsz[1],voxsz[2]],\n\t\t  sizes: sizes,//  newsizes,\n\t\t  permutationOrder:perm,\n\t\t  arrayReadDirection: Order.flips, \n\t\t  detsign:math.sign(math.det(edges))\n\t   }\n       return that;    \n    }();    \n    \n    KViewer.toggleMainViewport(\'world\');\n\n\n    signalhandler.send("reslice positionChange");\n  }\n  that.worldMaster = worldMaster;\n\n\n /*****************************************************************************************\n  *  Show the transform\n  ****************************************************************************************/\n  that.$applybutton = undefined;\n  that.transform = function ()\n  {\n\n  \t var transform = {};\t  \n     transform.$captionBar = $("<div></div>").append( $("<div class=\'annotation_tool_caption\' style=\'flex-grow:1;font-weight:bold\'> current transform</span>") );\n\t transform.$div = $("<div class=\'inactive annotation_tool_elemDIV\'></div>").appendTo($listDIV);\n     transform.$captionBar.appendTo(transform.$div)  ;\n     var $table  = $("<table></table>").appendTo(transform.$div);\n   \n\t \n\n\t var $tools = ( $("<div class=\'annotation_tool_elemDIV_tools\'></div>") )\n\t\t\t\t.append( that.$applybutton = $("<i class=\'fa fa-fw\'> <span> APPLY </span> </i>").click(applyTransform) )\n\t\t\t\t.append( $("<i class=\'fa fa-reply\'> </i>").click(resetTransform) )\n\t\t\t\t.append( $("<i class =\'fa fa-save \'></i>").click(saveTransform  ))\n\t transform.$captionBar.append($tools);\n\n    \n     var inputs = [];\n     for (var j = 0; j < 3; j++)\n     {\n\t\tinputs[j] = [];\n\t\tvar $row  = $("<tr></tr>");\n\t\tfor(var k=0;k<4;k++)\n\t\t{\n\t\t   var $td = $("<td>").appendTo($row).on(\'change\', onInputFieldChange);\n\t\t   inputs[j][k] = $("<input type = \'number\' value=\'"+ ((j==k)?1:0) +"\' />").appendTo($td);\n\t\t}\n\t\t$row.appendTo( $table );\n \t }\n       \n  \n     function update()\n\t {\n\t\t var mat = KViewer.reorientationMatrix.matrix;\n\t\t if (mat != undefined)\n\t\t {\n\t\t\tmat = mat._data;\n\t \t    for (var j = 0; j < 3; j++)\n\t\t\t  for(var k=0;k<4;k++)\n\t\t\t\tinputs[j][k][0].value = mat[j][k].toFixed(3);\n     \t }\n  \t }\n\t signalhandler.attach("positionChange",update);\n\t transform.update = update;\n\n\t function onInputFieldChange(event)\n\t {\t   \t  \n\t    var mat = KViewer.reorientationMatrix.matrix;\n\t\tfor (var j = 0; j < 3; j++)\n \t\t    for(var k=0;k<4;k++)\n \t\t    \t mat._data[j][k] = parseFloat( inputs[j][k][0].value);\n\n\n//\t    coords = math.multiply(mat, KViewer.currentPoint ); // apply RAS or other\n//\t    master.currentPoint = math.matrix( coords );\n\t    signalhandler.send("positionChange");\n\t }\n\n\t return transform;\n    }();\n\n\n /*****************************************************************************************\n  *  Apply the transform by drop of files\n  ****************************************************************************************/\n\n\n  function Waiter(callback)\n  {\n\t var funs = [];\n\t var waiter = {};\n\t waiter.callback = callback;\n\t waiter.waitfor = function(f)\n\t {\n\t \tfuns.push(f);\n\t }\n\t waiter.done = function(f)\n\t {\n\t \tfor (var k= 0; k < funs.length;k++)\n\t \t{\n\t \t\tif (funs[k]==f)\n\t \t\t{\n\t \t\t\tfuns.splice(k,1);\n\t \t\t\tbreak;\n\t \t\t}\n\t \t}\n\t \tif (funs.length == 0)\n\t \t\twaiter.callback();\n\t \t\n\t }\n\t return waiter;\n\n  }\n\n\n  that.movingObjs = {};\n\n  that.updateMoving = function()\n  {\n\t dropapply.$dragarea.children().remove();\n\t objs = Object.keys(that.movingObjs);\n\t for (var k = 0; k < objs.length; k++)\n\t {\n\t \tvar fobj = that.movingObjs[objs[k]];\n\t \tif (fobj != undefined)\n\t \t{\n\t\t\tvar dragstuff = "draggable=\'true\' data-type=\'file\' data-piz=\'\' data-sid=\'\' data-tag=\'"+fobj.fileinfo.Tag+"\' data-filename=\'"+fobj.filename+"\' data-subfolder=\'\' data-fileID=\'"+fobj.fileID+"\' data-mime=\'"+fobj.contentType+"\'";\n\t\t\tdragstuff = dragstuff + " ondragstart=\'setdragstart(event);\' ondragend=\'setdragend(event);\' ondblclick=\'loadDataOndblClick(event);\'";\t \t\n\t\t\tvar $close = $("<i class=\'fa fa-fw fa-close\'></i>").click(function(o) { return function() { delete that.movingObjs[o];  that.updateMoving();   } }(objs[k]) );\n\t\t\t$("<div> <div "+dragstuff+">" + fobj.filename + "</div>  </div>").append($close).appendTo(dropapply.$dragarea);\n\t \t}\t \t\n\t }\n \t if (objs.length > 0)\n\t {\n\t   if (KViewer.navigationMode != 0)\n\t      that.switchToNavimode(0);\n\t   if (KViewer.mainViewport != \'world\')\n\t   \t  worldMaster();\n\t }\n\t else\n\t {\n\t   $("<span>drop nifti to define moving images </span>").appendTo(dropapply.$dragarea);\n\t   that.switchToNavimode(2);\n\t }\n\n\t signalhandler.send("positionChange");\n  }\n\n \n\n  function ondrop(e) {\n\n\t\t\te.preventDefault();\n\t\t\te.stopPropagation();\n\t\t\tvar params = getloadParamsFromDrop(e,{});\n\t\t\tfor (var k = 0;k < params.length;k++)\n\t\t\t{\n\t\t\t\tif (!params.patient_study_drop)\n\t\t\t\t{\n\t\t\t\t\tparams[k].callback = function(fobj) {\n\t\t\t\t\t\tif (fobj.contentType == \'nii\')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tthat.movingObjs[fobj.fileID] = fobj;\n\t\t\t\t\t\t\tthat.updateMoving();\n\t\t\t\t\t\t}\n\t\t\t     \t\telse if(fobj.contentType == \'json\')\n\t\t\t\t\t\t   if (fobj.fileinfo.Tag.search("RO") >= 0)\n\t\t\t\t \t\t\t\tmaster.setReorientationMatrix(fobj);\n\n\n\t\t\t\t\t\tthis.progressSpinner();\n\t\t\t\t\t}\n\t\t\t\t\tparams[k].progressSpinner = that.progressSpinner;\n\t\t\t\t\tKViewer.dataManager.loadData(params[k]);\t\t\n\n\t\t\t\t}\n\t\t\t}\n  }\n\n\n\n  var dropapply = function ()\n  {\n\t\tvar dropapply = {};\t  \n\t\tdropapply.$master = $("<div class=\'annotation_tool_elemDIV\' ></div>").appendTo($listDIV);\n\t\tdropapply.$dragarea = $("<div dragover=\'return false\'; class=\'annotation_tool_droparea\'><span>drop nifti to define moving images</span></div>").appendTo(dropapply.$master);\n\n\n\t\n\n\t\tdropapply.$master.on("dragover", function(ev){ev.preventDefault();ev.stopPropagation();return false;});\n\t\tdropapply.$master.on("dragleave", function(ev){ev.preventDefault();ev.stopPropagation();return false;});\n\n\n    \t return  dropapply;\n     }();\n\n\tfunction applyTransform()\n\t{\n\t    alertify.prompt("Please enter a name of the transform (note that you also change the " +\n\t    "affine matrix of all niftis selected for coregistration)",function (e,name) {\n\t\tif (e)\n\t\t{\n   \t\t    var fnames = [];\n   \t\t    var keys = Object.keys(that.movingObjs);\n\t\t\tfor (var k = 0; k < keys.length; k++)\n\t\t\t   fnames.push(that.movingObjs[keys[k]].filename);\n\t\t\t\n\t\t\tvar finfo = that.movingObjs[keys[0]].fileinfo;\n\n\t\t\t\n\t\t\tKViewer.reorientationMatrix.name = name;\n\t\t\tuploadJSON(name,\n\t\t\t  {matrix: KViewer.reorientationMatrix.matrix._data, applied_when:Date(), applied_on:fnames  },\n\t\t\t  {subfolder: "transforms", tag:"RO", patients_id:finfo.patients_id, studies_id:finfo.studies_id},\n\t\t\t  applyOnNiftis );\n\t\t\t\n\t\t} },\'reorient\' );\n\n\t\tfunction applyOnNiftis()\n\t\t{\n\t\t\ttempObjectInfo = [];\n\t\t\tvar keys = Object.keys(that.movingObjs);\n\t\t\tfor (var k = 0; k < keys.length; k++)\n\t\t\t{\n\t\t\t\tvar fobj = that.movingObjs[keys[k]];\n\t\t\t\tvar newedges = math.multiply(math.inv(KViewer.reorientationMatrix.matrix),fobj.content.edges);\n\n\t\t\t\tvar view = new DataView(fobj.content.buffer)\n\t\t\t\tfor(var i=0; i<3; i++) \n\t\t\t\t  for (var j=0; j<4; j++)\n\t\t\t\t\tview.setFloat32(280+4*(4*i+j), newedges._data[i][j], fobj.content.endian==\'little\');\n\n\n                var qquat = sform2quaternion(newedges);\n\n\t\t\t\tview.setFloat32(256, qquat.q[0], fobj.content.endian==\'little\');\n\t\t\t\tview.setFloat32(260, qquat.q[1], fobj.content.endian==\'little\');\n\t\t\t\tview.setFloat32(264, qquat.q[2], fobj.content.endian==\'little\');\n\t\t\t\tview.setFloat32(268, newedges._data[0][3], fobj.content.endian==\'little\')\n\t\t\t\tview.setFloat32(272, newedges._data[1][3], fobj.content.endian==\'little\')\n\t\t\t\tview.setFloat32(276, newedges._data[2][3], fobj.content.endian==\'little\')\n\n\n                view.setFloat32(76+4*1, qquat.pixdim[1] , fobj.content.endian==\'little\')\n                view.setFloat32(76+4*2, qquat.pixdim[2] , fobj.content.endian==\'little\')\n                view.setFloat32(76+4*3, qquat.pixdim[3] , fobj.content.endian==\'little\')\n\n  \t\t\t\tview.setInt16(252, 0, fobj.content.endian==\'little\')\n  \t\t\t\tview.setInt16(254, 1, fobj.content.endian==\'little\')\n\n\t\t\t\tvar tmp = prepareMedicalImageData(parse(fobj.content.buffer), {});\n\t\t\t\tfobj.content.edges = tmp.edges;\n\t\t\t\tfobj.content.arrayReadDirection = tmp.arrayReadDirection;\n\t\t\t\tfobj.content.permutationOrder = tmp.permutationOrder; \n\t\t\t\tfobj.modified = true;\n        \t    tempObjectInfo.push({fileID:keys[k]});      \n\t\t\t\tKViewer.cacheManager.update();\n\t\t\t}\n\t\t\tsignalhandler.send(\'reslice positionChange\');\n\t\t\tresetTransform();\n            KViewer.cacheManager.uploadFiles(that.progressSpinner,"usenativePID");\n\n\t\t}\n\n\n\t}\n\n\n    that.switchToNavimode(master.navigationMode);\n\n\treturn that;\n}\n\n'},function(t,n){t.exports='\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= KRoiTool\n// ======================================================================================\n// ======================================================================================\n\n\nfunction KRoiTool(master)\n{\n    var $menu = $("<ul class=\'KView_tool_menu\'></ul>").append($("<li>ROI Tool</li>"));\n    var $thetog = $("<div class=\'KView_tool \'><i class=\'fa fa-pencil fa-1x\'></i></div>").append($menu);\n\n    /** A ROI-tool for drawing and managing ROIs\n\t * @class\n\t * @alias KRoiTool\n\t * @augments KToolWindow\n\t */\n    var that = new KToolWindow(master,$thetog);\n\n    that.name = \'ROIs\';\n\n    that.conncompdesc = "island";\n\n    var ROIs = {};\n    that.ROIs = ROIs;\n\n    var currentROI = undefined;\n\n    that.$topRow.addClass("RoiTool_topmenu")\n\n    /***************************************************************************************\n    * the roi menu\n    ****************************************************************************************/\n    var $mainmenu = $("<ul></ul>");\n    var $menu = $("<ul ></ul>");\n    //$menu.append($("<li><a>New ROI</a> </i></li>").click(addROI));\n\n    $menu.append($("<li><a>Save all ROIs </a></i></li>").click(function()\n    {\n        saveAllROIs();\n    }));\n    $menu.append($("<li><a>Delete all ROIs</a></i></li>").click(function()\n    {\n        clearAll();\n    }));\n\n    that.$topRow.append($("<li><a>ROI menu</a></li>").append($menu).appendTo($mainmenu));\n    that.$topRow.append($mainmenu);\n\n    that.$topRow.append($("<li style=\'margin-left:5px; padding-left:5px; border-left:1px solid gray\'><a>  ROI stats</a> </i></li>").click(function()\n    {\n        that.statdlg.toggle();\n        that.statdlg.dostats();\n    }\n    ));\n\n    that.statdlg = new statistics_dialog();\n\n    that.computeStats = computeStats;\n\n        function computeStats(roi, img, opts)\n        {\n            var w = roi.sizes[0];\n            var wh = roi.sizes[0] * roi.sizes[1];\n            var whd = roi.sizes[0] * roi.sizes[1] * roi.sizes[2];\n\n            var np = 0;\n            if (img)\n            {\n                var A = math.multiply(math.inv(img.edges), roi.edges);\n                np = img.numTimePoints\n            }\n\n            var mean = [];\n            var std = [];\n            var vol = [];\n            var vol_tot = [];            \n            var area = [];\n            var area_tot = [];\n\n            // set calcmedian as flag, might be expensive on huge arrays to store all vals\n            var calcmedian = true;\n            var median = [];\n            var iqr1    = [];\n            var iqr2    = [];\n            var values = [];\n\n\t\t\tvar exclude_zeros = (opts && opts.exclude_zeros);\n\n            // iterate over timeseries if present\n            for (var t = 0; t < math.max([np, roi.numTimePoints]); t++)\n            {\n                var m = 0;\n                var m2 = 0;\n                var cnt = 0;\n                var cnt2 = 0;\n                var tvals = [];\n\n                var currentTimePointROI =  t>roi.numTimePoints-1?roi.numTimePoints-1:t\n                var currentTimePointIMG =  t>np-1?np-1:t\n                \n                for (var z = 0; z < roi.sizes[2]; z++)\n                    for (var y = 0; y < roi.sizes[1]; y++)\n                        for (var x = 0; x < roi.sizes[0]; x++)\n                        {\n\n                            if (roi.data[x + y * w + z * wh + currentTimePointROI*whd] > 0)\n                            {\n                                var tp = 0;\n                                var v = 0;\n                                if (img)\n                                {\n                                    var toffs = img.sizes[0] * img.sizes[1] * img.sizes[2] * currentTimePointIMG;\n                                    v = NNInterp(img, x, y, z, A._data, toffs);\n                                    v = img.datascaling.e(v);\n                                }\n                                if (!isNaN(v))\n                                {\n                                \tif( !(v==0 && exclude_zeros) )\n                                \t{\n\t\t\t\t\t\t\t\t\t\tm += v;\n\t\t\t\t\t\t\t\t\t\tm2 += v * v;\n\t\t\t\t\t\t\t\t\t\tcnt++;\n\t\t\t\t\t\t\t\t\t\tif(calcmedian)\n\t\t\t\t\t\t\t\t\t\t\ttvals.push(v);\n                                \t}\n                                }\n                                cnt2++;\n                            }\n                        }\n\n                mean.push( m / cnt );\n                //console.log(m + " count " + cnt)\n                std.push( math.sqrt( m2 / cnt - mean[t] * mean[t]) )\n\n                if(calcmedian)\n                {\n                \tvar xx = math.median(tvals, 1) ;\n                \tif (xx.median == undefined)\n                \t{\n                \t   xx.median = NaN;\n                \t   xx.iqr1 = NaN;\n                \t   xx.iqr2 = NaN;\n                \t}\n                    median.push( xx.median);\n                    iqr1.push( xx.iqr1 );\n                    iqr2.push( xx.iqr2 );\n                    values.push(tvals);\n                }\n\n                var tvol  = cnt * roi.voxSize[0] * roi.voxSize[1] * roi.voxSize[2] / 1000; // mL\n                var tvol_tot  = cnt2 * roi.voxSize[0] * roi.voxSize[1] * roi.voxSize[2] / 1000; // mL\n                // mL or microliters ??\n    //             if( tvol < 1)\n    //                 var volumestr = (tvol *1000).toFixed(1) + " microL";\n    //             else\n    //                 var volumestr = tvol.toFixed(1) + " mL";\n                // for 1-D rois ,allow also a area\n                vol.push(tvol);\n                vol_tot.push(tvol_tot);\n\n                var tarea = cnt * roi.voxSize[0] * roi.voxSize[1] / 100;// in cm2\n                var tarea_tot = cnt2 * roi.voxSize[0] * roi.voxSize[1] / 100;// in cm2\n\n                area.push(tarea);\n                area_tot.push(tarea_tot);\n            }\n\n            return {\n                mean: mean,\n                std: std,\n                vol:vol,\n                vol_tot:vol_tot,\n                area:area,\n                area_tot:area_tot,\n                median:median,\n                iqr1: iqr1,\n                iqr2: iqr2,\n\n            };\n        }\n\n\n\n    /***************************************************************************************\n   * statistics dialog\n   ****************************************************************************************/\n\n    function statistics_dialog()\n    {\n        var that = new dialog_generic();\n        that.$frame.hide()\n        $("<li><a>ROI statistics</a></li>").appendTo(that.$menu)\n        $("<li><a> <i class=\'fa fa-refresh\'></i> </a>  </li>").click(dostats).appendTo(that.$menu);\n        $("<li><a> <i class=\'fa fa-copy\'></i>copy table to clipboard </a>  </li>").click(function() { copyTableToClipboard($table.get(0)); } ).appendTo(that.$menu);\n\n\t\tvar $options = $("<table class=\'\'></table>").appendTo(that.$container);\n\t\t//var $threshold = $("<input value=\'-Inf\' type=\'number\'/>").appendTo($("<div><span> take values greater than: </span></div>").appendTo($options));\n\t\tvar $exclude_zeros = $("<input id=\'dsgssgafsgafgaeeae\' type=\'checkbox\'/>").appendTo($("<div><label for=\'dsgssgafsgafgaeeae\'>exclude zeros: </label></div>").appendTo($options));\n\n\n        //that.$container.append($("<div id=\'roistatsdialog\'></div>"));\n\n\n        /***************************************************************************************\n        * statistics table\n        ****************************************************************************************/\n        var $table;\n\n        function dostats()\n        {\n            var _imgs = {};\n            for (var k = 0; k < KViewer.viewports.length; k++)\n                if (KViewer.viewports[k] && KViewer.viewports[k].medViewer != undefined && KViewer.viewports[k].medViewer.nii != undefined)\n                {\n                    var v = KViewer.viewports[k].getCurrentViewer();\n                    _imgs[v.currentFileID] = KViewer.viewports[k].getCurrentViewer();\n\n                }\n\n            var rois = Object.keys(ROIs);\n            var imgs = Object.keys(_imgs);\n\n\n            that.$container.find(".KRoistats_tablecontainer").remove();\n\n            var $div = $("<div class=\'KRoistats_tablecontainer\'></div>").appendTo(that.$container);\n\n\n            $table = $("<table class=\'KRoistats_table text_selectable\'></table>").appendTo($div);\n\n            //var $row = $("<tr> <td>Image</td> <td>T</td> <td>ROI</td>  <td></td> <td>mean</td>  <td>std</td>  <td>vol (mL)</td>  <td>area (cm2)</td>  </tr>").appendTo( $("<thead></thead>").appendTo($table ));\n\n            var $row = $("<tr> <td>Image</td> <td>T</td> <td>ROI</td> <td>T</td> <td></td> <td>median</td> <td>iqr1</td> <td>iqr2</td> <td>mean</td>  <td>std</td>  <td>vol (mL)</td>  <td>area (cm2)</td>  </tr>").appendTo( $("<thead></thead>").appendTo($table ));\n\n            var $tbody = $("<tbody></tbody>").appendTo($table);\n\n            for (var j = 0; j < imgs.length; j++)\n            {\n\n                var x= _imgs[imgs[j]];\n                var img = _imgs[imgs[j]].niiOriginal;\n\n                for (var k = 0; k < rois.length; k++)\n                {\n                    var roi = ROIs[rois[k]];\n\n\n                    var stats = computeStats(roi.content, img, {exclude_zeros: $exclude_zeros.is(\':checked\') });\n\n                    // iterate over timepoints\n                    for(var t=0; t<stats.mean.length; t++)\n                    {\n\n                        var $trow = $("<tr></tr>").appendTo($tbody);\n                        if(k==0)\n                        {\n                            var filename =  x.currentFileinfo.SubFolder + x.currentFilename  ;\n                            var tclass = ""\n                        }\n                        else\n                        {\n                            var filename = "";\n                            var tclass = "noupperborder"\n                        }\n                        var roicolor = "rgb(" + KColor.list[roi.color].join(\',\') +")";\n\n                        if( t > 0)\n                            filename = "";\n\n                        $("<td class=\'"+tclass+"\'>" + filename + "</td>").appendTo($trow);\n                        if(stats.mean.length>1)\n                            var tp = ("0"+ (t+1).toString()).slice(-2);\n                        else\n                            var tp = "";\n\n                        var currentTimePointROI =  t>roi.content.numTimePoints-1?roi.content.numTimePoints-1:t\n                        var currentTimePointIMG =  t>img.numTimePoints-1?img.numTimePoints-1:t\n\n\n                        $("<td class=\'\'>" + currentTimePointIMG + "</td>").appendTo($trow);\n\n                        $("<td style=\'\'>" + roi.filename        +"</td>").appendTo($trow);\n\n                        $("<td class=\'\'>" + currentTimePointROI + "</td>").appendTo($trow);\n\n                        $("<td style=\'background:"+roicolor+";width:8px;\'>" +"</td>").appendTo($trow);\n\n                        $("<td>" + stats.median[t].toFixed(3)       +"</td>").appendTo($trow);\n                        $("<td>" + stats.iqr1[t].toFixed(3)       +"</td>").appendTo($trow);\n                        $("<td>" + stats.iqr2[t].toFixed(3)       +"</td>").appendTo($trow);\n\n                        $("<td>" + stats.mean[t].toFixed(3)       +"</td>").appendTo($trow);\n                        $("<td>" + stats.std[t].toFixed(3)       +"</td>").appendTo($trow);\n\n                        $("<td>" + stats.vol[t].toFixed(3)      +"</td>").appendTo($trow);\n                        $("<td>" + stats.area[t].toFixed(3)      +"</td>").appendTo($trow);\n                    }\n\n                }\n            }\n\n        }\n\n        that.dostats = dostats;\n\n        return that;\n    }\n\n    /***************************************************************************************\n   * the panel and the activation\n   ****************************************************************************************/\n\n    that.panelEnabled = false;\n    // needs a medViewer as target\n    that.$pencil = $("<div class=\'roiTool_pencil\'></div>").append($("<div class=\'roiTool_pencil_haircross left\'></div>")).append($("<div class=\'roiTool_pencil_busy\'><i class=\'fa fa-spinner fa-spin\'></i></div>")).append($("<div class=\'roiTool_pencil_haircross right\'></div>")).hide().appendTo(document.body);\n\n    // check if any roi is enabled for drawing in any viewport, and set panel active / inactive\n    function checkForAnyActiveRoi()\n    {\n        /*\n\t\tvar found = false;\n\t\tfor(var v = 0; v<KViewer.viewports.length; v++)\n\t\t{\n\t\t\tvar viewer = KViewer.viewports[v].getCurrentViewer();\n\t\t\tif(viewer==undefined)\n\t\t\t\tcontinue;\n\t\t\tfor (var k = 0; k < viewer.ROIs.length;k++)\n\t\t\t{\n\t\t\t\tif (viewer.ROIs[k].isCurrent)\n\t\t\t\t{\n\t\t\t\t   found = true;\n\t\t\t\t   break;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t*/\n        // there is always an activ roi\n        found = currentROI != undefined;\n        if (!found)\n        {\n            that.roiPanel.$drawingEnabledSign.hide();\n        }\n        //that.roiPanel.$container.find(".roiTool_panel_flex").addClass("inactive");\n        else\n        {\n           that.roiPanel.$drawingEnabledSign.show();\n        }\n        //that.roiPanel.$container.find(".roiTool_panel_flex").removeClass("inactive");\n        return found;\n    }\n    that.checkForAnyActiveRoi = checkForAnyActiveRoi;\n\n\n    that.togglePen = function(state)\n    {\n        that.penEnabled = state;\n\n    }\n\n\n\n    /***************************************************************************************\n   * the pencil\n   ****************************************************************************************/\n    var pencil = {\n        radius: 20,\n        radius_z: 3,\n        thres: 0,\n        thres_low:0,\n        thres_high:"off"\n    };\n    that.pencil = pencil;\n    that.smartpaw = false;\n    that.regionGrow = false;\n\n    that.penEnabled = false;\n    that.threspen = 0;\n\n    that.pensizechange = pensizechange;\n    function pensizechange(ev, which, medViewer)\n    {\n        if (ev.myScrollAmount !== undefined) // pensizechange was triggered by shift + mousescroll\n        {\n            var newval = pencil[which] + ev.myScrollAmount;\n            if (newval >= 0)\n            {\n                pencil[which] = newval;\n                that.roiPanel.$inplaneradius.val(newval);\n                drawPen(ev, medViewer);\n            }\n\n        }\n        else\n        {\n            var prop = parseFloat($(ev.target).val());\n            if(prop<0)\n                prop=0;\n            pencil[which] = prop;\n        }\n    }\n\n\n\n    var $innerDIV = $("<div class=\'roiToolContainer\'></div>").appendTo(that.$container);\n\n    that.$panelcontainer = $("<div class=\'roiToolPanelContainer\'></div>").appendTo($innerDIV);\n    that.$tablecontainer = $("<div class=\'\'></div>").appendTo($innerDIV);\n    var $table = $("<table class=\'localfiletable\'></table>").appendTo(that.$tablecontainer);\n\n\n    /***************************************************************************************\n   * the colors\n   ****************************************************************************************/\n\n    var colors = KColor.list;\n    that.colors = colors;\n    function componentToHex(c) {\n        var hex = c.toString(16);\n        return hex.length == 1 ? "0" + hex : hex;\n    }\n    function RGB2HTML(r, g, b) {\n        return "#" + componentToHex(r) + componentToHex(g) + componentToHex(b);\n    }\n\n\n    update();\n\n    /***************************************************************************************\n   * resize handler\n   ****************************************************************************************/\n\n    that.resize = function(hei)\n    {\n        that.$container.height(hei);\n        $innerDIV.height(hei - that.$container.find(\'.KToolsTopMenu\').height());\n\n\n    }\n\n\n    /***************************************************************************************\n   * clear all\n   ****************************************************************************************/\n\n    function clearAll()\n    {\n\n        for (var r in ROIs)\n            deleteReferencesOnROI(ROIs[r].fileID);\n\n        ROIs = {};\n        that.ROIs = ROIs;\n        update();\n        signalhandler.send("positionChange");\n    }\n    that.clearAll = clearAll;\n\n\n    function deleteReferencesOnROI(id)\n    {\n        KViewer.iterateMedViewers(function (medViewer) {\n                for (var j = 0; j < medViewer.ROIs.length; j++)\n                {\n                    if (medViewer.ROIs[j].roi.fileID == id)\n                        medViewer.ROIs[j].close();\n                }\n\n        });\n    }\n\n\n    /***************************************************************************************\n   * add/newROI callback\n   ****************************************************************************************/\n\n    function addROI()\n    {\n        var fid;\n        for (var k in patientTableMirror.filesSelected.objs)\n        {\n            fid = k.split(riddelim);\n            fid = fid[fid.length - 1];\n        }\n        if (fid == undefined)\n        {\n            alertify.alert("select a file as template");\n            return;\n        }\n        alertify.prompt("ROI name", function(e, name) {\n            if (e)\n                pushROI(fid, name);\n        });\n    }\n\n\n    /***************************************************************************************\n   * addROI on drop\n   ****************************************************************************************/\n    var $container = that.$container;\n    new Dragster($container.get(0));\n    var $dropIndicator = undefined;\n\n    $container.get(0).addEventListener(\'dragenter\', showDropIndicators);\n    $container.get(0).addEventListener(\'dragster:leave\', hideDropIndicators);\n    function showDropIndicators(ev)\n    {\n\n        if (!isDragFromRoiTool(ev) && tempObjectInfo != undefined && tempObjectInfo.length > 0 && $dropIndicator == undefined)\n        {\n            if (tempObjectInfo[0].mime != "nii")\n                return;\n            $dropIndicator = $("<div class=\'dropindicator_general_vert\' ></div>").appendTo($container);\n            that.dragster = {};\n            that.dragster.emptyRoi = $("<div>create empty roi</div>").appendTo($dropIndicator);\n            // this is not fully implemented yet: depends from where the drop will come from\n            if(tempObjectInfo[0].intent && tempObjectInfo[0].intent.clim)\n            {\n                that.dragster.upperThresh =  $("<div>From upper threshold</div>").appendTo($dropIndicator);\n                that.dragster.lowerThresh =  $("<div>From lower threshold</div>").appendTo($dropIndicator);\n            }\n\n            $dropIndicator.width($container.width());\n            $dropIndicator.height($container.height() - 25);\n            $dropIndicator.offset($innerDIV.offset())\n            $dropIndicator.children().each(function(k,e){\n    \t       $(e).on(\'dragover\',  function(ev){ $(e).css(\'background\', \'rgba(0,139,139,0.6)\');})\n    \t       $(e).on(\'dragleave\', function(ev){ $(e).css(\'background\', \'\');})\n    \t      });\n\n            //$dropIndicator.fadeIn(150);\n        }\n        ev.preventDefault();\n        ev.stopPropagation();\n        return false;\n\n    }\n\n\n    function hideDropIndicators(ev)\n    {\n        if($dropIndicator != undefined)\n            $dropIndicator.fadeOut(150, function(){$(this).remove(); })\n        $dropIndicator = undefined;\n        ev.preventDefault();\n        ev.stopPropagation();\n        return false;\n    }\n\n\n    $container.on("dragenter dragleave dragover", function(ev) {\n        ev.preventDefault();\n        ev.stopPropagation();\n        return false;\n    });\n    $container.on("drop", function(ev) {\n        ondrop(ev);\n        hideDropIndicators(ev);\n        cleanAllDropIndicators();\n        return false;\n    });\n\n\n    function ondrop(ev)\n    {\n        if (ev.isDefaultPrevented())\n            return;\n        ev.preventDefault();\n        ev.stopPropagation();\n        if (that.viewport != undefined)\n            that.viewport.hideDropIndicators();\n        if (ev.originalEvent.dataTransfer.getData("fromfiletable"))\n        {\n            for (var k = 0; k < tempObjectInfo.length; k++)\n            {\n                if (tempObjectInfo[k].type == "file")\n                {\n                    var fid = tempObjectInfo[k].fileID;\n                    if (tempObjectInfo[k].tag.search("/mask/") != -1)\n                    {\n                        createRoisFromFileID(fid, "frommaskfile");\n                    }\n                    else\n                    {\n                        var fromviewport =  (tempObjectInfo[0].intent && tempObjectInfo[0].intent.clim) ;\n                        if( ev.originalEvent.target == that.dragster.emptyRoi.get(0) )\n                            createRoisFromFileID(fid);\n                        else if(fromviewport && ev.originalEvent.target == that.dragster.upperThresh.get(0) )\n                            createRoisFromFileID(fid, "upper" + tempObjectInfo[0].intent.clim[0]);\n                        else if(fromviewport && ev.originalEvent.target == that.dragster.lowerThresh.get(0) )\n                            createRoisFromFileID(fid, "lower" + tempObjectInfo[0].intent.clim[0]);\n                    }\n                }\n            }\n        }\n        else // a file drop from local\n        {\n            params = getloadParamsFromDrop(ev.originalEvent, {});\n            for (var k = 0; k < params.length; k++)\n                createRoisFromFileID(params[k], "frommaskfile");\n\n        }\n\n    }\n\n    /***************************************************************************************\n   * create the ROI from a viewport nifti adder\n   ****************************************************************************************/\n    function createRoisFromFileID(templateFileID, lims, viewport, roistring)\n    {\n        if(roistring==undefined)\n            roistring =  KViewer.dataManager.getNextIteratedFilename(\'mask_untitled\');// + Object.keys(ROIs).length;\n\n        var roinames = roistring.replace("\\n", \'\').split(\',\')\n\n        for (var k = 0; k < roinames.length; k++)\n        {\n            var name = roinames[k].trim().replace(/\\s/g, \'\');\n\n            // lims shall be \'upper_<number>\' if set ...\n            pushROI(templateFileID, name, lims,\n            function arrived(fobj)\n            {\n                if (viewport != undefined) // set only in one specific\n                {\n                    viewport.setContent(fobj, {\n                        intent: {\n                            ROI: true\n                        }\n                    });\n                    //viewport.ROIs[viewport.ROIs.length - 1].makeCurrent();\n                }\n                else // set in all vps\n                {\n                    master.iterateMedViewers(function(m) {\n                        if (m.nii !== undefined)\n                            m.viewport.setContent(fobj, {\n                                intent: {\n                                    ROI: true\n                                }\n                            });\n                    })\n                }\n                that.makeCurrentGlobal(fobj.fileID)\n            });\n        }\n    }\n    that.createRoisFromFileID = createRoisFromFileID;\n\n\n\n\n\n    /***************************************************************************************\n   * create the ROI add to list\n   ****************************************************************************************/\n\n    function pushROI(params_or_fid, name, lim, arrived, progress,createparams)\n    {\n        // why this? do not re-create a ROI?\n        // with this set, we cannot clone a ROI ...\n        /*\n        if (ROIs[params_or_fid] != undefined)\n            return;\n        */\n\n\n        if (progress == undefined)\n            progress = that.progressSpinner;\n\n        progress("creating ROI");\n        var params;\n        if (params_or_fid.fileID == undefined)\n            params = {\n                URLType: "serverfile",\n                fileID: params_or_fid,\n                filename: name,\n                intent: {}\n            };\n        else\n            params = params_or_fid;\n\n\n        master.dataManager.loadData($.extend(\n        {\n            progressSpinner: function(perc, t) {},\n            callback: function()\n            {\n                if (name == \'mask_untitled\')\n                    name = name + Object.keys(ROIs).length;\n\n                var fobjs = master.dataManager.cloneAsROI(params.fileID, name, lim,createparams);\n\n                for (var k = 0; k < fobjs.length; k++)\n                {\n                    var fobj = fobjs[k];\n\n\n                    if (ROIs[fobj.fileID] == undefined)\n                    {\n                        ROIs[fobj.fileID] = fobj;\n                        fobj.color = Object.getOwnPropertyNames(ROIs).length % colors.length;\n                        if (KViewer.defaults.ROI)\n                        {\n                            if (KViewer.defaults.ROI.color)\n                                fobj.color = KViewer.defaults.ROI.color;\n                        }\n                        // unique color for rois\n                    }\n                }\n                that.update();\n                if (arrived != undefined)\n                    arrived(fobj);\n\n                signalhandler.send("roiListUpdate");\n\n                signalhandler.send("positionChange");\n                progress();\n\n            }\n        }, params));\n\n        //     if (!that.enabled)\n        //         that.$toggle.trigger(\'click\');\n    }\n    that.pushROI = pushROI;\n\n    /***************************************************************************************\n   * creation/updating of the ROI table\n   ****************************************************************************************/\n   that.resetRoiVolume = function(roi)\n   {\n        $table.find( $("[id=\'KROI_" + roi.fileID + "\']") ).find(\'.roivolume\').text(\'---\');\n   }\n\n    /***************************************************************************************\n   * creation/updating of the ROI table\n   ****************************************************************************************/\n\n    function update()\n    {\n\n        that.currentrow = undefined;\n        $table.children().remove();\n\n\n\n        if ($.isEmptyObject(ROIs))\n        {\n            $table.append($("<div class=\'dummymessage\'> drop template image to create new ROI(s)<br> </div> "));\n            return;\n        }\n\n\n        var $thead = $("<thead>").appendTo($table);\n        var $row = $("<tr></tr>").appendTo($thead);\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'8\'><i class=\'fa fa-fw  fa-square-o\'></i> </td>").click(function(e) {\n            toggle_all_visible();\n        }));\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'13\'> </td>"));\n        //$row.append($("<td class=\'fixedwidth\' fixedwidth=\'6\'> </td>"));\n        $row.append($("<td>ROI filename</td>"));\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'9\'><i class=\'fa  fa-fw\'></i> </td>"));\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'9\'> </td>"));\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'9\'> </td>"));\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'9\'> </td>"));\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'9\'> </td>"));\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'9\'> </td>"));\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'9\'> </td>"));\n        $row.append($("<td class=\'fixedwidth\' fixedwidth=\'9\'> </td>"));\n        $row.append($("<td style=\'white-space:nowrap\'>&nbsp;<i class=\'fa fa-refresh\'></i> &nbsp; mL </td>").click( calcVolumes)  );\n        $row.append($("<td>matrix </td>"));\n        $row.append($("<td>patientID</td>"));\n        $row.append($("<td>studyID</td>"));\n\n        function calcVolumes()\n        {\n            for (var k in ROIs)\n            {\n                var r = ROIs[k].content;\n                var totsz = r.sizes[0] * r.sizes[1] * r.sizes[2];\n                var numvox = 0;\n                for (var j = 0; j < totsz; j++)\n                    if (r.data[j] > 0.5)\n                        numvox++;\n                var vol = numvox * r.voxSize[0] * r.voxSize[1] * r.voxSize[2]; // in mm\n                vol = Math.round( (vol/1000 * 100))/100; // in mL\n\n                var $td = $table.find( $("[id=\'KROI_" + ROIs[k].fileID + "\']") ).find(\'.roivolume\');\n                $td.text(vol);\n            }\n        }\n\n        var $tbody = $("<tbody>").appendTo($table);\n        // sort the ROIs by name\n        var roilistsorted = [];\n        for (var k in ROIs)\n            roilistsorted.push(ROIs[k]);\n        roilistsorted = roilistsorted.sort(function(a,b) { return (a.filename>b.filename?1:-1); })\n\n        /**************** roigroups ************************/\n        var roigroups = [];\n        /*\n        var roigroups =\n        [\n            {title:\'NEW   lesions\', prefix:\'NEW_\', color: \'red\'},\n            {title:\'GROWN lesions\', prefix:\'GRO_\', color: \'yellow\'} ,\n            {title:\'OLD   lesions\', prefix:\'OLD_\', color: \'lightgreen\'},\n        ]\n        if(roigroups.length > 0)\n        {\n            var roilistsortedbygroup = [];\n            var remainders = [];\n            for(var g=0;g<roigroups.length; g++)\n            {\n                roilistsortedbygroup.push(roigroups[g])\n                for (var z=roilistsorted.length-1; z>-1; z-- )\n                {\n                    if(roilistsorted[z].filename.substr(0,roigroups[g].prefix.length) == roigroups[g].prefix)\n                        roilistsortedbygroup.push(roilistsorted.splice(z,1)[0]);\n                }\n\n            }\n            roilistsortedbygroup.push({title:\'OTHERS\', prefix:\'\', color: \'lightgray\'})\n            roilistsorted = roilistsortedbygroup.concat(roilistsorted);\n        }\n*/\n\n        //for (var k in ROIs)\n        for (var z=0; z<roilistsorted.length; z++ )\n        {\n            if(roigroups.length>0 && roilistsorted[z].fileID==undefined )\n            {\n                var $row = $("<tr class=\'roiTool_filelist_filerow\'></tr>").appendTo($tbody);\n                $("<td class=\'\' colspan=\'100\' style=\'background:"+ roilistsorted[z].color+"\'><span>"+roilistsorted[z].title+"</span></td>").appendTo($row)\n                continue\n            }\n\n            k=roilistsorted[z].fileID;\n            var fobj = ROIs[k];\n            var id = fobj.fileID;\n            var dragstuff = "draggable=\'true\'"\n//            var dragstuff = "draggable=\'true\' data-filename=\'" + fobj.filename + "\' data-type=\'file\' data-tag=\'/mask/\' data-fileID=\'" + id + "\' data-mime=\'ROI\'";\n  //          dragstuff = dragstuff + " ondragstart=\'setdragstart(event);\' ondragend=\'setdragend(event);\' ";\n            var $row = $("<tr class=\'roiTool_filelist_filerow\' id =\'KROI_" + id + "\' " + dragstuff + " ></tr>").appendTo($tbody);\n\n            $row.on("dragstart", dragstarter(function(fobj) { return function() {\n                return {\n                    type: \'file\',\n                    mime: \'nii\',\n                    tag: \'/mask/\',\n                    filename: fobj.filename,\n                    fileID: fobj.fileID,\n                    intent: {\n                        color: fobj.color\n                    },\n                    close: close\n                }\n            } }(fobj))  );\n\n\n            if (currentROI == fobj)\n                $row.addClass(\'selected\')\n\n            var makeCurrentGlobal_ = function(z) {\n                return function(ev)\n                {\n                    that.makeCurrentGlobal(z);\n                }\n            }(k);\n\n            $row.append($("<td class=\'fixedwidth\'><i class=\'vis fa fa-fw fa-square-o\'></i> </td>").click(function(e)\n            {\n                toggle_visibility(e.target);\n                signalhandler.send("positionChange");\n            }));\n\n//             var $hand = $("<td class=\'fixedwidth\'><i class=\'fa fa-fw fa-hand-paper-o\'></i> </td>").click(makeCurrentGlobal_)\n//             //$row.append($("<td><i class=\' fa fa-fw fa-pencil-square-o\'></i></td>").click(makeCurrentGlobal_ ));\n//             if (fobj.color != undefined)\n//                 $hand.css(\'background\', (new KColor(KColor.list[fobj.color])).getCSS() );\n//             $row.append($hand);\n\n\n            // color contextmenu\n            var $colselector = KColorSelector(that.colors,\n                function(c) {\n                    return "background:" + RGB2HTML(c[0], c[1], c[2]) + ";";\n                },\n                function(obj,id){return function()\n                {\n                     that.setColorGlobal(id, obj.color)\n                }}(fobj,id)\n                ,fobj\n               );\n            $row.append($colselector)\n            $colselector.find("i").css(\'margin-right\', \'-5px\')\n\n            var $namediv = $("<span  id =\'KROINAME_" + id + "\' contenteditable=\'false\' >" + fobj.filename + " </span>")\n            .keydown(function(ev) {\n                if (ev.keyCode == 13) {\n                    $(ev.target).blur();\n                    return false\n                }\n            })\n            .keyup(function(sel) {\n                return function(ev)\n                {\n                    sel.filename = $(ev.target).text().trim();\n                    if (sel.namedivs != undefined)\n                        for (var i = 0; i < sel.namedivs.length; i++)\n                            $(sel.namedivs[i]).text(sel.filename);\n                }\n            }(fobj)\n            )\n            \n            if(KViewer.static.roilist_contextmenu !== false)\n                makeEditableOnDoubleClick($namediv)\n                \n            var $treexpander\n            if (fobj.ccanalysis == undefined || !fobj.ccanalysis.enabled)\n                $treexpander = $("<i class=\'fa fa-fw fa-plus-square-o\'></i>");\n            else\n                $treexpander = $("<i class=\'fa fa-fw fa-minus-square-o\'></i>");\n            var $namewrap = $("<div>  </div>").append($treexpander).append($namediv).on(\'click\', makeCurrentGlobal_)\n            $row.append($("<td></td>").append($namewrap));\n\n\n            $treexpander.click(function(fobj) { return function()\n            {\n               if (fobj.ccanalysis != undefined)\n               {\n                  fobj.ccanalysis.enabled = !fobj.ccanalysis.enabled;\n                  if (fobj.ccanalysis.enabled)\n                    fobj.ccanalysis.update();\n               }\n               else\n               {\n                  createConnCompAnalysis(fobj);\n               }\n\n               KViewer.roiTool.update();\n\n            }}(fobj) );\n\n            // ROI\'s contextmenu\n            var tools_contextmenu = function(fobj) { return KContextMenu(\n            function() {\n\n                var $menu = $("<ul class=\'menu_context\'>");\n                $menu.append($("<li onchoice=\'clear\'> clear  </li>"));\n                $menu.append($("<li onchoice=\'clone\'> clone  </li>"));\n                $menu.append($("<li onchoice=\'invert\'> invert  </li>"));\n                $menu.append($("<hr>"));                \n                $menu.append($("<li onchoice=\'mergeAND\'> intersection of selected ROIs </li>"));\n                $menu.append($("<li onchoice=\'mergeOR\'> union of selected ROIs  </li>"));\n                $menu.append($("<li onchoice=\'mergeDIFF\'> set difference  </li>"));\n\n                $menu.append($("<hr>"));\n                $menu.append($("<li onchoice=\'fillholes\'> fill holes  </li>"));\n\n                var thres = removesalt.threshold;\n\n                var $salt_threshold = $("<input onchoice=\'preventSelection\' type=\'number\' step=\'5\' min=\'2\' max=\'10000\'>").val(thres).\n                     on(\'keyup\', function(ev) {\n                    var $input = $(ev.target);\n                    removesalt.threshold = $input.val();\n                   });\n\n                $menu.append($("<li onchoice=\'removesalt\'> remove salt </li>").append($salt_threshold));\n                $menu.append($("<li onchoice=\'splatter\'> splatter </li>"));\n                if (KViewer.currentPoint != undefined)\n                {\n                    var str = "("+KViewer.currentPoint._data[0].toFixed(0)+","+KViewer.currentPoint._data[1].toFixed(0)+","+KViewer.currentPoint._data[2].toFixed(0)+")"\n                    $menu.append($("<li onchoice=\'crop\'> crop at seed "+str+" </li>"));\n                }\n                $menu.append($("<hr>"));                \n                $menu.append($("<li onchoice=\'opening\'> opening  </li>"));\n                $menu.append($("<li onchoice=\'closing\'> closing  </li>"));\n                $menu.append($("<li onchoice=\'erode\'> erosion  </li>"));\n                $menu.append($("<li onchoice=\'dilate\'> dilation  </li>"));\n                $menu.append($("<hr>"));\n                if (0) //fobj.content.numTimePoints  > 1)\n                {                    \n                    $menu.append($("<li onchoice=\'logic4D\'> logical op. along 4th dim.  </li>"));\n                    $menu.append($("<hr>"));\n                }\n                $menu.append($("<li onchoice=\'extend4d\'> extend 4th dimension </li>"));                \n                $menu.append($("<li onchoice=\'surface\'> create surface </li>"));\n                $menu.append($("<li onchoice=\'download\'> download </li>"));\n                $menu.append($("<li onchoice=\'saveas\'> save as ... </li>"));\n                $menu.append($("<li onchoice=\'close\'> close </li>"));\n                return $menu;\n            }\n            ,function(str, ev) {\n                    var id = fobj.fileID;\n                    tools(str, ev, id)\n            },true\n            ) }(fobj)\n\n            if(KViewer.static.roilist_contextmenu !== false)\n                $row.on("contextmenu",tools_contextmenu);\n\n\n\n            $row.append($("<td class=\'fixedwidth\'><i class=\'tablebutton fa fa-fw fa-binoculars\'></i> </td>").click(function(e) {\n                var target = e.target;\n                while (!$(target).is("tr"))\n                    target = $(target).parent();\n                var id = $(target).attr("id").substring(5);\n                set_to_center(ROIs[id].content);\n            }));\n\n            var $currentdiv = $("<td class=\'fixedwidth\'> <i class=\'tablebutton fa fa-fw fa-pencil-square-o\'></td>").appendTooltip(\'toggleedit\');\n            $row.append($currentdiv.click(function(id) { return function()\n            {\n                   that.makeCurrentGlobal(id);\n            } }(fobj.fileID) ) );\n\n            if ((currentROI == fobj))\n                $currentdiv.find(".fa").addClass("selected");\n\n\n\n\n            \n\n            // toggle visibility global\n            var $eyetoogle = $("<td class=\'fixedwidth\'> <i class=\'tablebutton fa fa-fw fa-eye\'></td>").appendTo($row).appendTooltip(\'toggle\')\n            $eyetoogle.click(function(fobj, $eyetoogle){\n                return function(){\n                    if(fobj.visible==1 || fobj.visible==undefined )\n                    {\n                        fobj.visible = 0;\n                        $eyetoogle.find(\'i\').addClass(\'fa-eye-slash\').removeClass(\'fa-eye\').css(\'color\', \'red\');\n                    }\n                    else\n                    {\n                        fobj.visible = 1;\n                        $eyetoogle.find(\'i\').removeClass(\'fa-eye-slash\').addClass(\'fa-eye\').css(\'color\', \'\');\n                    }\n                    KViewer.iterateMedViewers(function(viewer)\n                    {\n                        for (var k = 0; k < viewer.ROIs.length; k++)\n                        {\n                            if(viewer.ROIs[k].roi.fileID == fobj.fileID)\n                            {\n                                viewer.ROIs[k].toggle_visibility(fobj.visible)\n                            }\n                        }\n                    });\n                }\n            }(fobj, $eyetoogle))\n\n            if(fobj.visible === 0)\n                  $eyetoogle.find(\'i\').addClass(\'fa-eye-slash\').removeClass(\'fa-eye\').css(\'color\', \'red\');\n\n\n            $row.append($("<td class=\'fixedwidth\'> <i class=\'tablebutton fa fa-fw fa-wrench\'></td>").click(tools_contextmenu));\n            $row.append($("<td class=\'fixedwidth\'> <i class=\'tablebutton fa fa-fw fa-save\'></td>").click(saveROI_table).appendTooltip(\'saveroi\'));\n            $row.append($("<td class=\'fixedwidth\'> <i class=\'tablebutton fa fa-fw fa-download\'></td>").click(function(fobj) { return function(){\n                saveNiftilocal(fobj)}\n            }(fobj)).appendTooltip(\'downloadroi\'));\n            $row.append($("<td class=\'fixedwidth\'> <i class=\'tablebutton fa fa-fw fa-eraser\'></td>").click(function(fobj,id) { return function(){\n                KViewer.roiTool.history.record(\'startRecording\', that.roiPanel.getParentViewer(),fobj);\n                var changedPoints = clearROI(fobj)\n                that.history.add(changedPoints, 1,fobj);\n                $(".KROI_"+id).remove()\n                }\n            }(fobj,id)).appendTooltip(\'clear\'));\n            $row.append($("<td class=\'fixedwidth\'> <i class=\'tablebutton fa fa-fw fa-trash\'></td>").click(delROI).appendTooltip(\'delete\'))\n            $row.append($("<td style=\'text-align:right\' class=\'roivolume\'>---</td>"));\n            $row.append($("<td><span>" + fobj.content.sizes[0] + "," + fobj.content.sizes[1] + "," + fobj.content.sizes[2]+ "," + fobj.content.sizes[3] + "</span></td>"));\n            $row.append($("<td>" + fobj.fileinfo.patients_id + "</td>"));\n            $row.append($("<td>" + fobj.fileinfo.studies_id + "</td>"));\n\n            if (fobj.ccanalysis && fobj.ccanalysis.enabled)\n            {\n                var cc = fobj.ccanalysis;\n                if (cc.persistent != undefined)\n                {\n                    for (var j=0; j<cc.persistent.length;j++)\n                    {\n                        var $row = $("<tr class=\'islandrow KROI_" + id + "\' kid=\'KROI_" + id + "\' label=\'" + j +"\'></tr>").appendTo($tbody);\n                        if (currentROI == fobj)\n                            $row.addClass(\'selected\')\n                        $row.on("contextmenu", function(fobj,conncomp_label) { return function(ev) {\n                            contextMenuLabel(fobj,conncomp_label,undefined,ev)\n                        }\n                        }(fobj,cc.persistent[j]));\n\n                        $row.append($("<td> </td>"));\n                        $row.append($("<td> </td>"));\n                        var $namediv = $("<td class=\'namediv\'> "+  that.conncompdesc + " " + cc.persistent[j].name +"</td>").keydown(function(ev) {\n                                if (ev.keyCode == 13) {\n                                    $(ev.target).blur();\n                                    return false\n                                }\n                            }).keyup(function(sel) {\n                                return function(ev)\n                                {\n                                    sel.name = $(ev.target).text().trim();\n                                }\n                            }(cc.persistent[j])\n                            )\n                         //makeEditableOnDoubleClick($namediv)\n                         $row.append($namediv);\n\n\n                         function jumpTo(e)\n                         {\n                                var target = e.target;\n                                while (!$(target).is("tr"))\n                                    target = $(target).parent();\n                                var id = $(target).attr("kid").substring(5);\n                                var label = $(target).attr("label");\n                                $(target).parent().find("tr").removeClass("current");\n                                $(target).addClass("current");\n                                var cc = ROIs[id].ccanalysis;\n                                var v = cc.persistent[label].cog;\n                                KViewer.currentPoint = math.multiply(ROIs[id].content.edges,[v[0],v[1],v[2],1]);\n                                signalhandler.send(\'positionChange\',{point:KViewer.currentPoint});\n\n                                that.currentrow =  $(target);\n\n\n\n\n                         }\n                         $namediv.click(jumpTo)\n\n                         //$row.append($("<td class=\'fixedwidth\'><i class=\'tablebutton fa fa-fw fa-binoculars\'></i> </td>").click(jumpTo));\n                         $row.append($("<td> </td>"));\n\n                         $row.append($("<td> </td>"));\n                         $row.append($("<td> </td>"));\n                         $row.append($("<td> </td>"));\n                         $row.append($("<td> </td>"));\n                         $row.append($("<td> </td>"));\n                         //$row.append($("<td> </td>"));\n                         $row.append($("<td class=\'fixedwidth\'> <i class=\'tablebutton fa fa-fw fa-eraser\'></td>").click(\n                                function(fobj,conncomp_label,$row) { return function(ev) {\n\n                                var point = math.multiply(fobj.content.edges, [conncomp_label.cog[0],conncomp_label.cog[1],conncomp_label.cog[2],1]);\n                                 delROI_component(fobj, point)\n                                 $row.remove();\n\n                                 }}(fobj,cc.persistent[j],$row)\n                         ));\n                         $row.append($("<td> </td>"));\n\n\n                         if (cc.persistent[j].idx != undefined)\n                         {\n                             var r = ROIs[id].content;\n                             var clusterVolume = cc.cc.clusterSize[cc.persistent[j].idx] *r.voxSize[0] * r.voxSize[1] * r.voxSize[2] / 1000;\n                         }\n                         else\n                             clusterVolume = 0;\n                             $row.append($("<td> "+ math.round(clusterVolume*100)/100 +"</td>"));\n                    }\n                }\n            }\n        }\n\n        that.attachTableOperator($table.parent());\n\n        function delROI_component(fobj, point,timerange)\n        {\n            var cp = [];\n            if (timerange == \'all\')\n            {\n                for (var k = 0; k<fobj.content.numTimePoints;k++)\n                  cp = cp.concat(cropConnectedComponent2(fobj,undefined, point,k))\n            }\n            else\n                cp = cropConnectedComponent2(fobj,undefined, point)\n            signalhandler.send("updateImage",{id: fobj.fileID});\n            KViewer.roiTool.history.record(\'startRecording\', undefined ,fobj, \'use_as_last\');\n            KViewer.roiTool.history.add(cp, 1,fobj);\n        }\n        that.delROI_component = delROI_component;\n        function keepROI_component(fobj, point,timerange)\n        {\n            var cp = [];\n            if (timerange == \'all\')\n            {\n                for (var k = 0; k<fobj.content.numTimePoints;k++)\n                    cp.concat(cropConnectedComponent2(fobj,"keep", point,k))\n            }\n            else\n                cp = cropConnectedComponent2(fobj,"keep", point)\n            signalhandler.send("updateImage",{id: fobj.fileID});\n            KViewer.roiTool.history.record(\'startRecording\', undefined ,fobj, \'use_as_last\');\n            KViewer.roiTool.history.add(cp, 1,fobj);\n        }\n        that.keepROI_component = keepROI_component;\n\n        function delROI(ev)\n        {\n            var id;\n\n            if (ev.target != undefined)\n            {\n                var target = ev.target;\n                while (!$(target).is("tr"))\n                    target = $(target).parent();\n                id = $(target).attr("id").substring(5);\n            }\n            else\n                id = ev;\n\n\n            if (ROIs[id].worker != undefined)\n            {\n                 ROIs[id].worker.postMessage({msg:\'kill\'})\n                 ROIs[id].worker = undefined;\n            }\n\n\n            delete ROIs[id];\n            if (that.visibleROIs[id])\n            {\n                delete that.visibleROIs[id];\n            }\n\n            deleteReferencesOnROI(id);\n\n            that.update();\n            signalhandler.send("roiListUpdate");\n\n        }\n        that.deleteROI = delROI;\n\n\n        function saveROI_table(ev)\n        {\n            var target = ev.target;\n            while (!$(target).is("tr"))\n                target = $(target).parent();\n            var id = $(target).attr("id").substring(5);\n            var roi = ROIs[id];\n\n            saveROI(roi)\n        }\n\n\n\n\n        function namechange(ev)\n        {\n            var id = $(ev.target).attr("id").substring(9);\n            ROIs[id].filename = $(ev.target).text();\n            return true;\n        }\n\n\n        master.cacheManager.update();\n\n\n    }\n    that.update = update;\n\n\n    $table.on("mouseenter",function() { that.hasMouse = true })\n    $table.on("mouseleave",function() { that.hasMouse = false })\n\n    window.addEventListener("keyup",function(evt) \n    {\n       if (that.currentrow != undefined && that.hasMouse\n           && (evt.keyCode == 38 | evt.keyCode == 40) && !evt.shiftKey && !evt.ctrlKey)\n       {\n\n           evt.stopPropagation();\n           evt.preventDefault();\n           var n;\n           if (evt.keyCode == 40)\n              n = that.currentrow.next("tr")\n           if (evt.keyCode == 38)\n              n = that.currentrow.prev("tr")\n           if (n == undefined)\n              return;\n           n.find(".namediv").trigger("click")\n       }\n    },{capture:true})\n \n\n\n    /***************************************************************************************\n    * save a roi\n    ****************************************************************************************/\n\n    function saveROI(roi, saveas)\n    {\n        runROIworker(\'clean\',roi,{noupdate:true}, function()\n        {\n\n            if (typeof customUploadNifti != "undefined")\n            {\n                customUploadNifti(roi)\n            }\n            else if (userinfo.username == guestuser)\n            {\n                saveNiftilocal(roi);\n            }\n            else\n            {\n                var doUpload = function() {\n\n                    // add a unique patient id first if not set\n                    if (roi.fileinfo.patients_id == undefined)\n                       extendWithUniquePSID(roi.fileinfo);\n\n                    var zipped = true;\n\n                    if (roi.fileinfo && roi.fileinfo.Filename && roi.fileinfo.Filename.search("\\\\.gz") == -1)\n                        zipped = false;\n                    if (roi.notzipped)\n                        zipped = false;\n\n                    if (roi.fileinfo.patients_id != undefined)\n                    {\n                            uploadUnregisteredBinary(roi, {\n                                SubFolder: roi.subfolder,\n                                Tag: "/mask/",\n                                permission: "rwp"\n                            }, that.progressSpinner,\n                            function(newid, id) {\n                                ROIs[newid] = roi;\n                                delete ROIs[id];\n                                that.update();\n                            },zipped);\n                    }\n                    else\n                    {\n                        alertify.alert("There is no unique patient id set for this roi.")\n                    }\n    \n                }\n\n                if (saveas == true)\n                {\n                    if( (roi.filename.substring(0, 13) == "mask_untitled" & roi.fileID.substring(0, 3) == "ROI"))\n                    {\n                        alertify.prompt("Name of the ROI?", function(e, str)\n                        {\n                            if (e)\n                            {\n                                var idx = str.lastIndexOf(\'/\');\n                                if (idx > -1)\n                                {\n                                    roi.subfolder = str.substring(0, idx);\n                                    roi.filename = str.substring(idx + 1);\n                                }\n                                else\n                                {\n                                    roi.subfolder = "";\n                                    roi.filename = str;\n                                }\n                                for (var i = 0; i < roi.namedivs.length; i++)\n                                    $(roi.namedivs[i]).text(roi.filename);\n                                doUpload();\n                            }\n                        }, roi.filename);\n                    }\n                }\n                else\n                    doUpload();\n            }\n        }\n        )\n    }\n\n    /***************************************************************************************\n    * save all ROIs\n    ****************************************************************************************/\n    function saveAllROIs()\n    {\n        for(k in that.ROIs)\n        {\n            saveROI( that.ROIs[k], false);\n        }\n\n    }\n    that.saveAllROIs = saveAllROIs;\n\n    \n    function clearROI(fobj)\n    {\n        var changedPoints = [];\n        for (var k = 0; k < fobj.content.data.length; k++)\n        {\n            if (fobj.content.data[k] > 0)\n                changedPoints.push(k);\n            fobj.content.data[k] = 0;\n        }\n        if (fobj.content.onVoxels != undefined)\n            fobj.content.onVoxels = undefined;\n\n        signalhandler.send("positionChange");\n        update3D(fobj);\n\n        return changedPoints;\n    }\n\n\n\n    /***************************************************************************************\n    * context menu callbacks\n    ****************************************************************************************/\n    function update3D(roi,progress)\n    {\n        var fileinfo;\n        if (roi.fileinfo)\n            fileinfo = roi.fileinfo\n        if (roi.currentFileinfo)\n            fileinfo = roi.currentFileinfo;\n        if (fileinfo == undefined)\n            return;\n\n        if (fileinfo && fileinfo.surfreference)\n        {\n            var surf = fileinfo.surfreference;\n            if (surf.hangingUpdate == 0 | surf.hangingUpdate == undefined)\n                surf.hangingUpdate = 1;\n            else if (surf.hangingUpdate >= 1)\n            {\n                surf.hangingUpdate = 2;\n                return;\n            }\n\n            var labelObj;\n            if (roi.type == "overlay" || roi.type == \'mainview\')\n                 labelObj = {threshold:roi.histoManager.clim[0]};\n\n\n            if (progress == undefined)\n                progress = that.progressSpinner;\n\n            KViewer.obj3dTool.computeIsoSurf2(surf,labelObj,progress,function()\n            {\n                if (surf.hangingUpdate == 2)\n                {\n                    surf.hangingUpdate = 0;\n                    update3D(roi);\n                }\n                else\n                {\n                   for (var k = 0; k < surf.content.update.length; k++)\n                        surf.content.update[k]();\n                }\n                surf.hangingUpdate = 0;\n\n            });\n        }\n    }\n    that.update3D = update3D;\n\n\n    function runROIworker(func,fobj,params,callback,progress)\n    {  \n        $(document.body).addClass(\'wait\');\n\n        if (params == undefined)\n            params = {}\n        var eobj = {func:func,\n                    buf: fobj.content.buffer,\n                    data:fobj.content.data,\n                    size:fobj.content.sizes,\n                    keepOpen:false }\n        eobj = $.extend(eobj,params)\n        if (progress == undefined)\n            progress = function (e) {}\n        var worker = executeImageWorker(eobj,[fobj.content.buffer], progress,\n        function(e)\n        {\n            fobj.content.buffer = e.execObj.buf;\n            fobj.content.data = new Uint8Array(fobj.content.buffer,fobj.content.hdroffset);\n            if (!eobj.noupdate)\n            {\n                signalhandler.send("positionChange");\n                update3D(fobj);\n            }\n            var changedPoints = e.execObj.changedPoints\n            if (changedPoints != undefined)\n                that.history.add(e.execObj.changedPoints, 1,fobj);\n            if (callback)\n                callback()\n            $(document.body).removeClass(\'wait\');\n\n        })\n    }\n\n\n    function tools(str, ev, id,viewer)\n    {\n        if (str == undefined)\n            return;\n\n        var fobj = ROIs[id];\n\n        KViewer.roiTool.history.record(\'startRecording\', that.roiPanel.getParentViewer(),fobj);\n        var changedPoints = [];\n        var valtoset;\n        if (str == "invert")\n        {\n            runROIworker(\'invert\',fobj)\n        }\n        else if (str == "opening")\n        {\n            runROIworker(\'opening\',fobj)\n        }\n        else if (str == "closing")\n        {\n            runROIworker(\'closing\',fobj)\n        }\n        else if (str == "removesalt")\n        {\n            runROIworker(\'removesalt\',fobj,{threshold:removesalt.threshold})\n        }\n        else if (str == "splatter")\n        {\n            splatter(fobj);\n        }\n        else if (str == "crop")\n        {\n            var nfobj = KViewer.dataManager.cloneAsROI(fobj.fileID, fobj.filename + "_cropped","upper0")[0];\n            cropConnectedComponent(nfobj, KViewer.currentPoint)\n            KViewer.roiTool.ROIs[nfobj.fileID] = nfobj;\n            nfobj.color = Object.getOwnPropertyNames(KViewer.roiTool.ROIs).length % 5;\n            KViewer.roiTool.update();\n            if (viewer != undefined)\n                viewer.setContent(nfobj,{intent:{ROI:true}});\n        }\n        else if (str == "erode")\n        {\n            runROIworker(\'erode\',fobj)\n        }\n        else if (str == "dilate")\n        {\n            runROIworker(\'dilate\',fobj)\n        }\n        else if (str == "clear")\n        {\n            changedPoints = clearROI(fobj)\n        }\n        else if (str == "clone")\n        {\n            createRoisFromFileID(id, "upper0.5", undefined, undefined)\n            //pushROI(id, "untitled", );\n        }\n        else if (str == "fillholes")\n        {\n            runROIworker(\'fillholes\',fobj)\n\n        }\n        else if (str == "mirror")\n        {\n            mirror_roi(fobj, $(ev.target).attr(\'dim\'));\n            //runROIworker(\'fillholes\',fobj)\n        }\n        else if (str == "threshold_upper" | str == "threshold_lower")\n        {\n            var eqfun;\n            var mview = that.roiPanel.getParentViewer();\n            var clim = mview.histoManager.clim;\n            var parentnii = mview.content.content;\n            var low = clim[0];\n\n            if (str == "threshold_upper")\n                eqfun = function(x) {\n                    return x > low\n                }\n                ;\n            else\n                eqfun = function(x) {\n                    return x < low\n                }\n                ;\n\n            var roi = fobj.content;\n\n            if (roi.edges._data.toString() == parentnii.edges._data.toString())\n            {\n                var sz = roi.sizes[0] * roi.sizes[1] * roi.sizes[2];\n                for (var z = 0; z < sz; z++)\n                    roi.data[z] = eqfun(parentnii.data[z]);\n\n            }\n            else\n            {\n                var A = math.inv(math.multiply(math.inv(roi.edges), parentnii.edges))._data;\n                for (var z = 0; z < roi.sizes[2]; z++)\n                    for (var y = 0; y < roi.sizes[1]; y++)\n                        for (var x = 0; x < roi.sizes[0]; x++)\n                            roi.data[roi.sizes[1] * roi.sizes[0] * z + roi.sizes[0] * y + x] = eqfun(trilinInterp(parentnii, x, y, z, A, 0));\n            }\n            signalhandler.send("positionChange");\n            update3D(fobj);\n        }\n        else if (str == "mergeAND" | str == "mergeOR" | str == "mergeDIFF")\n        {\n            var fun;\n            if (str == "mergeAND")\n                fun = function(x, y) {\n                    return (x > 0.5) & (y > 0.5)\n                }\n            else if (str == "mergeDIFF")\n                fun = function(x, y) {\n                    return (x > 0.5) & (y < 0.5)\n                }\n            else\n                fun = function(x, y) {\n                    return (x > 0.5) | (y > 0.5)\n                }\n            var rois = Object.keys(that.visibleROIs);\n            for (var j = 0; j < rois.length; j++)\n            {\n                if (rois[j] == fobj.fileID)\n                {\n                   rois.splice(j,1)\n                   break;\n                }\n            }\n\n\n            var nii = fobj.content;\n            for (var j = 0; j < rois.length; j++)\n            {\n                if ( ROIs[rois[j]].content == undefined)\n                    continue;\n                var roi = ROIs[rois[j]].content;\n                roi.A = (math.multiply(math.inv(roi.edges), nii.edges))._data;\n                for (var z = 0; z < nii.sizes[2]; z++)\n                    for (var y = 0; y < nii.sizes[1]; y++)\n                        for (var x = 0; x < nii.sizes[0]; x++)\n                        {\n                            var v = trilinInterp(roi, x, y, z, roi.A, 0);\n                            nii.data[nii.sizes[1] * nii.sizes[0] * z + nii.sizes[0] * y + x] =\n                            fun(nii.data[nii.sizes[1] * nii.sizes[0] * z + nii.sizes[0] * y + x], v);\n                        }\n\n            }\n            update3D(fobj);\n            signalhandler.send("positionChange");\n        }\n        else if (str == "surface")\n            KViewer.obj3dTool.createSurfaceFromROI(fobj);\n        else if (str == "logic4D")\n        {\n               var eval_str = "data[k] = data[k+totsz*2] | data[k+totsz*2]";\n               var data = fobj.content.data;\n               var totsz= fobj.content.sizes[0]*fobj.content.sizes[1]*fobj.content.sizes[2]*fobj.content.sizes[3]\n               for (var k = 0; k < totsz;k++)\n               {\n                   eval(eval_str);\n               }\n\n         /*   alertify.prompt("Change 4th dimension of ROI to:", function(e, str) {\n                if (e)\n                {            \n\n                }\n\n            });*/\n        }\n        else if (str == "extend4d")\n        {\n            alertify.prompt("Change 4th dimension of ROI to:", function(e, str) {\n                if (e)\n                {            \n                    var num = parseInt(str);\n                    if (num < 1 | num > 50)\n                    {\n                        alertify.error("outside a valid range")\n                        return;\n                    }\n                    if (num < fobj.content.sizes[3])\n                    {\n                      alertify.confirm("Are you sure? There might be data loss! ", function(e, str) {\n                          if (e)\n                            changeit(num)\n                      })\n                      return\n                    }\n                    else\n                      changeit(num)\n\n                    function changeit(num)\n                    {\n                        var nfobj = cloneNifti(fobj, fobj.filename, "uint8",num)\n                        var totsz_src = fobj.content.sizes[0]*fobj.content.sizes[1]*fobj.content.sizes[2]*fobj.content.sizes[3]\n                        var totsz_dest = nfobj.content.sizes[0]*nfobj.content.sizes[1]*nfobj.content.sizes[2]*nfobj.content.sizes[3]\n                        if (totsz_dest < totsz_src)\n                            totsz_src = totsz_dest;\n                        nfobj.content.data.set(fobj.content.data.subarray(0,totsz_src))\n\n\n                        fobj.content = nfobj.content\n                        fobj.buffer = nfobj.buffer\n\n                        signalhandler.send("updateFilelink",{id:fobj.fileID});\n                    }\n                }\n            }, ""+fobj.content.sizes[3])\n        }\n        else if (str == "download")\n            saveNiftilocal(fobj);\n        else if (str == "saveas")\n        {\n            saveROI(fobj, true)\n        }\n        else if (str == "close")\n            delROI(id);\n\n        if (changedPoints != undefined && changedPoints.length > 0)\n            that.history.add(changedPoints, valtoset,fobj);\n\n    }\n    that.tools = tools;\n\n\n\n\n\n\n\n    /***************************************************************************************\n     * selection of ROIs (visibility is deprecated)\n     ****************************************************************************************/\n\n    var visibleROIs = {};\n    that.visibleROIs = visibleROIs;\n    function toggle_visibility(target)\n    {\n        while (!$(target).is("tr"))\n            target = $(target).parent();\n        var id = $(target).attr("id").substring(5);\n        var $b = $(target).find(".vis");\n        $b.toggleClass("fa-square-o").toggleClass("fa-check-square-o");\n        if ($b.hasClass("fa-square-o"))\n            delete visibleROIs[id];\n        else\n            visibleROIs[id] = true;\n    }\n\n    function toggle_all_visible()\n    {\n        for (var k in ROIs)\n            toggle_visibility($("tr[id=\'KROI_" + k + "\']"));\n        signalhandler.send("positionChange");\n\n    }\n\n\n\n    /***************************************************************************************\n     * ROI painting\n     ****************************************************************************************/\n    regionGrow.helper = {\n        simscaling: 0\n    };\n\n\n    function keepExclusive(changedPoints,medViewer,ev)\n    {\n        var type = that.roiMode;\n\n        if (type == "overlap")\n            return changedPoints;\n\n        var rois = [];\n        var nii =  medViewer.currentROI.content;\n        for (var k = 0; k < medViewer.ROIs.length;k++)\n        {\n            if (medViewer.currentROI != medViewer.ROIs[k].roi &&\n                medViewer.ROIs[k].nii.edges._data.toString() ==\n                medViewer.currentROI.content.edges._data.toString())\n            {\n                rois.push(medViewer.ROIs[k].roi);\n\n                if (ev.type == \'mousedown\' && type == "override")\n                    KViewer.roiTool.history.record(\'startRecording\', medViewer,medViewer.ROIs[k].roi,\'dontaddtoglobal\');\n\n            }\n        }\n\n\n        var roilen = rois.length;\n        var plen = changedPoints.length;\n        if (type == "override")\n        {\n            for (var k = 0; k < roilen;k++)\n            {\n                var cp_r = [];\n                var data = rois[k].content.data;\n                for (var j = 0 ;j < plen; j++)\n                {\n                    if (data[changedPoints[j]] > 0)\n                        cp_r.push(changedPoints[j])\n                    data[changedPoints[j]]=0;\n                }\n                that.history.add(cp_r, 0,rois[k]);\n            }\n            changedPoints.others = rois;\n\n            return changedPoints;\n        }\n        if (type == "block")\n        {\n            var changedPoints_new = [];\n            for (var j = 0 ;j < plen; j++)\n            {\n                var on = false;\n                for (var k = 0; k < roilen;k++)\n                {\n                    var tp = changedPoints[j];\n                    // if blocking roi has only one timepoint, use this\n                    if(rois[k].content.numTimePoints == 1)\n                        var tp = tp % nii.widheidep;\n\n                    on = on | (rois[k].content.data[tp]>0);\n                }\n                if (on)\n                    nii.data[changedPoints[j]] = 0;\n                else\n                    changedPoints_new.push(changedPoints[j]);\n            }\n            return changedPoints_new;\n        }\n\n    }\n    that.keepExclusive = keepExclusive\n\n    that.modifyRoi = function(ev, medViewer,callback)\n    {\n\n        if (!that.penEnabled)\n            return false;\n\n        var valtoset = (ev.buttons == 1) | ( ev.buttons == 0);\n        if (ev.roipreview)\n            valtoset = 255;\n\n\n        // careful, firefox and chrome might behave differently\n        var points_wc = medViewer.getRealWorldCoordinatesFromMouseEvent(ev.clientX, ev.clientY)._data;\n        // the function calculates real world coordinates based on the mouse event\n        var slicing = medViewer.getSlicingDimOfArray();\n\n        if (ev.type == "mousedown")\n        {\n            that.resetRoiVolume(currentROI);\n        }\n\n\n        if ((!that.regionGrow && !that.regionGrowRestric) || valtoset == 0)\n        {\n            // here was the evil bug!\n            // ROI was modified on mouseup, but this was explicitely NOT added to history\n            // For now, only allow roi modification in normal pen mode on mousedonw and mousemove, not mouseup (return)\n            if(ev.type == "mouseup")\n            {\n                callback();\n                return false;\n            }\n\n            that.modifyRoiInternal(points_wc, valtoset, slicing, medViewer, undefined, function(changedPoints)\n            {\n                // evil bug remainder, not sure why this was used in the first place, but had some reason once.\n                 //if (ev.type != "mouseup" && valtoset != 2)\n                changedPoints=keepExclusive(changedPoints,medViewer,ev);\n                if (!ev.roipreview)\n                    that.history.add(changedPoints, valtoset);\n                callback(changedPoints);\n            });\n        }\n        else if (that.regionGrowRestric)\n        {\n            if (ev.type == "mousedown")\n            {\n               if (regionGrow.timeout != -1)\n               {\n                   clearTimeout(regionGrow.timeout);\n                   regionGrow.timeout = -1;\n                   for (var k = 0; k < regionGrow.changedPoints.length;k++)\n                       medViewer.currentROI.content.data[regionGrow.changedPoints[k]] = 0;\n               }\n                that.modifyRoiInternal(points_wc, valtoset, slicing, medViewer, undefined, function(changedPoints)\n                {\n                    changedPoints = keepExclusive(changedPoints,medViewer,ev)\n                    if (!ev.roipreview)\n                        that.history.add(changedPoints, valtoset);\n                    callback(changedPoints);\n                });\n\n\n               regionGrow.changedPoints = [];\n            }\n            else if (ev.type == "mousemove" | ev.type == "mousewheel")\n            {\n                that.modifyRoiInternal(points_wc, valtoset, slicing, medViewer, undefined, function(changedPoints)\n                {\n                    changedPoints = keepExclusive(changedPoints,medViewer,ev)\n                    if (!ev.roipreview)                    \n                        that.history.add(changedPoints, valtoset);\n                    callback(changedPoints);\n                });\n            }\n            else\n            {\n                callback();\n            }\n\n        }\n        else\n        {\n            if (ev.type == "mousedown")\n            {\n                that.$pencil.addClass(\'leftright busy\')\n                regionGrow.helper.downev = ev;\n                regionGrow.helper.simscaling = 0;\n                regionGrow.changedPoints = [];\n                that.modifyRoiInternal(points_wc, valtoset, slicing, medViewer, undefined,function(changedPoints){\n                   that.$pencil.removeClass(\'busy\');\n                   callback(changedPoints);\n                });\n            }\n            if (ev.type == "mousemove")\n            {\n                regionGrow.helper.simscaling = (ev.clientX - regionGrow.helper.downev.clientX);\n                points_wc = medViewer.getRealWorldCoordinatesFromMouseEvent(regionGrow.helper.downev.clientX, regionGrow.helper.downev.clientY)._data;\n                that.$pencil.addClass(\'busy\');\n                that.modifyRoiInternal(points_wc, valtoset, slicing, medViewer, undefined, function(changedPoints){\n                   that.$pencil.removeClass(\'busy\');\n                   callback(changedPoints);\n                });\n            }\n            if (ev.type == "mouseup" || ev.type == "mouseleave")\n            {\n                KViewer.roiTool.$pencil.removeClass(\'leftright busy\')\n\n               if (regionGrow.timeout != -1)\n                {\n                    clearTimeout(regionGrow.timeout);\n                    regionGrow.timeout = -1;\n                    alertify.error(\'region growing breaked to early, keep mouse down to produce full result\')\n                }\n\n                if (!ev.roipreview)     \n                    that.history.add(regionGrow.changedPoints, 1);\n\n                callback(regionGrow.changedPoints);\n                regionGrow.changedPoints = [];\n\n            }\n        }\n\n\n    }\n\n\n\n\n    function applyPerm(idx, perm)\n    {\n        var newidx = [];\n        for (var k = 0; k < perm.length; k++)\n            newidx[perm[k]] = idx[k];\n        return newidx;\n    }\n\n    that.modifyRoiInternal = function(points_wc, valtoset, slicing, medViewer, params, callback)\n    {\n\n        function updateVal(valtoset,currentIndex)\n        {\n            if (valtoset < 2 )\n            {\n                if (nii.data[currentIndex] != undefined)\n                {\n                   if (valtoset>0)\n                   {\n                       if (nii.data[currentIndex] == 0)\n                       {\n                           changedPoints.push(currentIndex);\n                           nii.data[currentIndex] = valtoset;\n                       }\n                   }\n                   else\n                   {\n                       if (nii.data[currentIndex] > 0)\n                       {\n                           changedPoints.push(currentIndex);\n                           nii.data[currentIndex] = valtoset;\n                       }\n                   }\n                }\n            }\n            else\n            {\n                if (nii.data[currentIndex] == 0 | nii.data[currentIndex] == 2 )\n                {\n                    changedPoints.push(currentIndex);\n                    nii.data[currentIndex] = valtoset;\n                }\n            }\n        }\n\n       // if (master.mainViewPort != -1)\n       //     points_wc = math.multiply(math.inv(master.reorientationMatrix.matrix), points_wc);\n\n        // function can also be called from outside as "standalone" to modify an abstract roi\n        // in this case, all necessary variables must be set in "params"\n        // therefore, must use a local that_ and pencil_ here\n        if( params == undefined )\n        {\n            var nii = medViewer.currentROI.content;\n            var that_ = that;\n            var max_extent_perc = medViewer.computeMaxExtentFac() / 300;\n        }\n        else\n        {\n            var that_ = params;\n            var nii  = that_.nii;\n            slicing = medViewer.getSlicingDimOfArray();\n            // required fields are\n            /*\n            that.pencil\n            that.smartpaw;\n            that.threspen;\n            that.regionGrow ;\n            that.regionGrowRestric;\n            */\n\n            // why is this not 1 in some cases???? radius will be wrong then\n            var max_extent_perc = 1;\n\n        }\n\n        var pencil_ = that_.pencil;\n\n\n        var nii_ondraw = medViewer.nii;\n\n        slicing = applyInvPerm(nii.permutationOrder, nii_ondraw.permutationOrder[slicing]);\n\n        var p = [0,1,2];\n        var radiusx = math.floor(((slicing == p[0]) ? pencil_.radius_z : pencil_.radius) / nii.voxSize[p[0]] * max_extent_perc);\n        var radiusy = math.floor(((slicing == p[1]) ? pencil_.radius_z : pencil_.radius) / nii.voxSize[p[1]] * max_extent_perc);\n        var radiusz = math.floor(((slicing == p[2]) ? pencil_.radius_z : pencil_.radius) / nii.voxSize[p[2]] * max_extent_perc);\n        var sx2 = nii.voxSize[p[0]] * nii.voxSize[p[0]] / max_extent_perc / max_extent_perc;\n        var sy2 = nii.voxSize[p[1]] * nii.voxSize[p[1]] / max_extent_perc / max_extent_perc;\n        var sz2 = nii.voxSize[p[2]] * nii.voxSize[p[2]] / max_extent_perc / max_extent_perc;\n\n\n\n        // calculate vectors in plane to draw\n        var ie = math.inv(nii.edges);\n        var rectilinear = true;\n        var R =  (medViewer.getTiltMat(slicing));\n\n        if (KViewer.mainViewport != -1) // && !isIdentity(R))\n            rectilinear = false;\n\n\n        if (KViewer.navigationMode == 0 || KViewer.mainViewport == -1 )\n        {\n            var U =  math.multiply(math.inv(nii.edges),nii_ondraw.edges);\n            var iee = math.multiply(math.multiply(U,R),math.inv(U));\n        }\n        else\n        {\n            var W = (KViewer.reorientationMatrix.matrix);\n            var iee = math.multiply(math.multiply(math.inv(nii.edges),W),nii.edges);\n        }\n        var vx = math.multiply(iee,  [1,0,0,0])._data;\n        var vy = math.multiply(iee,  [0,1,0,0])._data;\n        var vz = math.multiply(iee,  [0,0,1,0])._data;\n\n\n        var points = math.multiply(ie, points_wc)._data;\n        points[0] = Math.round(points[0])\n        points[1] = Math.round(points[1])\n        points[2] = Math.round(points[2])\n\n        var radiusx_up = radiusx;\n        var radiusx_down = radiusx;\n        if (radiusx_up >= nii.sizes[0]-points[0])\n            radiusx_up = nii.sizes[0]-points[0]-1;\n        if (points[0]-radiusx_down <= 0 )\n            radiusx_down = points[0];\n\n        var radiusy_up = radiusy;\n        var radiusy_down = radiusy;\n        if (radiusy_up >= nii.sizes[1]-points[1])\n            radiusy_up = nii.sizes[1]-points[1]-1;\n        if (points[1]-radiusy_down <= 0 )\n            radiusy_down = points[1];\n\n        var radiusz_up = radiusz;\n        var radiusz_down = radiusz;\n        if (radiusz_up >= nii.sizes[2]-points[2])\n            radiusz_up = nii.sizes[2]-points[2]-1;\n        if (points[2]-radiusz_down <= 0 )\n            radiusz_down = points[2];\n\n\n        // prepare vars for our own in line add (math add is very slow)\n        var currentVoxel = [0, 0, 0];\n        var currentIndex = 0;\n\n        var sigma = math.abs(medViewer.histoManager.clim[1] - medViewer.histoManager.clim[0]);\n\n        // for the history\n        var changedPoints = [];\n\n\n        var dx = rectilinear?1:0.5;\n        var dy = rectilinear?1:0.5;\n        var dz = rectilinear?1:0.5;\n\n        // mode4D\n        /*\n        if(medViewer.nii.numTimePoints != nii.numTimePoints)\n        {\n            // must resize the nii to have correct number of dimensions ??\n            // or at least alert?\n        }\n        */\n\n        var current_t_contrast = 0;\n        if (medViewer.nii.numTimePoints > 1)\n            current_t_contrast = medViewer.nii.currentTimePoint.t;\n        else\n            if (nii.numTimePoints > 1)\n                current_t_contrast =  nii.currentTimePoint.t;\n\n\n        var currentTimePoint = current_t_contrast;\n        if (currentTimePoint > nii.numTimePoints-1)\n            currentTimePoint = nii.numTimePoints-1;\n\n\n        if (medViewer.currentROI && medViewer.currentROI.fileinfo && medViewer.currentROI.fileinfo.surfreference)\n        {\n            if (medViewer.currentROI.fileinfo.surfreference.changed == undefined)\n            {\n                medViewer.currentROI.fileinfo.surfreference.changed = {}\n            }\n            medViewer.currentROI.fileinfo.surfreference.changed[currentTimePoint] = true;\n        }\n            \n\n\n\n        // take thres from clim if desired\n        var thres = ["off","off"]\n        if (pencil_.thres_high != undefined && pencil_.thres_high != "off")\n        {\n            if (pencil_.thres_high == "climL" )\n                thres[1] = medViewer.histoManager.clim[0];\n            else if(pencil_.thres_high == "climR" )\n                thres[1] = medViewer.histoManager.clim[1];\n            else \n                thres[1] = medViewer.niiOriginal.datascaling.ie(pencil_.thres_high);\n        }\n\n        if (pencil_.thres_low != undefined && pencil_.thres_low != "off")\n        {\n            if (pencil_.thres_low == "climL" )\n                thres[0] = medViewer.histoManager.clim[0];\n            else if(pencil_.thres_low == "climR" )\n                thres[0] = medViewer.histoManager.clim[1];\n            else \n                thres[0] = medViewer.niiOriginal.datascaling.ie(pencil_.thres_low);\n        }\n\n        var comp = function () { return true}\n        if (that_.threspen > 0)\n        {\n             if (thres[0] == "off" & thres[1] != "off")\n                comp = function(x) { return x < thres[1]}\n             if (thres[0] != "off" & thres[1] == "off")\n                comp = function(x) { return x > thres[0]}\n             if (thres[0] != "off" & thres[1] != "off")\n                comp = function(x) { return x > thres[0] & x < thres[1]}\n        }\n\n        // always delete all on right click with threspen, therefore here also != 0\n        if (  ( that_.smartpaw | ( that_.threspen > 0 & !(that_.regionGrowRestric | that_.regionGrow) & valtoset != 0 ) ) )\n        {\n\n\n            var t = 1;\n            if (medViewer.nii.sizes.length > 3)\n                t = medViewer.nii.sizes[3];\n            var whd = medViewer.nii.sizes[0] * medViewer.nii.sizes[1] * medViewer.nii.sizes[2];\n\n\n\n            var ie_im = math.multiply(math.inv(medViewer.niiOriginal.edges),nii.edges);\n            var vx_im = math.multiply(ie_im, vx)._data;\n            var vy_im = math.multiply(ie_im, vy)._data;\n            var vz_im = math.multiply(ie_im, vz)._data;\n            points_im = math.multiply(math.inv(medViewer.niiOriginal.edges), points_wc)._data;\n\n            var currentVoxel_im = (math.round(points_im));\n            var offset_im = medViewer.niiOriginal.sizes[0] * medViewer.niiOriginal.sizes[1] * medViewer.niiOriginal.sizes[2] * current_t_contrast ;\n            var currentIndex_im = offset_im + medViewer.niiOriginal.sizes[0] * medViewer.niiOriginal.sizes[1] * currentVoxel_im[2] + currentVoxel_im[1] * medViewer.niiOriginal.sizes[0] + currentVoxel_im[0];\n\n            var centerval = medViewer.niiOriginal.data[currentIndex_im];       \n            function grayValdif(currentIndex_im)\n            {\n                return math.abs(medViewer.niiOriginal.data[currentIndex_im] - centerval) / sigma;            \n            }\n\n\n            for (var z = -radiusz_down; z <= radiusz_up; z+=dz)\n                for (var x = -radiusx_down; x <= radiusx_up; x+=dx)\n                    for (var y = -radiusy_down; y <= radiusy_up; y+=dy)\n                    {\n                        var d2 = x * x * sx2 + y * y * sy2 + z * z * sz2;\n                        if (d2 <= pencil_.radius * pencil_.radius)\n                        {\n                            currentVoxel[0] = Math.round(points[0] + x * vx[0] + y * vy[0] + z * vz[0]);\n                            currentVoxel[1] = Math.round(points[1] + x * vx[1] + y * vy[1] + z * vz[1]);\n                            currentVoxel[2] = Math.round(points[2] + x * vx[2] + y * vy[2] + z * vz[2]);\n\n                            currentVoxel_im[0] = Math.round(points_im[0] + x * vx_im[0] + y * vy_im[0] + z * vz_im[0]);\n                            currentVoxel_im[1] = Math.round(points_im[1] + x * vx_im[1] + y * vy_im[1] + z * vz_im[1]);\n                            currentVoxel_im[2] = Math.round(points_im[2] + x * vx_im[2] + y * vy_im[2] + z * vz_im[2]);\n\n                            currentIndex = nii.sizes[0] * nii.sizes[1] * currentVoxel[2] + currentVoxel[1] * nii.sizes[0] + currentVoxel[0] + nii.widheidep*(currentTimePoint);\n\n                            currentIndex_im = offset_im+ medViewer.niiOriginal.sizes[0] * medViewer.niiOriginal.sizes[1] * currentVoxel_im[2] + currentVoxel_im[1] * medViewer.niiOriginal.sizes[0] + currentVoxel_im[0];\n\n                            if (that_.smartpaw)\n                            {\n                                if (grayValdif(currentIndex_im) + d2 / (pencil_.radius * pencil_.radius) * 0.1 < 0.2 &\n                                (!(that_.threspen == 1 | that_.threspen == 3) | centerval > thres) &\n                                (!(that_.threspen == 2 | that_.threspen == 4) | centerval < thres))\n                                {\n                                    updateVal(valtoset,currentIndex);\n                                }\n                            }\n                            else if (that_.threspen == 1)\n                            {\n                                if (comp(medViewer.niiOriginal.data[currentIndex_im]))\n                                    updateVal(valtoset,currentIndex);\n                            }\n                        }\n                    }\n\n        }\n        else if ( valtoset != 0 && (that_.regionGrow | that_.regionGrowRestric) )\n        {\n\n            currentVoxel[0] = Math.round(points[0]);\n            currentVoxel[1] = Math.round(points[1]);\n            currentVoxel[2] = Math.round(points[2]);\n\n            currentIndex = nii.sizes[0] * nii.sizes[1] * currentVoxel[2] + currentVoxel[1] * nii.sizes[0] + currentVoxel[0] + nii.widheidep*(currentTimePoint);;\n\n            var B;\n            if (KViewer.navigationMode == 0 || KViewer.mainViewport == -1 )\n              B = math.multiply(math.inv(medViewer.niiOriginal.edges),nii.edges)._data;\n            else\n              B = math.multiply(math.multiply(math.inv(medViewer.niiOriginal.edges),math.inv(KViewer.reorientationMatrix.matrix)),nii.edges)._data;\n            var A = math.multiply(math.inv(medViewer.niiOriginal.edges),nii.edges)._data;\n\n            // if threspen is enabled, take these (hard) clims, otherwise take histogram clims\n            if(that_.threspen !== 0)\n            {\n\n               var clims = {}; \n               if (thres[0] != "off") \n                   clims.threshold_higher = thres[0];\n               if (thres[1] != "off") \n                   clims.threshold_lower = thres[1];\n            }\n            else\n            {\n                var clims = medViewer.histoManager.clim;\n            }\n\n            var rv = [nii.voxSize[0]/nii_ondraw.voxSize[0],nii.voxSize[1]/nii_ondraw.voxSize[1],nii.voxSize[2]/nii_ondraw.voxSize[2]]\n\n            var roidata\n\n            if (nii.numTimePoints > currentTimePoint)\n               roidata = new Uint8Array(nii.data.buffer,nii.hdroffset+currentTimePoint*nii.widheidep);\n            else\n               roidata = new Uint8Array(nii.data.buffer,nii.hdroffset);\n\n            if (current_t_contrast >= medViewer.niiOriginal.numTimePoints)\n                current_t_contrast=0;\n\n            regionGrow(medViewer.niiOriginal,roidata,A,B,nii.sizes, currentVoxel, valtoset,\n                    clims, that_.regionGrowRestric,\n                    radiusx*rv[0],radiusy*rv[1],radiusz*rv[2],\n                    sx2/(rv[0]*rv[0]), sy2/(rv[1]*rv[1]), sz2/(rv[2]*rv[2]), pencil_.radius * pencil_.radius, callback, current_t_contrast);\n\n\n\n            return;\n\n        }\n        else\n        {\n            var dx = rectilinear?1:0.5;\n            var dy = rectilinear?1:0.5;\n            var dz = rectilinear?1:0.5;\n            for (var z = -radiusz_down; z <= radiusz_up; z+=dz)\n                for (var x = -radiusx_down; x <= radiusx_up; x+=dx)\n                    for (var y = -radiusy_down; y <= radiusy_up; y+=dy)\n                        if (x * x * sx2 + y * y * sy2 + z * z * sz2 <= pencil_.radius * pencil_.radius)\n                        {\n\n                            currentVoxel[0] = Math.round(points[0] + x * vx[0] + y * vy[0] + z * vz[0]);\n                            currentVoxel[1] = Math.round(points[1] + x * vx[1] + y * vy[1] + z * vz[1]);\n                            currentVoxel[2] = Math.round(points[2] + x * vx[2] + y * vy[2] + z * vz[2]);\n\n                            currentIndex = nii.sizes[0] * nii.sizes[1] * currentVoxel[2] + currentVoxel[1] * nii.sizes[0] + currentVoxel[0] + nii.widheidep*(currentTimePoint);\n\n                            updateVal(valtoset,currentIndex);\n                        }\n        }\n\n        callback(changedPoints);\n\n\n    }\n\n\n    /***************************************************************************************\n     * History\n    ****************************************************************************************/\n    /** the history for undo/redo capabilities */\n    that.history = {};\n    \n    that.history.current = 0;\n    that.history.globalsteps = [];\n    that.history.maxSteps = 10;\n\n    // control + z: undo\n    // control + shift + z: redo\n    document.addEventListener("keydown", function(evt)\n    {\n        evt = evt || window.event;\n\n        if ($(evt.target).is("textarea") || $(evt.target).is("input"))\n            return;\n        if ((evt.which == 90 || evt.keyCode == 90) && evt.ctrlKey && !evt.shiftKey)\n        {\n            that.history.goto(1);\n            evt.preventDefault();evt.stopPropagation();return false;\n\n        }\n        else if ((evt.which == 90 || evt.keyCode == 90) && evt.ctrlKey && evt.shiftKey)\n        {\n            that.history.goto(-1);\n            evt.preventDefault();evt.stopPropagation();return false;\n        }\n    });\n\n\n    that.history.record = function(job, medViewer,whichROI,operation_type)\n    {\n        if (whichROI == undefined)\n            whichROI = currentROI;\n\n        if (whichROI == undefined || whichROI.content == undefined)\n            return;\n\n        whichROI.modified = true;\n\n        if (operation_type == \'use_as_last\')\n             that.history.lastROImodified = whichROI;\n        else if (operation_type != \'keep_last\')\n            that.history.lastROImodified = undefined;\n\n\n        that.history.medViewer = medViewer;\n        if (job === "startRecording")\n        {\n            if (whichROI.content.history === undefined)\n            {\n                whichROI.content.history = {\n                    steps: [],\n                    current: 0\n                };\n            }\n\n            var h = whichROI.content.history;\n            // set current pos to zero and delete significat rest\n            h.steps = h.steps.splice(h.current, that.history.maxSteps);                         \n            h.current = 0;\n\n            if (operation_type == undefined || operation_type != "dontaddtoglobal")\n            {\n\n            that.history.globalsteps = that.history.globalsteps.splice(that.history.current, that.history.maxSteps);\n            that.history.current = 0;\n\n\n            // insert a new step at the beginning\n            that.history.globalsteps.unshift(whichROI);\n\n            }\n\n            h.steps.unshift({\n                data: new Uint32Array(10000),\n                valtoset: false,\n                actualLength: 0\n            });\n\n\n        }\n        if (job === "stopRecording")\n        {\n\n        }\n\n    }\n\n\n    that.history.add = function(data, valtoset,whichROI)\n    {\n\n        if (whichROI == undefined)\n            whichROI = currentROI;\n\n        if (data == undefined || data.length == 0)\n            return\n\n        if (whichROI == undefined || (whichROI.content && whichROI.content.history == undefined))\n            return;\n\n        //var h = that.history.whichROI.content.history.steps[that.history.whichROI.content.history.current];\n        var h = whichROI.content.history.steps[whichROI.content.history.current];\n        h.actualLength += data.length;\n        h.others = data.others;\n        data.others = undefined;\n\n        // must enlarge the array, take at least 10000 points\n        if (h.data.length <= h.actualLength)\n        {\n            //console.log(\'ROI history: enlargin buffer for this step.\');\n            var tmp = new Uint32Array(h.data.length + math.max(10000, data.length));\n            tmp.set(h.data, 0);\n            tmp.set(data, h.actualLength - data.length);\n            h.data = tmp;\n        }\n        else\n        {\n            h.data.set(data, h.actualLength - data.length);\n        }\n\n        if (whichROI.content.onVoxels)\n        {\n            if (valtoset > 0)\n            {\n                for (var k = 0; k < data.length;k++)\n                    whichROI.content.onVoxels[data[k]] = 1;\n            }\n            else\n            {\n                for (var k = 0; k < data.length;k++)\n                    if (whichROI.content.onVoxels[data[k]])\n                        whichROI.content.onVoxels[data[k]] = undefined;\n            }\n\n        }\n\n        if (whichROI.ccanalysis)\n            whichROI.ccanalysis.update();\n\n\n        if (whichROI.fileinfo && whichROI.fileinfo.surfreference)\n        {\n            if (whichROI.fileinfo.surfreference.changed == undefined)\n                whichROI.fileinfo.surfreference.changed = {}\n            if (whichROI.content.currentTimePoint)                \n                whichROI.fileinfo.surfreference.changed[whichROI.content.currentTimePoint.t] = true;\n        }\n            \n\n\n        h.valtoset = valtoset;\n    }\n\n\n    that.history.goto = function(step,whichROI)\n    {\n        var h = that.history;\n\n        if (h.current + step > h.globalsteps.length | h.current + step < 0)\n            return;\n\n        if (step === -1)\n            h.current += step;\n        \n        if (whichROI == undefined)\n           whichROI = h.globalsteps[h.current];\n\n        that.history.goto_single(step,whichROI)\n\n        if (step === 1)\n            h.current += step;\n\n\n    }\n\n    that.history.goto_single = function(step,whichROI)\n    {\n\n        whichROI = whichROI || that.history.lastROImodified || currentROI;\n\n        // step = plus means go BACK in time\n        if (whichROI==undefined || whichROI.content == undefined || whichROI.content.history == undefined)\n            return;\n\n        var h = whichROI.content.history;\n\n        if (h.current + step > h.steps.length | h.current + step < 0)\n            return;\n\n        if (step === -1)\n            // go one step in redo-direction of possible\n            h.current += step;\n\n        var thisstep = h.steps[h.current];\n\n        that.history.applyChange(thisstep.data, thisstep.actualLength,whichROI);\n\n        if (step === 1)\n            // if backward, increment AFTER\n            h.current += step;\n\n        update3D(whichROI);\n\n        signalhandler.send("updateImage",{id:whichROI.fileID});\n\n        if (thisstep.others != undefined)\n            {\n                for (var k = 0; k < thisstep.others.length;k++)\n                {\n                     that.history.goto_single(step,thisstep.others[k]);\n                }\n            }\n       that.history.lastROImodified = undefined;\n\n\n\n    }\n\n    that.history.initOnVoxels = function(roi)\n    {\n        var onvox = {};\n        for (var z = 0; z < roi.sizes[2]; z++)\n            for (var y = 0; y < roi.sizes[1]; y++)\n                for (var x = 0; x < roi.sizes[0]; x++)\n                {\n                    var idx = roi.sizes[0] * roi.sizes[1] * z + roi.sizes[0] * y + x;\n                    if (roi.data[idx] > 0.5)\n                        onvox[idx] = 1;\n                }\n\n        return onvox;\n    }\n\n\n    that.history.applyChange = function(data, actualLength,whichROI)\n    {\n\n\n        if (whichROI == undefined)\n            whichROI = currentROI;\n\n\n        if (actualLength == undefined)\n            actualLength = data.length;\n        var nii = whichROI.content;\n\n        if (whichROI.content.onVoxels)\n        {\n            for (var k = 0; k < actualLength; k++)\n            {\n                if (nii.data[data[k]] > 0)\n                {\n                    nii.data[data[k]] = 0;\n                    whichROI.content.onVoxels[data[k]] = undefined;\n                }\n                else\n                {\n                    nii.data[data[k]] = 1;\n                    whichROI.content.onVoxels[data[k]] = 1;\n                }\n            }\n        }\n        else\n        {\n            for (var k = 0; k < actualLength; k++)\n            {\n                if (nii.data[data[k]] > 0)\n                    nii.data[data[k]] = 0;\n                else\n                    nii.data[data[k]] = 1;\n            }\n        }\n        if (whichROI.ccanalysis)\n            whichROI.ccanalysis.update();\n\n\n\n    }\n\n\n\n\n\n    /***************************************************************************************\n     * computing the bbox of a ROI\n     ****************************************************************************************/\n\n    function computeBBox(roi)\n    {\n        var max = [-100000, -100000, -100000];\n        var min = [100000, 100000, 100000];\n\n        var edges = roi.content.edges;\n        var sz = roi.content.sizes;\n        for (var z = 0; z < sz[2]; z++)\n            for (var y = 0; y < sz[1]; y++)\n                for (var x = 0; x < sz[0]; x++)\n                {\n                    if (roi.content.data[sz[0] * sz[1] * z + sz[0] * y + x] > 0.5)\n                    {\n                        var p = math.multiply(edges, [x, y, z, 1]);\n                        if (max[0] < p._data[0])\n                            max[0] = p._data[0];\n                        if (min[0] > p._data[0])\n                            min[0] = p._data[0];\n                        if (max[1] < p._data[1])\n                            max[1] = p._data[1];\n                        if (min[1] > p._data[1])\n                            min[1] = p._data[1];\n                        if (max[2] < p._data[2])\n                            max[2] = p._data[2];\n                        if (min[2] > p._data[2])\n                            min[2] = p._data[2];\n                    }\n                }\n\n        roi.bbox = {\n            max: max,\n            min: min\n        };\n\n\n\n    }\n    that.computeBBox = computeBBox;\n\n\n\n    /***************************************************************************************\n    * set current position to center of ROI\n    ****************************************************************************************/\n\n    function set_to_center(roi)\n    {\n        var cx = 0;\n        var cy = 0;\n        var cz = 0;\n        var cnt = 0;\n        for (var z = 0; z < roi.sizes[2]; z++)\n            for (var y = 0; y < roi.sizes[1]; y++)\n                for (var x = 0; x < roi.sizes[0]; x++)\n                {\n                    if (roi.data[roi.sizes[0] * roi.sizes[1] * z + roi.sizes[0] * y + x] > 0.5)\n                    {\n                        cx += x;\n                        cy += y;\n                        cz += z;\n                        cnt++;\n                    }\n                }\n        cx /= cnt;\n        cy /= cnt;\n        cz /= cnt;\n        if (cnt > 0)\n        {\n            var p = math.multiply(roi.edges, [cx, cy, cz, 1]);\n            master.currentPoint = p;\n            signalhandler.send("positionChange",{point:p});\n        }\n    }\n\n\n\n\n      function contextPicker(ev,viewer)\n      {\n          var point = viewer.getRealWorldCoordinatesFromMouseEvent(ev.clientX,ev.clientY);\n\n\n          var R;\n          if (KViewer.navigationMode == 0 | KViewer.navigationMode == 2 )\n             R = math.diag([1, 1, 1, 1]);\n          else\n            R = getTiltMat(slicingDimOfArray);\n          if (master.mainViewport !== -1)\n              point = math.multiply(math.inv(KViewer.reorientationMatrix.matrix), point);\n          var curV = math.multiply(math.inv(viewer.nii.edges), point);\n          var reorient = math.diag([1, 1, 1, 1]);\n\n\n          var fobj;\n          var conncomp_label;\n          for (var k = 0; k < viewer.ROIs.length;k++)\n          {\n              if (!viewer.ROIs[k].visible)\n                  continue;\n              var roi = viewer.ROIs[k].roi;\n              if (KViewer.navigationTool.isinstance &&\n                   ((KViewer.navigationTool.movingObjs[roi.fileID] != undefined & KViewer.navigationMode == 0) | KViewer.navigationMode == 2 ) )\n                    reorient = KViewer.reorientationMatrix.matrix;\n              var A = (math.multiply(math.multiply(math.multiply(math.inv(roi.content.edges), reorient), viewer.nii.edges), R))._data;\n              var offs = 0;\n              if (roi.content.currentTimePoint != undefined)\n                   offs = roi.content.currentTimePoint.t*roi.content.widheidep\n              var roi_val =  NNInterp(roi.content, curV._data[0], curV._data[1], curV._data[2], A, offs)\n              if (roi_val >0.5)\n              {\n                    fobj = roi;\n                    if (fobj.ccanalysis && fobj.ccanalysis.enabled)\n                    {\n                        var ii  = NNInterp({data:fobj.ccanalysis.cc.labels,wid:roi.content.wid,widhei:roi.content.widhei\n                                            ,widheidep:roi.content.widheidep,sizes:roi.content.sizes},\n                                             curV._data[0], curV._data[1], curV._data[2], A, offs);\n                        for (var j = 0; j < fobj.ccanalysis.persistent.length;j++)\n                            if (fobj.ccanalysis.persistent[j].idx == ii)\n                            {\n                                conncomp_label = fobj.ccanalysis.persistent[j];\n                                break;\n                            }\n\n                    }\n                    break;\n              }\n          }\n\n          if (fobj == undefined)\n          {\n               return false;\n          }\n          else\n          {\n              contextMenuLabel(fobj,conncomp_label,point,ev)\n              return true;\n\n          }\n      }\n\n      function contextMenuLabel(fobj,conncomp_label,point,ev)\n      {\n\n          var labels;\n          if (KViewer.predefinedROIlabels != undefined)\n            labels = KViewer.predefinedROIlabels;\n          else\n          {\n                labels = [];\n                for (var k in KViewer.roiTool.ROIs)\n                  if (KViewer.roiTool.ROIs[k].fileID != fobj.fileID)\n                    labels.push({name:KViewer.roiTool.ROIs[k].filename,color:KViewer.roiTool.ROIs[k].color,id:KViewer.roiTool.ROIs[k].fileID});\n\n          }\n\n\n          KContextMenu(\n            function()\n            {\n                var mediaire = false;\n                var $menu = $("<ul class=\'menu_context\'>");\n\n                if (conncomp_label & !mediaire)\n                    $menu.append($("<li class=\'inactive\'>crop label "+fobj.filename +"/"+ conncomp_label.name +" to...&nbsp</li>"));\n                else\n                    $menu.append($("<li class=\'inactive\'>move "+that.conncompdesc+" to...&nbsp </li>"));\n\n\n                if (labels.length == 0)\n                {\n                    if (!mediaire)\n                        $menu.append($("<span> &nbsp no other ROIs ... </span>"));\n                }\n                else\n                {\n                    for (var k = 0; k < labels.length;k++)\n                    {\n\t\t\t\t\t\tif(labels[k].name ==  fobj.filename || (conncomp_label != undefined && labels[k].name == conncomp_label.name))\n\t\t\t\t\t\t\tcontinue\n                        \n                        if(labels[k].color!=undefined)\n                        {\n                            var c = colors[labels[k].color];\n                            var chtml = "background:" +RGB2HTML(c[0], c[1], c[2])\n                        }\n                        else\n                            chtml = "";\n                        var colordiv = "<span  class=\'color_selector_virtual\' style=\'" + chtml + "\'></span>"\n                        $menu.append($("<li onchoice=\'addto"+k+"\'>  "+ colordiv + labels[k].name+ " </li>"));\n                    }\n                }\n               $menu.append($("<li  onchoice=\'addto\'><span  class=\'color_selector_virtual\' style=\'background:white;\'></span>... new mask </li>"));\n               $menu.append($("<hr width=\'99%\'> "));\n               \n               $menu.append($("<li onchoice=\'keep\'><i class=\'leftaligned fa fa-square\'></i>keep "+that.conncompdesc+"</li>"));\n               $menu.append($("<li onchoice=\'delete\'><i class=\'leftaligned fa fa-trash\'></i>delete "+that.conncompdesc+"</li>"));\n               if (fobj.content.numTimePoints > 1)\n               {\n                  $menu.append($("<li onchoice=\'keep4D\'><i class=\'leftaligned fa fa-square\'></i>keep "+that.conncompdesc+" (4D)</li>"));\n                  $menu.append($("<li onchoice=\'delete4D\'><i class=\'leftaligned fa fa-trash\'></i>delete "+that.conncompdesc+" (4D)</li>"));\n               }\n\n               if (currentROI != fobj)\n                    $menu.append($("<li onchoice=\'edit\'><i class=\'leftaligned fa fa-pencil\'></i>edit "+that.conncompdesc+"</li>"));\n\n\n                return $menu;\n            },\n            function(str, ev2)\n            {\n                if (point == undefined)\n                    point = math.multiply(fobj.content.edges, [conncomp_label.cog[0],conncomp_label.cog[1],conncomp_label.cog[2],1]);\n\n                if (str == undefined)\n                    return;\n                  else if (str.substring(0,5) == "addto")\n                        {\n                            var l = parseInt(str.substring(5)); // will b NaN for new roi\n                            var roiid;\n                            var color;\n\n                            // found an existing ROI, or a predefined label\n                            if (labels[l] != undefined)\n                            {\n                                if (labels[l].id != undefined)\n                                    roiid = labels[l].id;\n                                else\n                                    roiid = labels[l].name;\n                                var intendedName =  labels[l].name;\n                                // choose the\n                                var color = labels[l].color;\n                            }\n                            else\n                            {\n                                var intendedName = KViewer.dataManager.getNextIteratedFilename( fobj.filename + "_c" );\n                            }\n\n                            // if no color specified, choose next available\n                            if(color==undefined)\n                            {\n                                if (that.last_created_roicolor == undefined)\n                                    if (fobj.color != undefined)                               \n                                        that.last_created_roicolor  = fobj.color;\n                                    else\n                                        that.last_created_roicolor  = 0\n                                color = (++that.last_created_roicolor) % KColor.list.length\n                            }\n\n\t\t\t\t\t\t\tif(roiid==undefined)\n\t\t\t\t\t\t\t   roiid = \'ROI_\' + intendedName\n\t\t\t\t\t\t\t// try to get files\n\n\t\t\t\t\t\t\tvar nfobj = KViewer.dataManager.getFile(roiid);\n\n                            if(nfobj==undefined)\n                            {\n                                fobj.intendedROIid = roiid;\n                                nfobj = KViewer.dataManager.cloneAsROI(fobj.fileID,intendedName)[0];\n                                nfobj.color=color;\n                                KViewer.roiTool.ROIs[nfobj.fileID] = nfobj;\n                                KViewer.roiTool.update();\n                            }\n\n                            // this does the actual cropping\n                            var cp = cropConnectedComponent2(fobj,nfobj, point)\n\n                            // keep cclabels up to date\n                            if (conncomp_label && fobj.ccanalysis)\n                            {\n                                for (var k = 0;k <fobj.ccanalysis.persistent.length;k++)\n                                {\n                                    if (conncomp_label == fobj.ccanalysis.persistent[k])\n                                    {\n                                        fobj.ccanalysis.persistent.splice(k,1);\n                                        break;\n                                    }\n                                }\n                                if (nfobj.ccanalysis)\n                                    nfobj.ccanalysis.persistent.push(conncomp_label);\n                            }\n\n\n                            // if ROI not yet present put into viewer\n                            setContentwithROI(nfobj,{intent:{ROI:true,color:color}},fobj.fileID);\n                            signalhandler.send("updateImage",{id: nfobj.fileID});\n\n\n                            // update history\n                            cp.others = [nfobj];\n                            KViewer.roiTool.history.record(\'startRecording\',  that.roiPanel.getParentViewer(),fobj, \'use_as_last\');\n                            KViewer.roiTool.history.add(cp, 1,fobj);\n                            KViewer.roiTool.history.record(\'startRecording\',  that.roiPanel.getParentViewer(),nfobj, \'dontaddtoglobal\');\n                            KViewer.roiTool.history.add(cp, 1,nfobj);\n\n\n                        }\n\n                  else if (str == "delete")\n                        {\n                            that.delROI_component(fobj, point)\n                        }\n                  else if (str == "delete4D")\n                        {\n                            that.delROI_component(fobj, point,\'all\')\n                        }\n                  else if (str == "keep")\n                        {\n                            that.keepROI_component(fobj, point)\n                        }\n                  else if (str == "keep4D")\n                        {\n                            that.keepROI_component(fobj, point,\'all\')\n                        }\n\n                  else if (str == "edit")\n                        {\n\n                            that.makeCurrentGlobal(fobj.fileID)\n\n                        }\n\n\n                  function setContentwithROI(f,intent,fid)\n                  {\n                        KViewer.iterateMedViewers(function(viewer)\n                        {\n                            for (var k = 0 ; k < viewer.ROIs.length;k++)\n                            {\n                                    if (viewer.ROIs[k].roi.fileID == fid)\n                                    {\n                                        viewer.setContent(f,intent);\n                                    }\n                            }\n\n                        });\n                  }\n            },true,false,true,false)(ev)\n\n            return true;\n      }\n\n    that.contextPicker = contextPicker;\n\n\n\n\n\n    function hidePen(medViewer)\n    {\n\n        that.enabled = false;\n        that.$pencil.hide();\n        medViewer.$canvas.css(\'cursor\', \'default\');\n    };\n    that.hidePen = hidePen;\n\n    function hidePenGlobal()\n    {\n        KViewer.iterateMedViewers(function(viewer)\n        {\n            KViewer.roiTool.hidePen(viewer);\n        });\n    }\n    that.hidePenGlobal = hidePenGlobal;\n\n\n    /***************************************************************************************\n    * pen representation in 2D-viewers\n    ****************************************************************************************/\n    function drawPen(ev, medViewer)\n    {\n        if ( medViewer.currentROI != undefined && (that.penEnabled & !that.polyEnabled && ( $(ev.target).hasClass("KViewPort_canvas") )))\n        {\n\n            var max_extent_perc = medViewer.computeMaxExtentFac() / 300\n            var fac = medViewer.embedrelfac * medViewer.zoomFac;\n            var r = (2 * (pencil.radius)) * fac * max_extent_perc;\n\n            that.$pencil.show();\n            that.enabled = true;\n            medViewer.$canvas.css(\'cursor\', \'none\');\n\n            if (that.regionGrow)\n            {\n                that.$pencil.addClass("regionGrow");\n                r = 50;\n            }\n            else\n                that.$pencil.removeClass("regionGrow");\n\n\n            var left = window.pageXOffset+ev.clientX - r / 2 - 1;\n            var top = window.pageYOffset+ev.clientY - r / 2 - 1;\n\n\n            that.$pencil.offset({\n                left: left,\n                top: top\n            });\n\n            that.$pencil.css({\n                left: left,\n                top: top,\n                width: r,\n                height: r\n            });\n            return true;\n        }\n        else\n        {\n            that.enabled = false;\n            that.$pencil.hide();\n            medViewer.$canvas.css(\'cursor\', \'default\');\n            return false;\n        }\n\n\n    }\n    that.drawPen = drawPen;\n\n\n\n\n    /***************************************************************************************\n    * tools for dynamic context manu based on passing the roi id\n   ****************************************************************************************/\n\n    var roitools_contextmenu = function() {\n        var $menu = $("<ul class=\'menu_context\'>");\n        $menu.append($("<li onchoice=\'invert\'> invert  </li>"));\n        $menu.append($("<li onchoice=\'clear\'> clear  </li>"));\n        $menu.append($("<hr>"));\n        $menu.append($("<li onchoice=\'fillholes\'> fill holes  </li>"));\n        var thres = removesalt.threshold;\n        var $salt_threshold = $("<input onchoice=\'preventSelection\' type=\'number\' step=\'5\' min=\'2\' max=\'10000\'>").val(thres).\n             on(\'keyup\', function(ev) {\n            var $input = $(ev.target);\n            removesalt.threshold = $input.val();\n           });\n        $menu.append($("<li onchoice=\'removesalt\'> remove salt </li>").append($salt_threshold));\n        $menu.append($("<li onchoice=\'splatter\'> splatter </li>"));\n        if (KViewer.currentPoint != undefined)\n        {\n            var str = "("+KViewer.currentPoint._data[0].toFixed(0)+","+KViewer.currentPoint._data[1].toFixed(0)+","+KViewer.currentPoint._data[2].toFixed(0)+")"\n            $menu.append($("<li onchoice=\'crop\'> crop at seed "+str+" </li>"));\n        }\n        $menu.append($("<hr>"));\n        $menu.append($("<li onchoice=\'opening\'> opening  </li>"));\n        $menu.append($("<li onchoice=\'closing\'> closing  </li>"));\n        $menu.append($("<li onchoice=\'erode\'> erode  </li>"));\n        $menu.append($("<li onchoice=\'dilate\'> dilate  </li>"));\n        $menu.append($("<li onchoice=\'mirror\' class=\'mirror_roi_dimspan\'> mirror  <span dim=\'X\'>LR</span> <span dim=\'Y\'>AP</span> <span dim=\'Z\'>Z</span> <span dim=\'C\'>custom</span></li>"));\n        $menu.append($("<hr>"));\n        $menu.append($("<li onchoice=\'threshold_upper\'> upper threshold  </li>"));\n        $menu.append($("<li onchoice=\'threshold_lower\'> lower threshold </li>"));\n        return $menu;\n    }\n\n\n\n\n    that.tools_contextmenu_dynamic = function(ev, id) {\n        new KContextMenu(roitools_contextmenu,function(id) {\n            return function(str, ev) {\n                tools(str, ev, id)\n            }\n        }(id))(ev, id)\n    }\n    ;\n\n\n\n    /***************************************************************************************\n    * create ROI subview\n    ****************************************************************************************/\n    /** creates a view of the ROI in a medviewer\n\t * @param {object} fobj - the fileObject of the ROI\n\t * @param {object} viewer - the medviewer (see {@link KMedViewer})\n\t * @param {object} intent - intention like color\n\t */\n    that.createView = function(fobj, viewer, intent)\n    {\n        var obj = {\n            type: "roi",\n            roi: fobj,\n            nii: fobj.content,\n            isCurrent: fobj == currentROI,\n            //color:(viewer.ROIs.length) % colors.length,\n            color: fobj.color,\n            visible: true\n        };\n\n\n        obj.color = Object.getOwnPropertyNames(ROIs).length % colors.length;\n        if (intent != undefined & intent.color != undefined)\n        {\n            obj.color = intent.color;\n            fobj.color = intent.color; // overwrite color with intent color\n        }\n\n        // color contextmenu\n        obj.$colselector = KColorSelector(colors,\n        function(c) {\n            return "background:" + RGB2HTML(c[0], c[1], c[2]) + ";";\n        },\n        function() {\n            if (obj.refSurfView != undefined)\n            {\n                obj.refSurfView.color = obj.color;\n                viewer.gl.setSurfColor(obj.refSurfView);\n            }\n            viewer.drawSlice({\n                mosaicdraw: true\n            });\n\n        }, obj);\n\n\n\n        // tools contextmenu\n        var tools_contextmenu = new KContextMenu(roitools_contextmenu,\n        function(fobj) {\n            return function(str, ev) {\n                tools(str, ev, fobj.fileID,viewer)\n            }\n        }(fobj));\n\n        /***************************************************************************************\n        * the subviews toolbar\n        ****************************************************************************************/\n        var $captiondiv, $cutdiv, $currentpickerdiv, $dragdiv,$wrench,$createOutlines, $toggleVisible;\n\n\n        obj.divs = [\n            $("<br style=\'clear:both\' />"),\n            $("<div  class=\'KViewPort_tool persistent roi\'>  <i class=\'fa fa-close fa-1x\'></i></div>").appendTooltip("closeROI")\n            .click(close).mousedown(viewer.viewport.closeContextMenu(obj)),\n            $("<div  class=\'KViewPort_tool roi\'>  <i class=\'fa fa-save fa-1x\'></i></div>").appendTooltip("saveuploadROI")\n            .click(function() {\n                saveROI(obj.roi)\n            }),\n            $("<div  class=\'KViewPort_tool roi\'> <i class=\'fa  fa-binoculars\'></i></div> ").appendTooltip("jumptoROI")\n            .click(function(roi) {\n                return function() {\n                    set_to_center(roi.content);\n                }\n            }(obj.roi)),\n            $createOutlines = $("<div  class=\'KViewPort_tool roi\'>  <i class=\'fa fa-1x fa-lemon-o\'></i></div>").appendTooltip("outline"),\n            $createIso = $("<div  class=\'KViewPort_tool roi\'>  <i class=\'fa fa-1x\'>3D</i></div>").appendTooltip("isosurfROI"),\n            $wrench = $("<div  class=\'KViewPort_tool roi\'>  <i class=\'fa fa-wrench fa-1x\'></i></div>").click(tools_contextmenu).appendTooltip("roitools"),\n            $toggleVisible = $("<div  class=\'KViewPort_tool roi \'>").append($("<i class=\'fa fa-eye fa-1x\'></i></div>").appendTooltip("showhide"))\n            .click(function(e){obj.toggle(e)}),\n            $currentpickerdiv = $("<div  class=\'KViewPort_tool roi \'>  <i class=\'currentFiberset fa fa-pencil-square-o fa-1x\'></i></div>").appendTooltip("makecurrent")\n            .click(makeCurrent),\n\n            $captiondiv = $("<div  class=\'KViewPort_tool roi caption\'> " + obj.roi.filename + "</div>"),\n            obj.$colselector.appendTooltip("selectcolor"),\n            $dragdiv = $("<div  class=\'KViewPort_tool  draganddrop\'>  <i class=\'fa fa-hand-paper-o fa-1x\'></i></div>").appendTooltip("dragdropviewport"),\n        ];\n\n        if(obj.nii.numTimePoints > 1)\n        {\n            var $timesliderDIV = $("<div  class=\'KViewPort_tool roi\' style=\'padding:0px;height:21px\'> </div>");\n            var $timeinput = $("<input class=\'KViewPort_roiview_timeindicator KViewPort_tool roi\' value=\'0\' min=\'0\' max=\'"+ (obj.nii.numTimePoints-1)+"\'/>").appendTo($timesliderDIV)\n                .on(\'change\', function(){ \n                    var xval = $(this).val();\n                    obj.nii.currentTimePoint.t = parseInt( xval )  \n                    signalhandler.send("updateImage",{id: obj.roi.fileID});\n                })\n            function timeinputwheel(ev, delta) { ev = ev.originalEvent || ev;var newval = parseInt($(this).val())+((ev.wheelDelta>0)?1:-1);if(newval >= 0 && newval <obj.nii.numTimePoints) {$(this).val( newval ); $(this).trigger(\'change\'); }ev.stopPropagation(); return false;  }\n            $timeinput.bind("mousewheel", timeinputwheel);\n                \n            obj.divs.splice(2, 0, $timesliderDIV);    \n            obj.$timeinput = $timeinput;\n\n        }    \n\n        obj.toggle = function (e)\n        {\n             var vis;\n             if (obj.visible)\n                vis = 0;\n             else\n                vis = 1;\n             if (e.shiftKey)\n                obj.toggle_visibility(vis)\n             else\n                KViewer.iterateMedViewers(function(viewer)\n                {\n                    obj;\n                    for (var k = 0; k < viewer.ROIs.length; k++)\n                    {\n                        if(viewer.ROIs[k].roi.fileID == obj.roi.fileID)\n                        {\n                            viewer.ROIs[k].toggle_visibility(vis)\n                        }\n                    }\n                });\n\n        }\n\n        obj.toggle_visibility = function(e)\n        {\n            if(e===0)\n               obj.visible = true;\n            else if(e===1)\n               obj.visible = false;\n\n            if (obj.visible)\n            {\n                obj.visible = false;\n                //var target = $(e.target).is(\'i\')?$(e.target):$(e.target).children();\n                var target = $toggleVisible.find(\'i\');\n                target.addClass(\'fa-eye-slash\').removeClass(\'fa-eye\').css(\'color\', \'red\');\n\n                if(obj.refSurfView)\n                {\n                    obj.refSurfView.visible = false;\n                    obj.refSurfView.update();\n                }\n\n            }\n            else\n            {\n                obj.visible = true;\n                //var target = $(e.target).is(\'i\')?$(e.target):$(e.target).children();\n                var target = $toggleVisible.find(\'i\');\n                target.removeClass(\'fa-eye-slash\').addClass(\'fa-eye\').css(\'color\', \'initial\');\n\n                if(obj.refSurfView)\n                {\n                    obj.refSurfView.visible = true;\n                    obj.refSurfView.update();\n                }\n\n            }\n            viewer.drawSlice({\n                mosaicdraw: true\n            });\n\n        }\n        if (typeof KMedImg3D == "undefined")\n            $createIso.hide()\n\n        obj.$currentpickerdiv = $currentpickerdiv;\n        obj.$captiondiv = $captiondiv;\n        if (obj.isCurrent)\n        {\n            $currentpickerdiv.addClass(\'current\')\n            viewer.currentROI = obj.roi;\n            //\n            viewer.toggleHairCrossControls( false );\n        }\n\n        if ( ! (intent != undefined && intent.hideview ) )\n            viewer.toolbar.append(obj.divs, "roi");\n        else\n            obj.hideview = true;\n\n\n\n\t\t$createOutlines.click(function(ev) {\n\t\t\tif (obj.outlines == undefined)\n\t\t\t{\n\t\t\t\tobj.outlines = Outlines(obj)\n\t\t\t    obj.outlines.update(viewer);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t    obj.outlines.close();\n\t\t\t\tobj.outlines = undefined;\n\t\t\t}\n\n\n\t\t});\n\n\n\n        /*\n            if (obj.roi.namedivs == undefined)\n                obj.roi.namedivs = [];\n            obj.roi.namedivs.push($captiondiv);\n            $captiondiv.keydown(function(ev) { if (ev.keyCode == 13) { $(ev.target).blur(); return false } })\n   \t\t\t\t\t\t.keyup(function(ev)\n            {\n                obj.roi.filename = $captiondiv.text();\n                if (obj.roi.namedivs != undefined)\n                    for (var i = 0; i < obj.roi.namedivs.length;i++)\n                    {\n                        if ($captiondiv != obj.roi.namedivs[i])\n                            obj.roi.namedivs[i].text(obj.roi.filename);\n                    }\n                that.update();\n            }\t);\n\n*/\n        attachNameDivHandler(obj.roi, $captiondiv, that.update);\n\n\n\n        $dragdiv.attr("draggable", \'true\');\n        //            $dragdiv.on("dragstart", dragstarter({ type:\'file\', tag: \'/mask/\', mime: \'nii\', filename: obj.roi.filename,  fileID: obj.roi.fileID }));\n\n        $dragdiv.on("dragstart", dragstarter(function() {\n            return {\n                type: \'file\',\n                mime: \'nii\',\n                tag: \'/mask/\',\n                filename: obj.roi.filename,\n                fileID: obj.roi.fileID,\n                intent: {\n                    color: obj.color\n                },\n                close: close\n            }\n        }));\n\n\n        $createIso.mousedown(function(ev)\n        {\n            if (obj.refSurfView && !obj.refSurfView.toolbarAttached)\n            {\n                ev.preventDefault();\n                ev.stopImmediatePropagation();\n                var id = setTimeout(function()\n                {\n                    $createIso.onhold = true;\n                    if (obj.refSurfView)\n                    {\n                        viewer.toolbar.append(obj.refSurfView.divs,\'surface\')\n                        obj.refSurfView.toolbarAttached = true;\n                    }\n\n                },500);\n                $(this).on("mouseleave mouseup",function(ev)\n                {\n                     clearTimeout(id);\n                     $(this).onhold = false;\n                     $(this).off("mouseleave mouseup");\n                });\n            }\n\n        }    );\n\n\n\n\n        $createIso.click(createISO);\n\n        function createISO(ev,intent)\n        {\n\n            if ($createIso.onhold)\n            {\n                $createIso.onhold = undefined;\n                return;\n            }\n\n            if (obj.refSurfView && !viewer.isGLenabled())\n            {\n                KViewer.roiTool.update3D(fobj,viewer.viewport.progressSpinner);\n                viewer.toggle3D()\n            }\n            else\n                viewer.attachSurfaceRef(obj,fobj,viewer.viewport.progressSpinner,intent)\n\n\n        }\n\n\n        if (fobj.fileinfo.surfreference != undefined)\n        {\n            var curRoiView = obj;\n            $createIso.addClass("current");\n            var surfView = viewer.appendObject3D(fobj.fileinfo.surfreference, {\n                color: curRoiView.color\n            });\n            curRoiView.refSurfView = surfView;\n\n        }\n\n\n\n        if (intent != undefined && intent.visible != undefined && intent.visible == false)\n            $toggleVisible.trigger(\'click\');\n\n        if (fobj.fileinfo.surfreference == undefined && (\n             (intent && intent.isosurf && fobj.fileinfo.surfreference == undefined) ||\n             (viewer.isGLenabled() && intent.isosurf != false) ) )\n        {\n            if (intent && intent.isosurf)\n               createISO(undefined,intent.isosurf);\n            else\n                createISO();\n        }\n\n\n\n        /***************************************************************************************\n            * activate this view for painting\n            ****************************************************************************************/\n        function makeCurrent()\n        {\n            // currentROI is global now for all viewports\n            that.makeCurrentGlobal(obj.roi.fileID);\n            /*\n\t\t\t\tcurrentROI = obj.roi!==currentROI?obj.roi:undefined;\n\t\t\t \tfor(var v = 0; v<KViewer.viewports.length; v++)\n\t\t\t \t{\n\n\t\t\t\t\tvar viewer = KViewer.viewports[v].getCurrentViewer();\n\t\t\t\t\tif(viewer==undefined)\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t viewer.currentROI = undefined;\n\t\t\t\t\t for (var k = 0; k < viewer.ROIs.length;k++)\n\t\t\t\t\t {\n\n\t\t\t\t\t\tif (obj.roi == viewer.ROIs[k].roi & viewer.ROIs[k].isCurrent == false)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t   viewer.ROIs[k].isCurrent = true;\n\t\t\t\t\t\t   viewer.currentROI = viewer.ROIs[k].roi;\n\t\t\t\t\t\t   viewer.ROIs[k].$currentpickerdiv.addClass("current");\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tviewer.ROIs[k].isCurrent = false;\n\t\t\t\t\t\t\tviewer.ROIs[k].$currentpickerdiv.removeClass("current");\n\t\t\t\t\t\t}\n\t\t\t\t\t }\n\n\t\t\t \t}\n\n\t\t\t \tcheckForAnyActiveRoi();\n\t\t\t\tthat.roiPanel.update();\n\t\t\t\t*/\n        }\n\n        obj.makeCurrent = makeCurrent;\n\n\n\n        if(state.viewer.showOutlines)\n            obj.outlines = Outlines(obj);\n\n\n        /***************************************************************************************\n        * close a roi\n        ****************************************************************************************/\n        function close()\n        {\n\n            if (that.visibleROIs[obj.roi.fileID])\n            {\n                delete that.visibleROIs[obj.roi.fileID];\n            }\n            \n\n\n            if (viewer.currentROI == obj.roi)\n            {\n                viewer.currentROI = undefined;\n                // enable haircross controls (hover and mouse events ...) to be sure\n                viewer.toggleHairCrossControls( true );\n            }\n\n\n            for (var k = 0; k < obj.divs.length; k++)\n                obj.divs[k].remove();\n\n            for (var k = 0; k < viewer.ROIs.length; k++)\n            {\n                if (obj == viewer.ROIs[k])\n                {\n                    viewer.ROIs.splice(k, 1);\n                    break;\n                }\n            }\n\n\t\t    if (obj.outlines != undefined)\n\t\t\t{\n\t\t\t    obj.outlines.close();\n\t\t\t\tobj.outlines = undefined;\n\t\t\t}\n\n\n            if (obj.refSurfView != undefined)\n            {\n                obj.refSurfView.close();\n                obj.refSurfView = undefined;\n            }\n\n            checkForAnyActiveRoi();\n\n            viewer.toolbar.update("roi")\n\n            viewer.drawSlice({\n                mosaicdraw: true\n            });\n        }\n\n\n        obj.close = close;\n        signalhandler.attach("close", close);\n\n\n\n\n        return obj;\n    }\n\n    /***************************************************************************************\n    * set the color of a roi in all viewports and layers (2D, 3D, 3D-objects)\n    ****************************************************************************************/\n    that.setColorGlobal = function(id, color)\n    {\n        if(typeof id == "object")\n            id = id.fileID;\n\n\t    // we have this mess with colors being indices or rga or whatever\n\t\t// here, we need an index (a color number), so find it if necessary\n\n        if(color instanceof KColor)\n            color = KColor.findColorIndex(color.color) ;\n\n        if(Array.isArray(color))\n            color = KColor.findColorIndex(color) ;\n\n\n        if (that.ROIs[id])\n            that.ROIs[id].color = color;\n        KViewer.iterateMedViewers(function(viewer)\n        {\n            for (var k = 0; k < viewer.ROIs.length; k++)\n            {\n                if(viewer.ROIs[k].roi.fileID == id)\n                {\n                    // call the individual color selectors of the representations\n                    // these will also take care of 3D objects\n                    //viewer.ROIs[k].$colselector.color_response(color)\n                    viewer.ROIs[k].color = color;\n                    if(viewer.ROIs[k].refSurfView != undefined)\n                    {\n                        viewer.ROIs[k].refSurfView.color = viewer.ROIs[k].color;\n                        viewer.gl.setSurfColor(viewer.ROIs[k].refSurfView);\n                    }\n                    if (viewer.ROIs[k].$colselector)\n                        viewer.ROIs[k].$colselector.updateColor();\n                    viewer.drawSlice({\n                    mosaicdraw: true\n                    });\n                }\n            }\n        });\n\n    }\n\n    /***************************************************************************************\n    * toggle ROI painting (remember last selected one)\n    ****************************************************************************************/\n    that.lastCurrentROIID = undefined;\n    that.toggleCurrentROI = function()\n    {\n        if(currentROI)\n        {\n            signalhandler.send("updateImage",{id: currentROI.fileID,no3d:true});\n            that.lastCurrentROIID = currentROI.fileID;\n            that.makeCurrentGlobal(currentROI.fileID);\n        }\n        else\n        {\n            that.makeCurrentGlobal(that.lastCurrentROIID)\n            document.body.dispatchEvent(new Event(\'mousemove\')); // show pen again\n            that.lastCurrentROIID = undefined;\n        }\n    }\n\n\n    /***************************************************************************************\n    * make roi current in all viewports\n    ****************************************************************************************/\n    that.makeCurrentGlobal = function(id)\n    {\n        if (currentROI == that.ROIs[id]) // same id again, so toggle\n        {\n            currentROI = undefined;\n            id = undefined\n        }\n        else\n        {\n            currentROI = that.ROIs[id];\n        }\n        KViewer.iterateMedViewers(function(viewer)\n        {\n            viewer.currentROI = undefined;\n            // enable haircross controls (hover and mouse events ...) to be sure\n            //viewer.toggleHairCrossControls( true );\n\n            master.roiTool.hidePen(viewer);\n\n            for (var k = 0; k < viewer.ROIs.length; k++)\n            {\n                if(viewer.ROIs[k].$currentpickerdiv)\n                    viewer.ROIs[k].$currentpickerdiv.removeClass("current");\n                viewer.ROIs[k].isCurrent = false;\n                if (viewer.ROIs[k].roi == currentROI)\n                {\n                    if( viewer.ROIs[k].$currentpickerdiv )\n                        viewer.ROIs[k].$currentpickerdiv.addClass("current");\n\n                    viewer.ROIs[k].isCurrent = true;\n                    viewer.currentROI = viewer.ROIs[k].roi;\n                    // hide or disable the haircross controls\n                    viewer.toggleHairCrossControls( false );\n\n                }\n            }\n        });\n        $table.find("tr").removeClass(\'selected\');\n        $table.find(".fa-pencil-square-o").removeClass("selected");\n        var $row = $table.find("tr[id=\'KROI_" + id + "\']");\n        $row.addClass(\'selected\');\n        $row.find(".fa-pencil-square-o").addClass("selected");\n        checkForAnyActiveRoi();\n        if (id == undefined)\n            that.roiPanel.disable();\n        else\n            that.roiPanel.enable();\n        that.roiPanel.update();\n    }\n\n    that.getCurrentGlobal = function()\n    {\n        return currentROI;\n    }\n\n\n    that.customToggle = function(forcestate)\n    {\n        if (that.enabled)\n        {\n            1\n        }\n        else\n        {\n            that.roiPanel.hide();\n            // deselect any active ROI\n            if(currentROI)\n                that.makeCurrentGlobal(currentROI.fileID)\n        }\n    }\n\n    var roiPanel = that.roiPanel = new KRoiPanel(that);\n\n    that.getState = roiPanel.getState;\n    that.setState = roiPanel.setState;\n\n    // do we need this because of tool proxy ...?\n    //if(state.tools && state.tools.roiTool)\n        //that.setState(state.tools.roiTool);\n\n    // return the roi tool\n    return that;\n}\n\n\n\n// ======================================================================================\n// ======================================================================================\n// ============= roi image proc functions\n// ======================================================================================\n// ======================================================================================\n\nfunction cropConnectedComponent2(fobj,fobj2,p,t_offset)\n{\n\n    //var cropped  = KViewer.dataManager.cloneAsROI(fobj.fileID,fobj.filename + "cropped",undefined);\n    //cropped = cropped[0];\n    p = math.multiply(math.inv(fobj.content.edges), p);\n    p = math.round(p._data);\n\n    var data = fobj.content.data;\n    var sz = fobj.content.sizes;\n\n    var w = sz[0];\n    var wh = sz[0] * sz[1];\n    var whd = wh * sz[2];\n\n    var tmp = new Uint8Array(whd);\n\n    var offs = 0;\n    if (fobj.content.currentTimePoint != undefined)\n    {\n        offs = whd*fobj.content.currentTimePoint.t;\n        if (t_offset != undefined)\n            offs = whd*t_offset;\n    }\n\n    function findseed()\n    {\n        for (var n = 0; n < 3; n++)\n            for (var x = -n; x < n; x++)\n                for (var y = -n; y < n; y++)\n                {\n                    a = x + p[0];\n                    b = y + p[1];\n                    c = n + p[2];\n                    if (data[a + w * b + wh * c + offs] > 0.5)\n                        return [a, b, c];\n                    a = x + p[0];\n                    b = y + p[1];\n                    c = -n + p[2];\n                    if (data[a + w * b + wh * c + offs] > 0.5)\n                        return [a, b, c];\n\n                    a = x + p[0];\n                    b = n + p[1];\n                    c = y + p[2];\n                    if (data[a + w * b + wh * c + offs] > 0.5)\n                        return [a, b, c];\n                    a = x + p[0];\n                    b = -n + p[1];\n                    c = y + p[2];\n                    if (data[a + w * b + wh * c + offs] > 0.5)\n                        return [a, b, c];\n\n                    a = n + p[0];\n                    b = x + p[1];\n                    c = y + p[2];\n                    if (data[a + w * b + wh * c + offs] > 0.5)\n                        return [a, b, c];\n                    a = -n + p[0];\n                    b = x + p[1];\n                    c = y + p[2];\n                    if (data[a + w * b + wh * c + offs] > 0.5)\n                        return [a, b, c];\n                }\n    }\n    p = findseed();\n\n\n\n    var data_ = new Uint8Array(fobj.content.buffer,fobj.content.hdroffset+offs);\n\n        \n    if (p == undefined)\n        return []\n\n    var changedPoints = floodfill(data_, tmp, fobj.content.sizes, p, 1);\n    if (fobj2 == "keep")\n    {\n        var cp = [];\n        for (var k = 0; k < whd; k++)\n        {\n            if (tmp[k] >=0.5)\n                fobj.content.data[k+offs] = 1;\n            else\n            {\n               if (fobj.content.data[k+offs]>0)\n                 cp.push(k+offs);\n               fobj.content.data[k+offs] = 0;\n            }\n        }\n        return cp;            \n    }\n    else\n    {    \n        var s;\n        if (fobj2 != undefined)\n            s = function(k) {fobj.content.data[k+offs]=0;fobj2.content.data[k+offs]=1;}\n        else\n            s = function(k) {fobj.content.data[k+offs]=0;}\n        for (var k = 0; k < whd; k++)\n            if (tmp[k]> 0.5)\n              s(k);\n        for (var k = 0; k < changedPoints.length;k++)\n            changedPoints[k] += offs;\n        return changedPoints;\n    }\n\n}\n\n\n\nfunction floodfill(data, vol, size, seed, v)\n{\n    var mystacksize = size[0] * size[1] * size[2];\n    var mystack = new Uint32Array(mystacksize);\n    var changedPoints = [];\n    var cnt = 0;\n    function push(x)\n    {\n        if (cnt < mystacksize)\n        {\n            mystack[cnt] = x;\n            vol[x] = 1;\n            changedPoints.push(x);\n            cnt++;\n        }\n\n\n    }\n    function pop()\n    {\n        cnt--;\n        return mystack[cnt];\n    }\n\n    if (v == undefined)\n        v = 0;\n\n    var w = size[0];\n    var h = size[1];\n    var wh = size[0] * size[1];\n    var whd = size[0] * size[1] * size[2];\n\n    push(seed[0] + w * seed[1] + wh * seed[2]);\n\n    function comp(a,b)\n    {\n        return (a>0 && b>0) | (a==b);\n    }\n\n\n    while (cnt > 0)\n    {\n\n        var idx = pop();\n        if (idx >= 0 & idx < whd)\n        {\n            if (comp(v,data[idx + 1]) & vol[idx + 1] == 0)\n                push(idx + 1);\n            if (comp(v,data[idx - 1]) & vol[idx - 1] == 0)\n                push(idx - 1);\n            if (comp(v,data[idx + w]) & vol[idx + w] == 0)\n                push(idx + w);\n            if (comp(v,data[idx - w]) & vol[idx - w] == 0)\n                push(idx - w);\n            if (comp(v,data[idx + wh]) & vol[idx + wh] == 0)\n                push(idx + wh);\n            if (comp(v,data[idx - wh]) & vol[idx - wh] == 0)\n                push(idx - wh);\n        }\n\n    }\n\n    return changedPoints;\n\n\n}\n\n\n\nregionGrow.changedPoints = [];\nregionGrow.currentStacksize = 0;\nregionGrow.currentStack = undefined;\n\nfunction regionGrow(contrast, vol, A, B ,size, seed,valtoset, clim, restrictedToPen,\n         radiusx, radiusy, radiusz, sx2, sy2, sz2, r2,callback, offset,offset_target)\n{\n    if (offset == undefined)\n        offset = 0;\n    if (offset_target == undefined)\n        offset_target = 0;\n\n    if (valtoset == 1)\n        valtoset = Math.floor(Math.random()*250)+1;\n\n    if (regionGrow.timeout != -1)\n    {\n        clearTimeout(regionGrow.timeout);\n        regionGrow.timeout = -1;\n    }\n\n    for (var k = 0; k < regionGrow.changedPoints.length;k++)\n            vol[regionGrow.changedPoints[k]] = 0;\n\n    regionGrow.changedPoints = [];\n\n    var changedPoints = regionGrow.changedPoints;\n\n\n    var mystacksize = size[0] * size[1] * size[2];\n    if (mystacksize > regionGrow.currentStacksize)\n        {\n            var mxst =50000000;\n            if (mystacksize>mxst)\n                mystacksize = mxst;\n            regionGrow.currentStack = new Uint32Array(mystacksize );\n            regionGrow.currentStacksize = mystacksize;\n\n        }\n\n    var mystack = regionGrow.currentStack;\n\n    var w = size[0];\n    var h = size[1];\n    var d = size[2];\n    var wh = size[0] * size[1];\n    var whd = size[0] * size[1] * size[2];\n\n\n    offset = offset * whd;\n    offset_target = offset_target * whd;\n\n    var cnt = 0;\n\n    //var data = contrast.data;\n    if (isIdentity(A))\n    {\n        if( contrast.datascaling.id )\n            var data = function(idx) { return  contrast.data[idx + offset] ; }\n        else\n            var data = function(idx) { return  contrast.datascaling.ie( contrast.data[idx + offset] ); }\n    }\n    else\n    {\n        if( contrast.datascaling.id )\n            var data = function(idx) {\n                var x = idx%w;\n                var y = Math.floor(idx/w)%h;\n                var z = Math.floor(idx/wh)%d;\n                return trilinInterp(contrast, x,y,z, A, offset);\n            }\n        else\n            var data = function(idx) {\n                var x = idx%w;\n                var y = Math.floor(idx/w)%h;\n                var z = Math.floor(idx/wh)%d;\n                return  contrast.datascaling.ie(trilinInterp(contrast, x,y,z, A, offset));\n            }\n\n    }\n\n\n\n    function push(x)\n    {\n        if (cnt < mystacksize)\n        {\n            mystack[cnt] = x;\n            if (valtoset > 0 && vol[x] == 0)\n                changedPoints.push(x);\n            vol[x+offset_target] = valtoset;\n            cnt++;\n        }\n    }\n    function pop()\n    {\n        cnt--;\n        return mystack[cnt];\n    }\n\n\n\n    var restriction = function() {\n        return true\n    }\n    ;\n    if (restrictedToPen)\n    {\n      if (isIdentity(B))\n      {\n        restriction = function(idx)\n        {\n            var x = math.floor(math.abs(idx % w - seed[0]));\n            var y = math.floor(math.abs(idx / w % h - seed[1]));\n            var z = math.floor(math.abs(idx / wh - seed[2]));\n            return x <= radiusx && y <= radiusy && z <= radiusz && x * x * sx2 + y * y * sy2 + z * z * sz2 < r2;\n        }\n      }\n      else\n      {\n        restriction = function(idx)\n        {\n            var x_ = (idx % w ) -seed[0];\n            var y_ = (idx / w % h ) -seed[1];\n            var z_ = (idx / wh ) -seed[2];\n            var x = math.floor(math.abs(B[0][0]*x_ + B[0][1]*y_ + B[0][2]*z_ ));\n            var y = math.floor(math.abs(B[1][0]*x_ + B[1][1]*y_ + B[1][2]*z_ ));\n            var z = math.floor(math.abs(B[2][0]*x_ + B[2][1]*y_ + B[2][2]*z_ ));\n\n\n            return x <= radiusx && y <= radiusy && z <= radiusz && x * x * sx2 + y * y * sy2 + z * z * sz2 < r2;\n\n        }\n      }\n    }\n\n\n\n\n\n\n\n\n    var t = 1;\n    if (contrast.sizes.length > 3)\n        t = contrast.sizes[3];\n\n\n    var v;\n    var trans;\n    var e;\n\n    if (0) //t > 1)\n    {\n\n        function trans(a)\n        {\n            a = Math.abs((a - clim[0])) / (clim[1] - clim[0]);\n            return a;\n        }\n\n        var norm = 0;\n        v = [];\n        for (var k = 0; k < t; k++)\n        {\n\n            v[k] = ( data( seed[0] + w * seed[1] + wh * seed[2] + whd * k ) ) ;\n            norm += v[k] * v[k];\n        }\n        norm = math.sqrt(norm);\n        for (var k = 0; k < t; k++)\n            v[k] /= 0.0000001 + norm;\n\n        var sim_thres = 2.5 - regionGrow.helper.simscaling / 100;\n        if (sim_thres < 0)\n            sim_thres = 0;\n\n//        sim_thres = 1-Math.abs(regionGrow.helper.simscaling/800);\n\n        sim_thres = 0.99;\n\n        e = function(idx) {\n            if (!restriction(idx))\n                return false;\n            var d = 0;\n            var z = 0;\n            for (var k = 0; k < t; k++)\n            {\n                var d_ = data( idx + whd * k ) ;\n                if (d_ != undefined)\n                {\n                    var a = (d_);\n                    d += a * v[k];\n                    z += a * a;\n                }\n                else\n                    return false;\n            }\n            return ( d/Math.sqrt(z) >= sim_thres) ;\n\n        }\n    }\n    else\n    {\n        if (clim.threshold != undefined)\n            trans = function(a) { return (a>clim.threshold)?1:0;  }\n        else if (clim.threshold_higher != undefined && clim.threshold_lower != undefined)\n            trans = function(a) { return (a>clim.threshold_higher & a<clim.threshold_lower  )?1:0;  }\n        else if (clim.threshold_higher != undefined)\n            trans = function(a) { return (a>clim.threshold_higher)?1:0;  }\n        else if (clim.threshold_lower != undefined)\n            trans = function(a) { return (a<clim.threshold_lower)?1:0;  }\n        else\n            trans = function(a)\n            {\n                a = (a - clim[0]) / (clim[1] - clim[0]);\n                if (a > 1)\n                    a = 1;\n                if (a < 0)\n                    a = 0;\n                return a;\n            }\n\n        if (clim.threshold  != undefined)\n            v = 1;\n        else\n            v = trans(data (seed[0] + w * seed[1] + wh * seed[2] ));\n\n        var dist_thres = Math.exp(regionGrow.helper.simscaling*0.01)*0.2-0.1;\n       // var dist_thres = Math.abs(regionGrow.helper.simscaling*0.001);\n        if (dist_thres < 0)\n            dist_thres = 0;\n\n        if (clim.threshold_higher != undefined || clim.threshold_lower != undefined )\n            e = function(idx) {\n                if (!restriction(idx))\n                    return false;\n                if (data(idx) != undefined)\n                    return trans(data(idx));\n                else\n                    return false;\n            }\n        else\n            e = function(idx) {\n                if (!restriction(idx))\n                    return false;\n\n                if (data(idx) != undefined)\n                {\n                    var a = trans(data(idx));\n\n                    return math.abs(a - v) <= dist_thres;\n                }\n                else\n                    return false;\n            }\n    }\n\n\n    var startidx = seed[0] + w * seed[1] + wh * seed[2];\n\n    if (!e(startidx) ) //| vol[startidx] > 0)\n    {\n        callback(changedPoints);\n        return;\n    }\n\n\n    push(startidx);\n\n    var iteration = 0;\n    var maxit = 1024;\n\n    doit();\n\n    function doit()\n    {\n        while (cnt > 0 && iteration < maxit)\n        {\n            var idx = pop();\n            if (idx >= 0 & idx < whd)\n            {\n                if (e(idx + 1, idx) & vol[idx + 1] != valtoset)\n                    push(idx + 1);\n                if (e(idx - 1, idx) & vol[idx - 1] != valtoset)\n                    push(idx - 1);\n                if (e(idx + w, idx) & vol[idx + w] != valtoset)\n                    push(idx + w);\n                if (e(idx - w, idx) & vol[idx - w] != valtoset)\n                    push(idx - w);\n                if (e(idx + wh, idx) & vol[idx + wh] != valtoset)\n                    push(idx + wh);\n                if (e(idx - wh, idx) & vol[idx - wh] != valtoset)\n                    push(idx - wh);\n            }\n            iteration++;\n        }\n\n\n        iteration = 0;\n\n        if (cnt > 0)\n            regionGrow.timeout = setTimeout(doit,0);\n        else\n        {\n            regionGrow.timeout = -1;\n            if (restrictedToPen)\n               regionGrow.changedPoints = [];\n            callback(changedPoints);\n        }\n\n        //callback(changedPoints)\n\n    }\n\n\n\n}\n\nfunction removesalt(data, size)\n{\n    var res = bwconncomp(data, size , function (x) { return x>0;},  removesalt.threshold , data)\n    return res.changedPoints;\n}\nremovesalt.threshold = 100;\n\n\nfunction createConnCompAnalysis(fobj)\n{\n   var conncompdesc = \'\';\n\n   if (fobj.ccanalysis == undefined)\n   {\n       fobj.ccanalysis = {\n       enabled:true,\n       inprogress:0,\n       update: function()\n       {\n            if (this.cid != undefined)\n            {\n                clearTimeout(this.cid);\n                fobj.ccanalysis.inprogress--;\n            }\n            fobj.ccanalysis.inprogress++;\n            this.cid = setTimeout( function()\n            {\n                this.cid = undefined;\n                bwconncomp_worker(fobj.content.data, fobj.content.sizes,1,function (res)\n                {\n                    fobj.ccanalysis.inprogress--;\n                    fobj.ccanalysis.cc = res;\n                    if (fobj.ccanalysis.persistent == undefined)\n                    {\n                        fobj.ccanalysis.persistent = [];\n                        fobj.ccanalysis.persistent.cnt = 0;\n                        for (var k in res.centerOfGrav)\n                        {\n                            var v = res.centerOfGrav[k];\n                            var p = math.round(math.multiply(fobj.content.edges,[v[0],v[1],v[2],1])._data);\n                            fobj.ccanalysis.persistent[fobj.ccanalysis.persistent.cnt++] = {name: conncompdesc + p[0] + "," + p[1] + "," +p[2], idx:k , cog:v};\n                        }\n\n                    }\n                    else\n                    {\n                        for (var j=0;j <fobj.ccanalysis.persistent.length;j++)\n                            fobj.ccanalysis.persistent[j].idx = undefined;\n                        for (var j=0;j <fobj.ccanalysis.persistent.length;j++)\n                        {\n                            var y = fobj.ccanalysis.persistent[j].cog;\n                            var min_d = 999999;\n                            var min_idx = -1;\n                            for (var k in res.centerOfGrav)\n                            {\n                                if (!res.centerOfGrav[k].assigned)\n                                {\n                                    var x = res.centerOfGrav[k];\n                                    var d =  Math.abs(x[0]-y[0])+Math.abs(x[1]-y[1])+Math.abs(x[2]-y[2]);\n                                    if (d < min_d && d < 10)\n                                    {\n                                        min_idx = k;\n                                        min_d = d;\n                                    }\n                                }\n                            }\n                            if (min_idx != -1)\n                            {\n                                res.centerOfGrav[min_idx].assigned = true;\n                                fobj.ccanalysis.persistent[j].idx = min_idx;\n                            }\n                        }\n                        for (var k in res.centerOfGrav)\n                        {\n                            if (!res.centerOfGrav[k].assigned)\n                            {\n                               var v = res.centerOfGrav[k];\n                               var p = math.round(math.multiply(fobj.content.edges,[v[0],v[1],v[2],1])._data);\n\n                               fobj.ccanalysis.persistent.push({name:  p[0] + "," + p[1] + "," +p[2], idx:k , cog:res.centerOfGrav[k]} )\n                               fobj.ccanalysis.persistent.cnt++\n                            }\n                        }\n                        for (var j=0; j < fobj.ccanalysis.persistent.length;j++)\n                        {\n                           if (fobj.ccanalysis.persistent[j] == undefined || fobj.ccanalysis.persistent[j].idx == undefined)\n                           {\n                               fobj.ccanalysis.persistent.splice(j,1); j--;\n                           }\n                        }\n\n                    }\n\n                    // sort the list by z,y,x\n                    function sortfun(a,b,idx){ return (a.cog[idx] - b.cog[idx]);}\n                    fobj.ccanalysis.persistent\n                        .sort(function(a,b){ return sortfun(a,b,0) ; })\n                        .sort(function(a,b){ return sortfun(a,b,1) ; })\n                        .sort(function(a,b){ return sortfun(a,b,2) ; });\n\n                    if (fobj.ccanalysis.inprogress <= 0)\n                    {\n                        KViewer.roiTool.update();\n                        fobj.ccanalysis.inprogress = 0;\n                    }\n                    this.cid = undefined;\n                },fobj)\n\n            },250);\n\n       } };\n\n       fobj.ccanalysis.update();\n\n\n\n   }\n\n}\n\nfunction splatter(fobj)\n{\n    var res = bwconncomp(fobj.content.data, fobj.content.sizes , function (x) { return x>0;},1);\n\n    var sobj = []\n    for (var k  in res.clusterSize)\n        sobj.push({idx:k,sz:res.clusterSize[k]});\n    sobj.sort(function(x,y) { return y.sz-x.sz;});\n    alertify.prompt("Keep the N largest out of " + sobj.length + " pieces ", function(e, str) {\n            if (e)\n            {\n                fobj;\n                var num = parseInt(str);\n                for (var k = 0; k < num & k < sobj.length; k++)\n                {\n                    var idx = parseInt(sobj[k].idx);\n                    var nfobj = KViewer.dataManager.cloneAsROI(fobj.fileID, fobj.filename + "_" + k)[0];\n                    var dlen = nfobj.content.data.length;\n                    res;\n                    for (var j = 0; j < dlen;j++)\n                    {\n                        if (res.labels[j] == idx)\n                            nfobj.content.data[j] = 1;\n                    }\n                    KViewer.roiTool.ROIs[nfobj.fileID] = nfobj;\n                    nfobj.color = Object.getOwnPropertyNames(KViewer.roiTool.ROIs).length % 5;\n\n\n                }\n                KViewer.roiTool.update();\n\n            }\n\n        },"5");\n\n}\n\n\n\nfunction bwconncomp_worker(data, size, clustthres, done, persistent)\n{\n    var worker\n    if (persistent)\n        worker = persistent.worker;\n    \n\n \tworker = executeImageWorker({func:\'conncomp\',\n \t    data:data,\n \t    size:size,\n \t    clustthres:clustthres,keepOpen:persistent!=undefined }, \t\n \t    [],\n \t \tfunction(e)\n \t \t{\n\t\t\t//progress(e);\n \t \t}\n \t \t,\n \t \tfunction(e)\n \t \t{\n\t\t\tdone(e.execObj);\t\t\n \t \t},\n \t \tworker\n \t \t);\n \t \n \tif (persistent != undefined)\n \t  persistent.worker = worker;\n\n\n \treturn worker;\n \n}\n\n\n/* bwconncomp - perform a connected component analsis\ninput: data - mask array or sontinous array to decomposed\n       size - size of the array [w,h,d]\n       comp - function defining whether data[i] is on or off, e.g. function (x) { return x>0;} for masks\n       clustthres - only clusters above this threshold are considered (number of voxels)\n       target - optional, array of same size as data, if given, all values that do not belong to the labeling are set to zero in target.\noutput: obj = {labels,clusterSize , changedPoints}\n       labels - label array of same size as data\n       clusterSize - sizes array of clusters\n       changedPoints - if target given the voxels that switched to zero */\n\nfunction bwconncomp(data, size, comp, clustthres, target)\n{\n\n    var changedPoints = [];\n    var labels = new Uint32Array(data);\n    var w = size[0];\n    var h = size[1];\n    var d = size[2];\n    var wh = size[0] * size[1];\n    var whd = size[0] * size[1] * size[2];\n    labels.fill(0);\n\n    var map = {}\n\n    var cur_label = 2147483648;\n    for (var z = 0; z < size[2]; z++)\n        for (var y = 0; y < size[1]; y++)\n            for (var x = 0; x < size[0]; x++)\n            {\n                var idx = x+w*y+wh*z;\n                if (comp(data[idx]))\n                {\n                    var l = 0\n                    if (labels[idx - 1] == 0 && labels[idx - w] == 0 && labels[idx - wh] == 0)\n                    {\n                        labels[idx] = cur_label--;\n                        continue;\n                    }\n\n\n                    mmi(1,w,wh)\n                    mmi(w,1,wh)\n                    mmi(wh,1,w)\n\n                    function mmi(a,b,c)\n                    {\n                        if (labels[idx - a] >= labels[idx - b]  && labels[idx - a] >= labels[idx - c])\n                        {\n                            l = labels[idx - a];\n                            labels[idx] = l;\n                            if (labels[idx - b] > 0 && l != labels[idx - b])\n                            {\n                                map[labels[idx - b]] = l;\n                                labels[idx - b] = l;\n                            }\n                            if (labels[idx - c] > 0 && l != labels[idx - c])\n                            {\n                                map[labels[idx - c]] = l;\n                                labels[idx - c] = l;\n                            }\n                            return true;\n                        }\n                    }\n\n\n\n                }\n            }\n\n            var keys = Object.keys(map);\n            function look(a)\n            {\n                if (map[a] == undefined)\n                    return a;\n                else\n                    return look(map[a]);\n            }\n            for (var k = 0; k < keys.length;k++)\n                map[keys[k]] = look(keys[k]);\n\n            var clustsize = {};\n            var cog = {};\n            for (var z = 0; z < whd; z++)\n                if (comp(data[z]))\n                {\n                    var k = map[labels[z]];\n                    if (k == undefined)\n                        k = labels[z];\n                    labels[z] = k;\n                    if (clustsize[k] == undefined)\n                    {\n                        clustsize[k] = 1;\n                        cog[k] = [z%w,Math.floor(z/w)%h,Math.floor(z/wh)%d]\n                    }\n                    else\n                    {\n                        clustsize[k]++;\n                        cog[k][0] += z%w\n                        cog[k][1] += Math.floor(z/w)%h\n                        cog[k][2] += Math.floor(z/wh)%d;\n                    }\n\n                }\n\n            var clusts = Object.keys(clustsize);\n            var indic = {};\n            var clusterSize = {};\n            var centerOfGrav ={}\n            var cnum = 1;\n            for (var k = 0 ; k < clusts.length;k++)\n            {\n                if (clustsize[clusts[k]] > clustthres)\n                {\n\n                    clusterSize[cnum] = clustsize[clusts[k]];\n                    var v = [ cog[clusts[k]][0]/clustsize[clusts[k]],\n                              cog[clusts[k]][1]/clustsize[clusts[k]],\n                              cog[clusts[k]][2]/clustsize[clusts[k]] ];\n                    centerOfGrav[cnum] = v;\n                    indic[clusts[k]] = cnum;\n                    cnum++;\n                }\n            }\n\n\n            for (var z = 0; z < whd; z++)\n                if (comp(data[z]))\n                {\n\n                    if (!indic[labels[z]])\n                    {\n                        if (target != undefined)\n                            target[z] = 0;\n                        labels[z] = 0;\n                        changedPoints.push(z);\n                    }\n                    else\n                        labels[z] = indic[labels[z]];\n                }\n                else\n                    if (target != undefined)\n                        target[z] = 0;\n\n\n           return {centerOfGrav:centerOfGrav,changedPoints:changedPoints,labels:labels,clusterSize:clusterSize};\n\n\n}\n\nfunction dilate(data, size)\n{\n\n    var changedPoints = [];\n    var tmp = new Uint8Array(data);\n    var w = size[0];\n    var h = size[1];\n    var wh = size[0] * size[1];\n    var whd = size[0] * size[1] * size[2];\n\n    for (var z = 0; z < size[2]; z++)\n        for (var y = 0; y < size[1]; y++)\n            for (var x = 0; x < size[0]; x++)\n            {\n                var idx = x + w * y + wh * z;\n                if (tmp[idx] > 0 | tmp[idx + 1] > 0 | tmp[idx - 1] > 0 | tmp[idx + w] > 0 | tmp[idx - w] > 0 | tmp[idx + wh] > 0 | tmp[idx - wh] > 0)\n                {\n                    if (data[idx] == 0)\n                        changedPoints.push(idx);\n                    data[idx] = 1;\n                }\n            }\n    return changedPoints;\n}\n\n\nfunction erode(data, size)\n{\n    var changedPoints = [];\n    var tmp = new Uint8Array(data);\n    var w = size[0];\n    var h = size[1];\n    var wh = size[0] * size[1];\n    var whd = size[0] * size[1] * size[2];\n\n    for (var z = 0; z < size[2]; z++)\n        for (var y = 0; y < size[1]; y++)\n            for (var x = 0; x < size[0]; x++)\n            {\n                var idx = x + w * y + wh * z;\n                if (!(tmp[idx] > 0 & (tmp[idx + 1] > 0 | x == size[0] - 1)\n                & (tmp[idx - 1] > 0 | x == 0)\n                & (tmp[idx + w] > 0 | y == size[1] - 1)\n                & (tmp[idx - w] > 0 | y == 0)\n                & (tmp[idx + wh] > 0 | z == size[2] - 1)\n                & (tmp[idx - wh] > 0 | z == 0)))\n                {\n                    if (data[idx] == 1)\n                        changedPoints.push(idx);\n                    data[idx] = 0;\n                }\n            }\n    return changedPoints;\n\n}\n\n\n\n\n/***************************************************************************************\n* The new Roi panel in the viewport\n****************************************************************************************/\nfunction KRoiPanel(parent)\n{\n\n    var that = new Object();\n\n    var $target = parent.$panelcontainer;\n    $target.empty();\n\n    var $container = $("<div class=\'roiTool_panel\'></div>");\n    that.$container = $container;\n\n    var roiTool = parent;\n    $container.appendTo($target);\n\n    that.show = function()\n    {\n        $container.show();\n        $(\'.roiTool_svg\').show();\n    }\n\n\n    function getParentViewer()\n    {\n        // get the parent from current location of the panel\n        var off = that.$container.offset();\n        var foundViewer;\n\n        for (var v = 0; v < KViewer.viewports.length; v++)\n        {\n            if (KViewer.viewports[v] != undefined)\n            {\n                var viewer = KViewer.viewports[v].getCurrentViewer();\n                if (viewer == undefined)\n                    continue;\n                var $c = KViewer.viewports[v].$container;\n                var off2 = $c.offset();\n\n                if (off.left < off2.left + $c.width() & off.left > off2.left & off.top < off2.top + $c.height() & off.top > off2.top)\n                {\n                    foundViewer = viewer;\n                    break;\n                }\n            }\n        }\n\n        // if over nobody, try to take the first match\n        if (foundViewer == undefined)\n            for (var v = 0; v < KViewer.viewports.length; v++)\n            {\n                var viewer = KViewer.viewports[v].getCurrentViewer();\n                if (viewer !== undefined)\n                {\n                    foundViewer = viewer;\n                    break;\n                }\n\n            }\n\n        return foundViewer;\n    }\n    that.getParentViewer = getParentViewer;\n\n\n    that.hide = function()\n    {\n        $(\'.roiTool_svg\').hide();\n    }\n\n    that.enabled = false;\n    that.toggle = function()\n    {\n        if (that.enabled)\n            that.disable();\n        else\n            that.enable();\n    }\n\n    that.enable = function()\n    {\n        that.enabled = true;\n        roiTool.togglePen(true);\n        $container.find(".roiTool_panel_flex").removeClass("inactive");\n        $penActiveBtn.addClass(\'KViewPort_tool_enabled\')\n        $drawingEnabledSign.show();\n    }\n    that.disable = function()\n    {\n        that.enabled = false;\n        roiTool.togglePen(false);\n        //$container.find(".roiTool_panel_flex").addClass("inactive");\n        //$history.addClass("inactive");\n        $penActiveBtn.removeClass(\'KViewPort_tool_enabled\')\n        $drawingEnabledSign.hide();\n\n    }\n\n\n\n    // ----------- the "create new roi row""\n    var $fileRow = $("<div style=\'white-space:nowrap\' class=\'roiTool_panel_flex persistent\'></div>").appendTo($container);\n    var $newEmptyRoi = $("<a class=\'KViewPort_tool\' ><span style=\'\'>New ROI</span></a>").appendTooltip("createemptyroi").click(createNewRoiButton).appendTo($fileRow);\n    var $drawingEnabledSign = that.$drawingEnabledSign =  $("<a class=\'\' style=\'background:darkred; width:15px; height:15px;margin-left:5px; border-radius:10px;\' ><span style=\'\'></span></a>").appendTo($fileRow).hide();\n\n    //var $newnameWrap = $("<span id=\'roi_default_names_wrap\'   class=\' persistent\'></span>").appendTo($fileRow);\n\n    var $penActiveBtn = $("<i class=\'KViewPort_tool  KViewPort_tool_enabled fa fa-power-off\'></i>").click(function() {\n        that.toggle();\n    }).appendTooltip("enable/disable roi drawing");\n    //$penActiveBtn.hide();\n\n    //$fileRow.append($penActiveBtn);\n    //$fileRow.append($("<i class=\'flexspacer\'></i>"));\n\n\n    function createNewRoiButton()\n    {\n        if(state.autoROI && state.autoROI.enable)\n        {\n            var rlist = state.autoROI.roiList;\n            for(var k=0; k<rlist.length; k++ )\n            {\n                var roiname = rlist[k].name;\n                var vpid = rlist[k].viewportID;\n                var medViewer = roiTool.master.viewports[vpid].medViewer;\n                if(medViewer != undefined && medViewer.nii !=undefined)\n                {\n                    var fileID = KViewer.dataManager.getFileIdByNiiFile( medViewer.niiOriginal );\n                    roiTool.createRoisFromFileID(fileID, undefined, medViewer, roiname);\n                }\n\n            }\n        }\n        else\n        {\n            var niftis = {};\n            roiTool.master.iterateMedViewers(function(medViewer)\n            {\n                if (medViewer.nii !== undefined && !medViewer.nii.dummy)\n                {\n                    //var key = "" + medViewer.nii.edges._data.toString() + medViewer.nii.voxSize.toString();\n                    var key = "" + medViewer.niiOriginal.edges._data.toString() + medViewer.niiOriginal.voxSize.toString();\n                    niftis[key] = medViewer.niiOriginal;\n                }\n            });\n            var list = Object.getOwnPropertyNames(niftis);\n            //console.log(list);\n            if (list.length == 0)\n            {\n                alertify.alert(\'There are currently no images loaded in any viewport. <br>I need one as a template.\')\n                return false;\n            }\n            else if (list.length > 1)\n            {\n                alertify.alert(\'There are images with different geometries / sizes in your viewports. <br> Please drag your desired template image onto the ROI panel to create a new roi.\')\n                return false;\n            }\n            else\n            {\n                var fileID = KViewer.dataManager.getFileIdByNiiFile(niftis[list[0]]);\n                roiTool.createRoisFromFileID(fileID);\n            }\n        }\n    }\n\n\n    /***************************************************************************************\n    the autoROIcreateor dialog\n    ****************************************************************************************/\n    $("<i class=\'flexspacer\'></i>").appendTo($fileRow);\n    var $autoROIDialog = $("<a class=\'KViewPort_tool\' "+ ((state.autoROI != undefined && state.autoROI.enable)?\'background:green\':\'\')  +"\' ><span> <i class = \'fa fa-car\'></i> </span></a>").appendTooltip("autoROIcreator").click(autoROIDialog).appendTo($fileRow);\n\n    var autoROIForm =\n    {\n        name \t\t: "autoROI",\n        layout:\n        [\n             {name:"enable"\t  , type: \'check\',     defaultval:false, class:"autoloaderitem" }\n            ,{name:"roiList" , type: \'formarray\', title:\'\', createbutton:"add new rule for a ROI",\n                layout:[\n\n                     {name:"name" , type: \'input\', defaultval:"untitled"  , title:\'name\'}\n                    ,{name:"viewportID" , type: \'option\', defaultval:0 , title:\'viewport ID\', choices: [0,1,2,3,4,5]}\n\n                    ]\n            }\n        ]\n    }\n\n    if(state.autoROI == undefined)\n        state.autoROI = KForm.getFormContent(autoROIForm, {} );\n\n\n    function autoROIDialog(args)\n    {\n        if($("#autoROIDialog").length > 0 )\n            return false;\n        var that = new dialog_generic();\n        that.$frame.width(500).height(600);\n        that.$frame.css({left:200, top:150} );\n        that.$frame .css(\'z-index\', 100000);\n        that.$frame.show();\n        that.$menu.append("<li>autoROI creation</li>");\n        that.$frame.attr(\'id\', \'autoROIDialog\');\n\n        that.deleteonclose = true;\n\n        var helptext = "With this feature, multiple ROIs will be created at one click on the \'New ROI\' button. Use comma separated list to create multiple ROIs per viewport."\n        var $topbar = $("<div class=\'\' style=\'font-size:16px; padding:10px; background:hsl(50,50%,40%);\'>" + helptext + "</div>").appendTo(that.$container);\n\n        var $middlebar = $("<div class=\'\' style=\'\'></div>").appendTo(that.$container);\n        var $searchbox = $("<div class=\'\' style=\'\'></div>").appendTo($middlebar);\n\n        var $toolbar = $("<div class=\'modernbuttongroup\' ></div>").appendTo($middlebar);\n        //var $startsearch = $("<div class=\'modernbutton small green\'><i style=\'padding:0px\' class=\'fa fa-binoculars\'></i><i style=\'padding:0px;display:none;\' class=\'fa fa-spinner fa-spin\'></i> Start search</div>").appendTo($toolbar).click( submitquery );\n\n\n        var $results   = $("<div class=\'\' style=\'display:flex;flex-direction:column;align-items:center:justify-content:center;padding:20px;\'></div>").appendTo(that.$container);\n\n\n        KForm.createForm(autoROIForm, state.autoROI , $searchbox);\n        $searchbox.find(\'input[type="checkbox"]\').on("change", function(){\n        if($(this).is(\':checked\'))\n             $autoROIDialog.css(\'background\', \'green\')\n        else\n             $autoROIDialog.css(\'background\',\'\');\n\n        }) ;\n\n\n        $searchbox.find(\'input\').attr(\'autocomplete\', \'off\');\n        //$searchbox.find(\'input\').get(0).focus();\n\n        return that;\n    }\n\n\n\n    var $selectRoi = $("<ul class=\'\'></ul>").click();\n    // parent.addAsROIMenu  );\n    // \t$fileRow.append($selectRoi);\n    // \t\tthat.buildRoiSelector = function()\n    // \t\t{\n    // \t\t\t$selectRoi.empty();\n    // \t\t\tvar rlist = Object.keys(roiTool.ROIs);\n    // \t\t\tfor(var k=0; k <rlist.length; k++)\n    // \t\t\t{\n    // \t\t\t\t$selectRoi.append($("<li>"+ roiTool.ROIs[rlist[k]].filename +"<span></span></li>")\n    // \t\t\t\t\t.click( function(ev){ roiTool.ROIs[rlist[k]].fileID } ) );\n    // \t\t\t}\n    // \t\t\t$selectRoi.append($("<li>Create New Roi<span></span></li>")).click(function(ev){getParentViewer().addAsROIMenu(ev); that.buildRoiSelector(); });\n\n    // \t\t}\n    // \tthat.buildRoiSelector();\n\n    // ----------- the history\n    $("<div class=\'roiTool_panel_caption\'></div>").appendTo($container);\n    var $history = $("<div class=\'roiTool_panel_flex\'></div>").appendTo($container);\n    var $stepBack = $("<span class=\'KViewPort_tool\'><i class=\' fa fa-reply\'></i> </span>").appendTooltip("undo").click(function() {\n        roiTool.history.goto(1)\n    });\n    var $stepFwd = $("<span class=\'KViewPort_tool\'><i class=\' fa fa-mail-forward \'></i> </span>").appendTooltip("redo").click(function() {\n        roiTool.history.goto(-1);\n    });\n    //$history.append($stepBack).append($stepFwd);\n    $history.append($("<span>undo</span>")).append($stepBack).append($("<i class=\'flexspacer\'></i><span>redo</span>")).append($stepFwd);\n    // ----------- the pen\n\n    $container.append( $("<div class=\'roiTool_panel_flex\'><span>Size XY</span><i class=\'flexspacer\'></i><span>Size Z</span></div>") );\n\n    var $circlePenRow = $("<div class=\'roiTool_panel_flex\'></div>").appendTo($container);\n    var $inplaneradius = $(" <input type___ = \'number\' min=\'0\' max=\'100\' value=\'" + roiTool.pencil.radius + "\' /> ").on(\'change\', function(ev) {\n        roiTool.pensizechange(ev, "radius")\n    });\n    var $outplaneradius = $(" <input type___ = \'number\' min=\'0\' max=\'100\' value=\'" + roiTool.pencil.radius_z + "\' /> ").on(\'change\', function(ev) {\n        roiTool.pensizechange(ev, "radius_z")\n    });\n    $circlePenRow.append($("<i class=\'flexspacer\'></i>")).append($inplaneradius).append($outplaneradius);\n    that.$inplaneradius = $inplaneradius;\n\n\n\tKMouseSlider( $inplaneradius, {min:0, incrementPerPixel: .1, logScaling:10 });\n\tKMouseSlider( $outplaneradius, {min:0, incrementPerPixel: .1, logScaling:10 });\n\n\n\n    var $thresBtn = $("<i class=\'RoiPen KViewPort_tool fa fa-power-off\'></i>").click(\n    function(ev)\n    {\n        selectPen();\n        setThreshPen(ev)\n    });\n\n    function setThreshPen(ev, tpen)\n    {\n\n        if(tpen!== undefined)\n        {\n            roiTool.threspen = tpen;\n            $thresInput.val( roiTool.pencil.thres_low );\n            $thresInput2.val( roiTool.pencil.thres_high );\n        }\n        else\n        {\n            roiTool.threspen = ( roiTool.threspen + 1) % 3;\n        }\n\n        $thresBtn.removeClass(" KViewPort_tool_enabled fa-power-off fa-arrow-circle-up fa-arrow-circle-down");\n        //$threshPlaceholder.hide();\n\n        if (roiTool.threspen == 0) {\n            $thresBtn.addClass(\'fa-power-off\');\n            //$threshPlaceholder.show();\n            $threshPlaceholder.text(\'disabled\');\n            $threshPenInputRow.slideUp();\n        }\n        else\n        {\n            selectPen()\n            $thresBtn.addClass(\'fa-arrow-circle-up\');\n            $threshPenInputRow.slideDown().css(\'display\', \'\');\n        }\n\n        if (roiTool.threspen == 1) {\n            $thresBtn.addClass(\'fa-arrow-circle-up\');\n            $threshPlaceholder.text(\'unrestricted\');  }\n        if (roiTool.threspen == 2) {\n            roiTool.regionGrowRestric = true;\n            $thresBtn.addClass(\'fa-arrow-circle-down\');\n            $threshPlaceholder.text(\'regiongrow\');  }\n    }\n\n\n    var $thresInput  = $(" <input value=\'" + roiTool.pencil.thres_low + "\' style=\'_width:100%\' /> ").on(\'change\', changeTreshInput).on(\'click\', function(ev) { return false });\n    var $thresInput2 = $(" <input value=\'" + roiTool.pencil.thres_high + "\' style=\'_width:100%\' /> ").on(\'change\', changeTreshInput2).on(\'click\', function(ev) { return false });\n    function changeTreshInput(ev)\n    {\n        var vval = $thresInput.val();\n        if(vval != "climL" & vval != "climR" & vval != "off")\n        {\n            vval = parseFloat(vval);\n        }\n        roiTool.pencil.thres_low = vval;\n        return false;\n    }\n\n    function changeTreshInput2(ev)\n    {\n        var vval = $thresInput2.val();\n        if(vval != "climL" & vval != "climR" & vval != "off")\n        {\n            vval = parseFloat(vval);\n        }\n        roiTool.pencil.thres_high = vval;\n        return false;\n    }\n    var $thresInputWrap = $(" <div> </div> ").append($thresInput);\n    var $thresInputWrap2 = $(" <div> </div> ").append($thresInput2);\n\n    $("<div class=\'roiTool_panel_caption\'>Thresholds</div>").appendTo($container);\n    var $threshPenRow = $("<div class=\'roiTool_panel_flex\'></div>").appendTo($container);\n    var $threshPlaceholder = $("<div class=\'\'>Disabled</div>");\n\n    $threshPenRow.append($thresBtn).append($("<i class=\'flexspacer\'></i>")).append($threshPlaceholder);\n\n    var $threshPenInputRow = $("<div class=\'thresPenInput\' ></div>").appendTo($container);\n    var $thresInputInner = $("<div class=\'roiTool_panel_flex\'></div>").appendTo($threshPenInputRow).append($thresInputWrap).append($thresInputWrap2);\n\n    var $thresInputMenuL = $("<div class=\'threspenclimsel\'\'></div>").appendTo($thresInputWrap)\n        .append( $("<div class=\'threspenclimsel\'\'>off</div>").click(function(){ $thresInput.val(\'off\'); changeTreshInput()}) )\n        .append( $("<div class=\'threspenclimsel\'>climL</div>").click(function(){ $thresInput.val(\'climL\'); changeTreshInput()}) )\n\n    var $thresInputMenuR = $("<div class=\'threspenclimsel\'\'></div>").appendTo($thresInputWrap2)\n        .append( $("<div class=\'threspenclimsel\'>off</div>").click(function(){ $thresInput2.val(\'off\'); changeTreshInput2()}) )\n        .append( $("<div class=\'threspenclimsel\'>climR</div>").click(function(){ $thresInput2.val(\'climR\'); changeTreshInput2()}) )\n    \n\n\tKMouseSlider( $thresInput, {min:-Infinity, max:Infinity, incrementPerPixel: 1 });\n\tKMouseSlider( $thresInput2, {min:-Infinity, max:Infinity, incrementPerPixel: 1 });\n\n    setAutoSelectAllOnFocus($thresInput);\n    setAutoSelectAllOnFocus($thresInput2);\n\n    $threshPenInputRow.hide();\n\n    // ----------- the smart pen\n    $("<div class=\'roiTool_panel_caption\'>Regiongrow</div>").appendTo($container);\n    var $smartPenRow = $("<div class=\'roiTool_panel_flex\'></div>").appendTo($container);\n    var $smartPenBtn = $("<i class=\'RoiPen KViewPort_tool fa fa-magic\'></i>").click(selectPen).appendTooltip("drawonlyonsimilarcolors");\n    var $regionGrowPenBtn = $("<i class=\'RoiPen  KViewPort_tool fa fa-fw fa-map-pin\'></i>").click(selectPen).appendTooltip("regionfillsimilarcolors");\n    var $regionGrowPenBtnRestric = $("<i class=\'RoiPen KViewPort_tool fa fa-fw fa-map-marker\'></i>").click(selectPen).appendTooltip("regionfillwithinpen");\n    // \t   var $tresh =  $(" <input type = \'number\' min=\'0\' max=\'100\' value=\'"+pencil.radius+"\' /> ").on(\'change\', function (ev) { pensizechange(ev,"radius")});\n    // \t   var $direction = $("<i class=\'KViewPort_tool fa fa-arrow-up\'></i>");\n    $smartPenRow.append($smartPenBtn).append($regionGrowPenBtnRestric).append($regionGrowPenBtn).append($("<i class=\'flexspacer\'></i>"));\n    //.append($direction).append($tresh);\n\n\n\n\n    // ----------- the polygon Tool\n    \t$("<div class=\'roiTool_panel_caption\'>Polygon</div>").appendTo($container);\n\tvar $polygonRow   = $("<div class=\'roiTool_panel_flex\'></div>").appendTo($container);\n    //var $polygonPenBtn = $("<i class=\'KViewPort_tool fa fa-openid\'></i>").click(\tfunction() { KMarkerPanel_outline()   } );\n\n    that.polymarkerset     = undefined;\n    roiTool.polyEnabled = 0;\n    var $polygonPenBtn = $("<i class=\'KViewPort_tool fa fa-openid\'></i>").click(\tfunction() {\n        roiTool.polyEnabled = !roiTool.polyEnabled;\n        if(roiTool.polyEnabled)\n        {\n            $polygonPenBtn.addClass(\'KViewPort_tool_enabled\');\n            that.polymarkerset = that.polymarkerset || KMarkerPanel_roiScribble(); \n            if ( that.polymarkerset.markerPanel == undefined)\n                that.polymarkerset.showPanel()\n            that.polymarkerset.markerPanel.$fileRow.hide();\n            that.polymarkerset.markerPanel.$toolsRow.hide();\n            //that.polymarkerset.markerPanel.$close.off("click").click(function(){roiTool.closePolyTool()});\n            that.polymarkerset.markerPanel.$close.off("click").click(function(ev){roiTool.closePolyTool();ev.stopPropagation(); ev.preventDefault(); return false;});\n                /*\n                that.polymarkerset.markerPanel.btns.$locked.hide()\n                that.polymarkerset.markerPanel.btns.$hoverdetails.hide()\n                that.polymarkerset.markerPanel.btns.$showOnAllImages.hide()\n                that.polymarkerset.markerPanel.btns.$defaultradius.hide()\n                */\n                //that.polymarkerset.markerPanel.$toolsRow.hide();\n                //that.polymarkerset.markerPanel.$close.hide();\n                //that.polymarkerset.markerPanel.$scribbleRow.html(helptext)\n            markerProxy.setCurrentSet( that.polymarkerset  );\n        }\n        else\n        {\n            $polygonPenBtn.removeClass(\'KViewPort_tool_enabled\');\n            markerProxy.currentSet = undefined;\n            if ( that.polymarkerset.markerPanel != undefined)\n            {\n                that.polymarkerset.markerPanel.$container.hide()\n            } \n           // if(roiTool.lastCurrentROIID)\n           //    roiTool.toggleCurrentROI();\n        }\n        that.polymarkerset.deleteAllPoints();\n   \n    } );\n    //var $polyThrash = $("<i class=\'KViewPort_tool fa fa-fw fa-trash\'></i>").click( function(){ that.polymarkerset.deleteAllPoints() } ).appendTooltip("clear")\n    //var $polyInterpSlices = $("<i class=\'KViewPort_tool fa fa-fw fa-clone\'></i>").click( function(){ that.polymarkerset.interplate_scribbles(); alertify.success(\'Interpolated all slices, please verify\') } ).appendTooltip("interpolate")\n    //var $polyFill = $("<i class=\'KViewPort_tool fa fa-fw fa-pencil\'></i>").click( function() { that.polymarkerset.map_to_ROI()} ).appendTooltip("mapToActiveROI")    \n    var helptext = "Click to draw polygon (pointwise, or drag mouse)<br>Click circle symbol to close polygopn. <br>Click to add intermediate points to closest segment.<br>Use \'pencil\' button to fill current ROI.<br>You can also draw several polygons in distinct slices and use \'copy\' button to interpolate polygons."\n    var $polyHelp   = $("<i class=\'KViewPort_tool fa fa-question\'></i>").click( function(){ \n            var that = new dialog_generic();\n            that.$frame.width(500).height(600);\n            that.$frame.css({left:200, top:150} );\n            that.$frame .css(\'z-index\', 100000); \n            that.$frame.show();\n            that.$menu.append("<li>PolgyonTool - Help</li>");\n            that.deleteonclose = true;\n            that.$container.html(helptext)\n\n     } );\n\n  \t$polygonRow.append($polygonPenBtn)\n  \t$polygonRow.append($polyHelp)\n  \t\n  \t//$polygonRow.append($polyFill).append($polyInterpSlices)\n\n  \troiTool.closePolyTool = function()\n  \t{\n  \t    if (roiTool.polyEnabled)\n  \t     $polygonPenBtn.trigger("click");\n  \t}\n\n    \n    // ----------- the special tools4\n\n\n\n    /*\n\t$("<div class=\'roiTool_panel_caption\'>Advanced Tools</div>").appendTo($container);\n\tvar $miscToolsRow   = $("<div class=\'roiTool_panel_flex\'></div>").appendTo($container);\n      var $copySlice =   $("<i class=\'KViewPort_tool fa fa-copy\'></i>").click();\n      var $pasteSlice =   $("<i class=\'KViewPort_tool fa fa-paste\'></i>").click();\n      var $special =   $("<i class=\'KViewPort_tool fa fa-wrench\'></i>").appendTooltip("misctools").click(function(ev){\n      \t\tif(getParentViewer().currentROI === undefined) return; roiTool.tools_contextmenu_dynamic(ev, getParentViewer().currentROI.fileID) }  );\n\n\t$miscToolsRow.append($("<i></i>")).append($("<i></i>")).append($special);//.append($copySlice).append($pasteSlice);\n*/\n\n\n\n    var $activePen = undefined;\n    //roiTool.checkForAnyActiveRoi();\n\n    $("<div class=\'roiTool_panel_caption\'></div>").appendTo($container);\n\n\n    /***********************************************************\n    * livepreview\n    ************************************************************/\n    var $livepreview;\n    roiTool.livepreview = false;\n\n    that.toggleLivePreview = function(val)\n    {\n      if (val != undefined)\n        roiTool.livepreview = val;\n      else\n        roiTool.livepreview =!roiTool.livepreview ;\n      if (roiTool.livepreview)\n            $livepreview.addClass("fa-check-square").removeClass("fa-square")\n      else\n            $livepreview.removeClass("fa-check-square").addClass("fa-square")\n    }\n    var $livePrevRow = $("<div class=\'roiTool_panel_flex\' ></div>").appendTo($container);\n    $livePrevRow.append($("<div class=\'\' >live preview</div>")).append( $("<i class=\'flexspacer\'></i>") );\n    var $livepreview = $("<i class=\'fa fa-square\'></i>").click(function() {that.toggleLivePreview()}).appendTo($livePrevRow);\n    that.toggleLivePreview( roiTool.livepreview )\n\n\n\n    /***********************************************************\n    * 4D mode\n    ************************************************************/\n    var $mode4DRow = $("<div class=\'roiTool_panel_flex\' ></div>").appendTo($container);\n    $mode4DRow.append($("<div class=\'\' >4D mode</div>")).append( $("<i class=\'flexspacer\'></i>") );\n    var $mode4DButton = $("<i class=\'fa fa-square\'></i>").appendTo($mode4DRow).click(function(){togglemode4D()});\n\n    function togglemode4D(force)\n    {\n        roiTool.mode4D = force==undefined?(!roiTool.mode4D):force;\n        if (roiTool.mode4D)\n            $mode4DButton.addClass("fa-check-square").removeClass("fa-square")\n        else\n            $mode4DButton.removeClass("fa-check-square").addClass("fa-square")\n    }\n\n\n\n    /***********************************************************\n    * outlines\n    ************************************************************/\n    that.toggleOutlines = function(val)\n    {\n      if (val != undefined)\n        state.viewer.showOutlines = val;\n      else\n        state.viewer.showOutlines =!state.viewer.showOutlines ;\n      if (state.viewer.showOutlines)\n            $outlines.addClass("fa-check-square").removeClass("fa-square")\n      else\n            $outlines.removeClass("fa-check-square").addClass("fa-square")\n      KViewer.iterateMedViewers(function(viewer)\n      {\n          for (var k = 0; k < viewer.ROIs.length; k++)\n          {\n             var obj = viewer.ROIs[k];\n             if (state.viewer.showOutlines && obj.outlines == undefined)\n             {\n\t\t\t\tobj.outlines = Outlines(obj)\n\t\t\t    obj.outlines.update(viewer);\n\n             }\n             if (!state.viewer.showOutlines && obj.outlines != undefined)             \n\t\t\t {\n\t\t\t    obj.outlines.close();\n\t\t\t\tobj.outlines = undefined;\n\t\t\t }\n                \n          }\n      })\n\n    }\n    var $outlinesRow = $("<div class=\'roiTool_panel_flex\' ></div>").appendTo($container);\n    $outlinesRow.append($("<div class=\'\' >outlines</div>")).append( $("<i class=\'flexspacer\'></i>") );\n    var $outlines = $("<i class=\'fa fa-square\'></i>").click(function() {that.toggleOutlines()}).appendTo($outlinesRow);\n    that.toggleOutlines( state.viewer.showOutlines )\n\n\n\n    var $opacityRow = $("<div class=\'roiTool_panel_flex\'>opacity</div>").appendTo($container);\n    var $opacityinput = $(" <input type___ = \'number\' min=\'0\' max=\'100\' value=\'" + (1-state.viewer.roiTransparency)+ "\' /> ").on(\'change\', function(ev) {\n\n        state.viewer.roiTransparency = 1-parseFloat(ev.currentTarget.value);\n        signalhandler.send("positionChange");\n\n    });\n    $opacityRow.append($("<i class=\'flexspacer\'></i>")).append($opacityinput)\n\n\n\tKMouseSlider( $opacityinput, {min:0, max:1,incrementPerPixel: .01, logScaling:100 });\n\n\n\n\n    /***********************************************************\n    * ROI modes\n    ************************************************************/\n    $("<div class=\'roiTool_panel_caption\'>MultiROI handling</div>").appendTo($container);\n    var $roiModeRow = $("<div class=\'roiTool_panel_flex\' ></div>").appendTo($container);\n    $roiModeSelector = $("<select></select>");\n    var roiModeList = [{"title":"Overlap","value":"overlap"},{ "title":"Override", "value":"override"}, { "title":"Block", "value":"block"}]\n    // setting default value\n    roiTool.roiMode = roiModeList[0].value;\n    roiModeList.forEach(function (item) {\n        $(\'<option>\' + item.title + \'</option>\').val(item.value).appendTo($roiModeSelector)\n    });\n    $roiModeRow.append($("<div>")).append($roiModeSelector);\n    $roiModeSelector.on(\'change\', function (evt) {\n        roiTool.roiMode = $roiModeSelector.val();\n    });\n\n\n\n    /***********************************************************\n    * select pen\n    ************************************************************/\n    function selectPen(ev, pen)\n    {\n        var $whichbtn;\n        if( pen != undefined)\n        {\n            if(pen == \'smartpaw\')\n                $whichbtn = $smartPenBtn;\n            else if(pen == \'regionGrow\')\n                $whichbtn = $regionGrowPenBtn;\n            else if(pen == \'regionGrowRestric\')\n                $whichbtn = $regionGrowPenBtnRestric;\n            else\n            {\n                $whichbtn  = $();\n                $activePen = undefined;\n            }\n        }\n        else\n        {\n            $whichbtn = $(this);\n        }\n        // first, toggle everything always to false\n        roiTool.$pencil.removeClass(\'leftright\')\n        $container.find(\'.RoiPen\').removeClass(\'KViewPort_tool_enabled\');\n        polygonTool.disable();\n        roiTool.smartpaw = false;\n        roiTool.regionGrow = false;\n        roiTool.regionGrowRestric = false;\n        //roiTool.togglePen(false);\n\n        if ($whichbtn.is($activePen) && pen == undefined)\n        {\n            // self click, disable all\n            $activePen = undefined;\n        }\n        else\n        {\n\n            $activePen = $whichbtn;\n\n            $whichbtn.addClass(\'KViewPort_tool_enabled\');\n\n\n\n            if ($whichbtn.is($smartPenBtn))\n            {\n                setThreshPen(undefined, 0);\n                roiTool.smartpaw = true;\n                roiTool.togglePen(true);\n            }\n            else if ($whichbtn.is($regionGrowPenBtn))\n            {\n                setThreshPen(undefined, 0);\n                roiTool.regionGrow = true;\n                roiTool.togglePen(true);\n            }\n            else if ($whichbtn.is($regionGrowPenBtnRestric))\n           {\n                setThreshPen(undefined, 0);\n                roiTool.regionGrowRestric = true;\n                roiTool.togglePen(true);\n            }\n          /*  else if ($whichbtn.is($polygonPenBtn))\n            {\n                polygonTool.enable(getParentViewer());\n            }*/\n        }\n\n    }\n\n    that.update = function()\n    {\n        var roi = roiTool.currentROI;\n        if (roi != undefined)\n        {\n            var bgnd = that.getParentViewer().content;\n            if (roi.content.edges._data.toString() == bgnd.content.edges._data.toString())\n            {\n                $regionGrowPenBtn.removeClass(\'inactive\')\n                $regionGrowPenBtnRestric.removeClass(\'inactive\')\n            }\n            else\n            {\n                $regionGrowPenBtn.addClass(\'inactive\')\n                $regionGrowPenBtnRestric.addClass(\'inactive\')\n            }\n        }\n    }\n\n\n    /***************************************************************************************\n    * Remember the state of this tool\n    ****************************************************************************************/\n    that.getState  = function getState()\n    {\n        var s =\n        {\n            pencil:    roiTool.pencil,\n            activePen: 0,\n            threspen: roiTool.threspen,\n            mode4D: roiTool.mode4D,\n            roiMode: roiTool.roiMode\n        };\n\n        if(roiTool.smartPaw)\n            s.activePen = \'smartPaw\';\n        else if(roiTool.regionGrow)\n            s.activePen = \'regionGrow\';\n        else if(roiTool.regionGrowRestric)\n            s.activePen = \'regionGrowRestric\';\n\n\n        return s;\n\n    }\n\n    /***************************************************************************************\n    * generic state\n    ****************************************************************************************/\n    /*\n    that.getGenericState  = function getGenericState()\n    {\n        var s =\n        {\n            pencil:    { radius:20, radius_z:4,   thres:100 },\n            activePen: 0,\n            threspen: 0,\n        };\n        return s;\n\n    }\n    */\n\n    /***************************************************************************************\n    * Set the state of this tool\n    ****************************************************************************************/\n    that.setState = function setState(snew)\n    {\n\n        // to be complete, first get the current state , then extend\n        var s = that.getState();\n        $.extend(true, s, snew);\n\n        selectPen(undefined, s.activePen);\n        setThreshPen(undefined, s.threspen);\n\n        $inplaneradius.val( s.pencil.radius );\n        $outplaneradius.val( s.pencil.radius_z );\n\n        if(s.mode4D != undefined)\n            togglemode4D(s.mode4D)\n\n        if (s.roiMode != undefined)\n        {\n            $roiModeSelector.val(s.roiMode);\n            roiTool.roiMode = s.roiMode;\n        }\n    }\n\n    $container.find("input").on("dragstart", function(){return false});\n\n    that.disable();\n    return that;\n\n}\n\n\n\n\n\n\n/***************************************************************************************\n* the polygon tool\n****************************************************************************************/\nKPolygonTool = function()\n{\n\n    var that = new Object();\n\n    that.polygon = {};\n    that.polygon.points = [];\n\n\n    // representation of points in voxel coordinates\n    var points = [];\n    /*\tpoints[0] = [20,20];\n\tpoints[1] = [20,50];\n\tpoints[2] = [50,50];*/\n\n\n    var $svg;\n    that.$svg = $svg;\n\n    that.enabled = false;\n    that.parent = undefined;\n    /* parent viewport */\n\n    var sigidp, sigidz;\n\n    that.enable = function(parent)\n    {\n        that.enabled = true;\n        that.parent = parent;\n        sigidp = signalhandler.attach("positionChange", drawAllPoints);\n        sigidz = signalhandler.attach("setZoom", drawAllPoints);\n        that.createPolygon();\n    }\n\n    that.disable = function()\n    {\n        that.enabled = false;\n        if (sigidp != undefined)\n            signalhandler.detach("positionChange", sigidp);\n        if (sigidz != undefined)\n            signalhandler.detach("setZoom", sigidz);\n        that.createPolygon();\n    }\n\n\n    that.clearPoints = function()\n    {\n        points = new Array();\n        that.createPolygon();\n    }\n\n\n    // get points in linear fashion x,y ,x,y ...\n    that.getPointsLinear = function()\n    {\n        var pointsLinear = [];\n        for (var i = 0; i < points.length; i++)\n        {\n            pointsLinear[2 * i] = points[i][0];\n            pointsLinear[2 * i + 1] = points[i][1];\n        }\n        return pointsLinear;\n    }\n\n    that.createPolygon = function()\n    {\n\n        // delete all svgs first\n        $(\'.roiTool_svg\').remove();\n\n        if (!that.enabled)\n            return\n\n\n        var pstr = "";\n        var cstr = "";\n        var circleradius = 8;\n\n        x_pixpvox = that.parent.$canvascontainer.width() / that.parent.$canvas.attr(\'width\');\n        y_pixpvox = that.parent.$canvascontainer.height() / that.parent.$canvas.attr(\'height\');\n\n        for (var i = 0; i < points.length; i++)\n        {\n            pstr = pstr + points[i][0] * x_pixpvox + "," + points[i][1] * y_pixpvox + " ";\n            cstr = cstr + "<circle class=\'polygonCircle\' ind =" + i + " cx=" + points[i][0] * x_pixpvox + " cy=" + points[i][1] * y_pixpvox + " r=" + circleradius + " stroke=\'green\' stroke-width=" + 4 + " fill=\'\' />";\n        }\n        var polyid = "KRoipolygon01";\n        var childstr = "<polygon id=\'" + polyid + "\' points=\'" + pstr + "\' style=\'fill:none;\'/>" + cstr;\n        var defs = "<defs><filter id=\'svg_blur\'>            <feGaussianBlur stdDeviation=\'2\'\' />        </filter>    </defs>";\n\n        $svg = $("<div class=\'roiTool_svg\'><svg  >" + defs + childstr + "</svg></div>").on("contextmenu", function(ev) {\n            ev.preventDefault()\n        }).appendTo(that.parent.$canvascontainer);\n\n\n        if (points.length == 0)\n        {\n            $("<div class=\'roiTool_svgText\'>Click to draw a polygon</div>").appendTo($svg);\n        }\n        else\n        {\n            $(\'.roiTool_svgText\').remove();\n        }\n\n        // mouse handler for the svg object\n        $svg[0].addEventListener("mousewheel", svgMouseScroll, false);\n        // Firefox\n        $svg.on(\'mousedown\', svgMouseDown);\n\n\n        // must find polygon and circles again in document tree node\n        $svg.polygon = document.getElementById(polyid);\n        $svg.circles = [];\n\n        var polyCircles = $svg.find(\'.polygonCircle\');\n        for (var k = 0; k < points.length; k++)\n        {\n            polyCircles.eq(k).mousedown(mousedown).mouseover(mouseover).mouseout(mouseout).click(mouseclick).on("contextmenu", mouseclick);\n            $svg.circles.push(polyCircles[k]);\n        }\n\n\n        // mouse handler for the single points\n        function mouseover(ev) {\n            ev.target.setAttribute(\'r\', circleradius * 1.5);\n        }\n        function mouseout(ev) {\n            ev.target.setAttribute(\'r\', circleradius);\n        }\n        function mouseclick(ev)\n        {\n            // delete with right click\n            if (ev.button == 2)\n            {\n                drawAllPoints();\n                // needed of viewportLayout was changed;\n                var ind = parseInt(this.getAttribute(\'ind\'));\n                points.splice(ind, 1);\n                mouseup(ev);\n                that.createPolygon();\n            }\n            ev.stopPropagation();\n            return false;\n        }\n\n        function mousedown(ev, ev2)\n        {\n            if (ev2 !== undefined)\n                ev = ev2;\n\n            var pindex = parseInt(this.getAttribute(\'ind\'));\n            var startpos = [parseInt(this.getAttribute(\'cx\')) - ev.clientX, parseInt(this.getAttribute(\'cy\')) - ev.clientY];\n            $(document).on("mousemove", function(ev) {\n                mousemove(ev, pindex, startpos)\n            });\n            $(document).on("mouseup mouseleave", mouseup);\n            ev.stopPropagation();\n            return false;\n        }\n\n        function mousemove(ev, pindex, startpos)\n        {\n\n            var newX = startpos[0] + ev.clientX;\n            var newY = startpos[1] + ev.clientY;\n\n            // set the new point value\n            points[pindex] = [newX / x_pixpvox, newY / y_pixpvox];\n\n            drawPoint(pindex);\n\n            ev.stopPropagation();\n            return false;\n\n\n        }\n\n        function mouseup(ev)\n        {\n            $(document).off("mousemove");\n            ev.stopPropagation();\n            return false;\n        }\n\n    }\n\n\n\n    function drawAllPoints()\n    {\n        x_pixpvox = that.parent.$canvascontainer.width() / that.parent.$canvas.attr(\'width\');\n        y_pixpvox = that.parent.$canvascontainer.height() / that.parent.$canvas.attr(\'height\');\n\n        for (var k = 0; k < points.length; k++)\n        {\n            drawPoint(k);\n        }\n\n    }\n\n\n\n    function drawPoint(k)\n    {\n        $svg.circles[k].setAttribute(\'cx\', points[k][0] * x_pixpvox);\n        $svg.circles[k].setAttribute(\'cy\', points[k][1] * y_pixpvox);\n        $svg.polygon.points[k].x = points[k][0] * x_pixpvox;\n        $svg.polygon.points[k].y = points[k][1] * y_pixpvox;\n    }\n\n\n    function svgMouseScroll(ev)\n    {\n        if (!ev.shiftKey)\n        {\n            return true;\n        }\n\n        var c = clientPosToPoint(ev);\n        if (PolyK.ContainsPoint(that.getPointsLinear(), c[0], c[1]))\n        {\n            var sFac = math.sign( (ev.wheelDelta || -ev.detail ) ) * .1;\n            if (ev.ctrlKey)\n                sFac = sFac * .5;\n            //console.log(sFac);\n            for (var k = 0; k < points.length; k++)\n            {\n                points[k][0] = (1 + sFac) * (points[k][0] - c[0]) + c[0];\n                points[k][1] = (1 + sFac) * (points[k][1] - c[1]) + c[1];\n            }\n            that.createPolygon();\n            ev.preventDefault();\n            ev.stopPropagation();\n            return false;\n        }\n\n    }\n\n    function svgMouseDown(ev)\n    {\n        if (ev.shiftKey | ev.ctrlKey)\n        {\n            return true;\n        }\n\n        if (ev.button == 0)\n        {\n            return addPointToClosestSegment(ev);\n        }\n        else if (ev.button == 2)\n        {\n            var startpos = [ev.clientX, ev.clientY];\n            var pointsStarPos = $.extend(true, [], points);\n            $(document).on("mousemove", function(ev) {\n                mousemove(ev, startpos)\n            });\n            $(document).on("mouseup mouseleave", mouseup);\n            ev.stopPropagation();\n            return false;\n\n            function mousemove(ev, startpos)\n            {\n                var newX = startpos[0] - ev.clientX;\n                var newY = startpos[1] - ev.clientY;\n                for (var k = 0; k < points.length; k++)\n                {\n                    points[k][0] = pointsStarPos[k][0] - newX / y_pixpvox;\n                    points[k][1] = pointsStarPos[k][1] - newY / x_pixpvox;\n                }\n\n                drawAllPoints();\n                ev.stopPropagation();\n                return false;\n\n            }\n            function mouseup(ev)\n            {\n                $(document).off("mousemove");\n                ev.stopPropagation();\n                return false;\n            }\n\n\n        }\n\n    }\n\n    function clientPosToPoint(ev)\n    {\n        var py = (ev.clientY - $svg.offset().top) / y_pixpvox;\n        var px = (ev.clientX - $svg.offset().left) / x_pixpvox;\n        return [px, py];\n\n    }\n\n\n    /* add a new point to polygon */\n    function addPointToClosestSegment(ev)\n    {\n        var p = clientPosToPoint(ev)\n        var cl = PolyK.ClosestEdge(that.getPointsLinear(), p[0], p[1]);\n\n        var newp = [p[0], p[1]];\n        points.splice(cl.edge + 1, 0, newp);\n\n        that.createPolygon();\n        $($svg.circles[cl.edge + 1]).trigger(\'mousedown\', ev);\n        return false;\n    }\n\n    // add the polygon content to roi.\n    that.modifyRoi = function(valtoset)\n    {\n\n        var medViewer = that.parent;\n\n        if (medViewer.currentROI === undefined)\n            return false;\n\n        var nii = medViewer.currentROI.content;\n\n        // transform canvas points to voxel space\n        var ei = math.inv(nii.edges);\n        var ox = $svg.offset().left;\n        var oy = $svg.offset().top;\n\n        var px = [];\n        var py = [];\n\n        for (var k = 0; k < points.length; k++)\n        {\n            px[k] = points[k][0];\n            py[k] = points[k][1];\n        }\n\n        // get the bounding box in pixels\n        var minX = Math.min.apply(null , px);\n        var minY = Math.min.apply(null , py);\n        var maxX = Math.max.apply(null , px);\n        var maxY = Math.max.apply(null , py);\n\n        var changedPoints = [];\n\n        // iterate voxel space on canvas\n        // this can be made much faster.\n        var f = PolyK.ContainsPointFast(that.getPointsLinear());\n        for (var x = minX; x < maxX; x += .8)\n        {\n            for (var y = minY; y < maxY; y += .8)\n            {\n                //var isin = PolyK.ContainsPoint(that.getPointsLinear(), x, y);\n                var isin = f( x, y);\n                if (isin)\n                {\n                    var cx = x * x_pixpvox + ox;\n                    var cy = y * y_pixpvox + oy;\n                    var pr = medViewer.getRealWorldCoordinatesFromMouseEvent(cx, cy);\n                    var currentVoxel = math.round(math.multiply(ei, pr)._data);\n                    var currentIndex = nii.sizes[0] * nii.sizes[1] * currentVoxel[2] + currentVoxel[1] * nii.sizes[0] + currentVoxel[0];\n                    if (nii.data[currentIndex] != valtoset)\n                        changedPoints.push(currentIndex);\n\n                    nii.data[currentIndex] = valtoset;\n\n\n                }\n                //console.log(isin);\n            }\n\n        }\n\n        if (valtoset != 2)\n        {\n            KViewer.roiTool.history.record(\'startRecording\', medViewer);\n            KViewer.roiTool.history.add(changedPoints, valtoset);\n        }\n          signalhandler.send("updateImage",{id:medViewer.currentROI.fileID});\n\n        return;\n\n    }\n    return that;\n\n}\n\nvar polygonTool = new KPolygonTool();\n\n\n\n\n\n\n\n/*\n\t\tPolyK library\n\t\turl: http://polyk.ivank.net\n\t\tReleased under MIT licence.\n\n\t\tCopyright (c) 2012 - 2014 Ivan Kuckir\n\n\t\tPermission is hereby granted, free of charge, to any person\n\t\tobtaining a copy of this software and associated documentation\n\t\tfiles (the "Software"), to deal in the Software without\n\t\trestriction, including without limitation the rights to use,\n\t\tcopy, modify, merge, publish, distribute, sublicense, and/or sell\n\t\tcopies of the Software, and to permit persons to whom the\n\t\tSoftware is furnished to do so, subject to the following\n\t\tconditions:\n\n\t\tThe above copyright notice and this permission notice shall be\n\t\tincluded in all copies or substantial portions of the Software.\n\n\t\tTHE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,\n\t\tEXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES\n\t\tOF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND\n\t\tNONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT\n\t\tHOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,\n\t\tWHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING\n\t\tFROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR\n\t\tOTHER DEALINGS IN THE SOFTWARE.\n\n\t\t19. 5. 2014 - Problem with slicing fixed.\n\t*/\n\nvar PolyK = {};\n\n/*\n\t\tIs Polygon self-intersecting?\n\n\t\tO(n^2)\n\t*/\n\nPolyK.IsSimple = function(p)\n{\n    var n = p.length >> 1;\n    if (n < 4)\n        return true;\n    var a1 = new PolyK._P()\n      , a2 = new PolyK._P();\n    var b1 = new PolyK._P()\n      , b2 = new PolyK._P();\n    var c = new PolyK._P();\n\n    for (var i = 0; i < n; i++)\n    {\n        a1.x = p[2 * i];\n        a1.y = p[2 * i + 1];\n        if (i == n - 1) {\n            a2.x = p[0];\n            a2.y = p[1];\n        }\n        else {\n            a2.x = p[2 * i + 2];\n            a2.y = p[2 * i + 3];\n        }\n\n        for (var j = 0; j < n; j++)\n        {\n            if (Math.abs(i - j) < 2)\n                continue;\n            if (j == n - 1 && i == 0)\n                continue;\n            if (i == n - 1 && j == 0)\n                continue;\n\n            b1.x = p[2 * j];\n            b1.y = p[2 * j + 1];\n            if (j == n - 1) {\n                b2.x = p[0];\n                b2.y = p[1];\n            }\n            else {\n                b2.x = p[2 * j + 2];\n                b2.y = p[2 * j + 3];\n            }\n\n            if (PolyK._GetLineIntersection(a1, a2, b1, b2, c) != null )\n                return false;\n        }\n    }\n    return true;\n}\n\nPolyK.IsConvex = function(p)\n{\n    if (p.length < 6)\n        return true;\n    var l = p.length - 4;\n    for (var i = 0; i < l; i += 2)\n        if (!PolyK._convex(p[i], p[i + 1], p[i + 2], p[i + 3], p[i + 4], p[i + 5]))\n            return false;\n    if (!PolyK._convex(p[l], p[l + 1], p[l + 2], p[l + 3], p[0], p[1]))\n        return false;\n    if (!PolyK._convex(p[l + 2], p[l + 3], p[0], p[1], p[2], p[3]))\n        return false;\n    return true;\n}\n\nPolyK.GetArea = function(p)\n{\n    if (p.length < 6)\n        return 0;\n    var l = p.length - 2;\n    var sum = 0;\n    for (var i = 0; i < l; i += 2)\n        sum += (p[i + 2] - p[i]) * (p[i + 1] + p[i + 3]);\n    sum += (p[0] - p[l]) * (p[l + 1] + p[1]);\n    return -sum * 0.5;\n}\n\nPolyK.GetAABB = function(p)\n{\n    var minx = Infinity;\n    var miny = Infinity;\n    var maxx = -minx;\n    var maxy = -miny;\n    for (var i = 0; i < p.length; i += 2)\n    {\n        minx = Math.min(minx, p[i]);\n        maxx = Math.max(maxx, p[i]);\n        miny = Math.min(miny, p[i + 1]);\n        maxy = Math.max(maxy, p[i + 1]);\n    }\n    return {\n        x: minx,\n        y: miny,\n        width: maxx - minx,\n        height: maxy - miny\n    };\n}\n\nPolyK.Reverse = function(p)\n{\n    var np = [];\n    for (var j = p.length - 2; j >= 0; j -= 2)\n        np.push(p[j], p[j + 1])\n    return np;\n}\n\n\nPolyK.Triangulate = function(p)\n{\n    var n = p.length >> 1;\n    if (n < 3)\n        return [];\n    var tgs = [];\n    var avl = [];\n    for (var i = 0; i < n; i++)\n        avl.push(i);\n\n    var i = 0;\n    var al = n;\n    while (al > 3)\n    {\n        var i0 = avl[(i + 0) % al];\n        var i1 = avl[(i + 1) % al];\n        var i2 = avl[(i + 2) % al];\n\n        var ax = p[2 * i0]\n          , ay = p[2 * i0 + 1];\n        var bx = p[2 * i1]\n          , by = p[2 * i1 + 1];\n        var cx = p[2 * i2]\n          , cy = p[2 * i2 + 1];\n\n        var earFound = false;\n        if (PolyK._convex(ax, ay, bx, by, cx, cy))\n        {\n            earFound = true;\n            for (var j = 0; j < al; j++)\n            {\n                var vi = avl[j];\n                if (vi == i0 || vi == i1 || vi == i2)\n                    continue;\n                if (PolyK._PointInTriangle(p[2 * vi], p[2 * vi + 1], ax, ay, bx, by, cx, cy)) {\n                    earFound = false;\n                    break;\n                }\n            }\n        }\n        if (earFound)\n        {\n            tgs.push(i0, i1, i2);\n            avl.splice((i + 1) % al, 1);\n            al--;\n            i = 0;\n        }\n        else if (i++ > 3 * al)\n            break;\n        // no convex angles :(\n    }\n    tgs.push(avl[0], avl[1], avl[2]);\n    return tgs;\n}\n\nPolyK.ContainsPoint = function(pp, x, y)\n{\n    // close polygon\n    pp.push(pp[0]);\n    pp.push(pp[1]);\n    var npoints = pp.length >> 1;\n    var j = pp.length-2 ;\n    var odd = false;\n   \n    \n    for (var i=0; i<npoints*2; i+=2) \n    {\n        if ((pp[i+1]< y && pp[j+1]>=y ||  pp[j+1]< y && pp[i+1]>=y)\n            && (pp[i]<=x || pp[j]<=x)) \n        {\n              odd ^= (pp[i] + (y-pp[i+1])*(pp[j]-pp[i])/(pp[j+1]-pp[i+1])) < x; \n        }\n        j=i; \n    }\n\n    return odd;\n}\n\n\nPolyK.ContainsPointFast = function(pp)\n{\n\n    // close polygon\n    pp.push(pp[0]);\n    pp.push(pp[1]);\n    var npoints = pp.length >> 1;\n    var j = pp.length-2 ;\n    var constant = [];\n    var multiple = [];\n    for (var i = 0; i < npoints-1;i++)\n    {\n        constant.push(pp[2*i]-(pp[2*i+1]*pp[2*j])/(pp[2*j+1]-pp[2*i+1])+(pp[2*i+1]*pp[2*i])/(pp[2*j+1]-pp[2*i+1]))\n        multiple.push((pp[2*j]-pp[2*i])/(pp[2*j+1]-pp[2*i+1]));\n        j=i;\n    }\n    return function(x,y)\n    {\n      var oddNodes=false\n      var current=pp[2*(npoints-1)+1]>y\n      var previous;\n      for (var i=0; i<npoints; i++) {\n        previous=current; \n        current=pp[2*i+1]>y; \n        if (current!=previous) \n            oddNodes^=y*multiple[i]+constant[i]<x; \n      }\n      return oddNodes; \n    }\n\n\n} \n\n\n\n\n\n\n\n\n/* this one makes mistakes sometimes, use the one from above!  ...!*/\n/* to be removed\nPolyK.ContainsPoint__ = function(p, px, py)\n{\n    var n = p.length >> 1;\n    var ax, ay = p[2 * n - 3] - py, bx = p[2 * n - 2] - px, by = p[2 * n - 1] - py;\n\n    var lup = by > ay;\n    for (var i = 0; i < n; i++)\n    {\n        ax = bx;\n        ay = by;\n        bx = p[2 * i] - px;\n        by = p[2 * i + 1] - py;\n        if (ay == by)\n            continue;\n        lup = by > ay;\n    }\n\n    var depth = 0;\n    for (var i = 0; i < n; i++)\n    {\n        ax = bx;\n        ay = by;\n        bx = p[2 * i] - px;\n        by = p[2 * i + 1] - py;\n        if (ay < 0 && by < 0)\n            continue;// both "up" or both "down"\n        if (ay > 0 && by > 0)\n            continue;// both "up" or both "down"\n        if (ax < 0 && bx < 0)\n            continue;// both points on the left\n\n        if (ay == by && Math.min(ax, bx) <= 0)\n            return true;\n        if (ay == by)\n            continue;\n\n        var lx = ax + (bx - ax) * (-ay) / (by - ay);\n        if (lx == 0)\n            return true;\n        // point on edge\n        if (lx > 0)\n            depth++;\n        if (ay == 0 && lup && by > ay)\n            depth--;\n        // hit vertex, both up\n        if (ay == 0 && !lup && by < ay)\n            depth--;\n        // hit vertex, both down\n        lup = by > ay;\n    }\n    //console.log(depth);\n    return (depth & 1) == 1;\n}\n*/ \n\nPolyK.Slice = function(p, ax, ay, bx, by)\n{\n    if (PolyK.ContainsPoint(p, ax, ay) || PolyK.ContainsPoint(p, bx, by))\n        return [p.slice(0)];\n\n    var a = new PolyK._P(ax,ay);\n    var b = new PolyK._P(bx,by);\n    var iscs = [];\n    // intersections\n    var ps = [];\n    // points\n    for (var i = 0; i < p.length; i += 2)\n        ps.push(new PolyK._P(p[i],p[i + 1]));\n\n    for (var i = 0; i < ps.length; i++)\n    {\n        var isc = new PolyK._P(0,0);\n        isc = PolyK._GetLineIntersection(a, b, ps[i], ps[(i + 1) % ps.length], isc);\n        var fisc = iscs[0];\n        var lisc = iscs[iscs.length - 1];\n        if (isc && (fisc == null || PolyK._P.dist(isc, fisc) > 1e-10) && (lisc == null || PolyK._P.dist(isc, lisc) > 1e-10)) //&& (isc.x!=ps[i].x || isc.y!=ps[i].y) )\n        {\n            isc.flag = true;\n            iscs.push(isc);\n            ps.splice(i + 1, 0, isc);\n            i++;\n        }\n    }\n\n    if (iscs.length < 2)\n        return [p.slice(0)];\n    var comp = function(u, v) {\n        return PolyK._P.dist(a, u) - PolyK._P.dist(a, v);\n    }\n    iscs.sort(comp);\n\n    //console.log("Intersections: "+iscs.length, JSON.stringify(iscs));\n\n    var pgs = [];\n    var dir = 0;\n    while (iscs.length > 0)\n    {\n        var n = ps.length;\n        var i0 = iscs[0];\n        var i1 = iscs[1];\n        //if(i0.x==i1.x && i0.y==i1.y) { iscs.splice(0,2); continue;}\n        var ind0 = ps.indexOf(i0);\n        var ind1 = ps.indexOf(i1);\n        var solved = false;\n\n        //console.log(i0, i1);\n\n        if (PolyK._firstWithFlag(ps, ind0) == ind1)\n            solved = true;\n        else\n        {\n            i0 = iscs[1];\n            i1 = iscs[0];\n            ind0 = ps.indexOf(i0);\n            ind1 = ps.indexOf(i1);\n            if (PolyK._firstWithFlag(ps, ind0) == ind1)\n                solved = true;\n        }\n        if (solved)\n        {\n            dir--;\n            var pgn = PolyK._getPoints(ps, ind0, ind1);\n            pgs.push(pgn);\n            ps = PolyK._getPoints(ps, ind1, ind0);\n            i0.flag = i1.flag = false;\n            iscs.splice(0, 2);\n            if (iscs.length == 0)\n                pgs.push(ps);\n        }\n        else {\n            dir++;\n            iscs.reverse();\n        }\n        if (dir > 1)\n            break;\n    }\n    var result = [];\n    for (var i = 0; i < pgs.length; i++)\n    {\n        var pg = pgs[i];\n        var npg = [];\n        for (var j = 0; j < pg.length; j++)\n            npg.push(pg[j].x, pg[j].y);\n        result.push(npg);\n    }\n    return result;\n}\n\nPolyK.Raycast = function(p, x, y, dx, dy, isc)\n{\n    var l = p.length - 2;\n    var tp = PolyK._tp;\n    var a1 = tp[0]\n      , a2 = tp[1]\n      ,\n    b1 = tp[2]\n      , b2 = tp[3]\n      , c = tp[4];\n    a1.x = x;\n    a1.y = y;\n    a2.x = x + dx;\n    a2.y = y + dy;\n\n    if (isc == null )\n        isc = {\n            dist: 0,\n            edge: 0,\n            norm: {\n                x: 0,\n                y: 0\n            },\n            refl: {\n                x: 0,\n                y: 0\n            }\n        };\n    isc.dist = Infinity;\n\n    for (var i = 0; i < l; i += 2)\n    {\n        b1.x = p[i];\n        b1.y = p[i + 1];\n        b2.x = p[i + 2];\n        b2.y = p[i + 3];\n        var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);\n        if (nisc)\n            PolyK._updateISC(dx, dy, a1, b1, b2, c, i / 2, isc);\n    }\n    b1.x = b2.x;\n    b1.y = b2.y;\n    b2.x = p[0];\n    b2.y = p[1];\n    var nisc = PolyK._RayLineIntersection(a1, a2, b1, b2, c);\n    if (nisc)\n        PolyK._updateISC(dx, dy, a1, b1, b2, c, (p.length / 2) - 1, isc);\n\n    return (isc.dist != Infinity) ? isc : null ;\n}\n\nPolyK.ClosestEdge = function(p, x, y, isc)\n{\n    var l = p.length - 2;\n    var tp = PolyK._tp;\n    var a1 = tp[0]\n      ,\n    b1 = tp[2]\n      , b2 = tp[3]\n      , c = tp[4];\n    a1.x = x;\n    a1.y = y;\n\n    if (isc == null )\n        isc = {\n            dist: 0,\n            edge: 0,\n            point: {\n                x: 0,\n                y: 0\n            },\n            norm: {\n                x: 0,\n                y: 0\n            }\n        };\n    isc.dist = Infinity;\n\n    for (var i = 0; i < l; i += 2)\n    {\n        b1.x = p[i];\n        b1.y = p[i + 1];\n        b2.x = p[i + 2];\n        b2.y = p[i + 3];\n        PolyK._pointLineDist(a1, b1, b2, i >> 1, isc);\n    }\n    b1.x = b2.x;\n    b1.y = b2.y;\n    b2.x = p[0];\n    b2.y = p[1];\n    PolyK._pointLineDist(a1, b1, b2, l >> 1, isc);\n\n    var idst = 1 / isc.dist;\n    isc.norm.x = (x - isc.point.x) * idst;\n    isc.norm.y = (y - isc.point.y) * idst;\n    return isc;\n}\n\nPolyK._pointLineDist = function(p, a, b, edge, isc)\n{\n    var x = p.x\n      , y = p.y\n      , x1 = a.x\n      , y1 = a.y\n      , x2 = b.x\n      , y2 = b.y;\n\n    var A = x - x1;\n    var B = y - y1;\n    var C = x2 - x1;\n    var D = y2 - y1;\n\n    var dot = A * C + B * D;\n    var len_sq = C * C + D * D;\n    var param = dot / len_sq;\n\n    var xx, yy;\n\n    if (param < 0 || (x1 == x2 && y1 == y2)) {\n        xx = x1;\n        yy = y1;\n    }\n    else if (param > 1) {\n        xx = x2;\n        yy = y2;\n    }\n    else {\n        xx = x1 + param * C;\n        yy = y1 + param * D;\n    }\n\n    var dx = x - xx;\n    var dy = y - yy;\n    var dst = Math.sqrt(dx * dx + dy * dy);\n    if (dst < isc.dist)\n    {\n        isc.dist = dst;\n        isc.edge = edge;\n        isc.point.x = xx;\n        isc.point.y = yy;\n    }\n}\n\nPolyK._updateISC = function(dx, dy, a1, b1, b2, c, edge, isc)\n{\n    var nrl = PolyK._P.dist(a1, c);\n    if (nrl < isc.dist)\n    {\n        var ibl = 1 / PolyK._P.dist(b1, b2);\n        var nx = -(b2.y - b1.y) * ibl;\n        var ny = (b2.x - b1.x) * ibl;\n        var ddot = 2 * (dx * nx + dy * ny);\n        isc.dist = nrl;\n        isc.norm.x = nx;\n        isc.norm.y = ny;\n        isc.refl.x = -ddot * nx + dx;\n        isc.refl.y = -ddot * ny + dy;\n        isc.edge = edge;\n    }\n}\n\nPolyK._getPoints = function(ps, ind0, ind1)\n{\n    var n = ps.length;\n    var nps = [];\n    if (ind1 < ind0)\n        ind1 += n;\n    for (var i = ind0; i <= ind1; i++)\n        nps.push(ps[i % n]);\n    return nps;\n}\n\nPolyK._firstWithFlag = function(ps, ind)\n{\n    var n = ps.length;\n    while (true)\n    {\n        ind = (ind + 1) % n;\n        if (ps[ind].flag)\n            return ind;\n    }\n}\n\nPolyK._PointInTriangle = function(px, py, ax, ay, bx, by, cx, cy)\n{\n    var v0x = cx - ax;\n    var v0y = cy - ay;\n    var v1x = bx - ax;\n    var v1y = by - ay;\n    var v2x = px - ax;\n    var v2y = py - ay;\n\n    var dot00 = v0x * v0x + v0y * v0y;\n    var dot01 = v0x * v1x + v0y * v1y;\n    var dot02 = v0x * v2x + v0y * v2y;\n    var dot11 = v1x * v1x + v1y * v1y;\n    var dot12 = v1x * v2x + v1y * v2y;\n\n    var invDenom = 1 / (dot00 * dot11 - dot01 * dot01);\n    var u = (dot11 * dot02 - dot01 * dot12) * invDenom;\n    var v = (dot00 * dot12 - dot01 * dot02) * invDenom;\n\n    // Check if point is in triangle\n    return (u >= 0) && (v >= 0) && (u + v < 1);\n}\n\nPolyK._RayLineIntersection = function(a1, a2, b1, b2, c)\n{\n    var dax = (a1.x - a2.x)\n      , dbx = (b1.x - b2.x);\n    var day = (a1.y - a2.y)\n      , dby = (b1.y - b2.y);\n\n    var Den = dax * dby - day * dbx;\n    if (Den == 0)\n        return null ;\n    // parallel\n\n    var A = (a1.x * a2.y - a1.y * a2.x);\n    var B = (b1.x * b2.y - b1.y * b2.x);\n\n    var I = c;\n    var iDen = 1 / Den;\n    I.x = (A * dbx - dax * B) * iDen;\n    I.y = (A * dby - day * B) * iDen;\n\n    if (!PolyK._InRect(I, b1, b2))\n        return null ;\n    if ((day > 0 && I.y > a1.y) || (day < 0 && I.y < a1.y))\n        return null ;\n    if ((dax > 0 && I.x > a1.x) || (dax < 0 && I.x < a1.x))\n        return null ;\n    return I;\n}\n\nPolyK._GetLineIntersection = function(a1, a2, b1, b2, c)\n{\n    var dax = (a1.x - a2.x)\n      , dbx = (b1.x - b2.x);\n    var day = (a1.y - a2.y)\n      , dby = (b1.y - b2.y);\n\n    var Den = dax * dby - day * dbx;\n    if (Den == 0)\n        return null ;\n    // parallel\n\n    var A = (a1.x * a2.y - a1.y * a2.x);\n    var B = (b1.x * b2.y - b1.y * b2.x);\n\n    var I = c;\n    I.x = (A * dbx - dax * B) / Den;\n    I.y = (A * dby - day * B) / Den;\n\n    if (PolyK._InRect(I, a1, a2) && PolyK._InRect(I, b1, b2))\n        return I;\n    return null ;\n}\n\nPolyK._InRect = function(a, b, c) // a in rect (b,c)\n{\n    var minx = Math.min(b.x, c.x)\n      , maxx = Math.max(b.x, c.x);\n    var miny = Math.min(b.y, c.y)\n      , maxy = Math.max(b.y, c.y);\n\n    if (minx == maxx)\n        return ( miny <= a.y && a.y <= maxy) ;\n    if (miny == maxy)\n        return ( minx <= a.x && a.x <= maxx) ;\n\n    //return (minx <= a.x && a.x <= maxx && miny <= a.y && a.y <= maxy)\n    return ( minx <= a.x + 1e-10 && a.x - 1e-10 <= maxx && miny <= a.y + 1e-10 && a.y - 1e-10 <= maxy) ;\n}\n\nPolyK._convex = function(ax, ay, bx, by, cx, cy)\n{\n    return (ay - by) * (cx - bx) + (bx - ax) * (cy - by) >= 0;\n}\n\nPolyK._P = function(x, y)\n{\n    this.x = x;\n    this.y = y;\n    this.flag = false;\n}\nPolyK._P.prototype.toString = function()\n{\n    return "Point [" + this.x + ", " + this.y + "]";\n}\nPolyK._P.dist = function(a, b)\n{\n    var dx = b.x - a.x;\n    var dy = b.y - a.y;\n    return Math.sqrt(dx * dx + dy * dy);\n}\n\nPolyK._tp = [];\nfor (var i = 0; i < 10; i++)\n    PolyK._tp.push(new PolyK._P(0,0));\n\n\n\n\n/********************************************************************\nmidplane\n********************************************************************/\n\nfunction mirror_roi(fobj, dim)\n{\n\n    /*****************************\n\tget the nifti\n\t*****************************/\n    fobj = fobj || KViewer.roiTool.getCurrentGlobal();\n    if(!fobj || !fobj.content)\n    {\n        alertify.error("No roi selected");\n        return;\n    }\n    var nii =  fobj.content;\n\n\n\n    if (dim == undefined)\n    {\n        alertify.error("No option selected!");\n    }\n    else if(dim == \'C\')\n    {\n        var mset = markerProxy.getSetByName(\'midplane\')\n        //var mset = markerProxy.markersets._midplane_\n        if(!mset)\n        {\n            alertify.confirm("Need a midplane for this operation. Do you want to create one? If yes, draw 2 or 3 points to define midplane, then re-run.<br>You can also save the midline for later use.", \n            function(e, name) {\n                if (e)\n                   KMarkerPanel_midplane()\n            });\n        }\n        else if(Object.getOwnPropertyNames(mset.markerpoints).lengh <3)\n        {\n             alertify.error("not enough points defined for midplane!");\n        }\n        else\n        {\n            run();\n        }\n    }\n    else\n    {\n        run();\n    }\n\n\n\t\n\n\n\t/*****************************\n\tcreate plane n,c from the first three points of markerset\n\t*****************************/\n\tfunction run()\n\t{\n\t    if(dim == \'C\')\n\t    {\n            var mset = markerProxy.getSets()[0];\n            var points = mset.markerpoints;\n\n            var x = [];\n            var count = 0;\n            for(var k in points)\n            {\n                count++;\n                if(count <= 3)\n                    x.push(points[k].p.coords);\n                else\n                    break\n            }\n\n\n            // if only two points defined, take plane normal vector of current image\n            if(x.length < 3)\n            {\n                if(KViewer.viewports[0].medViewer == undefined || KViewer.viewports[0].medViewer.nii == undefined)\n                {\n                     alertify.error("not enough points defined for midplane!");\n                     return;\n                }\n                else\n                {\n                    var u = KViewer.viewports[0].medViewer.nii.spaceDirections[ KViewer.viewports[0].medViewer.getSlicingDimOfArray() ] ;\n                    x.push( math.add(x[0], u )._data );\n                }\n            }\n\n            // account for minus c in plane dist calulation here\n            var c = math.multiply(x[0], -1);\n            var n = math.cross( math.add(x[1], math.multiply(x[0],-1)), math.add(x[2], math.multiply(x[0],-1)));\n            n = math.multiply(n, 1/math.norm(n))._data;\n\t    }\n\t    else\n\t    {\n            \n            var n;\n            if(dim == \'X\')\n                dd = 0;\n            else if(dim == \'Y\')\n                dd = 1;\n            else if(dim == \'Z\')\n                dd = 2;\n            var c = KViewer.currentPoint;\n            \n            // not completely sure, \n            n = nii.spaceDirections[ nii.invPermOrder[dd] ];\n            n = math.multiply(n, 1/math.norm(n))._data;\n            n.push(0);\n           \n            // account for minus c in plane dist calulation here\n            c = math.multiply( kmath.multiply(KViewer.reorientationMatrix.matrix, c), -1)._data.slice(0,3);\n            n = kmath.multiply(KViewer.reorientationMatrix.matrix, n)._data.slice(0,3);\n            console.log("mirroring along c, n: " + c + " | " + n)\n\t    }\n\n\t\t/*****************************\n\t\tprepare and run over array\n\t\tmust run in sub-steps in order to avoid artifacts\n\t\t*****************************/\n\t\tvar mode = "newroi"\n\n\t\tif(mode=="newroi")\n\t\t{\n\t\t\tvar name =  fobj.filename.replace(/\\.nii$|\\.nii\\.gz$/) + "_mirr"\n\n\t\t\tKViewer.roiTool.pushROI(fobj.fileID, name, "lower0.0",\n\t\t\t\tfunction arrived(fobj)\n\t\t\t\t{\n\t\t\t\t\tKViewer.iterateMedViewers(function(m) {\n\t\t\t\t\t\tif (m.nii !== undefined)\n\t\t\t\t\t\t\tm.viewport.setContent(fobj, { intent: { ROI: true } });\n\t\t\t\t\t})\n\t\t\t\t\t//KViewer.roiTool.makeCurrentGlobal(fobj.fileID);\n\t\t\t\t\tdoit(nii, fobj.content)\n\n\n\t\t\t\t});\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\tdoit(nii, nii)\n\t\t}\n\n\t\tfunction doit(nii, nii_mirrored)\n\t\t{\n\t\t\n\t\t\tvar siz = nii.sizes;\n\t\t\tvar eE  = nii.edges;\n\t\t\tvar iE  = math.inv(nii.edges);\n\t\t\tvar widheidep = siz[0]*siz[1]*siz[2];\n\n\t\t\tvar currentTimePoint = nii.currentTimePoint.t;\n\n\t\t\tvar x, y, z, p, ind, dist\n\t\t\tvar step = 1;\n\t\t\t//var pointsToAdd = [];\n\t\t\tfor(var z=0; z<siz[2]; z+=step)\n\t\t\t{\n\t\t\t\tfor(var y=0; y<siz[1]; y+=step)\n\t\t\t\t{\n\t\t\t\t\tfor(var x=0; x<siz[0]; x+=step)\n\t\t\t\t\t{\n\t\t\t\t\t\tind = siz[0]*siz[1]*z + siz[0]*y + x + widheidep*(currentTimePoint);\n\t\t\t\t\t\tif(nii.data[ind] > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t// must do some sub-sampling here ...\n\t\t\t\t\t\t\tvar tt = 2;\n\t\t\t\t\t\t\tvar nn =tt +.5\n\t\t\t\t\t\t\tfor(var u=0; u<tt; u++)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tfor(var v=0; v<tt; v++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor(var j=0; j<tt; j++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tp = math.multiply(eE, [x+u/nn, y+v/nn, z+j/nn, 1])._data.slice(0,3);\n\t\t\t\t\t\t\t\t\t\tdist = math.dot(n,  math.add(p,c ));\n\t\t\t\t\t\t\t\t\t\tp = math.add(p, math.multiply(n, -2*dist))._data;\n\t\t\t\t\t\t\t\t\t\tp = math.round( math.multiply(iE, [p[0],p[1],p[2],1])._data );\n\t\t\t\t\t\t\t\t\t\tif( p[0] < nii.sizes[0] && p[1] < nii.sizes[1] && p[2] < nii.sizes[2] && p[0] >=0  && p[1] >=0 && p[2] >=0 )\n\t\t\t\t\t\t\t\t\t\t{\n                                            ind = siz[0]*siz[1]*p[2] + siz[0]*p[1] + p[0] + widheidep*(currentTimePoint);\n                                            nii_mirrored.data[ind] = 1;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n// \t\t\tfor(var k=0, len=pointsToAdd.length;  k<len; k++)\n// \t\t\t\tnii_mirrored.data[pointsToAdd[k]] = 1;\n\t\t}\n\t}\n\n\n\t\n/*\nFor the worker, to be implemented\n\tvar tot = 1\n\t\tfor (var k = 0; k < execObj.size.length;k++)\n\t\t   tot *= execObj.size[k]\n\t\tvar changedPoints = [];\n\t\tfor (var k = 0; k < tot;k++)\n\t\t{\n\t\t    if (execObj.data[k] > 0)\n\t\t        execObj.data[k] = 0;\n\t\t    else\n\t\t        execObj.data[k] = 1;\n\t\t    changedPoints.push(k);\n\t\t}\n\t\tself.postMessage({msg:\'done\',execObj:{buf:execObj.buf,changedPoints:changedPoints}},[execObj.buf]);\t\t\n\t}\n\n*/\n\n}\n'},function(t,n){t.exports="\n// ======================================================================================\n// ======================================================================================\n// ============= KObject3DTool\n// ======================================================================================\n// ======================================================================================\n\nfunction KObject3DTool(master)\n{\n  /** objects that are typically looked in 3D like fiber tracts/surfaces/ccmats are controlled from here\n   * @class \n   * @alias KObject3DTool\n   * @augments KToolWindow\n   */\n  var that = new KToolWindow(master,\n  $(\"<div class='KView_tool '><i class='fa fa-cubes fa-1x'></i></div>\")\n  .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Objects 3D</li>\")) ) );\n  \n   that.$topRow.addClass(\"Obj3DTool_topmenu\")\n\n  var fibertool = master.obj3dTool;\n\n  that.tracking_panel = KTrackingPanel();\n  that.tracking_panel.toggle();\n\n\n  that.name = 'Objects 3D';\n  \n  // the list of 3D objects as key/value pairs\n  that.objs = {};\n\n\n  // the top menu\n  var $menu = $(\"<ul class='KView_tool_menu'></ul>\");\n\n  that.$topRow.append( $(\"<li ><a>Objects 3D</a></li>\").append($menu) );\n\n  $menu.append($(\"<li><a>Object Statistics</a> </i></li>\").click(function() \n    {\n        that.statdlg.toggle();\n        that.statdlg.dostats();\n    }\n    ));\n\n  that.statdlg = statistics_dialog(that);\n\n  // that tool table \n  var $innerDIV = $(\"<div ondragover='event.preventDefault();' class='annotation_tool_listDIV'></div>\").appendTo(that.$container);\n  var $table = $(\"<table  class='localfiletable'></table>\").appendTo($innerDIV);\n  \n  // drop handler \n  $innerDIV.on(\"drop\",function(e)\n  {\n    e.preventDefault();\n    var params = getloadParamsFromDrop(e.originalEvent,undefined);\n  \tif (params.length > 0)\n  \t{\n\t\tparams[0].progressSpinner = that.progressSpinner;\n\t\tparams[0].callback = that.hideSpinner;\n\t\tmaster.dataManager.loadData(params[0]);\n  \t}\n  });\n\n  // resize handler\n  that.resize = function(hei)\n  {\n      that.$container.height(hei);\n      $innerDIV.height(hei-that.$container.find('.KToolsTopMenu').height());\n      \n  }\n\n\n  /***************************************************************************************\n   *  object management\n   ****************************************************************************************/\n\n \n  that.addObject = function (fileObject)\n  {\n       that.objs[fileObject.fileID] = fileObject;\n       that.update();\n  }\n\n\n  that.clearAll = function ()\n  {\n      var obs = Object.keys(that.objs);\n      for (var k = 0; k< obs.length;k++)\n      \t\tdelete that.objs[obs[k]].content;\n      KViewer.obj3dTool.objs = {};\n      KViewer.obj3dTool.update();\n\n  }\n\n\n  that.uid_cnt = 0;\n  \n\n  that.cloneFibersFromSelection = function (tck,viewer,parent,name)\n  {\n  \t  var fobj = tck.fibers;\n  \t  var children; \t  \n  \t  if (tck.isParentView)\n  \t  \t children = tck.children;\n  \t  else\n  \t     children = tck.parent.children;\n\n  \t  if (tck.trackingVol == undefined)\n  \t  {\n\t\t  if (fobj.content.selections == undefined)\n\t\t\t\tfobj.content.selections =[];\n\t\t  var max = 0;\n\t\t  for (var k = 0 ; k < children.length;k++)\n\t\t  {\n\t\t  \t\tif (children[k].Selection != undefined) \n\t\t\t\t\tif (children[k].Selection.name.substring(0,9) == 'selection')\n\t\t\t\t\t\tmax = Math.max(max,parseInt(children[k].Selection.name.substring(9)));\n\t\t  }\n\t\t  if (name == undefined)\n\t\t  \tname = 'selection' + (max+1);\n\t\t  fobj.content.selections.push({subset: tck.subsetToDisplay, name:name, signs:tck.fiberSign});\n\t\t  that.update();  \t  \n\n\t\t  return that.createFiberView(fobj,viewer,{select: tck.fibers.content.selections.length-1 , parent:parent, donotmakecurrent:true});\n  \t  }\n  \t  else\n  \t  {\n  \t  \t var fobj_ = {content:{tracts : fobj.content.tracts,\n  \t  \t \t\t\t\t\t   tracts_max : fobj.content.tracts_max,\n  \t  \t \t\t\t\t\t   tracts_min : fobj.content.tracts_min,\n  \t  \t \t\t\t\t\t   tracts_len : fobj.content.tracts_len,\n  \t  \t \t\t\t\t\t   tot_points : fobj.content.tot_points,\n  \t  \t \t\t\t\t\t   max : fobj.content.max,\n  \t  \t \t\t\t\t\t   min : fobj.content.min } };\n\n\t\t var max = 0;\n\t\t for (var k = 0 ; k < children.length;k++)\n\t\t {\n\t\t\t\tif (children[k].fibers.filename.substring(0,9) == 'selection')\n\t\t\t\t\tmax = Math.max(max,parseInt(children[k].fibers.filename.substring(9)));\n\t\t }\n\t\t if (name == undefined)\n\t\t\t name = 'selection' + (max+1);\n\n\t\t that.buildOctree(fobj_.content,that.progressSpinner);\t\t\t\t \n  \t  \t fobj_.filename = name;\n\n  \t  \t var intent = {parent:parent, donotmakecurrent:true}\n\t\t if (tck.subsetToDisplay != undefined)\n\t\t {\n\t\t \t fobj_.content.selections = [{subset: tck.subsetToDisplay, name:name}];\n\t\t \t intent.select = 0;\n\t\t }\n\n\t\t that.update();  \t  \n\t\t return  that.createFiberView(fobj_,viewer,intent);\n  \t  }\n  }\n\n\n  /***************************************************************************************\n   *  table updater \n   ****************************************************************************************/\n\n  that.update = function()\n  {\n    $table.children().remove();\n  \n    var $thead = $(\"<thead>\").appendTo($table);\n    var $row = $(\"<tr class='filecache'></tr>\").appendTo($thead);\n    $row.append($(\"<td  class='fixedwidth' fixedwidth='6'><i class='fa fa-fw fa-square-o'></i> </td>\"));\n    $row.append($(\"<td>name </td>\"));\n    $row.append($(\"<td>type</td>\"));\n    $row.append($(\"<td class='fixedwidth' fixedwidth='6'></td>\"));\n    $row.append($(\"<td class='fixedwidth' fixedwidth='6'></td>\"));\n    $row.append($(\"<td>info</td>\"));\n\n  \n    var $tbody = $(\"<tbody>\").appendTo($table);\n    for  (var k in that.objs)\n    {\n\t   var id = that.objs[k].fileID;\n    \t\n       var dragstuff = \"draggable='true' data-type='file' data-filename='\"+that.objs[k].filename+\"' data-fileID='\"+that.objs[k].fileID+\"' data-mime='tracts'\";\n       dragstuff = dragstuff + \" ondragstart='setdragstart(event);' ondragend='setdragend(event);' ondblclick='loadDataOndblClick(event);'\";\n       var $row = $(\"<tr class='maintck' \" + dragstuff + \"></tr>\").appendTo($tbody);\n       $row.append($(\"<td><i class='fa fa-fw fa-circle-o'></i> </td>\").click(function(e){ \n    \n\t\t\tvar toselect = $(e.target).parent();\n\t\t\tif (!$(e.target).parent().is(\"tr\"))\n\t\t\t  toselect = toselect.parent();\n\t\t\ttoselect = toselect.nextAll();\n\t\t\tfor (var k = 0; k < toselect.length;k++)\n\t\t\t{\n\t\t\t\tvar to = $(toselect[k]).find(\".fa-square-o,.fa-check-square-o\");\n\t\t\t\tif (to.length > 0)\n\t\t\t\t\ttoggle_file(to);\n\t\t\t    else\n\t\t\t    \tbreak;\n\t\t\t}\n\t\t\treturn false;\n\n        }));      \n       \n       $row.append($(\"<td >\" + that.objs[k].filename + \"</td>\"));\n       $row.append($(\"<td>\" + that.objs[k].contentType + \"</td>\"));\n       if (that.objs[k].contentType == 'tracts'  & that.objs[k].content.selections != undefined) \n  \t   \t\t$row.append($(\"<td> <i class='fa tablebutton fa-fw fa-save'></td>\").click(function(t) { return function() { that.save(t) } }(that.objs[k])));\n       //if (that.objs[k].contentType == 'gii' && that.objs[k].content.nifti != undefined && that.objs[k].content.nifti.labels == undefined ) \n  \t   //\t\t$row.append($(\"<td> <i class='fa  fa-fw fa-refresh'></td>\").click(function(t) { return function() { \n  \t   //\t\tthat.computeIsoSurf(t);  \n  \t   //\t\tfor (var j=0;j < t.content.update.length;j++) t.content.update[j]();\n  \t   //\t\t} }(that.objs[k])));\n\n\t   $row.append($(\"<td> <i class='tablebutton fa fa-fw fa-close'></td>\").click(function(k) {return function(ev){\n\n\t   \t\t   ignoreDblClickBeforeClose(ev);\n\t   \t\t\tev.preventDefault();\n\t\t\t    if (that.objs[k].fileinfo.roireference != undefined)\n\t\t\t    \tdelete that.objs[k].fileinfo.roireference.fileinfo.surfreference;\n\t\t\n\t\t\t\tKViewer.iterateMedViewers(function (medViewer) {\n\t\t\t\t\tfor (var i = 0; i < medViewer.objects3D.length; i++)\n\t\t\t\t\t\tif (medViewer.objects3D[i].surf == that.objs[k])\n\t\t\t\t\t\t\tmedViewer.objects3D[i].close();\n\t\t\t\t});\n\n\t\t\t   \tdelete that.objs[k];\n\t\t\t   \tthat.update();\n\t\t\t   } }(k) ));\n\n\t  if (that.objs[k].contentType == 'tracts')\n\t         $row.append($(\"<td > tracts:\" + that.objs[k].content.tracts.length+ \"</td>\"));\n\n\t   if (that.objs[k].content.Contours != undefined)\n\t   {\n\t\t\tfor (var j = 0; j < that.objs[k].content.Contours.length;j++)\n\t\t\t{\n\t\t\t   var selection = that.objs[k].content.Contours[j];\n               var dragstuff = \"draggable='true' data-type='file' data-filename='tck:\"+selection.name+\"' data-fileID='\"+that.objs[k].fileID+\"'  data-mime='contour' data-intent='select:\"+j+\"'\";\n                \n               dragstuff += \" ondragstart='setdragstart(event);' ondragend='setdragend(event);' ondblclick='loadDataOndblClick(event);'\";\n\t\t\t   var $row = $(\"<tr class='filecache' \" + dragstuff + \"'></tr>\").appendTo($table);\n     \t\t   $row.append($(\"<td><i class='fa fa-fw fa-square-o'></i> </td>\").click(function(e){ toggle_file(e.target); return false; }));      \n\t\t\t   \n\t\t\t   $row.on(\"contextmenu\", function (ev) { formContextMenu(ev); });\n               var $namediv = $(\"<td>\" + selection.name + \"</td>\");\n               $row.append($namediv);\n               \n               \n\n\t\t\t   $row.append($(\"<td> contour </td>\"));\n \t\t\t   \n\t\t\t   $row.append($(\"<td> <i class='fa tablebutton fa-fw fa-close'></td>\").click(function(k,j) {return function(ev){\n\t\t\t\t   ignoreDblClickBeforeClose(ev);\n\t\t\t\t   ev.preventDefault();\n\t\t\t\t\tthat.objs[k].content.selections.splice(j,1);\n\t\t\t\t\tthat.update();\n\t\t\t   } }(k,j) ));\n\n\t\t\t   $row.click(function(ev){\n\t\t\t\t  if (ev.ctrlKey)\n\t\t\t\t  \ttoggle_file(ev.target);\n\n\t\t\t   })\n\n\n\n\t\t\t}\n\n\n\t   }\n\t\t\t  \n  \t   \t\t\n\n\n\t   if (that.objs[k].content.selections != undefined)\n\t   {\n            var list_to_sort = []\n\t\t\tfor (var j = 0; j < that.objs[k].content.selections.length;j++)\n\t\t\t\tlist_to_sort.push({id:j,name:that.objs[k].content.selections[j].name})\n            \n            list_to_sort.sort(function(a,b) {return (a.name > b.name)?1:-1 })\n\n\t\t\tfor (var j_ = 0; j_ < that.objs[k].content.selections.length;j_++)\n\t\t\t{\n\t\t\t   var j = list_to_sort[j_].id;\n\t\t\t   var selection = that.objs[k].content.selections[j];\n               var dragstuff = \"draggable='true' data-type='file' data-filename='tck:\"+selection.name+\"' data-fileID='\"+that.objs[k].fileID+\"'  data-mime='tracts' data-intent='select:\"+j+\"'\";\n                \n               dragstuff += \" ondragstart='setdragstart(event);' ondragend='setdragend(event);' ondblclick='loadDataOndblClick(event);'\";\n\t\t\t   var $row = $(\"<tr class='filecache' \" + dragstuff + \"'></tr>\").appendTo($table);\n     \t\t   $row.append($(\"<td><i class='fa fa-fw fa-square-o'></i> </td>\").click(function(e){ toggle_file(e.target); return false; }));      \n\t\t\t   \n\t\t\t   $row.on(\"contextmenu\", function (ev) { formContextMenu(ev); });\n               var $namediv = $(\"<td>\" + selection.name + \"</td>\");\n               $row.append($namediv);\n               if (selection.namedivs == undefined)\n               \t  selection.namedivs = {};\n\t\t\t   selection.namedivs.manager = $namediv;\n\t\t\t\n               $namediv.keydown(function(ev) { if (ev.keyCode == 13) { $(ev.target).blur(); return false } })\n               .keyup(  function(sel) { return  function(ev) \n\t\t\t   {\n\t\t\t   \t\tsel.name = $(ev.target).text(); \n\t\t\t   \t\tif (sel.namedivs != undefined)\n\t\t\t   \t\t{\n\t\t\t   \t\t\tfor (var i in sel.namedivs)\n\t\t\t   \t\t\t{\n\t\t\t   \t\t\t\t//if (sel.namedivs[i].constructor.name == 'm')\n\t\t\t   \t\t\t\t\t$(sel.namedivs[i]).text(sel.name);\n\t\t\t   \t\t\t}\n\t\t\t   \t\t}\n\t\t\t   } }(selection)\n               ).on('blur', that.update);\n\n\n              makeEditableOnDoubleClick($namediv);\n\n\n\t\t\t   $row.append($(\"<td> tractselection </td>\"));\n  \t   \t  \t   $row.append($(\"<td> <i class='fa tablebutton  fa-fw fa-save'></td>\").click(function(t,s) { return function() { that.save(t,s) } }(that.objs[k],selection)));\n \t\t\t   \n\t\t\t   $row.append($(\"<td> <i class='fa tablebutton fa-fw fa-close'></td>\").click(function(k,j) {return function(ev){\n\t\t\t\t   ignoreDblClickBeforeClose(ev);\n\t\t\t\t   ev.preventDefault();\n\t\t\t\t\tthat.objs[k].content.selections.splice(j,1);\n\t\t\t\t\tthat.update();\n\t\t\t   } }(k,j) ));\n\n\t\t\t   $row.click(function(ev){\n\t\t\t\t  if (ev.ctrlKey)\n\t\t\t\t  \ttoggle_file(ev.target);\n\n\t\t\t   })\n\n\t\t\t   if (that.objs[k].contentType == 'tracts')\n\t         \t\t$row.append($(\"<td > tracts:\" +that.objs[k].content.selections[j].subset.length+ \"</td>\"));\n\n\n\n\t\t\t}\n\n\t   }\n\t\t\n\n    }       \n    that.attachTableOperator($table.parent());\n\n  }\n\n\n    function toggle_file(target)\n    {\n      if (!$(target).hasClass(\"fa\"))\n         target = $(target).parent().find(\".fa\");\n      toggle(target);\n    }\n\n    function toggle(target)\n    {\n      if (target.length > 1)\n\t\ttarget = target[0];\n      $(target).toggleClass(\"fa-square-o\");\n      $(target).toggleClass(\"fa-check-square-o\");\n      $(target).parent().parent().toggleClass(\"selected\");\n    }\n\n  that.saveTCK = function(tck)\n  {\n  \t if (tck.Selection.name != undefined)\n  \t \ttck.fibers.filename = tck.Selection.name.trim()\n\n  \t var fibers = tck.fibers\n  \t var content = fibers.content;\n  \t var utf8encoder = new TextEncoder()\n  \t var hdr = \"mrtrix tracks\\ndatatype: Float32LE\\ncount: \"+ content.tracts.length + \"\\nfile: . 1024\\nEND\";\n  \t var buf = new ArrayBuffer(1024+ ((content.tot_points*4)*3 + content.tracts.length*4*3 ));\n  \t var uint8 = new Uint8Array(buf)\n     var hdrbuf = utf8encoder.encode(hdr);\n  \t uint8.set(hdrbuf);\n    \n     var nanbuf = new Float32Array(3)\n     nanbuf[0] = NaN\n     nanbuf[1] = NaN\n     nanbuf[2] = NaN\n\n     var offs = 1024\n     for (var k = 0; k < content.tracts.length;k++)\n     {\n        uint8.set(new Uint8Array(content.tracts[k].buffer),offs);\n        offs = offs + content.tracts[k].buffer.byteLength;\n        uint8.set(new Uint8Array(nanbuf.buffer),offs);\n        offs = offs + nanbuf.buffer.byteLength;\n     }\n\n\n     fibers.content.buffer = buf;\n\n    fibers.fileinfo = {};\n    fibers.fileID = \"TCK_1\"\n    fibers.filename = fibers.filename.replace(\"\\.tck\",\"\")\n    fibers.filename = fibers.filename + \".tck\"\n\n\t// add a unique patient id first if not set\n\tif (fibers.fileinfo.patients_id == undefined)\n\t   extendWithUniquePSID(fibers.fileinfo);\n\n\tvar zipped = false;\n\n\tif (fibers.fileinfo.patients_id != undefined)\n\t {\n\t\t\tuploadUnregisteredBinary(fibers, {\n\t\t\t\tSubFolder: \"\",\n\t\t\t\tpermission: \"rwp\"\n\t\t\t}, that.progressSpinner,\n\t\t\tfunction(newid, id) {\n\n\t\t\t},zipped);\n\t}\n\telse\n\t{\n\t\talertify.alert(\"There is no unique patient id set for this file.\")\n\t}\n      \t \n  \t \n  }\n\n\n  // save a selection as json\n  that.save = function(fibers,selection,donotupload)\n  {\n      var sels;\n      var name;\n      if (selection != undefined)\n      {\n      \tsels = [selection];\n      \tname = selection.name;\n      }\n      else\n      \tsels = fibers.content.selections;\n\n\t  var csels = [];\n\t  for (var k = 0; k < sels.length; k++)\n\t  {\n\t  \t  csels[k]= $.extend(false,{},sels[k]);\n\t  \t  csels[k].namedivs = undefined;\n\t  \t  delete csels[k].namedivs;\n\t  }\n\n  \t  var obj = {assoc: {fileID:fibers.fileID,filename:fibers.filename,subfolder:fibers.fileinfo.SubFolder,filepath:fibers.fileinfo.FilePath,md5:fibers.content.md5},\n  \t             selections: csels };\n  \t  if (donotupload != undefined && donotupload == true)\n\t\t  return obj;\n\n\n \t  if (name != undefined)\n\t\t uploadJSON(name,obj,{patients_id:fibers.fileinfo.patients_id,studies_id:fibers.fileinfo.studies_id,subfolder:fibers.fileinfo.SubFolder,tag:'TCKSEL'},function(fobj)\n\t\t {\n\t\t\tfibers.tckjsonref = fobj ;\n\t\t });\t\t\t\t\t\n\t  else  \t  \n\t  {\n\t  \t if (electron)\n\t\t\t uploadJSON(\"tract_selections.tck.json\",obj,{subfolder:fibers.fileinfo.SubFolder,tag:'TCKSEL'},function(fobj){\n\t\t\t \tfibers.tckjsonref = fobj;\n\t\t\t });\t\t\t\t\t\n\t  \t else\n\t  \t {\n\t  \t \t var def = that.lastSelectionName;\n\t  \t \t if (def == undefined)\n\t  \t \t {\n                if (fibers.fileinfo.SubFolder != undefined | fibers.fileinfo.SubFolder != \"\")\n\t  \t \t \t    def = fibers.fileinfo.SubFolder + \"/tract_selections\";\n\t  \t \t \telse \n\t  \t \t \t    def = \"tract_selections\";\n\t  \t \t }\n\t\t\t alertify.prompt(\"Enter a name for fiber selections\", function(e,name)\n\t\t\t {\n\t\t\t\tif (e)\n\t\t\t\t{\n\t\t\t\t\tthat.lastSelectionName = name;\n\t\t\t\t\tvar sp = name.split(\"/\");\n\t\t\t\t\tvar name = sp[sp.length-1];\n\t\t\t\t\tvar subfolder = sp.splice(0,sp.length-1).join(\"/\");\n\t\t\t\t\tuploadJSON(name,obj,{subfolder:subfolder,tag:'TCKSEL'},function(fobj){\n\t\t\t\t\t\tfibers.tckjsonref = fobj\n\t\t\t\t\t});\t\t\t\t\t\n\t\t\t\t}\n\t\t\t } ,def);\n\t  \t }\n\n\t  }\n\n\t  return obj;\n\n  }\n\n\n  /***************************************************************************************\n   *  context menu\n   ****************************************************************************************/\n\n\n  var fiberContextMenu = KContextMenu(\n  function(ev) {\n\n      var target = ev.target;\n      for (var k = 0;k< 3;k++)\n      {\n        if ($(target).is(\"tr\"))\n           break;\n        target = $(target).parent();\n      }\n      prepObjectInfo(target);\n\n\n      var $menu = $(\"<ul class='menu_context'>\")\n\n      $menu.append($(\"<li onchoice='save' >save</li>\"));\n\n      return $menu;\n  },\n  function (str,ev)\n  {\n      if (str==\"save\")\n      {\n      }\n  });\n\n\n\n  /***************************************************************************************\n   *  creation of 3D objects from volume data\n   ****************************************************************************************/\n\n\tthat.createSurfaceFromROI = function(fobj,ondone,thres,progress)\n\t{\n\t\tvar labelObj;\n\t\tif (thres != undefined)\n\t\t labelObj = {threshold:thres};\n\n\t\tif (progress == undefined)\n\t\t\tprogress = that.progressSpinner;\n\n\t\tif (fobj.fileinfo.surfreference != undefined)\n\t\t{\n\t\t\tvar fileObject = fobj.fileinfo.surfreference;\n\t\t\tthat.computeIsoSurf2(fileObject,labelObj,progress,function()\n\t\t\t{ \n\t\t\t\tfor (var j=0;j < fileObject.content.update.length;j++) \n\t\t\t\t\tfileObject.content.update[j]();\t\t\t\n\t\t\t});\n\t\t    return;\n\t\t}\n\n\n\t\tvar fileObject = {};\n\t\tfileObject.content =  {nifti:fobj.content,buffer:undefined,update:[] };\n\n\t\tfileObject.fileID = 'SURF_' + KObject3DTool.uidCnter++;\n\t\tfileObject.filename = 'surf.' + fobj.filename;\n\t\tfileObject.contentType = 'gii';\n\t\tfileObject.fileinfo = {roireference:fobj};\n\t\tfobj.fileinfo.surfreference = fileObject; \n\n\t\tfileObject.content.min = math.multiply(fobj.content.edges,[0,0,0,1])._data;\n\t\tfileObject.content.max = math.multiply(fobj.content.edges,[\n\t\tfobj.content.sizes[0],fobj.content.sizes[1],fobj.content.sizes[2],1])._data;\n\n\n\t\t// forward an update callback from the roi if desired\n\t\tif(fobj.update != undefined)\n\t\t\tfileObject.content.update.push(fobj.update);\n\n\t\tprogress(\"creating isosurface\");\n\t\n  \t    that.computeIsoSurf2(fileObject,labelObj,progress,function(){\n\t\t\tprogress();\n\t\t\t\n\t\t\tif (ondone)\n\t\t\t\tondone(fileObject);\n  \t    });\n\n\n\t}\n\n\n\tthat.createSurfaceFromAtlas = function(fobj,label,ondone)\n\t{\n\n\t\tvar fileObject = {};\n\t\tfileObject.content =  {nifti:fobj.content,buffer:undefined,update:[] };\n\n\t\tfileObject.fileID = 'SURF_' + KObject3DTool.uidCnter++;\n\t\tfileObject.filename = 'surf.' + ((label==undefined)?\"unknown\":label.name);\n\t\tfileObject.contentType = 'gii';\n\t\tfileObject.fileinfo = {};\n\n\t\tvar Labels;\n\n\t\tif (label)\n\t\t{\n\t\t\tif (label.key != undefined) // thats a single label\n\t\t\t{\n\t\t\t\tlabel.surfacereference = fileObject;\n\t\t\t\tLabels = parseInt(label.key);\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tLabels = label;\n\t\t\t}\n\t\t}\n\t\t\n\t\tthat.progressSpinner(\"creating isosurface\");\n\t\n\t\tthat.computeIsoSurf2(fileObject,Labels,that.progressSpinner,function()\n\t\t{\n\n\t\t\tKViewer.dataManager.setFile(fileObject.fileID,fileObject);\n\t\t\tKViewer.cacheManager.update();\n\n\t\t\tKViewer.obj3dTool.addObject(fileObject);\n\n\t\t\tif (!that.enabled)\n\t\t\t\t KViewer.obj3dTool.$toggle.trigger(\"click\");\t\t\n\n\t\t\tthat.progressSpinner();\n\n\t\t\tif (ondone)\n\t\t\t\tondone(fileObject);\n\t\t});\n\n\n\t}\n\n\n\n\n\n\n\n\t\tfunction smooth(verts,trigs)\n\t\t{\n\t\t\tvar verts_sm = new Float32Array(verts.length);\n\t\t\tvar ncnt = new Int32Array(verts.length/3);\n\t\t\tfor (var k=0;k<trigs.length/3;k++)\n\t\t\t\t{\n\t\t\t\t\tvar v = [0,0,0];\n\t\t\t\t\tfor (var j = 0; j < 3;j++)\n\t\t\t\t\t{\t\t\t\t\n\t\t\t\t\t\tfor (var i = 0; i < 3; i++)\n\t\t\t\t\t\t   v[i] += verts[3*trigs[3*k+j]+i]*0.3333;\n\t\t\t\t\t}\n\t\t\t\t\tfor (var j = 0; j < 3;j++)\n\t\t\t\t\t{\t\t\t\t\n\t\t\t\t\t\tfor (var i = 0; i < 3; i++)\n\t\t\t\t\t\t   verts_sm[3*trigs[3*k+j]+i] += v[i];\n\t\t\t\t\t\tncnt[trigs[3*k+j]]++;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\tfor (var k = 0; k < verts.length/3;k++)\n\t\t\t{\n\t\t\t\tverts_sm[3*k] /= ncnt[k];\n\t\t\t\tverts_sm[3*k+1] /= ncnt[k];\n\t\t\t\tverts_sm[3*k+2] /= ncnt[k];\n\t\t\t}\n\t\t\treturn verts_sm;\n\t\t}\n\n\n\n\n\tthat.computeIsoSurf2 = function(fobj,label,progress,done)\n\t{\n\n\n\t\tif (fobj.cache == undefined)\n\t\t\tfobj.cache = {};\n\n\t\tvar key = JSON.stringify(fobj.content.nifti.currentTimePoint) \n\n\t\tif (fobj.cache[key] != undefined && !(fobj.filename && fobj.filename.search(\"pointROI\")>-1 ))\n\t\t{\n\n            if (fobj.changed)  \n            {\n            \tif (fobj.changed && fobj.content.nifti.currentTimePoint &&\n             \t fobj.changed[fobj.content.nifti.currentTimePoint.t] == undefined)\n            \t {\n     \t\t\t\t$.extend(fobj.content,fobj.cache[key] );\n\t  \t\t\t\tdone(fobj);\n\t\t\t\t\treturn;\n            \t }\n            \t else\n                    fobj.changed[fobj.content.nifti.currentTimePoint.t] = undefined;\n            \t \n            }          \n\t\t\telse if (fobj.cache[key].last_label == JSON.stringify(label))\n\t\t\t{\n\t\t\t\t$.extend(fobj.content,fobj.cache[key] );\n\t\t\t\tdone(fobj);\n\t\t\t\treturn;\n\t\t\t}\n\n\n\t\t}\n\n\t\texecuteImageWorker.createIsoSurf_running = true\n\n\t\tprogress(\"creating isosurface\");\n\t\tvar worker = executeImageWorker({func:'createISOSurf', \n\t\t\t\tdata:fobj.content.nifti.data,\n\t\t\t\tsizes:fobj.content.nifti.sizes,\n\t\t\t\tedges:fobj.content.nifti.edges,\n\t\t\t\tcurrentTimePoint:fobj.content.nifti.currentTimePoint,\n\t\t\t\tdetsign:fobj.content.nifti.detsign,\n\t\t\t\tlabel:label\n\n\t\t},[],\n\t\t\tfunction(e)\n\t\t\t{\n\t\t\t\tif (progress)\n\t\t\t\t\tprogress(e);\n\t\t\t}\n\t\t\t,\n\t\t\tfunction(e)\n\t\t\t{\n\t\t\t\tif (progress)\n\t\t\t\t\tprogress(); \n        \t\texecuteImageWorker.createIsoSurf_running = undefined\n\t\t\t\t\t\n\t\t\t\t$.extend(fobj.content,e.execObj);\n\t\t\t\tfobj.cache[key] = e.execObj;\n\t\t\t\tfobj.cache[key].last_label = JSON.stringify(label);\n\t\t\t\tdone(fobj);\n\n\t\t\t}\n\t\t\t);\n\n\t\treturn worker;\n\n\n\t}\n\n/*\n\n\tthat.computeIsoSurf = function(fobj,label)\n\t{\n\n\t\tvar nii = fobj.content.nifti;\n\t\tvar data = nii.data;\n\t\tvar sizes = nii.sizes;\n\n\t\tvar w = sizes[0];\n\t\tvar h = sizes[1];\n\t\tvar d = sizes[2];\n\t\tvar wh = sizes[0]*sizes[1];\n\n\n\t\tvar cnt = 0;\n\t\tvar vertsIDX = [];\n\t\tfunction addVert(i)\n\t\t{\n\t\t\tif (vertsIDX[i] == undefined)\n\t\t\t{\n\t\t\t\tvertsIDX[i] = cnt;\n\t\t\t\tcnt++;\n\t\t\t\treturn cnt-1;\n\t\t\t}\t\t\n\t\t\telse\n\t\t\t\treturn vertsIDX[i];\n\t\t}\n\t\tvar trigs = [];\n\t\tvar addTrigs;\n\t\tif (nii.detsign == -1)\n\t\t\taddTrigs = function( i00,i10,i11,i01)\n\t\t\t\t{\n\t\t\t\t\ttrigs.push(i00,i10,i11,i00,i11,i01);\n\t\t\t\t}\n\t\telse\n\t\t\taddTrigs = function( i00,i10,i11,i01)\n\t\t\t\t{\n\t\t\t\t\ttrigs.push(i00,i01,i11,i00,i11,i10);\n\t\t\t\t}\n\t\t\n\n\t\tvar compfun = function(x) { return x>0 }\n\t\tvar negcompfun = function(x) { return x==0 }\n\t\tif (label)\n\t\t{\n\t\t\tvar key = parseInt(label.key);\n\t\t\tcompfun = function(x) {\n\t\t\t\treturn x==key;\n\t\t\t}\n\t\t\tnegcompfun = function(x) {\n\t\t\t\treturn x!=key;\n\t\t\t}\n\t\t}\n\t\t\t \n\t\t\n\n\t\tfor (var z = 1; z < sizes[2]-1;z++)\n\t\tfor (var y = 1; y < sizes[1]-1;y++)\n\t\tfor (var x = 1; x < sizes[0]-1;x++)\n\t\t{\n\t\t\tvar idx = z*wh + w*y + x;\n\t\t\tif (compfun(data[idx] > 0))\n\t\t\t{\n\t\t\t\tvar i00,i10,i01,i11;\n\t\t\t\tif (negcompfun(data[idx-1]))\n\t\t\t\t{\n\t\t\t\t\ti00 = addVert(idx);\n\t\t\t\t\ti10 = addVert(idx+w);\n\t\t\t\t\ti11 = addVert(idx+w+wh);\n\t\t\t\t\ti01 = addVert(idx+wh);\n\t\t\t\t\taddTrigs(i00,i01,i11,i10);\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif (negcompfun(data[idx+1]))\n\t\t\t\t{\n\t\t\t\t\ti00 = addVert(idx+1);\n\t\t\t\t\ti10 = addVert(idx+1+wh);\n\t\t\t\t\ti11 = addVert(idx+1+w+wh);\t\t\t\t\t\n\t\t\t\t\ti01 = addVert(idx+1+w);\n\t\t\t\t\taddTrigs(i00,i01,i11,i10);\n\t\t\t\t}\n\n\t\t\t\tif (negcompfun(data[idx-w]))\n\t\t\t\t{\n\t\t\t\t\ti00 = addVert(idx);\n\t\t\t\t\ti10 = addVert(idx+1);\n\t\t\t\t\ti11 = addVert(idx+1+wh);\n\t\t\t\t\ti01 = addVert(idx+wh);\n\t\t\t\t\taddTrigs(i00,i10,i11,i01);\n\t\t\t\t} \n\t\t\t\tif (negcompfun(data[idx+w]))\n\t\t\t\t{\n\t\t\t\t\ti00 = addVert(idx+w);\n\t\t\t\t\ti10 = addVert(idx+w+wh);\n\t\t\t\t\ti11 = addVert(idx+w+1+wh);\t\t\t\t\t\n\t\t\t\t\ti01 = addVert(idx+w+1);\n\t\t\t\t\taddTrigs(i00,i10,i11,i01);\n\t\t\t\t}\n\n\t\t\t\tif (negcompfun(data[idx-wh]))\n\t\t\t\t{\n\t\t\t\t\ti00 = addVert(idx);\n\t\t\t\t\ti10 = addVert(idx+w);\n\t\t\t\t\ti11 = addVert(idx+w+1);\n\t\t\t\t\ti01 = addVert(idx+1);\n\t\t\t\t\taddTrigs(i00,i10,i11,i01);\n\t\t\t\t} \n\t\t\t\t\n\t\t\t\tif (negcompfun(data[idx+wh]))\n\t\t\t\t{\n\t\t\t\t\ti00 = addVert(idx+wh);\n\t\t\t\t\ti10 = addVert(idx+wh+1);\n\t\t\t\t\ti11 = addVert(idx+wh+w+1);\t\t\t\t\t\n\t\t\t\t\ti01 = addVert(idx+wh+w);\n\t \t\t\t\taddTrigs(i00,i10,i11,i01);\n\t\t\t\t}\n\t\t\t}\n\n\t\t}\n\n\n\t\tvar pts = Object.keys(vertsIDX);\n\t\tvar verts = new Float32Array(pts.length*3);\n\t\tfor (var k = 0; k < pts.length;k++)\n\t\t{\n\t\t\tvar x = pts[k]%w -0.5;\n\t\t\tvar y = math.floor(pts[k]/w)%h -0.5;\n\t\t\tvar z = math.floor(pts[k]/wh) -0.5;\n\t\t\tvar v = math.multiply(nii.edges,[x,y,z,1])._data;\n\t\t\tvar i = vertsIDX[pts[k]];\n\t\t\tverts[3*i] = v[0];\n\t\t\tverts[3*i+1] = v[1];\n\t\t\tverts[3*i+2] = v[2];\n\t\t}\n\n\t   verts = smooth(verts,trigs);\n\t    verts = smooth(verts,trigs);\n\t    verts = smooth(verts,trigs);\n\t \n\n\n\t\tvar normal = new Float32Array(trigs.length);\n\t    for (var k=0;k<trigs.length/3;k++)\n\t\t\t{\n\t\t\t\tvar t1 = trigs[3*k];\n\t\t\t\tvar t2 = trigs[3*k+1];\n\t\t\t\tvar t3 = trigs[3*k+2];\n\n\t\t\t\tvar a = [verts[3*t1+0],verts[3*t1+1],verts[3*t1+2]]\n\t\t\t\tvar b = [verts[3*t2+0],verts[3*t2+1],verts[3*t2+2]]\n\t\t\t\tvar c = [verts[3*t3+0],verts[3*t3+1],verts[3*t3+2]]\n\t\t\t\tvar n =     [(b[1]-a[1])*(c[2]-a[2]) - (b[2]-a[2])*(c[1]-a[1]), \n\t\t\t\t\t\t\t (b[2]-a[2])*(c[0]-a[0]) - (b[0]-a[0])*(c[2]-a[2]),\n\t\t\t\t\t\t\t (b[0]-a[0])*(c[1]-a[1]) - (b[1]-a[1])*(c[0]-a[0])];\n\n\t\t\t\tfor (var j=0;j<3;j++)\n\t\t\t\t{\t\n\t\t\t\t\tnormal[3*trigs[3*k+j]+0] -= n[0];\n\t\t\t\t\tnormal[3*trigs[3*k+j]+1] -= n[1];\n\t\t\t\t\tnormal[3*trigs[3*k+j]+2] -= n[2];\n\t\t\t\t}\n\t\t\t}\n\n\n\t\tvar c = fobj.content;\n\t\tc.points = verts;\n\t\tc.indices = trigs;\n\t\tc.normals = normal;\n\n\n\t}*/\n\n\n  /***************************************************************************************\n   *  unpacking/reading of Surface data\n   ****************************************************************************************/\n\n\tthat.prepareSurfaceData = function(fileObject,uint8Response,processinfo,arrived)\n\t{\n\t\tif (fileObject.filename.search(\"\\\\.gii\") > -1)\n\t\t{\n\n\t\t    var scriptname = 'gifti-reader-min.js' + '?' +  static_info.softwareversion;\n\n\t\t\tscriptLoader.loadScript(scriptname, function() {\n\n\t\t\tvar gii = gifti.parse(ab2str(uint8Response));\n\t\t\tfileObject.content = {gifti:gii,buffer:uint8Response.buffer };\n\t\t\tvar c = fileObject.content;\n\t\t\tc.points = gii.getPointsDataArray();\n\n\t\t\tvar max = [-99999,-99999,-99999];\n\t\t\tvar min = [99999,99999,99999];\n\n\t\t\tif (c.points != null) c.points = c.points.getData();\n\t\t\tfor (var k = 0;k < c.points.length/3;k++)\n\t\t\t{\n\t\t\t\tfor (var j=0; j < 3;j++)\n\t\t\t\t{\n\t\t\t\t\tif (c.points[k*3+j] > max[j])\n\t\t\t\t\t\tmax[j] = c.points[k*3+j];\n\t\t\t\t\tif (c.points[k*3+j] < min[j])\n\t\t\t\t\t\tmin[j] = c.points[k*3+j];\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tc.max = max;\n\t\t\tc.min = min;\n\n\n\n\n\n\t\t\tc.indices = gii.getTrianglesDataArray();\n\t\t\tif (c.indices != null) c.indices = c.indices.getData();\n\t\t\tc.normals = gii.getNormalsDataArray();\n\t\t\tif (c.normals != null) c.normals= c.normals.getData();\n\t\t\telse\n\t\t\t{\n\t\t\t\tc.normals = new Float32Array(c.points.length)\n\t\t\t\tfor (var k = 0;k < c.indices.length/3;k++)\n\t\t\t\t{\n\t\t\t\t\tvar a = [c.points[3*c.indices[3*k]],c.points[3*c.indices[3*k]+1],c.points[3*c.indices[3*k]+2]];\n\t\t\t\t\tvar b = [c.points[3*c.indices[3*k+1]],c.points[3*c.indices[3*k+1]+1],c.points[3*c.indices[3*k+1]+2]];\n\t\t\t\t\tvar d = [c.points[3*c.indices[3*k+2]],c.points[3*c.indices[3*k+2]+1],c.points[3*c.indices[3*k+2]+2]];\n\t\t\t\t\tvar n =     [(b[1]-a[1])*(d[2]-a[2]) - (b[2]-a[2])*(d[1]-a[1]), \n\t\t\t\t\t\t\t\t (b[2]-a[2])*(d[0]-a[0]) - (b[0]-a[0])*(d[2]-a[2]),\n\t\t\t\t\t\t\t\t (b[0]-a[0])*(d[1]-a[1]) - (b[1]-a[1])*(d[0]-a[0])];\n\t\t\t\t\tfor (var j=0;j<3;j++)\n\t\t\t\t\t{\t\n\t\t\t\t\t\tc.normals[3*c.indices[3*k+j]+0] += n[0];\n\t\t\t\t\t\tc.normals[3*c.indices[3*k+j]+1] += n[1];\n\t\t\t\t\t\tc.normals[3*c.indices[3*k+j]+2] += n[2];\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tfor (var k = 0; k < c.normals.length/3;k++)\n\t\t\t\t{\n\t\t\t\t\tvar no = math.sqrt(c.normals[3*k]*c.normals[3*k] +c.normals[3*k+1]*c.normals[3*k+1] +c.normals[3*k+2]*c.normals[3*k+2]);\n\t\t\t\t\tc.normals[3*k] /= no;\n\t\t\t\t\tc.normals[3*k+1] /= no;\n\t\t\t\t\tc.normals[3*k+2] /= no;\n\n\t\t\t\t}\n\n\t\t\t}\n\t\t\tc.colors = gii.getColorsDataArray();\n\t\t\tif (c.colors != null) c.colors= c.colors.getData();\n\t\t\tif (arrived != undefined)\n\t\t\t\tarrived();\n\n\t\t\t});\n\t\t}\n\t\telse // a stl\n\t\t{\n\n\t\t\tfileObject.content = {buffer:uint8Response.buffer };\n\t\t\tvar c = fileObject.content;\n\n\t\t\tvar view = new DataView(uint8Response.buffer);\n\t\t\tvar LE = true;\n\t\t\tvar numTrigs = view.getUint32(80,LE);\n\t\t\tvar pos = 84;\n\n\t\t\tvar normals = [];\n\t\t\tvar indices = [];\n\t\t\tvar points = [];\n\t\t\tvar vals = [];\n\t\t\tvar bbox_max = [-10000,-10000,-10000];\n\t\t\tvar bbox_min = [10000,10000,10000];\n\t\t\t\n\t\t\tfor (var k = 0; k < numTrigs;k++)\n\t\t\t{\n\t\t\t\tvar n = [view.getFloat32(pos,LE),view.getFloat32(pos+4,LE),view.getFloat32(pos+8,LE)];\n\t\t\t\tnormals.push(n[0],n[1],n[2],n[0],n[1],n[2],n[0],n[1],n[2]);\n\t\t\t\tvar p1 = [view.getFloat32(pos+12,LE),view.getFloat32(pos+16,LE),view.getFloat32(pos+20,LE)];\n\t\t\t\tvar p2 = [view.getFloat32(pos+24,LE),view.getFloat32(pos+28,LE),view.getFloat32(pos+32,LE)];\n\t\t\t\tvar p3 = [view.getFloat32(pos+36,LE),view.getFloat32(pos+40,LE),view.getFloat32(pos+44,LE)];\n\t\t\t\tpoints.push(p1[0],p1[1],p1[2]);\n\t\t\t\tpoints.push(p2[0],p2[1],p2[2]);\n\t\t\t\tpoints.push(p3[0],p3[1],p3[2]);\n\t\t\t\tfor (var i = 0 ; i < 3;i++)\n\t\t\t\t{\n\t\t\t\t\tbbox_max[i] = math.max(bbox_max[i],p1[i]);\n\t\t\t\t\tbbox_max[i] = math.max(bbox_max[i],p2[i]);\n\t\t\t\t\tbbox_max[i] = math.max(bbox_max[i],p3[i]);\n\t\t\t\t\tbbox_min[i] = math.min(bbox_min[i],p1[i]);\n\t\t\t\t\tbbox_min[i] = math.min(bbox_min[i],p2[i]);\n\t\t\t\t\tbbox_min[i] = math.min(bbox_min[i],p3[i]);\n\t\t\t\t}\n\t\t\t\tindices[3*k] = 3*k;\n\t\t\t\tindices[3*k+1] = 3*k+1;\n\t\t\t\tindices[3*k+2] = 3*k+2;\n\t\t\t\tvals.push(view.getUint16(pos+48,LE))\n\n\t\t\t\tpos += 50;\n\t\t\t}\n\n\n\t\t    c.points = new Float32Array(points);\n\t\t    c.normals = new Float32Array(normals);\n\t\t    c.indices = new Int32Array(indices);\n\t\t    c.vals = new Uint16Array(vals);\n\n\n\t\t\tvar minmax = getMinMax(c.vals,c.vals.length,500);\n\t\t\tc.histogram = comphisto(minmax.min,minmax.max,20,c.vals,c.vals.length,500);\n\n\t\t\tif (Math.abs(minmax.min-minmax.max) < 0.0000000001)\n\t\t\t\tc.vals = undefined;\n\n\t\t    c.max = bbox_max;\n\t\t    c.min = bbox_min;\n\n\t\t\tif (arrived != undefined)\n\t\t\t\tarrived();\n\n\n\t\t}\n\n\t}\t\t\n\n\n\n\n   that.prepareConmatData = function(fileObject,processinfo,arrived)\n   {\n\t\tfileObject.content= JSON.parse(fileObject.content);\n\n\t\tfileObject.content.themat = fileObject.content.cc;\n\n\t\tif (fileObject.content.themat.length > 0)\n\t\t{\n\t\t\tvar m = fileObject.content.themat[0].length;\n\t\t\tvar ac;\n\t\t\tif (m>1)\n\t\t\t\tac = fileObject.content.themat.reduce(function(a, b) {\n\t\t\t\t\t\t  return a.concat(b);\n\t\t\t\t\t\t});\n\t\t\telse \n\t\t\t{\n\t\t\t\tac = fileObject.content.themat.slice(0);\n\t\t\t\tfileObject.content.themat = [ac];\n\t\t\t}\n\n\n\n\t\t\tvar n = ac.length;\n\n\t\t\tvar ac_minmax = getMinMax(ac,n,500);\n\t\t\tfileObject.histogram = comphisto(ac_minmax.min,ac_minmax.max,20,ac,n,500);\n\t\t}\n\t\telse\n\t\t\t\talertify.error(\"Problem while reading connectivty matrix\");\n\t\t\n\t\tprocessinfo();\n\t\tarrived();\n\n\n   }\n\n\n\n\n  /***************************************************************************************\n   *  unpacking/reading of Fiber data\n   ****************************************************************************************/\n\n\tthat.prepareFiberData = function(fileObject,uint8Response,processinfo,arrived)\n\t{\n\n\t\tif (fileObject.filename.search('.tck') > 0)\n\t\t{      \t\n\t\t   that.importandbuildOcttree(fileObject,uint8Response,processinfo, arrived,\"TCK\")\n\t\t}\n\t\telse if (fileObject.filename.search('.trk') > 0)\n\t\t{      \t\n\t\t   that.importandbuildOcttree(fileObject,uint8Response,processinfo, arrived,\"TRK\")\n\t\t}\n\t\t/*\n\t\tif (fileObject.filename.search('.tck') > 0)\n\t\t{      \t\n\n\t\t   importTCK(fileObject,uint8Response,processinfo, \n\t\t   function()\n\t\t   {\n\t\t\t   if (fileObject.content != undefined)\n\t\t\t   {\n\t\t\t\t fileObject.content.md5 = SparkMD5.ArrayBuffer.hash(uint8Response.buffer);\n\t\t\t\t that.buildOctree(fileObject.content,processinfo);\t\t\t\t \n\t\t\t   }\n\t\t\t   arrived();\n\t\t   });\n\t\t}\n\t\telse if (fileObject.filename.search('.trk') > 0)\n\t\t{      \t\n\n\t\t   importTRK(fileObject,uint8Response,processinfo, \n\t\t   function()\n\t\t   {\n\t\t\t   if (fileObject.content != undefined)\n\t\t\t   {\n\t\t\t\t fileObject.content.md5 = SparkMD5.ArrayBuffer.hash(uint8Response.buffer);\n\t\t\t\t that.buildOctree(fileObject.content,processinfo);\t\t\t\t \n\t\t\t   }\n\t\t\t   arrived();\n\t\t   });\n\t\t}*/\n\t}\n\n\n\tthat.importandbuildOcttree = function(fileObject,uint8Response,processinfo,arrived,typ)\n\t{\n\t\t    var scriptname = 'KTools/KOctreeImportWorker.js' + '?' +  static_info.softwareversion;;\n\t\t\tif (typeof url_pref != \"undefined\")\n\t\t\t   scriptname = url_pref + scriptname;\n\n\t\t\tvar worker = new Worker(scriptname);\n\t\t\tfileObject.octreeWorker = worker;\n\t\n\t\t\tworker.queryInProgress = false;\n\t\t\tworker.ready = false;\n\t\t\tworker.postMessage = worker.webkitPostMessage || worker.postMessage;\n\t\t\tworker.addEventListener('message', function(e) {\n\t\t\t\te = e.data;\n\t\t\t\tif (e.msg == 'index_progress')\n\t\t\t\t{\n\t\t\t\t\tprocessinfo(e.detail);\n\t\t\t\t\tif (e.detail == undefined)\n\t\t\t\t\t\tworker.ready = true;\n\t\t\t\t\tworker.queryInProgress = false;\n\t\t\t\t}\n\t\t\t\telse if (e.msg == 'query_done')\t\t\t\n\t\t\t\t{\n\t\t\t\t\tworker.queryInProgress = false;\n\t\t\t\t\tworker.currentCallback(e.selection);\n\t\t\t\t}\n\t\t\t\telse if (e.msg == 'import_done')\t\t\t\n\t\t\t\t{\n\t\t\t\t\tworker.queryInProgress = false;\n\t\t\t\t\tvar content = e.tracts;\t\t\t\t\t\n                    KObject3DTool.unpackTracts(content);\n                    content.octreeWorker = worker;\n \t\t\t\t    fileObject.content = content;                    \n                    fileObject.content.md5 = e.md5;\n\t\t\t\t\tarrived(content)\n\t\t\t\t}\n\t\t\t\telse if (e.msg == 'import_failed')\t\t\t\n\t\t\t\t{\n    \t\t\t\tworker.postMessage({message:'kill'},[]);\n\t\t\t\t\tarrived()\n\t\t\t\t}\n\t\t\t}, false);\n\n\t\t\tworker.postMessage({message:'import',typ:typ,buffer: uint8Response },[uint8Response.buffer]);\n\t\n\t\t\tworker.kill = function()\n\t\t\t{\n\t\t\t\tworker.postMessage({message:'kill'},[]);\n\n\t\t\t}\n\n\t\t\tworker.queue = [];\n\n\t\t\tworker.findFibers = function (p,r,d,callback,force)\n\t\t\t{\n\n\t\t\t\tif (!worker.queryInProgress | force)\n\t\t\t\t\tlaunch()\n\t\t\t\n\t\t\t\tfunction launch()\n\t\t\t\t{\n\t\t\t\t\tworker.postMessage({message:'query', query:p,radius:r,dirsel:d,qid:worker.currentQueryID},\t\t[]);\n\t\t\t\t\tworker.currentCallback = callback;\n\t\t\t\t\tworker.queryInProgress = true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t}\n    \n\n\n\tthat.buildOctree = function(tracking,processinfo)\n\t{\n\t\tif (KObject3DTool.useOctreeWorker)\n\t\t{\n\t\t    var scriptname = 'KTools/KOctreeWorker.js' + '?' +  static_info.softwareversion;;\n\t\t\tif (typeof url_pref != \"undefined\")\n\t\t\t   scriptname = url_pref + scriptname;\n\n\t\t\tvar worker = new Worker(scriptname);\n\t\t\ttracking.octreeWorker = worker;\n\t\t\tworker.queryInProgress = false;\n\t\t\tworker.ready = false;\n\t\t\tworker.postMessage = worker.webkitPostMessage || worker.postMessage;\n\t\t\tworker.addEventListener('message', function(e) {\n\t\t\t\te = e.data;\n\t\t\t\tif (e.msg == 'index_progress')\n\t\t\t\t{\n\t\t\t\t\tprocessinfo(e.detail);\n\t\t\t\t\tif (e.detail == undefined)\n\t\t\t\t\t\tworker.ready = true;\n\t\t\t\t\tworker.queryInProgress = false;\n\t\t\t\t}\n\t\t\t\telse if (e.msg == 'query_done')\t\t\t\n\t\t\t\t{\n\t\t\t\t\tworker.queryInProgress = false;\n\t\t\t\t\tworker.currentCallback(e.selection);\n\t\t\t\t}\n\t\t\t}, false);\n\n\t\t\tworker.postMessage({message:'createOctree',\n\t\t\ttracts: KObject3DTool.packTractsForTransfer({content:tracking}) },\t\t[]);\n\t\n\t\t\tworker.kill = function()\n\t\t\t{\n\t\t\t\tworker.postMessage({message:'kill'},[]);\n\n\t\t\t}\n\n\t\t\tworker.queue = [];\n\n\t\t\tworker.findFibers = function (p,r,d,callback,force)\n\t\t\t{\n\t\t\t/*\tworker.queue.push(launch);\n\n\t\t\t\tvar toexec = worker.queue[0];\n\t\t\t\tworker.queue.splice(0,1);\n\t\t\t\t\n\t\t\t\tif (!worker.queryInProgress)\n\t\t\t\t\ttoexec();\n*/\n\n\t\t\t\tif (!worker.queryInProgress | force)\n\t\t\t\t\tlaunch()\n\t\t\t\n\t\t\t\tfunction launch()\n\t\t\t\t{\n\t\t\t\t\tworker.postMessage({message:'query', query:p,radius:r,dirsel:d,qid:worker.currentQueryID},\t\t[]);\n\t\t\t\t\tworker.currentCallback = callback;\n\t\t\t\t\tworker.queryInProgress = true;\n\t\t\t\t}\n\n\t\t\t}\n\n\t\t}\n\t\telse\n\t\t{\n\t\t\t var tracts = tracking.tracts;\t\t\n\t\t\t var octree = tracking.octree;\n\n\n\t\t\t myOctree.fiberstep = math.floor(tracking.tot_points/5000000);\n\t\t\t if (myOctree.fiberstep < 1) \n\t\t\t\tmyOctree.fiberstep = 1;\n\n\n\t\t\t tracts.chunk( function(t,j){\t\t \t\n\t\t\t\toctree.add(t,j);\t\t\t\n\t\t\t },512, 1, function(i) {\n\t\t\t\tprocessinfo(\"building octree \" + Math.round(100*i/tracts.length) + \"%\");} ,\n\t\t\t\tfunction() {processinfo(undefined)} );\n\t\t}\n\n\t}\n\n\n\n  /***************************************************************************************\n   *  SubView creation\n   ****************************************************************************************/\n\n\n    that.createView = function(imageStruct,viewer,intent)\n    {\n       var fobj = imageStruct;\n\t   if (imageStruct.contentType == 'tracts')\n\t   {\n\t   \t\tvar parent_view;\n\t   \t\tif (intent.jsonsubsets)\n\t   \t\t{\n\t   \t\t\tfobj.content.selections = intent.jsonsubsets.selections;\n\t   \t\t}\n\t   \t\tif (intent.select >= 0  || (typeof intent.select == 'string' && intent.select != 'allselections'  && intent.select != 'all'))\n\t\t\t{\n\t\t\t\tvar found = false;\t\t\t\t\n\t\t\t\tfor (var k = 0;k < viewer.objects3D.length;k++)\t\t\t\t\t\n\t\t\t\t\tif (viewer.objects3D[k].fibers && \n\t\t\t\t\t viewer.objects3D[k].fibers.fileID == fobj.fileID)\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tparent_view = viewer.objects3D[k];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t    if (!found)\n\t\t\t    {\n\t\t\t       parent_view = that.createFiberView(fobj,viewer,{isParentView:true})\n\t\t\t       parent_view.Selection = undefined;\n\t\t\t       viewer.objects3D.push(parent_view);\n\t\t\t    }\n\t\t\t}\n\t\t\telse\n\t\t\t\tintent.isParentView = true;\n\n\t\t\tintent.parent = parent_view;\n\n\t\t\tvar view = that.createFiberView(fobj,viewer,intent);\n\t\t\tif (!intent.isParentView)\n\t\t\t{\n\t\t\t\tview.parent = parent_view;\n\t\t\t\tif (parent_view.children == undefined)\n\t\t\t\t\tparent_view.children = [];\n\t\t\t\tparent_view.children.push(view);\n\t\t\t}\n\n\t\t\treturn view\n\t   }\n\t   else if (imageStruct.contentType == 'gii')\n\t\t\treturn that.createSurfaceView(fobj,viewer,intent);\n\t   else if (imageStruct.contentType == 'rtstruct')\n\t\t\treturn that.createContourView(fobj,viewer,intent);\n\t   else if (imageStruct.filename.search(\".cc.json\") != -1)\n\t\t\treturn that.createConmatView(fobj,viewer,intent);\n\t   else\n\t   {\n\t   \t\tconsole.log('contenttype unknown');\n\t   \t\treturn;\n\t   }       \n    }\n\n\n  /***************************************************************************************\n   *  The fiber SubView \n   ****************************************************************************************/\n\n\n    that.createFiberView = function(fobj,viewer,intent)\n        {\n            var viewer = viewer;\n            var alpha = 1;\n\t\t\tif (state.viewer.fiberAlpha)\n\t\t\t\talpha = 0.15;\n\n\n            var tck = { fibers:fobj,\n                        fiberUpdater:undefined,\n                        \n                        fibcut:-1,\n                        fibcut_thres:5,\n                        fibcut_proj:-1,\n\t\t\t\t\t\tcolor: (viewer.objects3D.length)%KColor.list.length,\n\t\t\t\t\t\talpha:alpha,\n\t\t\t\t\t\ttype:\"fiber\",\n\n\t\t\t\t\t\tannotation_subsets:{},\n\t\t\t\t\t\tassociated_annotation:-1,\n                        subsetToDisplay:undefined,\n                        fiberSign:undefined,\n                        Selection:{},\n                        children:[],\n\n                        viewer:viewer,\n\n\t\t\t\t\t\tuid: KObject3DTool.uidCnter++,\n                        isCurrent: false\n            };\n\n\t\t\ttck.getViewProperties = function()\n\t\t\t{\n\t\t\t\treturn {color:this.color,\n \t\t\t\t\t\tfibcut:this.fibcut,\n                        fibcut_thres:this.fibcut_thres,\n                        fibcut_proj:this.fibcut_proj,\n\t\t\t\t\t\talpha:this.alpha\n\t\t\t\t};\n\t\t\t}\n\t\t\tif (intent.isParentView && intent.dirvolref == undefined)\n\t\t\t\ttck.Selection = undefined;\n\n\t\t\tif (intent != undefined)\n\t\t\t{\t\t\t\n\t\t\t\tif (intent.dirvolref)\n\t\t\t\t{\n\t\t\t\t\tvar scale = intent.dirvolref.nii.voxSize[0];\n\t\t\t\t\tvar params = that.tracking_panel.params;\n\t\t\t\t\tparams.Jitter = scale / 40;\n\t\t\t\t\tparams.Stepwidth = scale / 5;\n\t\t\t\t\tthat.tracking_panel.update();\n\t\t\t\t\ttck.trackingVolHistoman = intent.dirvolref.histoManager;\n\t\t\t\t\ttck.trackingVol =  intent.dirvolref.nii\n\t\t\t\t\ttck.trackingVolID = intent.dirvolref.currentFileID\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\n\t\t\t\t\tif (intent.select != undefined && intent.select != 'all')\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tck.fibers.content.selections != undefined)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (typeof intent.select == 'string')\n\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t for (var k = 0; k < tck.fibers.content.selections.length;k++)\n\t\t\t\t\t\t\t\t\tif (tck.fibers.content.selections[k].name == intent.select)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tintent.select = k;\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\ttck.Selection = tck.fibers.content.selections[intent.select];\n\t\t\t\t\t\t\tif (tck.Selection != undefined)\n\t\t\t\t\t\t\t\ttck.subsetToDisplay = tck.Selection.subset;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\ttck.parent = intent.parent;\n\n\t\t\t\tif (intent.alpha != undefined) tck.alpha = intent.alpha;\n\t\t\t\tif (intent.fibcut != undefined) tck.fibcut = intent.fibcut;\n\t\t\t\tif (intent.fibcut_thres != undefined) tck.fibcut_thres = intent.fibcut_thres;\n\t\t\t\tif (intent.fibcut_proj != undefined) tck.fibcut_proj = intent.fibcut_proj;\n\t\t\t\tif (intent.isParentView != undefined) tck.isParentView = intent.isParentView;\n\t\t\t}\n\n\t\t\tvar fiberDirColor_shader = viewer.gl.createFiberShader()\n\t\t\tfiberDirColor_shader.setFloat(\"planesThres\",parseFloat(tck.fibcut_thres));   \t\n\t\t    fiberDirColor_shader.setFloat(\"planesNum\",tck.fibcut);\n\t\t\tfiberDirColor_shader.setFloat(\"alpha\",tck.alpha);\n\t\t\tfiberDirColor_shader.setFloat(\"planesProj\",tck.fibcut_proj);\n\t\t\ttck.fiberDirColor_shader = fiberDirColor_shader;\n\t\t\t\n\t\t\ttck.selectFibersReset =selectFibersReset;\n\t\t\tfunction selectFibersReset(str)\n\t\t\t{\n\t\t\t  \t  removeAnnotationAssoc();\n\t\t\t\t  tck.associated_annotation = -1;\n\t\t\t\t  tck.autogenerate_tracks = false;\n\t\t\t\t  if (str == 'all' || str == 'accumulate' )\n\t\t\t\t  {\n\t\t\t\t\t tck.subsetToDisplay = undefined;\n\n\t\t\t\t\t if (tck.Selection != undefined)\n\t\t\t\t\t {\n\t\t\t\t\t \tif (tck.Selection.subset != undefined)\n\t\t\t\t\t \t{\n\t\t\t\t\t\t\ttck.subsetToDisplay = tck.Selection.subset;\n\t\t\t\t\t\t\tviewer.statusbar.report(tck.subsetToDisplay.length + \" fibers shown\");\n\t\t\t\t\t \t}\t\t\t\t\n\t\t\t\t\t }\n\n\t\t\t\t\t if (tck.trackingVol != undefined)\n\t\t\t\t\t {\n\t\t\t\t\t \ttck.autogenerate_tracks = true;\n\t\t\t\t\t\tif (str == 'accumulate')\n\t\t\t\t\t\t\ttck.autogenerate_tracks = 2;\n\t\t\t\t\t }\n\n\n\t\t\t\t  }\n\t\t\t\t  else\n\t\t\t\t\t tck.subsetToDisplay = [];\n\t\t\t\t  tck.updateFibers();\n\t\t\t}\n\n\n\t\t\tfunction computeFiberMorphology(type)\n\t\t\t{\n\n\t  \t\t\t  var vismap =  cloneNifti(viewer.content,\"tmpvisit\",\"float\");\n\n\t\t\t\t  createFiberVisitMap(tck.fibers.content.tracts,tck.subsetToDisplay,-1,\n\t\t\t\t                      vismap,\n\t\t\t\t                      viewer.viewport.progressSpinner,\n\t\t\t\t  function()\n\t\t\t\t  {\n\t\t\t\t  \t  vismap.content = prepareMedicalImageData(parse(vismap.buffer), vismap, {});\n\t\t\t\t\t  if (type == \"dilate\")\n\t\t\t\t\t  {\n\t\t\t\t      \t  tck.subsetToDisplay = undefined;\n\t\t\t\t\t \t  selectFibersByROI(tck,vismap,false,0.6,0);\n\t\t\t\t\t  }\n\t\t\t\t\t  else if (type == \"erode\")\n\t\t\t\t\t  {\n\t\t\t\t\t \t  selectFibersByROI(tck,vismap,false,0.8,1.5);\t\t\t\t\t  \t\n\t\t\t\t\t  }\n\t\t\t\t\t  else\n\t\t\t\t\t  {\n\t\t\t\t      \t  tck.subsetToDisplay = undefined;\n\t\t\t\t\t \t  selectFibersByROI(tck,vismap,false,0.8,1.5);\n\t\t\t\t\t  }0.4\n\t\t\t\t\t\n\t\t\t\t  });\n\n\t\t\t}\n\n\t\t\t\n\t\t\t////////////// color context menu\n       \t    var colors = [\"dir\"];\n       \t    colors = colors.concat(KColor.list);\n\t\t\tvar $colselector = KColorSelector(colors,\t\n\t\t\t\t function(c) {\tif (c==\"dir\") return \"\"; else return \"background:\"+RGB2HTML(c[0],c[1],c[2])+\";\"; },\n\t\t\t\t function (col,colindex)\n\t\t\t\t {\n\t\t\t\t \tif (tck.Selection)\n\t\t\t\t \t\ttck.Selection.color = colindex;\n\t\t\t\t   viewer.gl.activateRenderLoop();\n                    fiberDirColor_shader.setFloat(\"alpha\",tck.alpha);\t\n                    if (col != undefined)\n                    {\t\t\t\t\t\n\t\t\t\t\t\tif (col == 'dir')\n\t\t\t\t\t\t\tfiberDirColor_shader.setVector4(\"col\",new BABYLON.Vector4(0,0,0,0));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tfiberDirColor_shader.setVector4(\"col\",new BABYLON.Vector4(col[0]/255,col[1]/255,col[2]/255,1));\n                    }\n\n\t\t\t\t\tif (tck.fiberUpdater && tck.fiberUpdater.nicefibs!= undefined)\n\t\t\t\t\t\ttck.showNiceFibs();\n\n\t\t\t\t },\n\t\t\t\t tck);\n\n\t\t\tif (intent != undefined && intent.color != undefined)\n\t\t\t{\n\t\t\t\ttck.color = intent.color%colors.length ;\n\t\t\t\tif (tck.Selection)\n\t\t\t\t\ttck.Selection.color = tck.color;\n\t\t\t\t$colselector.updateColor();\n\t\t\t}\n\n\n\n\t\t    /***************************************************************************************\n\t\t     *  fiber selection context menu \n\t\t     ****************************************************************************************/\n\t\t\t \n\t\t\t tck.fiberSelAction = fiberSelAction;\n \t\t\t function fiberSelAction(str)\n\t\t\t  {\n\t\t\t\t//console.log(tck);\n\t\t\t\t  if (str == '' | str == undefined)\n\t\t\t\t\treturn;\n\t\t\t\t  else if (str == 'all' | str == 'none')\n\t\t\t\t  {\n\t\t\t\t\tselectFibersReset(str)\n\t\t\t\t  }  \n\t\t\t\t  else if (str == 'fiberode')\n\t\t\t\t  {\n\t\t\t\t\tcomputeFiberMorphology(\"erode\");\n\t\t\t\t  }\n\t\t\t\t  else if (str == 'fibdilate')\n\t\t\t\t  {\n\t\t\t\t\tcomputeFiberMorphology(\"dilate\");\n\t\t\t\t  }\n\t\t\t\t  else if (str == 'fibclose')\n\t\t\t\t  {\n\t\t\t\t\tcomputeFiberMorphology(false);\n\t\t\t\t  }\n\t\t\t\t  else if (str == 'trackparams')\n\t\t\t\t  {\n\t\t\t\t  \tthat.tracking_panel.toggle();\n\t\t\t\t  }\n\t\t\t\t  else if (str.substring(0,4) == 'ROI_' | str.substring(0,9) == 'minusROI_' )\n\t\t\t\t  {\n\n\t\t\t\t\t  var minus = false;\n\t\t\t\t\t  if (str.substring(0,5) == 'minus') { str =  str.substring(5); minus = true; }\n\t\t\t\t\t  var roi = KViewer.roiTool.ROIs[str.substring(4)];\n\n\t\t\t\t\t  alertify.prompt(\"Minimal overlap of streamline with ROI in percent (0 - at least one vertex touches)\", function(e,str)\t\n\t\t\t\t\t  {\t\t\t\t\n\t\t\t\t\t\tif (e)\n\t\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t\t\tvar percentage = parseFloat(str)/100;\n\t\t\t\t\t\t\tselectFibersByROI(tck,roi,minus,percentage)\n\t\t\t\t\t\t}\n\t\t\t\t\t  },\"0\");\n\t\t\t\t  }\n\t\t\t\t  else if (str.substring(0,8) == 'seedROI_' )\n\t\t\t\t  {\n\t\t\t\t\t  var roi = KViewer.roiTool.ROIs[str.substring(8)];\n\n\t\t\t\t\t  var ret = tck.fiberTracking({roi:roi});\n\t\t\n\t\t\t\t\t  tck.fibers.content = ret;\n\t\t\t\t\t  tck.subsetToDisplay = undefined;\n\t\t\t\t\t  tck.updateFibers();\n\t\t\t\t\t\t\t\t\t  \n\n\n\t\t\t\t  }\n\t\t\t\t  else if (str.substring(0,5) == 'WMQL_' )\n\t\t\t\t  {\n\t\t\t\t\tsetAnnotationAssoc(-1);\n\t\t\t\t\tif (!KWMQLPanel.visible)\n\t\t\t\t\t{\n\t\t\t\t\t\t var atlas = KViewer.atlasTool.objs[str.substring(5)];\n\t\t\t\t\t\t KWMQLPanel.openPanel(tck.fibers,atlas);\n\t\t\t\t\t}\n\t\t\t\t  }\n\t\t\t\t  else if (str == \"selectbymarker\" )\n\t\t\t\t  {\n\t\t\t\t\tif (markerProxy.currentSet == undefined)\n\t\t\t\t\t\tKMarkerPanel_points();\n\t\t\t\t\tsetAnnotationAssoc(markerProxy.currentSet.uuid);\n\t\t\t\t\tmarkerProxy.currentSet.showPanel()\n\t\t\t\t\tif (!tck.isCurrent)\n\t\t\t\t\t    makeCurrent();\n\t\t\t\t  }\n\t\t\t\t  else if (str == \"deselectbymarker\" )\n\t\t\t\t  {\n\t\t\t\t  \tselectFibersReset('all')\n\t\t\t\t  }\n\t\t\t\t  else if (str == \"genmarkersels\" )\n\t\t\t\t  {\n\t\t\t\t  \t\n\t\t\t\t\tvar keys = Object.keys(markerProxy.markersets);\n\t\t\t\t\ttck.viewer.viewport.progressSpinner(\"processing\");\t\t\t\t\t\n\t\t\t\t\titerate(0);\n\t\t\t\t\tfunction iterate(k)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar mset = markerProxy.markersets[keys[k]];\t\n\t\t\t\t\t\tif (mset == undefined)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsetAnnotationAssoc(-1);\n\t\t\t\t\t\t\ttck.viewer.viewport.progressSpinner();\t\t\t\t\t\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsetAnnotationAssoc(mset.uuid,function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tcloneFibs(mset.name);\n\t\t\t\t\t\t\titerate(k+1);\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\n\t\t\t\t  }\n\t\t\t\t  /*\n\t\t\t\t  else\n\t\t\t\t\t  setAnnotationAssoc(str);\t\t\t\t\t  \t  \t\t\t\t\t  \t  */\n\t\t\t  }\n\n\t\t\t var $fiberpickselector = $(\"<div  class='KViewPort_tool fibers' >  <i   class='fa fa-comment-o fa-1x'></i></div>\");\n\t\t\t var fibpick_contextmenu = new KContextMenu(\n\t\t\t\t  function() { {\n\t\t\t\t\t var $menu = $(\"<ul class='menu_context'>\");\n\t\t\t\t\t if (tck.trackingVol == undefined)\n\t\t\t\t\t {\n\t\t\t\t\t\t $menu.append($(\"<li  onchoice='fibdilate' > fiber dilation   </li>\"));\n\t\t\t\t\t\t $menu.append($(\"<li  onchoice='fibclose' > fiber closure   </li>\"));\n\t \t\t\t\t\t $menu.append($(\"<li  onchoice='fiberode' > fiber erosion   </li>\"));\n\t\t\t\t\t }\n \t\t\t\t\t if (tck.trackingVol != undefined)\n \t\t\t\t\t {\n\t\t\t\t\t\t $menu.append($(\"<hr width='100%'> \")); \t\t\t\t\t \n \t\t\t\t     \t $menu.append($(\"<li onchoice='trackparams' > tracking parameters   </li>\"));\n \t\t\t\t\t }\n \t\t\t\t\t var sets = markerProxy.getSets();\n\n\t\t\t\t\t $menu.append($(\"<hr width='100%'> \")); \t\t\t\t\t \n\t\t\t\t\t var cur = tck.viewer.getCurrentFiberView() || tck;\n\t\t\t\t\t if (cur != undefined)\n\t\t\t\t\t {   \n\n\t\t\t\t\t\t if (cur.associated_annotation != -1)\n\t\t\t\t\t\t\t $menu.append($(\"<li onchoice='selectbymarker' > Select by markerset   <i class='fa fa-dot-circle-o'></i>  </li>\"));\n\t\t\t\t\t\t else\n\t\t\t\t\t\t\t $menu.append($(\"<li onchoice='selectbymarker' > Select by markerset   <i class='fa fa-circle-o'></i>    </li>\"));\n\t\t\t\t\t }\n\n\t\t\t\t      if ( sets.length >0)\n \t\t\t\t\t {\t\t \n\t\t\t\t\t\t $menu.append($(\"<li onchoice='genmarkersels' > Generate fiber selections from all sets  </li>\"));\n\t \t\t\t\t   \n\n \t\t\t\t\t }\n\n \t\t\t\t\tvar ROIs = KViewer.roiTool.ROIs\n \t\t\t\t\tvar rois = Object.keys(ROIs);\n  \t\t\t\t\tif (rois.length > 0)\n \t\t\t\t\t{\n\t\t\t\t\t\t$menu.append($(\"<hr width='100%'> \")); \t\t\t\t\t \n\t\t\t\t\t\t$menu.append($(\"<span class='inactive_menu_point'> &nbsp Select by ROI</span>\"));\n\t\t\t\t\t\t$menu.append($(\"<hr width='100%'> \")); \t\t\t\t\t \n\t\t\t\t\t\t for (var k = 0; k < rois.length;k++)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t \tvar add = \"\"\n\t\t\t\t\t\t \tif (tck.trackingVol != undefined)\n\t\t\t\t\t\t \t{\n\t\t\t\t\t\t\t\tadd = \" <i  onchoice='seedROI_\"+rois[k]+\"' class='fa button' style='right:30px;'>seed</i> \"\n\t\t\t\t\t\t \t}\n\t\t\t\t\t\t \t$menu.append($(\"<li onchoice='ROI_\"+rois[k]+\"'  >\"+ROIs[rois[k]].filename+\" <i  onchoice='minusROI_\"+rois[k]+\"' class='fa fa-minus button'></i>\"+add+\" </li>\"));\n\t\t\t\t\t\t }\n\n \t\t\t\t\t}\n\t\t\t\t\t//else\n \t\t\t\t\t//\t$menu.append($(\"<span class='inactive_menu_point emptylist'> &nbsp no ROI present</span>\"));\n\n\n \t\t\t\t\tvar ATLASs = KViewer.atlasTool.objs;\n \t\t\t\t\tvar atlass = Object.keys(ATLASs);\n \t\t\t\t\tif (tck.trackingVol == undefined)\n \t\t\t\t\t{\n\t\t\t\t\t\t$menu.append($(\"<hr width='100%'> \")); \t\t\t\t\t \n\t\t\t\t\t\t$menu.append($(\"<span class='inactive_menu_point'> &nbsp White Matter QL</span>\"));\n\t\t\t\t\t\t$menu.append($(\"<hr width='100%'> \")); \t\t\t\t\t \n\t\t\t\t\t\tif (atlass.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\t for (var k = 0; k < atlass.length;k++)\n\t\t\t\t\t\t\t {\n\t\t\t\t\t\t\t\t\t$menu.append($(\"<li onchoice='WMQL_\"+atlass[k]+\"'  >\"+ATLASs[atlass[k]].filename+\"</li>\"));\n\t\t\t\t\t\t\t }\n\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\t$menu.append($(\"<span class='inactive_menu_point emptylist'> &nbsp no atlas present</span>\"));\n \t\t\t\t\t}\n \t\t\t\t\n\t\t\t\t\treturn $menu; }\n\t\t\t\t  }, function(str,ev)\n\t\t\t\t  {\n\t\t\t\t  \tif (tck.children != undefined)\n\t\t\t\t\t\tfor (var k = 0; k < tck.children.length;k++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tck.children[k].isCurrent)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttck.children[k].fiberSelAction(str)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t  \tfiberSelAction(str);\n\t\t\t\t  }\n\n\t\t\t\t );\n\t\t\t $fiberpickselector.click(fibpick_contextmenu);\n\n\t\t    /***************************************************************************************\n\t\t     *  fiber cut context menu \n\t\t     ****************************************************************************************/\n\n\n\t\t      function fiberCutAction(str,ev)\n\t\t\t\t  {\n\t\t\t\t  \t  if (str == '' | str == undefined)\n\t\t\t\t  \t  \treturn;\n\t\t\t\t  \t  if (str == '-1' | str == '0' | str == '1' | str == '2' )\n\t\t\t\t  \t  {\n\t\t\t\t         tck.fibcut = parseInt(str);\n\t\t\t\t         tck.fiberDirColor_shader.setFloat(\"planesNum\",tck.fibcut);\n\t\t\t\t         tck.fiberDirColor_shader.setFloat(\"planesProj\",tck.fibcut_proj);\n\t\t\t\t  \t  }\n\t\t\t\t  \t  if (str == 'project')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \t  tck.fibcut_proj = -tck.fibcut_proj;\n\t\t\t\t          tck.fiberDirColor_shader.setFloat(\"planesProj\",tck.fibcut_proj);\n\t\t\t\t  \t  }\n\t\t\t\t  \t  viewer.gl.activateRenderLoop();\n\t\t\t\t  }\n\n\t\t\t tck.fiberCutAction = fiberCutAction;\n\t\t\t var $fibercutselector = $(\"<div  class='KViewPort_tool fibers' >  <i   class='fa fa-cut fa-1x'></i></div>\");\n\t\t\t var fibcut_contextmenu = new KContextMenu(\n\t\t\t\t  function() { \n\t\t\t\t\t var $menu = $(\"<ul class='menu_context'>\");\n\t\t\t\t\t var name = ['No cut','Coronal','Transversal','Saggital'];\n\t\t\t\t\t var sel = ['','','','']; sel[tck.fibcut+1] = 'dot-';\n\t\t\t\t\t for (var k = -1;k <3;k++)\n \t\t\t\t\t \t$menu.append($(\"<li  onchoice='\"+k+\"' > \"+name[k+1]+\"  <i  onchoice='\"+k+\"' class='fa fa-\"+sel[k+1]+\"circle-o'></i> </li>\"));\n\t\t\t\t      if (tck.fibcut != -1)\n\t\t\t\t      {\n\n\t\t\t\t\t\t  var $thres = $(\"<input onchoice='preventSelection' type='number' min='0.01' step='0.1' max='20'>\").val(tck.fibcut_thres).\n\t\t\t\t\t\t  on('change',function(ev){\n\t\t\t\t\t\t\tvar $input = $(ev.target);\n\t\t\t\t\t\t\ttck.fibcut_thres = $input.val();\n\t\t\t\t\t\t\tfiberDirColor_shader.setFloat(\"planesThres\",parseFloat(tck.fibcut_thres));   \t\n\t\t\t\t\t\t\tif (tck.children)\n\t\t\t\t\t\t\t\tfor (var k = 0; k < tck.children.length;k++)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\ttck.children[k].fibcut_thres = $input.val();\n\t\t\t\t\t\t\t\t\ttck.children[k].fiberDirColor_shader.setFloat(\"planesThres\",parseFloat(tck.fibcut_thres));   \t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t viewer.gl.activateRenderLoop();\n\t\t\t\t\t\t  });\n\t\t\t\t\t\t  $menu.append($(\"<li  onchoice='preventSelection'> Width: </li>\").append($thres));\n\t\t\t\t      }\n\t\t\t\t    $menu.append($(\"<hr width='100%'> \")); \t\t\n\t\t\t\t    var sel = '';\n\t\t\t\t    if (tck.fibcut_proj>0) sel = '-check';\t\t\t \t\t\t\t       \n \t\t\t\t    $menu.append($(\"<li onchoice='project'> Projection  <i onchoice='project' class='fa fa\"+sel+\"-square-o'></i> </li>\"));\n\t\t\t\t\treturn $menu; \n\t\t\t\t  },\n\t\t\t\t  function(str,ev)\n\t\t\t\t  {\n\t\t\t\t\tfiberCutAction(str);\n\t\t\t\t  \tif (tck.children)\n\t\t\t\t\t\tfor (var k = 0; k < tck.children.length;k++)\n\t\t\t\t\t\t\ttck.children[k].fiberCutAction(str);\n\t\t\t\t  }\n\t\t\t\t  );\n\t\t\t $fibercutselector.click(fibcut_contextmenu);\n\n\n\n\n\n\n\n\n\t\t\t var $osamp = $(\"<input title='Spatial undersampling factor of matrix' style='right:50px;width:40px' onchoice='preventSelection' type='number' min='0.5' step='1' max='20'>\")\n\t\t\t \t\t\t\t.val(2);\n\t\t\t var $osamp2 = $(\"<input title='Spatial undersampling factor of matrix' style='right:50px;width:40px' onchoice='preventSelection' type='number' min='0.5' step='1' max='20'>\")\n\t\t\t \t\t\t\t.val(2);\n\t\t\t \t\t\t\n\t\t\t var $termlen = $(\"<input title='length of terminal' style='right:50px;width:40px' onchoice='preventSelection' type='number' min='0.5' step='1' max='20'>\").val(2);\n\t\t\t var barscontextmenu = new KContextMenu(\n\t\t\t\t  function() { \n\t\t\t\t     var numfibs = tck.fibers.content.tracts.length ;\n\t\t\t\t\t if (tck.Selection && tck.Selection.subset)\t\t\t \n\t\t\t\t\t \tnumfibs = tck.Selection.subset.length;\n\t\t\t\t  \n\t\t\t\t\t var $menu = $(\"<ul class='menu_context'>\");\n\t\t\t\t\t if (tck.isParentView && tck.children != undefined && tck.children.length>0)\n\t\t\t\t\t {\n\t\t\t\t\t \t$menu.append($(\"<li onchoice='save' ><i class='leftaligned fa fa-save'></i>  save all</li>\"));\n\t\t\t\t\t \t$menu.append($(\"<li onchoice='showall' ><i class='leftaligned fa fa-refresh'></i>  show all selections</li>\"));\n\t\t\t\t\t }\n\t\t\t\t\t else\n\t\t\t\t\t \t$menu.append($(\"<li onchoice='save' ><i class='leftaligned fa fa-save'></i>  save selection</li>\"));\n\t\t\t\t\t if (tck.subsetToDisplay != undefined && tck.subsetToDisplay.length > 0 && tck.subsetToDisplay.length < numfibs) \n\t\t\t\t\t \t$menu.append($(\"<li onchoice='crop' > <i class='leftaligned fa fa-plus'></i>crop selection (\"+tck.subsetToDisplay.length+\"/\"+numfibs+\")</li>\"));\n\t\t\t\t\t if (tck.trackingVol != undefined && tck.fibers.content.tracts.length > 0)\n\t\t\t\t\t \t$menu.append($(\"<li onchoice='crop' > <i class='leftaligned fa fa-plus'></i>crop selection (\"+numfibs+\")</li>\"));\n\t\t\t\t\t \n\t\t\t\t\t if (!tck.isParentView)\n\t\t\t\t\t \t$menu.append($(\"<li onchoice='fix' > <i class='leftaligned fa fa-dot-circle-o'></i>fix selection </li>\"));\n\t\t\t\t\t if (!tck.visitworker)\n\t\t\t\t\t\t $menu.append($(\"<li onchoice='visitmap' ><i class='leftaligned fa fa-print'></i> render visit map </li>\").append($osamp));\n\t\t\t\t\t else\n\t\t\t\t\t\t $menu.append($(\"<li onchoice='visitmap' ><i class='leftaligned fa fa-print'></i> show visit map </li>\"));\n\n\n\t\t\t\t\t if (!tck.visitworker_terms)\n     \t \t\t\t \t$menu.append($(\"<li onchoice='termmap' ><i class='leftaligned fa fa-print'></i> render terminal map </li>\").append($termlen).append($osamp2));\n\t\t\t\t\t else\n     \t \t\t\t \t$menu.append($(\"<li onchoice='termmap' ><i class='leftaligned fa fa-print'></i> show terminal map </li>\"));\n\n\t\t\t\t\t $menu.append($(\"<hr width='100%'> \")); \t\t\n\t\t\t\t\t var nfp= \" <i  onchoice='parametersnv' class='fa button' style='right:30px;'>parameters</i> \"\n\n\t\t\t\t\t $menu.append($(\"<li onchoice='nicefibs' > Display nice fibers \"+nfp+\" </li>\"));\n\t\t\t\t\t $menu.append($(\"<hr width='100%'> \")); \t\t\t\t\t \n\n\t\t\t\t\t $menu.append($(\"<span class='inactive_menu_point'> &nbsp #tracts: \" +\n\t\t\t\t\t numfibs + \"</span>\"));\n\t\t\t\t\t $menu.append($(\"<hr width='100%'> \")); \t\t\t\t\t \n\t\t\t\t\t\n\n\n\n\t\t\t\t\treturn $menu; \n\t\t\t\t  }, function(str,ev)\n\t\t\t\t  {\n\t\t\t\t  \t  if (str == '' | str == undefined)\n\t\t\t\t  \t  \treturn;\n\t\t\t\t  \t  if (str == 'save')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \t if (tck.fibers.content.md5 != undefined)\n\t\t\t\t  \t  \t     that.save(tck.fibers,tck.Selection);\n\t\t\t\t  \t  \t else\n\t\t\t\t  \t  \t {\n\t\t\t\t  \t  \t     that.saveTCK(tck)\n\t\t\t\t  \t  \t }\n\t\t\t\t  \t  }\n\t\t\t\t  \t  else if (str == 'showall')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \tselectFibersReset('none');\n\t\t\t\t\t\t for (var k = 0 ; k < tck.children.length; k++)\n\t\t\t\t  \t  \t\t tck.children[k].selectFibersReset('all');\n\t\t\t\t  \t  \t\n\t\t\t\t  \t  }\n\t\t\t\t  \t  else if (str == 'crop')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \tcloneFibs();\n\t\t\t\t  \t  }\n\t\t\t\t  \t  else if (str == 'fix')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \tif (tck.Selection == undefined)\n\t\t\t\t  \t  \t\ttck.Selection = {subset: tck.subsetToDisplay, name:\"\"};\n\t\t\t\t  \t  \telse\n\t\t\t\t  \t  \t\ttck.Selection.subset = \ttck.subsetToDisplay;\n\t\t\t\t  \t  }\n\t\t\t\t  \t  else if (str == 'visitmap')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \tif (tck.visitworker != undefined)\n\t\t\t\t  \t  \t\ttck.visitworker.showInViewer(tck.viewer);\n\t\t\t\t  \t  \telse\n\t\t\t\t  \t  \t\ttck.visitworker = createVisitMap(parseFloat($osamp.val()),undefined,true);\n\t\t\t\t  \t  }\n\t\t\t\t  \t  else if (str == 'termmap')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \tif (tck.visitworker_terms != undefined)\n\t\t\t\t  \t  \t\ttck.visitworker_terms.showInViewer(tck.viewer);\n\t\t\t\t  \t  \telse \n//\t\t\t\t  \t  \t    tck.visitworker_terms = createVisitMap(parseFloat($osamp.val()),undefined,true);\n\t\t\t\t  \t  \n\t\t\t\t  \t  \t    tck.visitworker_terms = createVisitMap(parseFloat($osamp2.val()),parseFloat($termlen.val()),true);\n\t\t\t\t  \t  }\n\t\t\t\t\t  else if (str == 'nicefibs')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \ttck.showNiceFibs();\n\t\t\t\t  \t  }\n\t\t\t\t\t  else if (str == 'parametersnv')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \ttck.nicefibers_panel.show();\n\t\t\t\t  \t  }\n\t\t\t\t  },undefined);\n\n\n\n\t\t\ttck.nicefibers_panel = KNiceFibPanel()\n\n\t\t    /***************************************************************************************\n\t\t     *  the viewer toolbar\n\t\t     ****************************************************************************************/\n\t\t\tvar $captiondiv,$currentpickerdiv,$dragdiv,$savediv,$showhidediv,$bardiv;\n            tck.divs = [ \t$(\"<br style='clear:both' />\"),\n                          $(\"<div  class='KViewPort_tool persistent fibers'>  <i class='fa fa-close fa-1x'></i></div>\")\n                              .click( close  ).appendTooltip(\"closefiberview\").mousedown(viewer.viewport.closeContextMenu(tck)),\n                          $savediv=$(\"<div  class='KViewPort_tool fibers'>  <i class='fa fa-save fa-1x'></i></div>\")\n                              .appendTooltip(\"savefibers\").click(function(t,s) { return function() { \n                              that.save(t,s) } }(tck.fibers,tck.Selection)).hide(),\n\t\t\t\t\t\t  $bardiv = $(\"<div  class='KViewPort_tool fibers'>  <i class='fa fa-bars fa-1x'></i></div>\")\n\t\t\t\t\t\t  .click(barscontextmenu),\n                          $(\"<div  class='KViewPort_tool fibers'>  <i class='fa fa-print fa-1x'></i></div>\")\n                              .appendTooltip(\"createvisitmap\").click(createVisitMap).hide(),\n                          $(\"<div  class='KViewPort_tool fibers'>  <i class='fa fa-plus fa-1x'></i></div>\")\n                              .appendTooltip(\"cropfibers\").click(cloneFibs).hide(),\n                          $showhidediv = $(\"<div  class='KViewPort_tool fibers'>  <i class='fa fa-refresh fa-1x'></i></div>\")\n                              .appendTooltip(\"showallfibers\").click(function(e) {\n\n                              \tif (tck.Selection == undefined || tck.Selection.subset == undefined)\n                              \t{\n\t\t\t\t\t\t\t\t\tif (tck.subsetToDisplay == undefined)\n\t\t\t\t\t\t\t\t\t\tselectFibersReset('none')\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tselectFibersReset('all')\n                              \t}\n                              \telse\n                              \t{\n\t\t\t\t\t\t\t\t\tif (tck.Selection.subset.length == tck.subsetToDisplay.length)\n\t\t\t\t\t\t\t\t\t\tselectFibersReset('none')\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\tselectFibersReset('all')                              \t\t\n                              \t}\n\n                              \t}).mousedown(function(e) {\n\n                              \t\tif (e.buttons == 2)\n                              \t\t\tselectFibersReset('accumulate')\n\n                              \t}),\n\n                          $currentpickerdiv = $(\"<div  class='KViewPort_tool fibers'>  <i class='fa fa-pencil-square-o fa-1x'></i></div>\")\n                              .appendTooltip(\"currentpicker\").click( makeCurrent  ),\n                          $fibercutselector.appendTooltip(\"fibercut\"),\n                          \n                          $fiberpickselector.appendTooltip(\"fiberpick\"),\n                          $captiondiv = $(\"<div lang='klingon' spellcheck='false'  class='KViewPort_tool fibers caption'> \"+tck.fibers.filename+\"</div>\"),\n                          $colselector.appendTooltip(\"selectcolor\"),\n\n                          $dragdiv = $(\"<div  class='KViewPort_tool draganddrop'>  <i class='fa fa-fw fa-hand-paper-o fa-1x'></i></div>\")\n                          \t.appendTooltip(\"dragdropviewport\")\n                          \n                       ];\n\t\t\t//if (tck.Selection == undefined)\n\t\t\t//\t$savediv.addClass(\"inactive\")\n\n\t\t\tif (!tck.isParentView)\n\t\t\t{\n\t\t\t\t$fibercutselector.hide();\n\t\t\t\t$fiberpickselector.hide();\n\t\t\t}\n\n\t\t\tif (tck.parent != undefined)\n\t\t\t\tviewer.toolbar.appendAfter(tck.divs,tck.parent);\n\t\t\telse\n\t\t\t\tviewer.toolbar.append(tck.divs,'fiber');\n\n\n\t\t\ttck.$currentpickerdiv = $currentpickerdiv;\n\t\t\ttck.$currentpickerdiv.hide();\n\t\t\ttck.$captiondiv = $captiondiv;\n\n \n\n\t\t\t$captiondiv.on('click',function(){\n\t\t\t\tmakeCurrent();\n\t\t\t});\n\t\t\t$captiondiv.on('mouseenter',function(){\n\t\t\t\tfiberDirColor_shader.setFloat(\"hover\",0.5);\t\t\t\n\t\t\t\tviewer.gl.activateRenderLoop();\n\t\t\t});\n\t\t\t$captiondiv.on('mouseleave',function(){\n\t\t\t\tfiberDirColor_shader.setFloat(\"hover\",0);\t\t\t\t\n\t\t\t\tviewer.gl.activateRenderLoop();\t\n\t\t\t});\n            $dragdiv.attr(\"draggable\",'true');\n            $dragdiv.on(\"dragstart\", dragstarter({ type:'file', mime: 'tck',  filename: tck.fibers.filename,  fileID: tck.fibers.fileID,close:close }));\n\t\t\tviewer.toolbar.attachhandhover($dragdiv);\n\t\t\tif (tck.Selection  != undefined)\n\t\t\t{\n\t\t\t\tif (tck.Selection.namedivs == undefined)\n\t\t\t\t\ttck.Selection.namedivs = {};\n\n\t\t\t\t$captiondiv.text(tck.Selection.name);\n\n\n\t\t\t    tck.Selection.namedivs[tck.uuid] = ($captiondiv);\n\n\t\t\t\tKSetContentEditable($captiondiv, function() {\n\n\t\t\t\t\tvar sel = tck.Selection;\n\t\t\t\t\t\n\t\t\t\t\tsel.name = $captiondiv.text();\n\t\t\t\t\tif (sel.namedivs != undefined)\n\t\t\t   \t\t{\n\t\t\t   \t\t\tfor (var i in sel.namedivs)\n\t\t\t   \t\t\t{\n\t\t\t   \t\t\t\tif ($captiondiv != sel.namedivs[i] && sel.namedivs[i].text != undefined)\n\t\t\t   \t\t\t\t\tsel.namedivs[i].text(sel.name);\n\t\t\t   \t\t\t}\n\t\t\t   \t\t}\t\t\t\t\n\t\t\t   \t\tthat.update();\t\n\n\t\t\t\t});\n\n/*\n\t\t\t\t$captiondiv.attr(\"contenteditable\",true);\n\n                $captiondiv.keydown(function(ev) { if (ev.keyCode == 13) { $(ev.target).blur(); return false } })\n \t\t\t    \n\t\t\t    $captiondiv.keyup(function(ev)\n\t\t\t\t{\n\t\t\t\t\tvar sel = tck.Selection;\n\t\t\t\t\t\n\t\t\t\t\tsel.name = $captiondiv.text();\n\t\t\t\t\tif (sel.namedivs != undefined)\n\t\t\t   \t\t{\n\t\t\t   \t\t\tfor (var i = 0; i < sel.namedivs.length;i++)\n\t\t\t   \t\t\t{\n\t\t\t   \t\t\t\tif ($captiondiv != sel.namedivs[i])\n\t\t\t   \t\t\t\t\tsel.namedivs[i].text(sel.name);\n\t\t\t   \t\t\t}\n\t\t\t   \t\t}\t\t\t\t\n\t\t\t   \t\tthat.update();\t\n\t\t\t\t}\t);\t\t   \n*/\n\n\n\t\t\t}\n\n\t\t\n\t\t\ttck.setVisibilityMarkup = function(vis)\n\t\t\t{\n\t\t\t\tfor (var k = 0; k < tck.divs.length;k++)\n\t\t\t\tif (vis)\n\t\t\t\t\ttck.divs[k].removeClass(\"tckNotVisible\");\n\t\t\t\telse\t\n\t\t\t\t{\n\t\t\t\t\tvar b = $(tck.divs[k].children()[0]);\n\t\t\t\t\tif (!b.hasClass('fa-comment-o') && !b.hasClass('fa-cut'))\n\t\t\t\t\t\ttck.divs[k].addClass(\"tckNotVisible\");\n\t\t\t\t}\n\t\t\t}\n\n\t\t   /***************************************************************************************\n\t\t    *  fiber renderer\n\t\t    ****************************************************************************************/\n\n\t\t    tck.updateFibers = function()\n\t\t\t{\n\t\t\t\tif (this.fibers == undefined)\n\t\t\t\t\ttck.close();\n\n\t\t\t\tvar subset = tck.subsetToDisplay;\n\t\t\t\tvar content = this.fibers.content; \n\t\t\t\tvar tracts = content.tracts;\n\t\t\t\tif (tracts != undefined && tracts.length == 0 && !tck.autogenerate_tracks)\n\t\t\t\t\treturn;\n\n\t\t\t\tif (subset!=undefined && subset.length == 0)\n\t\t\t\t\ttck.setVisibilityMarkup(false)\n\t\t\t\telse\n\t\t\t\t    tck.setVisibilityMarkup(true)\n\n\t\t\t\tif (tck.visitworker)\n\t\t\t\t{\n\t\t\t\t\ttck.visitworker.updateVisit();\n\t\t\t\t}\n\t\t\t\tif (tck.visitworker_terms)\n\t\t\t\t{\n\t\t\t\t\ttck.visitworker_terms.updateVisit();\n\t\t\t\t}\n\n\t\t\t\tif (tck.fiberUpdater != undefined)\n\t\t\t\t{\n\t\t\t\t\ttck.fiberUpdater.clear();\n\t\t\t\t}\n\n\t\t\t\ttck.fiberUpdater = {chunksize:64, current_chunk:0, objs:[]};\n\t\t\t\tvar fiberUpdater = tck.fiberUpdater;\n\t\t\t\tfiberUpdater.num_chunks = 200;\n\n\t\t\t\tvar seeding;\n\t\t\t\tif (subset == undefined)\n\t\t\t\t{\n\t\t\t\t\tif (tck.autogenerate_tracks)\n\t\t\t\t\t{\n\t\t\t\t\t\tsubset = 'autogenerate_tracks';\n\t\t\t\t\t\tif (tck.autogenerate_tracks != 2)\t\t\t\t\n\t\t\t\t\t\t\tcontent.tracts = undefined;\n\t\t\t\t\t\tif (that.tracking_panel.params.climcon==0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseeding = { vol:tck.trackingVol,\n\t\t\t\t\t\t\t\t\t\tthreshold:tck.trackingVolHistoman.clim[1],\n\t\t\t\t\t\t\t\t\t\tthreshold_term:tck.trackingVolHistoman.clim[0],\n\t\t\t\t\t\t\t\t\t\tnumfibs:that.tracking_panel.params.Density*5};\n\t\t\t\t\t\t\ttck.seedID = tck.trackingVolID ;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tseeding = { vol:tck.viewer.nii,\n\t\t\t\t\t\t\t\t\t\tthreshold:tck.viewer.histoManager.clim[1],\n\t\t\t\t\t\t\t\t\t\tthreshold_term:tck.viewer.histoManager.clim[0],\n\t\t\t\t\t\t\t\t\t\tnumfibs:that.tracking_panel.params.Density*5};\n\n\t\t\t\t\t\t\ttck.seedID = tck.viewer.currentFileID;\n\t\t\t\t\t\t}\n\t\t\t\t\t    fiberUpdater.num_chunks = that.tracking_panel.params.numChunks;\n\t\t\t\t\t\tif (tck.osid_climchange != undefined)\n\t\t\t\t\t\t\t signalhandler.detach(\"overlay_climChange\",tck.osid_climchange);\n\t\t\t\t\t\tif (tck.sid_climchange != undefined)\n\t\t\t\t\t\t\t signalhandler.detach(\"climChange\",tck.sid_climchange);\n\n\n\t\t\t\t\t\ttck.sid_climchange = signalhandler.attach(\"climChange\", function(ev)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tck.seedID == ev.id && tck.subsetToDisplay == undefined) //tck.subsetToDisplay.length >0)\n\t\t\t\t\t\t\t    selectFibersReset('all');\t\n\n\t\t\t\t\t\t});\n\n\n\t\t\t\t\t\ttck.osid_climchange = signalhandler.attach(\"overlay_climChange\", function(ev)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tck.seedID == ev.id && tck.subsetToDisplay == undefined) //tck.subsetToDisplay.length >0)\n\t\t\t\t\t\t\t    selectFibersReset('all');\t\n\n\t\t\t\t\t\t});\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (fiberUpdater.num_chunks*fiberUpdater.chunksize > tracts.length)\n\t\t\t\t\t\tsubset = 'full';\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\tfiberUpdater.num_chunks = subset.length/fiberUpdater.chunksize;\n\n\t\t\t\tfunction mergefibs(a,b)\n\t\t\t\t{\n\t\t\t\t\tif (a.tracts == undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\ta.tracts = b.tracts;\n\t\t\t\t\t\ta.tracts_len = b.tracts_len;\t\t\t\t\t\t\n\t\t\t\t\t\ta.tracts_min = b.tracts_min;\t\t\t\t\t\t\n\t\t\t\t\t\ta.tracts_max = b.tracts_max;\n\t\t\t\t\t\ta.tot_points = b.tot_points;\n\t\t\t\t\t\ta.max = [];\n\t\t\t\t\t\ta.min = [];\n\t\t\t\t\t\tfor (var t = 0; t < 3; t++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta.max[t] = b.max[t];\n\t\t\t\t\t\t\ta.min[t] = b.min[t];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\ta.tracts = a.tracts.concat(b.tracts);\n\t\t\t\t\t\ta.tracts_len = a.tracts_len.concat(b.tracts_len);\t\t\t\t\t\t\n\t\t\t\t\t\ta.tracts_min = a.tracts_min.concat(b.tracts_min);\t\t\t\t\t\t\n\t\t\t\t\t\ta.tracts_max = a.tracts_max.concat(b.tracts_max);\n\t\t\t\t\t\ta.tot_points = a.tot_points +b.tot_points;\n\t\t\t\t\t\tfor (var t = 0; t < 3; t++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ta.max[t] = Math.max(a.max[t],b.max[t]);\n\t\t\t\t\t\t\ta.min[t] = Math.min(a.min[t],b.min[t]);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\tfunction createSubset(subset,tracts,done)\n\t\t\t\t{\n\t\t\t\t\t\tif (viewer.gl == undefined)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttck.fiberUpdater.clear();\n\t\t\t\t\t\t\tdone();\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\n\t\t\t\t\t\tvar chunk = []; \t\n\t\t\t\t\t\tif (subset == undefined)\n\t\t\t\t\t\t{\t                 \n\t\t\t\t\t\t\tfor (var k = 0; k < fiberUpdater.chunksize;k++)\n\t\t\t\t\t\t\t\tchunk.push(k+fiberUpdater.current_chunk*fiberUpdater.chunksize);\n//\t\t\t\t\t\t\t\tchunk.push(Math.round(Math.random()*(tracts.length-1)-0.5)+1);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (subset == 'autogenerate_tracks')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (1) // fibtrackworker switch\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (tck.fibtrackWorker == undefined)\n\t\t\t\t\t\t\t    tck.fibtrackWorker = createFibTrackWorker(tck.trackingVol);\n\t\n\t\t\t\t\t\t\tif (tck.fibtrackWorker.istracking)\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\ttck.fibtrackWorker.track(seeding,params,\n\t\t\t\t\t\t\tfunction(ret)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tif (ret.tracts.length > 0)\n\t\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\t\tvar already_tracked = 0;\n\t\t\t\t\t\t\t\t\t\tif (content.tracts != undefined)\n\t\t\t\t\t\t\t\t\t\t\talready_tracked = content.tracts.length;\n\n\t\t\t\t\t\t\t\t\t\tfor (var k = 0; k < ret.tracts.length;k++)\n\t\t\t\t\t\t\t\t\t\t\tchunk.push(k+already_tracked);\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\t\t\tmergefibs(content,ret);\t\t\n\t\t\t\t\t\t\t\t\t\ttck.viewer.viewport.progressSpinner(content.tracts_len.length + \" fibers tracked\");\n\n\t\t\t\t\t\t\t\t\t\ttracts = content.tracts;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\tif (chunk.length>0)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tfiberUpdater.objs.push(viewer.gl.createFiberBundle(tracts,chunk,'wholebrain',colors[tck.color],fiberDirColor_shader,content));\n\t\t\t\t\t\t\t\t\t\tdone(true)\n\t\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tdone(false)\n\t\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t});\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\tvar ret = realtimeTracking(seeding,tck.trackingVol,that.tracking_panel.params);\n\t\t\t\t\t\t\tif (ret.tracts.length > 0)\n\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\tvar already_tracked = 0;\n\t\t\t\t\t\t\t\tif (content.tracts != undefined)\n\t\t\t\t\t\t\t\t\talready_tracked = content.tracts.length;\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tfor (var k = 0; k < ret.tracts.length;k++)\n\t\t\t\t\t\t\t\t\tchunk.push(k+already_tracked);\t\t\t\t\t\t\t\n\n\t\t\t\t\t\t\t\tmergefibs(content,ret);\t\t\n\t\t\t\t\t\t    \ttck.viewer.viewport.progressSpinner(content.tracts_len.length + \" fibers tracked\");\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\ttracts = content.tracts;\n\n\t\t\t\t\t\t\t\tif (chunk.length>0)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfiberUpdater.objs.push(viewer.gl.createFiberBundle(tracts,chunk,'wholebrain',colors[tck.color],fiberDirColor_shader));\n\t\t\t\t\t\t\t\t\tdone(true)\n\t\t\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tdone(false)\n\t\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdone(false)\n\t\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (subset == 'full')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (var k = 0; k < fiberUpdater.chunksize  & k+fiberUpdater.chunksize*fiberUpdater.current_chunk < tracts.length;k++)\n\t\t\t\t\t\t\t\tchunk.push(k+fiberUpdater.chunksize*fiberUpdater.current_chunk);\t\t\t\t\t\t\t\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (subset.length > 0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfor (var k = 0; k < fiberUpdater.chunksize & k+fiberUpdater.chunksize*fiberUpdater.current_chunk < subset.length;k++)\n\t\t\t\t\t\t\t\tchunk.push(subset[k+fiberUpdater.chunksize*fiberUpdater.current_chunk]);\t\t\t\t\t\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tif (chunk.length>0)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tfiberUpdater.objs.push(viewer.gl.createFiberBundle(tracts,chunk,'wholebrain',colors[tck.color],fiberDirColor_shader,content));\n\t\t\t\t\t\t\tdone(true)\n\t\t\t\t\t\t\treturn true;\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tdone(false)\n\t\t\t\t\t\t\treturn false;\n\t\t\t\t\t\t}\n\n\n\n\t\t\t\t}\n\n\t\t\t\tfiberUpdater.clear = function(dontdisposenicefibers) {\n\t\t\t\t\t\t if (tck.fibtrackWorker && tck.fibtrackWorker.istracking)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t \ttck.fibtrackWorker.callback = function() {}\n\t\t\t\t\t\t }\n\n\t\t\t\t\t\t if (fiberUpdater.id != -1) \n\t\t\t\t\t\t {\n\t\t\t\t\t\t\tclearInterval(fiberUpdater.id); \n\t\t\t\t\t\t\tfiberUpdater.id=-1;  \n\t\t\t\t\t\t } \n\t\t\t\t\t\t for (var k = 0; k < fiberUpdater.objs.length;k++)\n\t\t\t\t\t\t\tfiberUpdater.objs[k].dispose();\n\n\t\t\t\t\t\t if (fiberUpdater.nicefibs && !dontdisposenicefibers)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t \tfiberUpdater.nicefibs.dispose();\n\t\t\t\t\t\t \tfiberUpdater.nicefibs = undefined\n\n\t\t\t\t\t\t\tvar curList = tck.nicefibers_panel.currentlyNice;\n\n\t\t\t\t\t\t\tfor (var k = 0; k < curList.length;k++)\n\t\t\t\t\t\t\t\tif (curList[k] == tck)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tcurList.splice(k,1);\n\t\t\t\t\t\t\t\t\tbreak\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t }\n\n\t\t\t\t};\n\n\n\n\t\t\t\tvar builder = function(subset,tracts) { return function() {\n\t\t\t\t\t\t\tif (fiberUpdater.id == -1)\n\t\t\t\t\t\t\t\tconsole.log(\"very strange!!!\");\n\t\t\t\t\t\t\tcreateSubset(subset,tracts,function(ret){\t\t\t\t\n\t\t\t\t\t\t\t\tfiberUpdater.current_chunk++;\n\n\t\t\t\t\t\t\t\tif (fiberUpdater.current_chunk >= fiberUpdater.num_chunks || !ret)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tclearInterval(fiberUpdater.id); \n\t\t\t\t\t\t\t\t\tfiberUpdater.id=-1;\n\t\t\t\t\t\t\t\t\ttck.viewer.viewport.progressSpinner();\n\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t});\n\t\t\t\t} }(subset,tracts) ;\n\n\t\t\t\tviewer.gl.activateRenderLoop();\n\t\t\t\tfiberUpdater.id = setInterval(builder, 50);\n\n\t\t\t\t//builder();\n\n\t\t\t}\n\t\t    tck.update = tck.updateFibers;\n\n     \t\t\n\t\t\ttck.showNiceFibs = function()\n\t\t\t{\n\n\n\t\t\t\tvar params = tck.nicefibers_panel.params;\n\n\t\t\t\tvar curList = tck.nicefibers_panel.currentlyNice;\n\n\t\t\t\tvar found = false;\n\t\t\t\tfor (var k = 0; k < curList.length;k++)\n\t\t\t\t\tif (curList[k] == tck)\n\t\t\t\t\t{\n\t\t\t\t\t\tfound = true;\n\t\t\t\t\t\tbreak\n\t\t\t\t\t}\n\n\t\t\t\tif (!found)\n\t\t\t\t\tcurList.push(tck);\n\n\n\t\t\t\tif (tck.fiberUpdater.nicefibs != undefined)\n\t\t\t\t\ttck.fiberUpdater.nicefibs.dispose();\n\n\n\t\t\t\tvar plens = tck.fiberUpdater.objs[0].plens;\n\t\t\t\tvar scene = tck.viewer.gl.scene\n\t\t\t\tvar grandParent = tck.viewer.gl.grandParent\n\t\t\t\tvar papa = BABYLON.Mesh.CreateSphere(\"sphere1\", {segments:1,diameter:0}, scene);\n\t\t\t\tpapa.visibility = 1;\n\t\t\t\tpapa.parent = grandParent;\n\n\n\t\t\t\tvar mat = tck.viewer.gl.world2GL_matrix()._data;\n\t\t\t\tvar objs = tck.fiberUpdater.objs\n\t\t\t\tvar col = tck.color-1;\n\t\t\t\tif (col <0 ) col = 0;\n\t\t\t\tvar color = new KColor(KColor.list[col]).darken(0.3).getBabylon();\n\t\t\t\tvar material = new BABYLON.StandardMaterial(\"texture1\", scene);\n\t\t\t\tmaterial.diffuseColor  = color;\n\t\t\t\tmaterial.specularPower = params.SpecularPower;\n\t\t\t\tmaterial.specularColor =  new KColor(KColor.list[col]).darken(1.2).getBabylon();\n\t\t\t\tvar tubopt = { radius: params.Radius, tessellation:params.Tessellation , cap:BABYLON.Mesh.CAP_ALL}\n\t\t\t\tvar thres_ang = Math.pow(Math.abs(1-params.Simplification/100),0.2);\n\n\t\t\t\tfor (var i = 0; i < objs.length;i++)\n\t\t\t\t{\n//\t\t\t\t\tvar pts = objs[i].positions;\n//\t\t\t     \tvar plens_ = objs[i].plens;\n\n                    var plens = [];\n                    var idx = objs[i].getIndices();\n                    var c = 1;\n                    var k = 0;\n                    for (;;)\n                    {\n                    \tif (idx[k+1] != idx[k+2])\n                    \t{\n                            plens.push(c+1);\n                            c=0;\n                            //k+=3;\n                    \t}\n                    \tk+=2;\n                    \tc++;\n                    \tif (k >= idx.length)\n                    \t    break;\n\n                    }\n\n                    var pts = objs[i].getVertexBuffer(\"position\")._buffer._data;\n\n\n\t\t\t\t\tvar offs = 0;\n\t\t\t\t\tvar flip = tck.viewer.gl.flip;\n\t\t\t\t\tfor (var k = 0; k <plens.length;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar p = [];\n\t\t\t\t\t\tvar d;\n\t\t\t\t\t\tvar d_old = [1,0,0];\n\t\t\t\t\t\tfor (var j = 0; j< plens[k];j++)\t\t\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\td = [pts[3*j+offs]-pts[3*j+offs-3],(pts[3*j+offs+1]-pts[3*j+offs-2]),(pts[3*j+offs+2]-pts[3*j+offs-1])]\n\t\t\t\t\t\t\tvar dot = d[0]*d_old[0]+d[1]*d_old[1]+d[2]*d_old[2];\n\t\t\t\t\t\t\tif (j<2 | j==plens[k]-1 | dot*dot / ((d[0]*d[0]+d[1]*d[1]+d[2]*d[2])*(d_old[0]*d_old[0]+d_old[1]*d_old[1]+d_old[2]*d_old[2])) < thres_ang)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tp.push((new BABYLON.Vector3(\n\t\t\t\t\t\t\t\t\t\tmat[0][0]*pts[3*j+offs]+mat[0][1]*pts[3*j+offs+1]+mat[0][2]*pts[3*j+offs+2]+mat[0][3],\n\t\t\t\t\t\t\t\t\t\tmat[1][0]*pts[3*j+offs]+mat[1][1]*pts[3*j+offs+1]+mat[1][2]*pts[3*j+offs+2]+mat[1][3],\n\t\t\t\t\t\t\t\t\t\tmat[2][0]*pts[3*j+offs]+mat[2][1]*pts[3*j+offs+1]+mat[2][2]*pts[3*j+offs+2]+mat[2][3]\n\t\t\t\t\t\t\t\t\t\t)));\n\t\t\t\t\t\t\t\td_old = d;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\toffs += plens[k]*3;\n\t\t\t\t\t\ttubopt.path = p;\n\t\t\t\t\t\tvar tube = BABYLON.MeshBuilder.CreateTube(\"tube\", tubopt, scene);\n\t\t\t\t\t\ttube.material = material;\n\t\t\t\t\t\ttube.color = col;\n\t\t\t\t\t\ttube.parent = papa;\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\tviewer.gl.activateRenderLoop();\t\t\t\t\n\t\t\t\ttck.fiberUpdater.nicefibs = papa;\n\t\t\t\ttck.fiberUpdater.clear(true);\n\n\t\t\t\t\n\t\t\t}\n\n\t\t   /***************************************************************************************\n\t\t    *  subset selection by click\n\t\t    ****************************************************************************************/\n\n     \t\ttck.modifyByPick = function(p,type,directionsel)\n\t\t    {\n\n\t\t\t\tfunction showFibs(selectionresult)\n\t\t\t\t{\t\n\t\t\t\t    var old = tck.subsetToDisplay\n\t\t\t\t\tif (type == 'delete')\t\n\t\t\t\t\t{\t\t\t\t\t\t\n\t\t\t\t\t    \t\n\t\t\t\t\t\tif (tck.subsetToDisplay != undefined)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttck.subsetToDisplay = kdiff(tck.subsetToDisplay,selectionresult);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttck.subsetToDisplay = kdiff({all:tck.fibers.content.tracts.length},selectionresult);\n\t\t\t\t\t\t}                    \n\n\t\t\t\t\t}\n\t\t\t\t\telse if (type == 'append')\t\n\t\t\t\t\t{\t\t\t\t\t\t\t\n\t\t\t\t\t\tif (tck.subsetToDisplay != undefined)\n\t\t\t\t\t\t\ttck.subsetToDisplay = kunion(tck.subsetToDisplay,selectionresult).sort();\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttck.subsetToDisplay = selectionresult;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse if (type == 'subselect')\t\n\t\t\t\t\t{\t\t\t\t\t\t\t\n\t\t\t\t\t\tif (tck.subsetToDisplay != undefined)\n\t\t\t\t\t\t\ttck.subsetToDisplay = kintersect(tck.subsetToDisplay,selectionresult);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\ttck.subsetToDisplay = selectionresult;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\ttck.subsetToDisplay = selectionresult;\n\n\t\t\t\t\tif (tck.Selection != undefined && tck.Selection.subset != undefined)\n\t\t\t\t \t\t tck.subsetToDisplay = kintersect(tck.subsetToDisplay,tck.Selection.subset);\n\n\t\t\t\t\tif (old == undefined || Math.abs(old.length - tck.subsetToDisplay.length) > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tthat.fiberHistory.add(tck,tck.subsetToDisplay)   \n\t\t\t\t\t}\t\n\t\t\t\t\tviewer.statusbar.report(tck.subsetToDisplay.length + \" fibers shown\");\t\t\t\t\t\t\t\t \t\t \n\t\t\t\t\ttck.updateFibers();\n\t\n\t\t\t\t\t\n\t\t\t\t}\n\n\n\t\t\t\ttck.autogenerate_tracks = false;\n\t\t\t\tif (tck.trackingVol )\n\t\t\t\t{\n\t\t\t\t\tif (type == 'select')\n\t\t\t\t\t{\n\t\t\t\t\t\tvar ret = tck.fiberTracking({seed:p,radius:viewer.gl.selectionRadius/2,threshold:tck.trackingVolHistoman.clim[1]});\n\n\t\t\t\t\t\ttck.fibers.content = ret;\n\t\t\t\t\t\ttck.subsetToDisplay = undefined;\n\t\t\t\t\t}\n\t\t\t\t\telse if (type == 'delete')\n\t\t\t\t\t{\n\n\t\t\t\t\t\tvar octreeWorker = tck.fibers.content.octreeWorker;\n\t\t\t\t\t\toctreeWorker.findFibers(p,viewer.gl.selectionRadius/2,directionsel,showFibs);\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (type == 'subselect')\n\t\t\t\t\t{\n\n\t\t\t\t\t\tvar octreeWorker = tck.fibers.content.octreeWorker;\n\t\t\t\t\t\toctreeWorker.findFibers(p,viewer.gl.selectionRadius/2,directionsel,showFibs);\n\n\t\t\t\t\t}\n\t\t\t\t\telse if (type == 'append')\n\t\t\t\t\t{\n                        tck.fibers.content.octreeWorker.kill();\n\n\t\t\t\t\t\tvar ret = tck.fiberTracking({seed:p,radius:viewer.gl.selectionRadius/2,threshold:tck.trackingVolHistoman.clim[1]},true);\n                        tck.fibers.content = concatfibs(ret,tck.fibers.content,tck.subsetToDisplay)                        \n\t\t\t\t\t\ttck.fibers.content.cid = setTimeout(function(){\n\t\t\t\t\t\t\tthat.buildOctree(tck.fibers.content,that.progressSpinner);\t\n\t\t\t\t\t\t\ttck.fibers.content.cid = undefined;\t\t\t \n\t\t\t\t\t\t},10);\n\n\n\t\t\t\t\t\ttck.subsetToDisplay = undefined;\n\t\t\t\t\t}\n \t\t\t\t\ttck.updateFibers();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t    \n\t\t\t\t\tsetAnnotationAssoc(-1);\n\n\t\t\t\t\tif (KObject3DTool.useOctreeWorker)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar octreeWorker = tck.fibers.content.octreeWorker;\n\t\t\t\t\t\toctreeWorker.findFibers(p,viewer.gl.selectionRadius/2,directionsel,showFibs);\n\t\t\t\t\t}\n\t\t\t\t\telse\t\t\t\t\n\t\t\t\t\t{    \t\n\t\t\t\t\t\tvar selectionresult = tck.fibers.content.octree.findFibers(p,viewer.gl.selectionRadius/2,directionsel)\n\t\t\t\t\t\tshowFibs(selectionresult);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t     }\n\n            function concatfibs(a,b,idx)\n            {\n                var tot_points = a.tot_points;\n                var len = b.tracts.length;\n                if (idx != undefined)\n                    len = idx.length;\n\n                for (var j = 0; j < len;j++)\n                {\n                \tvar k = j;\n                \tif (idx != undefined)\n                \t    k = idx[j]\n                \ta.tracts.push(b.tracts[k])\n                \ta.tracts_len.push(b.tracts_len[k])\n                \ta.tot_points += b.tracts[k].length\n                \ta.tracts_max.push(b.tracts_max[3*k],b.tracts_max[3*k+1],b.tracts_max[3*k+2])\n                \ta.tracts_min.push(b.tracts_min[3*k],b.tracts_min[3*k+1],b.tracts_min[3*k+2])\n                \tfor (var i = 0;i < 3;i++)\n                \t{\n                        a.max[i] = math.max(a.max[i],b.tracts_max[3*k+i])\n                        a.min[i] = math.min(a.min[i],b.tracts_min[3*k+i])\n                \t}\n                }\n                return a;\n\n\n            }\n\n \t        /***************************************************************************************\n\t\t     * clone subset and create new view\n \t\t     ****************************************************************************************/\n\n\t\t\t function cloneFibs(name)\n\t\t\t { \n\t\t\t\tvar parent;\n\t\n\t\t\t   \tif (tck.isParentView)\n\t\t\t   \t\tparent = tck;\n\t\t\t    else\n\t\t\t    \tparent = tck.parent;\n\n\t\t\t    var fv = that.cloneFibersFromSelection(tck,viewer,parent,name) ;\n\t\t\t  \n\t\t\t\tfv.fibcut = tck.fibcut;\n \t\t\t\tfv.fiberDirColor_shader.setFloat(\"planesNum\",fv.fibcut);\t\n \t\t\t\t\t\t\t\n  \t\t\t    fv.fibcut_proj = tck.fibcut_proj;\n\t\t\t    fv.fiberDirColor_shader.setFloat(\"planesProj\",fv.fibcut_proj);\n\n//\t\t\t\t  \t  \t  tck.fibcut_proj =\n\n\t\t\t    if (fv.parent.children == undefined)\n\t\t\t    \tfv.parent.children = [];\n\t\t\t    fv.parent.children.push(fv);\n\t\t\t    \t\n\n\t\t\t    viewer.objects3D.push(fv);\n\n\t\t\t    tck.subsetToDisplay = [];\n\t\t\t    tck.updateFibers();\n\t\t\t } \n\n\t\t\t\n\t        /***************************************************************************************\n\t\t     * manage selection assoc with annotations\n\t\t     ****************************************************************************************/\n\n\n\t\t\tfunction getAnnotationByID(id)\n\t\t\t{\n\t\t\t\treturn markerProxy.markersets[id];\n\t\t\t\t\t\t\t\t\n\t\t\t}\n\t\t\ttck.getAnnotationByID = getAnnotationByID;\n\n\n\n\n\t\t\t function setAnnotationAssoc(annotid,callback)\n\t\t\t {\n\t\t\t/*\tif (annotid == tck.associated_annotation && annotid != -1)\n\t\t\t\t{\n\t\t\t\t\tvar annot = getAnnotationByID(tck.associated_annotation);\n\t\t\t\t\tif (annot != undefined && annot.onupdate && annot.onupdate[tck.uid])\t\t\t\t\t\n\t\t\t\t\t\tannot.onupdate[tck.uid]();\n\t\t\t\t\telse\n\t\t\t\t\t\tremoveAnnotationAssoc();\t\t\n\t\t\t\t\treturn;\n\t\t\t\t}*/\n\t\t\n\n\t\t\t\tremoveAnnotationAssoc();\n\n\t\t\t\t\n\t\t\t\tif (annotid == -1)\n\t\t\t\t{\n\t\t\t\t \ttck.associated_annotation = -1;\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\n\t\t\t\tif (typeof annotid == 'string')\t\t\t\t\n\t\t\t\t\ttck.associated_annotation = markerProxy.markersets[annotid ].uuid;\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\ttck.associated_annotation = markerProxy.getSets()[annotid].uuid;\n\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\tvar annot = getAnnotationByID(tck.associated_annotation);\n\t\t\t\tif (annot == undefined)\n\t\t\t\t\treturn;\n\n\t\t\t   // $showhidediv.addClass(\"current\");\n\n\t\t\n\t\t\t\tannot.onupdate[tck.uid] = function()\n\t\t\t\t{\n\n\t\t\t\t\tvar fobj_cur;\n\t\t\t\t\tvar points = annot.getPoints();\n\t\t\t\t\tvar active = annot.getActive();\n\t\t\t\t\tif (active != undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar id = \"DBS_\"+annot.name+\"_\"+active.pts.p.name+\"_current\";\n\t\t\t\t\t\tfobj_cur = KViewer.dataManager.getFile(id);\n\t\t\t\t\t}\n\n\n\t\t\t\t\t for (var j = 0; j < points.length; j++)\n\t\t\t\t\t {\n\t\t\t\t\t\tvar point = points[j];\n\t\t\t\t\t\tif (point.removeupdater[tck.uid])\n\t\t\t\t\t\t\tdelete point.removeupdater[tck.uid];\n\t\t\t\t\t\tif (point.onupdate[tck.uid])\n\t\t\t\t\t\t\tdelete point.onupdate[tck.uid];\n\t\t\t\t\t }\t\t\t\t\t\t\n\t\t\t\t\t\n\n\n\t\t\t\t\tif (fobj_cur != undefined) // && annot.type == 'electrode') \n\t\t\t\t\t{\n\n\t\t\t\t\t\tselectFibersByCurrent(tck,fobj_cur,annot.threshold)\n\t\t\t\t\t\treturn fobj_cur;\n\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if (annot.type == 'freeline')\n\t\t\t\t\t{\n\n\t\t\t\t\t\tfor (var j = 0; j < points.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar point = points[j];\n\t\t\t\t\t\t\tpoint.onupdate[tck.uid] = \n\n\t\t\t\t\t\t\tfunction(point) { return function(ondone)\t\t\t\t\t\t\n\t\t\t\t\t\t\t{\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\tselectFibersByTemplate(tck,annot);\n\t\t\t\t\t\t\t\t\tif (ondone && typeof ondone == 'function')\n\t\t\t\t\t\t\t\t\t\tondone();\n\t\t\t\t\t\t\t} \n\n\t\t\t\t\t\t\t}(point) \n\n\n\t\t\t\t\t\t\tpoint.removeupdater[tck.uid] =  function(point) { return function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdelete tck.annotation_subsets[point.uuid];\n\t\t\t\t\t\t\t} }(point) \n\t\t\t\t\t\t}\n\t\t\t\t\t\t\n\t\t\t\t\t\tif (points.length>0) // to force update after point cunt change\n\t\t\t\t\t\t\tpoints[0].onupdate[tck.uid](); \n\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\n\n\t\t\t\t\t\tfor (var j = 0; j < points.length; j++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar point = points[j];\n\t\t\t\t\t\t\tpoint.onupdate[tck.uid] = \n\n\t\t\t\t\t\t\tfunction(point) { return function(ondone)\t\t\t\t\t\t\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar coords = point.coords;\n\t\t\t\t\t\t\t\t\tif (coords == undefined)\n\t\t\t\t\t\t\t\t\t\tcoords = point.p.coords;\n\n\t\t\t\t\t\t\t\t\tif (tck.trackingVol)\n\t\t\t\t\t\t\t\t\t{\n\t                        \t\t\ttck.autogenerate_tracks = false;\n    \t\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\tvar ret = tck.fiberTracking({seed:{_data:coords},radius:point.size,threshold:tck.trackingVolHistoman.clim[1]});\n\n\t\t\t\t\t\t\t\t\t\ttck.fibers.content = ret;\n\t\t\t\t\t\t\t\t\t\ttck.subsetToDisplay = undefined;\n\t\t\t\t\t\t\t\t\t\ttck.updateFibers();\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse if (KObject3DTool.useOctreeWorker)\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t{\n\n\t\t\t\t\t\t\t\t\t\tvar callback2 = function(res)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tres.reference = point; \n\t\t\t\t\t\t\t\t\t\t\ttck.annotation_subsets[point.uuid] = res;\n\t\t\t\t\t\t\t\t\t\t\taggregateSelectionAndShow(point.parentmarkerset.markerpoints);\t\n\t\t\t\t\t\t\t\t\t\t\tif (typeof ondone == 'function')\n\t\t\t\t\t\t\t\t\t\t\t\tondone();\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t\t\t} \n\t\t\t\t\t\t\t\t\t\tvar octreeWorker = tck.fibers.content.octreeWorker;\n\t\t\t\t\t\t\t\t\t\toctreeWorker.findFibers(coords,point.size,undefined,callback2);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tvar octree = tck.fibers.content.octree;\n\t\t\t\t\t\t\t\t\t\ttck.annotation_subsets[point.uuid] = octree.findFibers(coords,point.size);\n\t\t\t\t\t\t\t\t\t\taggregateSelectionAndShow(point.parentmarkerset.markerpoints);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t} \n\n\t\t\t\t\t\t\t}(point) \n\n\n\t\t\t\t\t\t\tpoint.removeupdater[tck.uid] =  function(point) { return function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdelete tck.annotation_subsets[point.uuid];\n\t\t\t\t\t\t\t} }(point) \n\t\t\t\t\t\t}\n\t\t\t\t\t\tinitialSelection(points);\n\t\t\t\t\t}\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\t\n\t\t\t\tif (annot.onupdate[tck.uid]() == undefined)\n\t\t\t\t{\n\t\t\t\t\tvar points = annot.getPoints();\t\t\n\t\t\t\t\tif (tck.trackingVol)\n\t\t\t\t\t{\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse if (KObject3DTool.useOctreeWorker)\t\t\t\t\t\t\t\t\n\t\t\t\t\t{\n\t\t\t\t\t\tvar trySelect = function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar octreeWorker = tck.fibers.content.octreeWorker;\n\t\t\t\t\t\t\tif (octreeWorker.ready)\n\t\t\t\t\t\t\t\tinitialSelection(points);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tsetTimeout(trySelect,250);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttrySelect();\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tinitialSelection(points)\n\n\n\t\t\t\t}\n\n\t\t\t\tfunction initialSelection(points)\n\t\t\t\t{\n\t\t\t\t\titerateSync(0,points.length,\n\t\t\t\t\t\tfunction(j,ondone) { \n\t\t\t\t\t\tpoints[j].onupdate[tck.uid](ondone);  });\t\t\n\t\t\t\t}\n\t\t\t\tfunction iterateSync(current,end,fun)\n\t\t\t\t{\n\t\t\t\t\tif (current < end)\n\t\t\t\t\t\tfun(current,function() {iterateSync(current+1,end,fun) });\n\t\t\t\t    else\n\t\t\t\t    {\n\t\t\t\t    \ttck;\n\t\t\t\t    \tif (callback)\n\t\t\t\t    \t\tcallback(tck);\n\t\t\t\t    }\n\t\t\t\t}\n\n\n\t\t\t }\n\n\t\t\t tck.setAnnotationAssoc = setAnnotationAssoc;\n\n  \t\t\t function aggregateSelectionAndShow(points)\n\t\t\t {\n\t\t\t \tvar ps = []; \t\t\t \t\n\t\t\t\tvar ps_tmp \n\t\t\t\tif (points != undefined)\n\t\t\t\t\tps_tmp = Object.keys(points);\n\t\t\t\telse\n\t\t\t\t\tps_tmp = Object.keys(tck.annotation_subsets);\t\t\t\t\n\t\t\t\tfor (var k = 0; k < ps_tmp.length;k++)\n\t\t\t\t\tif (tck.annotation_subsets[ps_tmp[k]] != undefined && tck.annotation_subsets[ps_tmp[k]].reference.active)\n\t\t\t\t\t\tps.push(ps_tmp[k]);\n\n\t\t\t\tif (ps.length > 0)\n\t\t\t\t\ttck.subsetToDisplay = tck.annotation_subsets[ps[0]];\n\t\t\t\telse\n\t\t\t\t\ttck.subsetToDisplay = [];\n\n                if (tck.Selection != undefined)\n\t\t\t\t\ttck.subsetToDisplay = kintersect(tck.subsetToDisplay,tck.Selection.subset);\n\t\t\t\tfor (var k = 1; k < ps.length; k++)\n\t\t\t\t\ttck.subsetToDisplay = kintersect(tck.subsetToDisplay,tck.annotation_subsets[ps[k]]);\n\t\t\t\tif (tck.subsetToDisplay )\n\t\t\t\t\tviewer.statusbar.report(tck.subsetToDisplay.length + \" fibers shown\");\n\t\t\t\t\t\n\t\t\t\ttck.updateFibers();\t\t\t\n\t\t\t\tviewer;\t\t\t\n\t\t\t } \n\t\t\t tck.aggregateSelectionAndShow =aggregateSelectionAndShow;\n\n\n\n             function removeAnnotationAssoc()\n             {\n             \t  $showhidediv.removeClass(\"current\");\n\t\t\t\t  if (tck.associated_annotation != -1)\n\t\t\t\t  {\n\t\t\t\t     var annot = getAnnotationByID(tck.associated_annotation);\n\t\t\t\t\t if (annot != undefined)\n\t\t\t\t\t {\n\t\t\t\t\t\t delete annot.onupdate[tck.uid];\n\t\t\t\t\t\t var points = annot.getPoints();\n\t\t\t\t\t\t \n\n\n\t\t\t\t\t\t for (var j = 0; j < points.length; j++)\n\t\t\t\t\t\t {\n\t\t\t\t\t\t\tvar point = points[j];\n\t\t\t\t\t\t\tif (point.removeupdater[tck.uid])\n\t\t\t\t\t\t\t\tdelete point.removeupdater[tck.uid];\n\t\t\t\t\t\t    if (point.onupdate[tck.uid])\n\t\t\t\t\t\t\t\tdelete point.onupdate[tck.uid];\n\t\t\t\t\t\t }\n\t\t\t\t\t }\n\t\t\t\t\t tck.annotation_subsets = {};\n\t\t\t\t  }\n             }\n             tck.removeAnnotationAssoc = removeAnnotationAssoc;\n\n\n\n\t\t\t tck.fiberTracking = function (seeding,nooctree)\n\t\t\t {\n\n\t\t\t\t\tif (tck.fibers.content!= undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (tck.fibers.content.octreeWorker != undefined)\n\t\t\t\t\t \t\ttck.fibers.content.octreeWorker.kill();\n\t\t\t\t\t \telse if (tck.fibers.content.cid != undefined)\n\t\t\t\t\t \t{\n\t\t\t\t\t \t\tclearTimeout(tck.fibers.content.cid);\n\t\t\t\t\t \t}\n\t\t\t\t\t}\n\t\t\t\t\tvar ret =  realtimeTracking(seeding,tck.trackingVol,that.tracking_panel.params);\n\t\t\t\t\t\n\t\t\t\t\tif (nooctree == undefined || nooctree == false)\n\t\t\t\t\t{\n\t\t\t\t\t\tret.cid = setTimeout(function(){\n\t\t\t\t\t\t\tthat.buildOctree(ret,that.progressSpinner);\t\n\t\t\t\t\t\t\tret.cid = undefined;\t\t\t \n\t\t\t\t\t\t},10);\n\t\t\t\t\t}\n\n\t\t\t\t\tviewer.statusbar.report(ret.tracts.length + \" fibers tracked\");\n\n\t\t\t\t\treturn ret;\n\n\t\t\t }\n\n\n\n\n\n\n\n\n\n\t\t\tfunction createVisitMap(undersamp,terminal,persistent,dontshow)\n\t\t\t{\n\t\t\t\t\n\n \t\t\t\t  var fileObject;\n\t\t\t\t  var id = \"FVS_0\";\n\t\t\t\t  var cnt = 1;\n\t\t\t\t  while (KViewer.dataManager.getFile(id)!=undefined)\n\t\t\t\t\t  id = \"FVS_\" + cnt++;\n\n\t\t\t\t  var fname_prefix = \"fvisit_\";\n\t\t\t\t  var endpoints = -1;\n\t\t\t\t  if (terminal != undefined)\n\t\t\t\t  {\n\t\t\t\t\t  endpoints = terminal;\n\t\t\t\t\t  fname_prefix = \"fterms_\";\n\t\t\t\t  }\n\n\t\t\t\t  var fname = fname_prefix + tck.fibers.filename.replace('.tck','').replace('.json','');\n\t\t\t\t  if (tck.Selection)\n\t\t\t\t\tfname = fname_prefix + tck.Selection.name;\n\t\t\t\t  fileObject =  cloneNifti(viewer.content,fname,\"float\",1,undersamp);\n\t\t\t\t  fileObject.fileID = id;\n\t\t\t\t  fileObject.modified = true;\n\t\t\t\t  fileObject.refvisit_tck = tck;\n\t\t\t\t  fileObject.refvisit_params = {undersamp:undersamp,terminal:terminal};\n\n\t\t\t\t  KViewer.dataManager.setFile(fileObject.fileID,fileObject);\n\t\t\t\t  KViewer.cacheManager.update();\n                  \n\t\t\t\t\n\t\t\t\t  var worker = {fobj:fileObject,\n\t\t\t\t  \t\t\t\tupdateVisit:updateVisit,\n\t\t\t\t  \t\t\t\tshowInViewer: function(viewer){\n\t\t\t\t  \t\t\t\t  var fobj = this.fobj;\n\n                                  if (dontshow)\n                                      return;\n                                   \n\t\t\t\t  \t\t\t\t  if (viewer.nii && viewer.nii.dummy)\n\t\t\t\t\t\t\t\t\t  viewer.setContent(this.fobj,{intent:{}});\n\t\t\t\t\t\t\t\t  else\n\t\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\t\t\tKViewer.iterateMedViewers(function(v)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (v.currentFileID == viewer.currentFileID)\n\t\t\t\t\t\t\t\t\t\t\t\tv.setContent(fobj,{intent:{overlay:true}});                                       \n\t\t\t\t\t\t\t\t\t\t});                      \n\t\t\t\t\t\t\t\t  }\n\t\t\t\t  \t\t\t\t},\n\n\t\t\t\t  kill:function(){\n\t\t\t\t\t\tthis.worker.postMessage({'msg':'kill'})\t\t\t\t  \t\n\t\t\t\t  }};\n\n\n\t\t\t\t  updateVisit(true);\n\n\t\t\t\t  return worker;\n\t\t\n\n\n\t\t\t\t  function updateVisit(newfvs)\n\t\t\t\t  {\n\t\t\t\t\t  if (worker.cid != undefined)\n\t\t\t\t\t\tclearTimeout(worker.cid)\n\n\t\t\t\t\t  worker.cid=setTimeout(function() {\n \t\t\t\t\t\tworker.cid = undefined;\n\t\t\t\t\t\t  if (worker.inprogress)\n\t\t\t\t\t\t\tupdateVisit()\n\t\t\t\t\t\t  else\n\t\t\t\t\t\t\tcalcvis();\n\t\t\t\t\t  },250);\n\n\t\t\t\t\t  function calcvis()\n\t\t\t\t\t  {\n\t\t\t\t\t  \t  if (tck.fibers.content ==undefined || tck.fibers.content.tracts == undefined)\n\t\t\t\t\t  \t  \t return;\n\t\t\t\t\t\t  worker.inprogress = true;\n\t\t\t\t\t\t  var fileObject = KViewer.dataManager.getFile(id);\n\n\t\t\t\t\t\t  var subset = tck.subsetToDisplay;\n\t\t\t\t\t\t  if (subset && subset.length == 0)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\tsubset = undefined;\n\t\t\t\t\t\t\tif (tck.Selection)\n\t\t\t\t\t\t\t\tsubset = tck.Selection.subset;\n\t\t\t\t\t\t  }\n\n\t\t\t\t\t\t  worker.worker = createFiberVisitMap(tck.fibers.content.tracts,subset,endpoints,\n\t\t\t\t\t\t\t\t\t\t\t  fileObject,\n\t\t\t\t\t\t\t\t\t\t\t  viewer.viewport.progressSpinner,\n\t\t\t\t\t\t  function()\n\t\t\t\t\t\t  {\n\n\t\t\t\t\t\t\t  // redo parsing to get histogram right \n\t\t\t\t\t\t\t  fileObject.content = prepareMedicalImageData(parse(fileObject.buffer), fileObject, {});\n\n\t\t\t\t\t\t\t  signalhandler.send(\"updateFilelink\",{id:fileObject.fileID});\n\t\t/*\t\t\t\t\t  var col = tck.color;\n\t\t\t\t\t\t\t  if (tck.Selection)\n\t\t\t\t\t\t\t\t col = tck.Selection.color;\n\t\t\t\t\t\t\t  if (viewer.nii && viewer.nii.dummy)\n\t\t\t\t\t\t\t\t  viewer.setContent(fileObject,{intent:{}});\n\t\t\t\t\t\t\t  else\n\t\t\t\t\t\t\t\t  viewer.setContent(fileObject,{intent:{roi:1,roilim:100050,color:col-1}});\n\t\t*/\t\t\t\n\n\t\t\t\t\t\t\t  if (newfvs)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  \t  worker.showInViewer(viewer);\n\t\t\t\t\t\t\t  \t  newfvs = false;\n\t\t\t\t\t\t\t  }\n\n\t\t\t\t\t\t\t  if (!persistent)\n\t\t\t\t\t\t\t  \tworker.kill();\n\n\t\t\t\t\t\t\t  worker.inprogress = false;\n\t\t\t\t\t\t\t \n\t\t\t\t\t\t  }, worker );\n\t\t\t\t\t  }\n\t\t\t\t}\n\t\t\t}\n\n            tck.createVisitMap = createVisitMap;\n\n\n\t\n\n\n\t\t\tfunction selectFibersByROI(tck,roi,minus,percentage,threshold)\n\t\t\t{\n\t\t\t\t  if (threshold == undefined)\n\t\t\t\t  \tthreshold = 0.5;\n\n\t\t\t\t  var tracts = tck.fibers.content.tracts;\n\t\t\t\t  var bbox_max = tck.fibers.content.tracts_max;\n\t\t\t\t  var bbox_min = tck.fibers.content.tracts_min;\n\t\t\t\t  var edges = math.inv(roi.content.edges);\n\t\t\t\t  var sz = roi.content.sizes;\n\n\t\t\t\t  viewer.$container.find(\"div[class='KViewPort_spinner']\").show()\n\t\t\t\t  viewer.viewport.progressSpinner(\"building Bounding Box\");\n\t\t\t\n\t\t\t\t  setTimeout(function() {\t\t\t\t\n\t\t\t\t  KViewer.roiTool.computeBBox(roi);\n\t\t\t\t  var roi_bbox_max  = roi.bbox.max;\n\t\t\t\t  var roi_bbox_min  = roi.bbox.min;\n\n\t\t\t\t  function filter(k)\n\t\t\t\t  {\n\t\t\t\t\t   var tract = tracts[k];\n\t\t\t\t\t   var max = [bbox_max[3*k],bbox_max[3*k+1],bbox_max[3*k+2]];\n\t\t\t\t\t   var min = [bbox_min[3*k],bbox_min[3*k+1],bbox_min[3*k+2]];\n\t\t\t\t\t   for (var i = 0; i < 3;i++)\n\t\t\t\t\t   {\n\t\t\t\t\t\t\tif (max[i]<roi_bbox_min[i] | roi_bbox_max[i]<min[i])\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t   }\n\n\n\t\t\t\t\t   var e =(edges)._data;\n\t\t\t\t\t   if (percentage > 0)\n\t\t\t\t\t   {\n\t\t\t\t\t\t   var hit = 0;\n\t\t\t\t\t\t   for (var j = 0; j < tract.length/3;j++)\n\t\t\t\t\t\t   {\n\t\t\t\t\t\t\t  var p = [Math.round(e[0][0]*tract[3*j] + e[0][1]*tract[3*j+1] + e[0][2]*tract[3*j+2] + e[0][3]),\n\t\t\t\t\t\t\t\t\t   Math.round(e[1][0]*tract[3*j] + e[1][1]*tract[3*j+1] + e[1][2]*tract[3*j+2] + e[1][3]),\n\t\t\t\t\t\t\t\t\t   Math.round(e[2][0]*tract[3*j] + e[2][1]*tract[3*j+1] + e[2][2]*tract[3*j+2] + e[2][3])];\n\t\t\t\t\t\t\t  if (p[0]>=0 && p[0] < sz[0] &&  p[1]>=0 && p[1] < sz[1] && p[2]>=0 && p[2] < sz[2] \n\t\t\t\t\t\t\t  \t  && roi.content.data[sz[0]*sz[1]*p[2] + sz[0]*p[1] + p[0]] > threshold)\n\t\t\t\t\t\t\t\thit++;\n\t\t\t\t\t\t\t  if (hit/tract.length*3 > percentage)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\t   tck.subsetToDisplay.push(k);\n\t\t\t\t\t\t\t\t   return;\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t   }\n\n\t\t\t\t\t   }\n\t\t\t\t\t   else\n\t\t\t\t\t\t   for (var j = 0; j < tract.length/3;j++)\n\t\t\t\t\t\t   {\n\t\t\t\t\t\t\t  var p = [Math.round(e[0][0]*tract[3*j] + e[0][1]*tract[3*j+1] + e[0][2]*tract[3*j+2] + e[0][3]),\n\t\t\t\t\t\t\t\t\t   Math.round(e[1][0]*tract[3*j] + e[1][1]*tract[3*j+1] + e[1][2]*tract[3*j+2] + e[1][3]),\n\t\t\t\t\t\t\t\t\t   Math.round(e[2][0]*tract[3*j] + e[2][1]*tract[3*j+1] + e[2][2]*tract[3*j+2] + e[2][3])];\n\t\t\t\t\t\t\t  if (p[0]>=0 && p[0] < sz[0] &&  p[1]>=0 && p[1] < sz[1] && p[2]>=0 && p[2] < sz[2] \n\t\t\t\t\t\t\t  \t  && roi.content.data[sz[0]*sz[1]*p[2] + sz[0]*p[1] + p[0]] > threshold)\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\t tck.subsetToDisplay.push(k);\n\t\t\t\t\t\t\t\t return;\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t   }\n\t\t\t\t  }\n\n\t\t\t\t  if (tck.subsetToDisplay == undefined) tck.subsetToDisplay = [];\t\t\t\t\t\t\t  \n\t\t\t\t  if (tck.subsetToDisplay.length >0)\n\t\t\t\t  {\n\t\t\t\t\t var subs = tck.subsetToDisplay;\n\t\t\t\t\t tck.subsetToDisplay =[];\n\t\t\t\t\t subs.chunk(\n\t\t\t\t\t   function(tract,k) { filter(subs[k]); },2048,1,\n\t\t\t\t\t   function(i) { viewer.viewport.progressSpinner(\"filtering \" + Math.round(100*i/subs.length) + \"%\"); },\n\t\t\t\t\t   function()  { \n\t\t\t\t\t\tif (minus)\n\t\t\t\t\t\t\ttck.subsetToDisplay = $(subs).not(tck.subsetToDisplay).get();\n\n\t\t\t\t\t   tck.updateFibers();\tviewer.viewport.progressSpinner();  });\n\t\t\t\t  }\n\t\t\t\t  else\n\t\t\t\t  {\n\t\t\t\t\t tck.subsetToDisplay =[];\n\t\t\t\t\t tracts.chunk(\n\t\t\t\t\t   function(tract,k) { filter(k); },2048,1,\n\t\t\t\t\t   function(i) { viewer.viewport.progressSpinner(\"filtering \" + Math.round(100*i/tracts.length) + \"%\"); },\n\t\t\t\t\t   function()  { \n\t\t\t\t\t\tif (minus)\n\t\t\t\t\t\t\ttck.subsetToDisplay = invert(tck.subsetToDisplay,tracts.length);\n\n\t\t\t\t\t   tck.updateFibers();\tviewer.viewport.progressSpinner();  });\n\t\t\t\t  }\n\t\t\t\t  tck.subsetToDisplay =[];\n\t\t\t\t  tck.fiberSign=[];\n\n\n\t\t\t   },0); \n\t\t\t } \n\n\t\t\tfunction selectFibersByTemplate(tck,annot)\n\t\t\t{\n\t\t\t\t  var tracts = tck.fibers.content.tracts;\n\t\t\t\t  var tracts_len = tck.fibers.content.tracts_len;\n\t\t\t\t  var pts = annot.getPoints();\n\t\t\t\t  var nc = pts.length;\n\t\t\t\t  tck.subsetToDisplay =[];\n\t\t\t\t  tck.fiberSign=[];\n\t\t\t\t  if (nc > 1)\n\t\t\t\t  {\n\n\t\t\t\t\t  var ps = [];\n\t\t\t\t\t  var r = [];\n\t\t\t\t\t  var cum_d = [];\n\t\t\t\t\t  var d0  = 0;\n\t\t\t\t\t  for (var k = 0; k < nc;k++)\n\t\t\t\t\t  {\n\t\t\t\t\t\t\tvar c = pts[k].p.coords;\n\t\t\t\t\t\t\tps.push(c[0],c[1],c[2]);\n\t\t\t\t\t\t\tr.push(1/(pts[k].p.size*pts[k].p.size));\n\t\t\t\t\t\t\tvar d = 0;\n\t\t\t\t\t\t\tif (k>0)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tvar c0 = pts[k-1].p.coords;\n\t\t\t\t\t\t\t\tvar c1 = pts[k].p.coords;\n\t\t\t\t\t\t\t\td = Math.sqrt( (c0[0]-c1[0])*(c0[0]-c1[0]) + (c0[1]-c1[1])*(c0[1]-c1[1]) + (c0[2]-c1[2])*(c0[2]-c1[2]) )\n\t\t\t\t\t\t\t\tif (d==0)\n\t\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\td0 += d;\n\t\t\t\t\t\t\tcum_d.push(d0);\n\t\t\t\t\t  }\n\t\t\t\t\t  for (var k = 0; k < nc;k++)\n\t\t\t\t\t\t  cum_d[k] /= cum_d[nc-1];\n\n\t\t\t\t\t  var dist = 0;\n\t\t\t\t\t  var dist2 = 0;\n\t\t\t\t\t  var sg;\n\t\t\t\t\t  var scale = 10;\n\n\t\t\t\t\t  for (var j = 0; j <tracts.length;j++)\n\t\t\t\t\t  {\n\t\t\t\t\t\t  var l = tracts_len[j]*0.99999999;\n\t\t\t\t\t\t  var dist = 0;\n\t\t\t\t\t\t  var dist2 = 0;\n\t\t\t\t\t\t  for (var k = 0; k < nc;k++)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  var idx = Math.floor(cum_d[k]*l);\n\t\t\t\t\t\t\t  var dx = ps[3*k]   - tracts[j][3*idx];\n\t\t\t\t\t\t\t  var dy = ps[3*k+1] - tracts[j][3*idx+1];\n\t\t\t\t\t\t\t  var dz = ps[3*k+2] - tracts[j][3*idx+2];\n\t\t\t\t\t\t\t  dist += ((dx*dx+dy*dy+dz*dz)*r[k] < scale)?1:0;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  for (var k = 0; k < nc;k++)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  var idx = Math.floor(cum_d[k]*l);\n\t\t\t\t\t\t\t  var dx = ps[3*(nc-1-k)]   - tracts[j][3*idx];\n\t\t\t\t\t\t\t  var dy = ps[3*(nc-1-k)+1] - tracts[j][3*idx+1];\n\t\t\t\t\t\t\t  var dz = ps[3*(nc-1-k)+2] - tracts[j][3*idx+2];\n\t\t\t\t\t\t\t  dist2 += ((dx*dx+dy*dy+dz*dz)*r[k] < scale)?1:0;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t\tif (dist < dist2)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tdist = dist2;\n\t\t\t\t\t\t\t\tsg = -1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tsg = 1;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (dist/nc >= 0.999)\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\ttck.subsetToDisplay.push(j);\n\t\t\t\t\t\t\t\ttck.fiberSign.push(sg);\n\t\t\t\t\t\t\t}    \t\t\t      \n\t\t\t\t\t  }\n\t\t\t\t  }\n\n\n\n\t\t\t\t  tck.updateFibers();\n\n\n\t\t\t}\n\n\t\t\tfunction selectFibersByTemplate_old(tck,annot)\n\t\t\t{\n\t\t\t\t  var tracts = tck.fibers.content.tracts;\n\t\t\t\t  var pts = annot.getPoints();\n\t\t\t\t  var nc = pts.length;\n\t\t\t\t  tck.subsetToDisplay =[];\n\t\t\t\t  tck.fiberSign=[];\n\t\t\t\t  if (tck.fibers.content.sub_samp == undefined)\n\t\t\t\t  \t tck.fibers.content.sub_samp = {};\n\t\t\t\t  if (tck.fibers.content.sub_samp[nc] == undefined)\n\t\t\t\t  {\t\t\t\n\t\t\t\t    var ss = [];\t  \t\n\t\t\t\t    for (var k = 0; k < tracts.length; k++)\n\t\t\t\t\t\tss[k] =  reparam_track_constPcnt(tracts[k],undefined,nc);\n\t\t\t\t\ttck.fibers.content.sub_samp[nc] = ss;\n\t\t\t\t  }\n\n\t\t\t\t  var tc_ss = tck.fibers.content.sub_samp[nc];\n\t\t\t\n\t\t\t\t  var ps = [];\n\t\t\t\t  var r = [];\n    \t\t\t  for (var k = 0; k < nc;k++)\n    \t\t\t  {\n\t\t\t\t\t\tps.push(pts[k].p.coords[0],pts[k].p.coords[1],pts[k].p.coords[2]);\n\t\t\t\t\t\tr.push(1/(pts[k].p.size*pts[k].p.size));\n    \t\t\t  }\n    \t\t\t  var sg = 1;\n\t\t\t\t  for (var j = 0; j < tc_ss.length;j++)\n\t\t\t\t  {\n\t\t\t\t\tvar dist = 0;\n\t\t\t\t  \tfor (var k = 0; k < nc;k++)\n\t\t\t\t  \t{\n\t\t\t\t\t\tvar dx = ps[3*k]   - tc_ss[j][3*k];\n\t\t\t\t\t\tvar dy = ps[3*k+1] - tc_ss[j][3*k+1];\n\t\t\t\t\t\tvar dz = ps[3*k+2] - tc_ss[j][3*k+2];\n\t\t\t\t\t\tdist += ((dx*dx+dy*dy+dz*dz)*r[k] < 10)?1:0;\n\n\t\t\t\t  \t}\n\t\t\t\t\tvar dist2 = 0;\n\t\t\t\t  \tfor (var k = 0; k < nc;k++)\n\t\t\t\t  \t{\n\t\t\t\t\t\tvar dx = ps[3*(nc-1-k)]   - tc_ss[j][3*k];\n\t\t\t\t\t\tvar dy = ps[3*(nc-1-k)+1] - tc_ss[j][3*k+1];\n\t\t\t\t\t\tvar dz = ps[3*(nc-1-k)+2] - tc_ss[j][3*k+2];\n\t\t\t\t\t\tdist2 += ((dx*dx+dy*dy+dz*dz)*r[k] < 10)?1:0;\n\n\t\t\t\t  \t}\n\t\t\t\t  \tif (dist < dist2)\n\t\t\t\t  \t{\n\t\t\t\t  \t\tdist = dist2;\n\t\t\t\t  \t\tsg = -1;\n\t\t\t\t  \t}\n\t\t\t\t  \telse\n\t\t\t\t  \t{\n\t\t\t\t  \t\tsg = 1;\n\t\t\t\t  \t}\n\t\t\t\t  \tif (dist/nc >= 0.999)\n\t\t\t\t  \t{\n\t\t\t\t  \t\ttck.subsetToDisplay.push(j);\n\t\t\t\t\t    tck.fiberSign.push(sg);\n\t\t\t\t  \t}\n\n\t\t\t\t  }\n\t\t\t\t    tck.updateFibers();\n\n\n\n\t\t\t}\n\n\n\t\t\tfunction selectFibersByCurrent(tck,current,thres)\n\t\t\t{\n\n\t\t\t\t  var tracts = tck.fibers.content.tracts;\n\t\t\t\t  var bbox_max = tck.fibers.content.tracts_max;\n\t\t\t\t  var bbox_min = tck.fibers.content.tracts_min;\n\t\t\t\t  var edges = math.inv(current.content.edges);\n\t\t\t\t  var sz = current.content.sizes;\n\t\t\t\t  var totsz = sz[0]*sz[1]*sz[2];\n\n\t\t\t\t  viewer.$container.find(\"div[class='KViewPort_spinner']\").show()\n\t\t\t\t  viewer.viewport.progressSpinner(\"building Bounding Box\");\n\n\t\t\t\n\t\t\t\t  setTimeout(function() {\t\t\t\t\n\t\t\t\t  var roi_bbox_max  = current.content.bbox.max;\n\t\t\t\t  var roi_bbox_min  = current.content.bbox.min;\n\t\t\t\t  var data = current.content.data;\n\n\t\t\t\t  function filter(k)\n\t\t\t\t  {\n\t\t\t\t\t   var tract = tracts[k];\n\t\t\t\t\t   var max = [bbox_max[3*k],bbox_max[3*k+1],bbox_max[3*k+2]];\n\t\t\t\t\t   var min = [bbox_min[3*k],bbox_min[3*k+1],bbox_min[3*k+2]];\n\t\t\t\t\t/*   for (var i = 0; i < 3;i++)\n\t\t\t\t\t   {\n\t\t\t\t\t\t\tif (max[i]<roi_bbox_min[i] | roi_bbox_max[i]<min[i])\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t   }\n\n*/\n\t\t\t\t\t   var e = edges._data;\n\t\t\t\t\t   var p0 ;\n\t\t\t\t\t   var v0 ;\n\t\t\t\t\t   var abscur = 0;\n\t\t\t\t\t   for (var j = 0; j < tract.length/3;j++)\n\t\t\t\t\t   {\n\t\t\t\t\t\t  var p = [tract[3*j],tract[3*j+1],tract[3*j+2]];\n\t\t\t\t\t\t  var v = [ trilinInterp(current.content,p[0],p[1],p[2],e,0),\n\t\t\t\t\t\t  \t\t\ttrilinInterp(current.content,p[0],p[1],p[2],e,totsz),\n\t\t\t\t\t\t  \t\t\ttrilinInterp(current.content,p[0],p[1],p[2],e,totsz*2)];\n\n\t\t\t\t\t\t  if (p0 !=undefined)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  var proj = v[0]*(p[0]-p0[0])+v[1]*(p[1]-p0[1])+v[2]*(p[2]-p0[2]);\n\t\t\t\t\t\t\t  if (!isNaN(proj))\n\t\t\t\t\t\t\t  \tabscur += proj*proj;\n\t\t\t\t\t\t  }\n\t\t\t\t\t\t  \n\t\t\t\t\t\t  p0 = p;\n\n\t\t\t\t\t\t  if (abscur > thres*thres)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t  \ttck.subsetToDisplay.push(k);\n\t\t\t\t\t\t  \tbreak;\n\t\t\t\t\t\t  }\n\t\t\t\t\t   }\n\t\t\t\t  }\n\n\n\n\t\t\t\t  tck.subsetToDisplay =[];\n\t\t\t\t  tck.fiberSign=[];\n\n\t\t\t\t  var offs = 0;\n\t\t\t\t  var cid = setInterval(function()\n\t\t\t\t  {\n\t\t\t\t  \t  for (var j = 0 ; j < 2048 & (j+offs) < tracts.length; j++)\n\t\t\t\t  \t  \t filter(j+offs);\n\t\t\t\t  \t  offs += 2048;\n\t\t\t\t  \t  if (offs >= tracts.length)\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \t clearInterval(cid);\n\t\t\t\t  \t  \t viewer.viewport.progressSpinner(); \n\t\t\t\t  \t  }\n\t\t\t\t  \t  else\n                      \t viewer.viewport.progressSpinner(\"filtering \" + Math.round(100*offs/tracts.length) + \"%\"); \t\t\t\t  \t \n                      tck.updateFibers();\t\n\n\t\t\t\t  });\n\n/*\n\n\t\t\t\t\t tracts.chunk(\n\t\t\t\t\t   function(tract,k) { filter(k); },2048,1,\n\t\t\t\t\t   function(i) { viewer.viewport.progressSpinner(\"filtering \" + Math.round(100*i/tracts.length) + \"%\"); },\n\t\t\t\t\t   function()  { \n\t\t\t\t\t   tck.updateFibers();\tviewer.viewport.progressSpinner();  });\n*/\n\t\t\t   },0); \n\t\t\t } \n\n\n\n\n\n\n\n\n\t        /***************************************************************************************\n\t\t     * close the viewer\n\t\t     ****************************************************************************************/\n\n  \t\t\t function close()\n             {\n\t\t\t\t  if (tck.children)\n\t\t\t\t  {\n\t\t\t\t  \tvar childs = tck.children.slice(0);\n\t\t\t\t  \tfor (var k = 0 ; k < childs.length;k++)\n\t\t\t\t  \t\tchilds[k].close();\n\t\t\t\t  }\n\t\t\t\t  if (tck.fibtrackWorker)\n\t\t\t\t  {\n\t\t\t\t  \t tck.fibtrackWorker.kill()\n\t\t\t\t  }\n\n\t\t\t\t  if (tck.visitworker)\n\t\t\t\t  \ttck.visitworker.kill();\n\t\t\t\t  if (tck.visitworker_terms)\n\t\t\t\t  \ttck.visitworker_terms.kill();\n\n\t\t\t\t  if (!tck.isParentView)\n\t\t\t\t  {\n\t\t\t\t  \t for (var k = 0 ; k < tck.parent.children.length; k++)\n\t\t\t\t  \t {\n\t\t\t\t\t  \t if (tck.parent.children[k] == tck)\n\t\t\t\t\t  \t {\n\t\t\t\t\t  \t \ttck.parent.children.splice(k,1);\n\t\t\t\t\t  \t \tbreak;\n\t\t\t\t\t  \t }\n\t\t\t\t  \t }\n\n\t\t\t\t  }\n\n\t\t\t\t  if (tck.sid_climchange != undefined)\n\t\t\t\t\t\t signalhandler.detach(\"climChange\",tck.sid_climchange);\n\t\t\t\t  if (tck.osid_climchange != undefined)\n\t\t\t\t\t\t signalhandler.detach(\"overlay_climChange\",tck.osid_climchange);\n\n\t\t\t\t  if ( (tck.isParentView && tck.trackingVol != undefined) ||\n\t\t\t\t  \t  (tck.parent != undefined && tck.parent.fibers.content && tck.parent.fibers.content.octreeWorker !=  tck.fibers.content.octreeWorker   ) )\n\t\t\t\t  {\n\t\t\t\t  \t\n\t\t\t\t  \t if (tck.fibers.content.octreeWorker != undefined)\n\t\t\t\t\t \t\ttck.fibers.content.octreeWorker.kill();\n\t\t\t\t  }\n\n             \t  if (viewer.gl != undefined)\n             \t  {\n\t\t\t\t\t  viewer.gl.detachShader(fiberDirColor_shader);\n\t\t\t\t\t  for (var k = 0; k< tck.divs.length;k++)\n\t\t\t\t\t\t tck.divs[k].remove();\n\t\t\t\t\t  for (var k = 0; k < viewer.objects3D.length;k++)\n\t\t\t\t\t  {\n\t\t\t\t\t\tif (tck == viewer.objects3D[k])\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (viewer.objects3D[k].fiberUpdater != undefined)\n\t\t\t\t\t\t\t\t\tviewer.objects3D[k].fiberUpdater.clear();\n\t\t\t\t\t\t\tviewer.objects3D.splice(k,1);\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t  }\n\t\t\t\t\t  removeAnnotationAssoc();\n\n\t\t\t\t\t  viewer.gl.activateRenderLoop();\n\t\t\t\t\t  if (viewer.objects3D.length == 0 & viewer.nii == undefined)\n\t\t\t\t\t\tviewer.$canvas3D.hide();\n             \t  }\n\n             \t  for (var k=0; k < viewer.overlays.length;k++)\n             \t  {\n             \t  \tif (viewer.overlays[k].content.content == tck.trackingVol)\n             \t  \t{\n             \t  \t\tviewer.overlays[k].close()\t;\n             \t  \t\tbreak;\n             \t  \t}\n             \t  }\n\n             \t  viewer.toolbar.update(\"fiber\");\n\n\t\t\t\t  if (viewer.nii && viewer.nii.dummy && viewer.objects3D.length == 0)\n\t\t\t\t  \tviewer.close();\n\n             }\n             tck.close = close;\n             signalhandler.attach(\"close\",close);\n\n\n\t        /***************************************************************************************\n\t\t     * select this fiberview as current active for (just concerns picker)\n\t\t     ****************************************************************************************/\n\n\n\n\n\t\t\t function makeCurrent(e)\n\t\t\t {\n\t\t\t \t var lastassoc =-1 ;\n\t\t\t\t for (var k = 0; k < viewer.objects3D.length;k++)\n\t\t\t\t {\n\t\t\t\t\t\n\t\t\t\t\tif (tck != viewer.objects3D[k])\n\t\t\t\t\t{\n\t\t\t\t\t\tif (viewer.objects3D[k].fibers != undefined)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tif (viewer.objects3D[k].isCurrent)\n\t\t\t\t\t   \t\t    lastassoc = viewer.objects3D[k].associated_annotation;\n\t\t\t\t\t\t\tif (e && e.shiftKey)\n\t\t\t\t\t\t\t\t;\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t//removeAnnotationAssoc();\n\t\t\t\t\t\t\t\tviewer.objects3D[k].selectFibersReset('none');\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tviewer.objects3D[k].isCurrent = false;\n\t\t\t\t\t\t\tviewer.objects3D[k].$currentpickerdiv.removeClass(\"current\");\n\t\t\t\t\t\t\tviewer.objects3D[k].$captiondiv.removeClass(\"current\");\n\t\t\t\t\t\t}\n\n\t\t\t\t\t}\n\t\t\t\t }\n \t\t\t     tck.isCurrent = true;\n\t\t\t     setAnnotationAssoc(lastassoc);\t\n\t\t\t\t if (lastassoc == -1)\n\t\t\t \t    selectFibersReset('all');\t\t\t\t  \t  \t\t\t\t\t  \t  \n\t\t\t     tck.$currentpickerdiv.addClass(\"current\");\n\t\t\t     tck.$captiondiv.addClass(\"current\");\n\t\t\t }\n\n\n\t\t\t \n\t\t\t if (intent.visible == undefined)\n\t\t\t \tintent.visible = true;\n\t\t\t\n\t\t\t if (!intent.donotmakecurrent)\n\t\t\t \tintent.donotmakecurrent = false;\n\n\n\t\t \t\n\t\t\t if (!intent.donotmakecurrent)\n\t\t\t {\n\t\t\t \tmakeCurrent();\n\t\t\t }\n\t\t\t if (!intent.visible)\n\t\t\t \ttck.subsetToDisplay = [];\t\n\n\t\t\t if (intent != undefined)\n\t\t\t {\n\t\t\t\tif(intent.assoc_annot != undefined)\n\t\t\t\t\tsetAnnotationAssoc(intent.assoc_annot);\n\t\t\t\telse if (intent.assoc != undefined)\n\t\t\t\t\tsetAnnotationAssoc(intent.assoc);\t\t\n\t\t\t }\n\n\t\t\t \n\n\n\t\t     tck.updateFibers();\n\n             return tck;\n        }\n\n\n\n\n\n  \t /***************************************************************************************\n\t  * the surface subview\n\t  ****************************************************************************************/\n\n\n\t  that.surfacecnter = 0;\n      that.createSurfaceView = function(fobj,viewer,intent)\n      {\n            var viewer = viewer;\n            var obj = { surf:fobj,\n                        color: (that.surfacecnter++)%6,\n                        alpha:0.8,\n                        gamma:1,\n\t\t\t\t\t\texposure:0,                        \n                        alphaMode:0,\n                        wire:false,\n                        cuts:[0,0,0],\n                        overlays:[],\n                        beltwidth:0,\n                        pickable:true,\n                        visible:true,\n                        type:\"surface\",\n\t\t\t\t\t\tuid: KObject3DTool.uidCnter++,\n            };\n\n\n\t\t\tobj.getViewProperties = function()\n\t\t\t{\n\t\t\t\treturn {color:this.color,\n\t\t\t\t\t\twire:this.wire,\n\t\t\t\t\t\talpha:this.alpha,\n\t\t\t\t\t\talphaMode:this.alphaMode,\n\t\t\t\t\t\tcuts:this.cuts,\n\t\t\t\t\t\tbeltwidth:this.beltwidth,\t\t\t\t\t\t\n\t\t\t\t\t\tvisible:this.visible};\n\t\t\t}\n\n\n\t\t\tobj = $.extend(obj,intent);\n\n \t\t    /***************************************************************************************\n\t\t    * the viewer toolbar\n\t\t\t****************************************************************************************/\n\n\t\t\t// color contextmenu\n\t\t\tvar cols = [].concat(KColor.list)\n\t\t\tcols[9] = [255,255,255];\n       \t    obj.colors = cols;\n\t\n       \t    function colencode(c) {\tif (c != undefined)\n       \t    \t\t\t\t\t\t\treturn \"background:\"+RGB2HTML(c[0],c[1],c[2])+\";\"; \n       \t    \t\t\t\t\t    else\n       \t    \t\t\t\t\t    \treturn \"background:\"+RGB2HTML(0,0,0)+\";\"; }\n\t\t\tvar $colselector = KColorSelector(obj.colors,colencode,\n\t\t\t\t function() {viewer.gl.setSurfColor(obj); \n\t\t\t\t \t\t\t obj.update();\n\t\t\t\t \t\t\t viewer.gl.activateRenderLoop(); },obj);\n\t\t\n\t\t\tvar $captiondiv,$cutdiv,$dragdiv,$visdiv,$griddiv,$alphadiv;\n            obj.divs = [ \t$(\"<br style='clear:both' />\"),\n                          $(\"<div  class='KViewPort_tool surface persistent'>  <i class='fa fa-close fa-1x'></i></div>\").click( close  )\n                          .mousedown(viewer.viewport.closeContextMenu(obj)),\n                          $cutdiv=$(\"<div  class='KViewPort_tool surface' >  <i   class='fa fa-cut fa-1x'></i></div>\").click( cutContextmenu ),\n                          $colselector,\n                          $visdiv = $(\"<div  class='KViewPort_tool surface'>  <i class='fa fa-eye fa-1x'></i></div>\").click( toggleVisibility  ),\n                          $alphadiv = $(\"<div  class='KViewPort_tool surface'>  <i class='fa fa-alpha fa-1x'>&#945;\t</i></div>\") .click( toggleAlpha  ),                             \n                          $griddiv = $(\"<div  class='KViewPort_tool surface'>  <i class='fa fa-th fa-1x'>\t</i></div>\") .click( toggleWire  ),                             \n                          $captiondiv = $(\"<div  class='KViewPort_tool surface caption'> \"+obj.surf.filename+\"</div>\"),\n                          $dragdiv = $(\"<div  class='KViewPort_tool draganddrop surface'>  <i class='fa fa-hand-paper-o fa-1x'></i></div>\"),\n                         \n                       ];\n\n\t\t\tif (fobj.content.vals != undefined)\n\t\t\t{\n\t\t\t\tobj.histoManager = viewer.createHistoManager();\n\t\t\t\tobj.histoManager.nii = { datascaling : {e:function(x){return x;} }, \n\t\t\t\t\t\t\t\t\t\t histogram: obj.surf.content.histogram};\n\t\t\t\tobj.histoManager.onclimchange = function(ev) {\t\t\t\t   viewer.gl.activateRenderLoop(); obj.update();}\n\t\t\t\tobj.histoManager.oncmapchange= function(ev) {\t\t\t\t   viewer.gl.activateRenderLoop(); obj.update();}\n\n\n\n\t\t\t\tif (intent.clim)\n\t\t\t\t\tobj.histoManager.clim = [intent.clim[0],intent.clim[1]];\n\t\t\t\telse\n\t\t\t\t{ \t\t\t\t\t\t\t\t\t \n\t\t\t\t\tvar histogram = obj.surf.content.histogram;\n\t\t\t\t\tobj.histoManager.clim = [histogram.min+0.1*(histogram.max-histogram.min),\t\t\t\t\t\n                                             histogram.max+0.1*(histogram.max-histogram.min)]\n\t\t\t\t}\n\t\t\t\n\n\n\n\t\t\t\tobj.histoManager.updateHistogramClim();\n\t\t\t\tobj.histoManager.layoutHistogram();\n\n\t\t\t}\n\n\t\t\tif (obj.surf.fileinfo.roireference == undefined || \n\t\t\t\tobj.surf.toolbar_visible)\n\t\t\t{\n\t\t\t\tviewer.toolbar.append(obj.divs,'surface')\n\t\t\t\tobj.toolbarAttached = true;\n\n\t\t\t}\n\n\t\t\t$captiondiv.on('mouseenter',function(){\t\t\t\t\n\t\t\t\t obj.alphaMode = (obj.alphaMode+1)%6;\n\t\t\t\t update();\n\t\t\t});\n\t\t\t$captiondiv.on('mouseleave',function(){\t\n\t\t\t\t  obj.alphaMode = (obj.alphaMode+5)%6;\t\t\t\n\t\t\t\t  update();\n\t\t\t});\n\n\t\t\tvar exTimeout = function(fun,time)\n\t\t\t{\n\t\t\t\tif (fun.id !== undefined)\n\t\t\t\t\tclearTimeout(fun.id);\n\t\t\t\tfun.id = setTimeout(fun,time);\t\t\t\t\t\n\n\t\t\t}\n\n\t\t\tobj.$captiondiv = $captiondiv;\n\n\n            $dragdiv.attr(\"draggable\",'true');\n            $dragdiv.on(\"dragstart\",\n\t\t\t\t\t\tdragstarter(function() {\n\t\t\t\t\t\treturn {\n\t\t\t\t\t\t\ttype: 'file',\n\t\t\t\t\t\t\tmime: 'surf',\n\t\t\t\t\t\t\tfilename:  obj.surf.filename,\n\t\t\t\t\t\t\tfileID:  obj.surf.fileID,\n\t\t\t\t\t\t\tintent: {\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\tcolor:obj.color\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tclose: close\n\t\t\t\t\t\t}}));\n\n\t\t\tobj.contextmenu3D = function(evt,pickResult,p)\n\t\t    {\n\t\t\t\t   var contextMenu = KContextMenu(\n\t\t\t\t\t  function() {\n\n\t\t\t\t\t\tvar $menu =  $(\"<ul class='menu_context'>\");\n\n\t\t\t\t\t\t$menu.append($(\"<li onchoice='color' > Color  </li>\"));\n\t\t\t\t\t\t$menu.append($(\"<li onchoice='crop' > xCrop connected comp.  </li>\"));\n\t\t\t\t\t\treturn  $menu;\n\t\t\t\t\t  },\n\t\t\t\t\t  function(str,ev)\n\t\t\t\t\t  { if (str == \"color\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t     var $dummy = KColorSelector(obj.colors,colencode,\n\t\t\t\t\t\t\t function() {viewer.gl.setSurfColor(obj); \n\t\t\t\t\t\t\t\t\t\tif (obj.refRoiView != undefined)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tobj.refRoiView.color = obj.color;\n\t\t\t\t\t\t\t\t\t\t\tobj.refRoiView.$colselector.attr('style',colencode(obj.colors[obj.color]));\n\t\t\t\t\t\t\t\t\t\t\tviewer.drawSlice();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$colselector.attr('style',colencode(obj.colors[obj.color]));\n\t\t\t\t\t\t\t },obj);\n\t\t\t\t\t\t\t var e = new jQuery.Event(\"click\");\n\t\t\t\t\t\t\t e.pageX = ev.clientX;\n\t\t\t\t\t\t\t e.pageY = ev.clientY;\n\t\t\t\t\t\t\t $dummy.trigger(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (str == 'crop')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar p = viewer.gl.flip(pickResult.pickedPoint);\n\t\t\t\t\t\t\tp = viewer.gl.GL2world([p.x,p.y,p.z]);\n\t\t\t\t\t\t\tvar roi = obj.surf.fileinfo.roireference;\n\t\t\t\t\t\t\tcropConnectedComponent(roi,p);\n\t\t\t\t\t\t\t//var surf = _this.viewer.currentROI.fileinfo.surfreference;\n\n\n     \t\t\t\t\t\tKViewer.roiTool.update3D(roi);\n\t\t\t\t\t\t\t/*\n\t\t\t\t\t\t\tthat.computeIsoSurf2(roi,undefined,viewer.viewport.progressSpinner,function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tfor (var j=0;j < obj.surf.content.update.length;j++) \n\t\t\t\t\t\t\t\t\t\t\tobj.surf.content.update[j]();\t\n\n\t\t\t\t\t\t\t\t\tsignalhandler.send('positionChange');\n\t\t\t\t\t\t\t});*/\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t  },true);\n\t\t\t\t  contextMenu(evt);\n\t \t\t\n\t\t   }\n\t\n\n\n\n\n\n\n\t\t\ttoggleAlpha(undefined,obj.alphaMode)\n\t\t\tfunction toggleAlpha(e,s)\n\t\t\t{\n\t\t\t\t if (s == undefined)\n\t\t\t\t \tobj.alphaMode = (obj.alphaMode+1)%6;\n\t\t\t\t else \n\t\t\t\t   obj.alphaMode = s;\n\t\t\t\t if (obj.alphaMode>0)\n\t\t\t\t\t $alphadiv.css('color','red');\n\t\t\t\t else\n\t\t\t\t\t $alphadiv.css('color','initial');\n\t\t\t\t update();\n\n\t\t\t}\n\n\t\t\ttoggleWire(undefined,obj.wire)\n         \tfunction toggleWire(e,s)\n\t\t\t{\n\t\t\t\t if (s == undefined)\n\t\t\t\t \tobj.wire = !obj.wire;\n\t\t\t\t else\n\t\t\t\t \tobj.wire = s;\n\t\t\t\t if (obj.wire)\n\t\t\t\t\t $griddiv.css('color','red');\n\t\t\t\t else\n\t\t\t\t\t $griddiv.css('color','initial');\n\t\t\t\t update();\n\n\t\t\t}\n         \n\t\t\tfunction toggleVisibility(e)\n\t\t\t{\n\t\t\t\t var $t= $($visdiv.children()[0]);\n\t\t\t\t if (obj.visible)\n\t\t\t\t {\n\t\t\t\t\t obj.visible = false;\n\t\t\t\t\t $t.addClass('fa-eye-slash').removeClass('fa-eye').css('color','red');;\n\t\t\t\t }\n\t\t\t\t else\n\t\t\t\t {\n\t\t\t\t\t obj.visible = true;\n\t\t\t\t\t $t.removeClass('fa-eye-slash').addClass('fa-eye').css('color','initial');\n\t\t\t\t }\n\t\t\t\t update();\n\t\t\t}\n\n\n                  \t\n\t\t    /***************************************************************************************\n\t\t    * rendering and updates\n\t\t\t****************************************************************************************/                  \t\n\t\t \t function update()\n\t\t\t {\n\t\t\t \tif (viewer.gl != undefined)\n\t\t\t\t\tviewer.gl.createSurface(obj);\n\t\t\t }\n\t\t\t obj.update = update;\n\n\n\t\n\t\t\t // the surface objs knows all its views via this updates\n\t\t\t if (obj.surf.content.update != undefined)\n\t\t\t\tobj.surf.content.update.push(obj.update);\n\n\t\t\t obj.updateCut = function(c)\n\t\t\t {\n\t\t\t \tif (obj.share != undefined)\n\t\t \t\t\tobj.shader.setVector3(\"planesCut\",new BABYLON.Vector3(c[0],c[1],c[2]));\n\t\t\t }\n\n\t\n\n\n\n\n\t\t\t var cutContextmenu = new KContextMenu(\n\t\t\t\t  function() { \n\t\t\t\t\t var $menu = $(\"<ul class='menu_context'>\");\n\t\t\t\t\t var name = ['Saggital','Coronal','Transversal'];\n\t\t\t\t\t $menu.append($(\"<hr width='100%'> \")); \t\t\t\t\t \t\t\t\t\t\n\t\t\t\t\t $menu.append($(\"<span> &nbsp Cuts</span>\"));\n\t\t\t\t\t $menu.append($(\"<hr width='100%'> \")); \t\t\n\t\t\t\t\t var cutnames = ['left','no cut','right'];\n\t\t\t\t\t for (var k = 0;k <3;k++)\n \t\t\t\t\t \t$menu.append($(\"<li  onchoice='vis_\"+k+\"' > \"+name[k]+\" (\"+cutnames[obj.cuts[k]+1]+\") </li>\"));\n\t\t\t\n  \t\t\t\t\t $menu.append($(\"<hr>\"));\n\n        \t\t\t  var $belt = $(\"<input onchoice='preventSelection' type='number' step='0.5' min='0' max='100'>\").val(obj.beltwidth).\n   \t\t            \t\t on('change', function(ev) {\n                      var $input = $(ev.target);\n                    \t\tobj.beltwidth = $input.val();\n                            obj.update();\n                \t       });\n                \t  $menu.append($(\"<li  onchoice='preventSelection'> Beltwidth: </li>\").append($belt));\n   \n\n\n\t\t\t\t\treturn $menu; \n\t\t\t\t  }, function(str,ev)\n\t\t\t\t  {\n\t\t\t\t  \t  if (str == '' | str == undefined)\n\t\t\t\t  \t  \treturn;\n\t\t\t\t\t  \n\t\t\t\t  \t  if (str.search(\"vis\") != -1)\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \t  str = str.substring(4);\n\t\t\t\t\t\t  var pl = parseInt(str);\n\t\t\t  \t\t      obj.cuts[pl] = (obj.cuts[pl]+2)%3 -1;\n\t\t\t\t  \t  }\n\n\t\t\t\t  \t  obj.update();\n\n\t\t\t\t  },undefined,true);\n\t\t\t$cutdiv.click( cutContextmenu )\n\n\n\n\n\n\n\n\n\n\n\n\t\n\n\t\t\t obj.clear = function()\n\t\t\t {\n\t\t\t\t delete this.surf;\n\t\t\t }\n\n\t\t    /***************************************************************************************\n\t\t    * close the view\n\t\t\t****************************************************************************************/                  \t\n  \t\t\t function close()\n             {             \t  \n\n\t\t\t      if (obj.histoManager != undefined) \n\t\t\t      \t\tobj.histoManager.remove();\n\n\n\t\t\t\t  if (obj.surf.content != undefined)\t\t\t  \n\t\t\t\t\t  if (obj.surf.content.update != undefined)  // roi update handler remove\n\t\t\t\t\t\t  for (var k = 0; k < obj.surf.content.update.length;k++)\n\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t  if (obj.update == obj.surf.content.update[k])\n\t\t\t\t\t\t\t  {\n\t\t\t\t\t\t\t\tobj.surf.content.update.splice(k,1);\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t  }\n\t\t\t\t\t\t  }\n\n\t\t\t\t   for (var k = 0; k < obj.overlays.length;k++)\n\t\t\t\t   {\n\t\t\t\t   \t  obj.overlays[k].close();\n\t\t\t\t   }\n\t\t\t\t\t  \n\t\t\t\t  if (obj.shader != undefined && viewer.gl != undefined) // shader update handler remove\n\t\t\t\t\tviewer.gl.detachShader(obj.shader);\n\n                  for (var k = 0; k< obj.divs.length;k++)\n                     obj.divs[k].remove();\n\n                  for (var k = 0; k < viewer.objects3D.length;k++)\n                  {\n                  \tif (obj == viewer.objects3D[k])\n                  \t{\n                  \t\tviewer.objects3D.splice(k,1);\n                  \t\tbreak;\n                  \t}\n                  }\t\t\t\t\t\n\t\t\t\t  if (viewer.objects3D.length == 0 & viewer.nii == undefined)\n\t\t\t\t  \tviewer.$canvas3D.hide();\n\t\t\t\t  if (obj.gl != undefined)\n\t\t\t\t  {\n\t\t\t\t\t  obj.gl.dispose();\n\t\t\t\t\t  obj.gl = undefined;\n\t\t\t\t  }\n\t\t\t\t  if (viewer.gl != undefined)\t\t\t\t  \t\n\t\t\t\t  \tviewer.gl.activateRenderLoop();\n             }\n             obj.close = close;\n             signalhandler.attach(\"close\",close);\n\n\n\t\t     obj.update();\n\n             return obj;\n        }\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \t /***************************************************************************************\n\t  * the conmatrix subview\n\t  ****************************************************************************************/\n\n\n\n      that.createConmatView = function(fobj,viewer,intent)\n      {\n            var viewer = viewer;\n            var obj = { cmat:fobj,\n                        visible:true,\n\t\t\t\t\t\tuid: KObject3DTool.uidCnter++,\n\t\t\t\t\t\thistoManager: viewer.createHistoManager()\n            };\n\n\t\t\tobj.histoManager.nii = { datascaling : {e:function(x){return x;} }, \n\t\t\t\t\t\t\t\t\t histogram: obj.cmat.histogram};\n\n\t\t\tif (intent.clim)\n\t\t\t\tobj.histoManager.clim = [intent.clim[0],intent.clim[1]];\n\t\t\telse \t\t\t\t\t\t\t\t\t \n\t\t\t\tobj.histoManager.clim = [obj.cmat.histogram.min+0.6*(obj.cmat.histogram.max-obj.cmat.histogram.min),\n                                             obj.cmat.histogram.max+0.1*(obj.cmat.histogram.max-obj.cmat.histogram.min)]\n\t\t\t\n\t\t\tobj.histoManager.onclimchange = function(ev) {\t\t\t\t   viewer.gl.activateRenderLoop(); obj.update();}\n\n\t\t\tobj.histoManager.updateHistogramClim();\n\t\t\tobj.histoManager.layoutHistogram();\n\n\t\t\tobj = $.extend(obj,intent);\n\n \t\t    /***************************************************************************************\n\t\t    * the viewer toolbar\n\t\t\t****************************************************************************************/\n\n\t\t\n\t\t\tvar $captiondiv,$cutdiv,$dragdiv,$visdiv;\n            obj.divs = [  $(\"<br style='clear:both' />\"),\n                          $(\"<div  class='KViewPort_tool cmat persistent'>  <i class='fa fa-close fa-1x'></i></div>\").click( close  ),\n                          $captiondiv = $(\"<div  class='KViewPort_tool cmat caption'> \"+obj.cmat.filename+\"</div>\"),\n                          $dragdiv = $(\"<div  class='KViewPort_tool draganddrop'>  <i class='fa fa-hand-paper-o fa-1x'></i></div>\"),\n                          \n                       ];\n\n\t\t\tviewer.toolbar.append(obj.divs,'cmat');\n\n            $dragdiv.attr(\"draggable\",'true');\n            $dragdiv.on(\"dragstart\", dragstarter({ type:'file', mime: 'conmat',   filename: obj.cmat.filename,  fileID: obj.cmat.fileID,close:close}));\n\n\n\n\n/*\n\t\t\tobj.contextmenu3D = function(evt,pickResult,p)\n\t\t    {\n\t\t\t\t   var contextMenu = KContextMenu(\n\t\t\t\t\t  function() {\n\n\t\t\t\t\t\tvar $menu =  $(\"<ul class='menu_context'>\");\n\n\t\t\t\t\t\t$menu.append($(\"<li onchoice='crop' > ssCrop connected comp.  </li>\"));\n\t\t\t\t\t\t$menu.append($(\"<li onchoice='color' > Color  </li>\"));\n\t\t\t\t\t\treturn  $menu;\n\t\t\t\t\t  },\n\t\t\t\t\t  function(str,ev)\n\t\t\t\t\t  { if (str == \"color\")\n\t\t\t\t\t\t{\n\t\t\t\t\t\t     var $dummy = KColorSelector(obj.colors,colencode,\n\t\t\t\t\t\t\t function() {viewer.gl.setSurfColor(obj); \n\t\t\t\t\t\t\t\t\t\tif (obj.refRoiView != undefined)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tobj.refRoiView.color = obj.color;\n\t\t\t\t\t\t\t\t\t\t\tobj.refRoiView.$colselector.attr('style',colencode(obj.colors[obj.color]));\n\t\t\t\t\t\t\t\t\t\t\tviewer.drawSlice();\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t$colselector.attr('style',colencode(obj.colors[obj.color]));\n\t\t\t\t\t\t\t },obj);\n\t\t\t\t\t\t\t var e = new jQuery.Event(\"click\");\n\t\t\t\t\t\t\t e.pageX = ev.clientX;\n\t\t\t\t\t\t\t e.pageY = ev.clientY;\n\t\t\t\t\t\t\t $dummy.trigger(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse if (str == 'crop')\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar roi = obj.surf.fileinfo.roireference;\n\t\t\t\t\t\t\tcropConnectedComponent(roi,p);\n\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t  },true);\n\t\t\t\t  contextMenu(evt);\n\t \t\t\n\t\t   }\n*/\t\n\n\n                  \t\n\t\t    /***************************************************************************************\n\t\t    * rendering and updates\n\t\t\t****************************************************************************************/                  \t\n\t\t \t function update()\n\t\t\t {\n\t\t\t \tif (viewer.gl != undefined)\n\t\t\t\t\tviewer.gl.createConmat(obj);\n\t\t\t }\n\t\t\t obj.update = update;\n\n\t\n\t\t\t // the surface objs knows all its views via this updates\n\t\t\t if (obj.cmat.content.update != undefined)\n\t\t\t\tobj.cmat.content.update.push(obj.update);\n\n\n\t\t\t obj.clear = function()\n\t\t\t {\n\t\t\t\t delete this.surf;\n\t\t\t }\n\n\t\t    /***************************************************************************************\n\t\t    * close the view\n\t\t\t****************************************************************************************/                  \t\n  \t\t\t function close()\n             {             \t  \n\t\t\t\t\t  \n\t\t\t      obj.histoManager.remove();\n\n\t\t\t\t  if (obj.shader != undefined) // shader update handler remove\n\t\t\t\t\tviewer.gl.detachShader(obj.shader);\n\n                  for (var k = 0; k< obj.divs.length;k++)\n                     obj.divs[k].remove();\n\n                  for (var k = 0; k < viewer.objects3D.length;k++)\n                  {\n                  \tif (obj == viewer.objects3D[k])\n                  \t{\n                  \t\tviewer.objects3D.splice(k,1);\n                  \t\tbreak;\n                  \t}\n                  }\t\t\t\t\t\n\t\t\t\t  if (viewer.gl)\n                  \tviewer.gl.activateRenderLoop();\n                  \n\t\t\t\t  if (viewer.objects3D.length == 0 & viewer.nii == undefined)\n\t\t\t\t  \tviewer.$canvas3D.hide();\n\n\t\t\t\t  if (obj.gl != undefined)\n\t\t\t\t  {\n\t\t\t\t\t  obj.gl.dispose();\n\t\t\t\t\t  obj.gl = undefined;\n\t\t\t\t  }\n             }\n             obj.close = close;\n             signalhandler.attach(\"close\",close);\n\n\n\t\t     obj.update();\n\n             return obj;\n        }\n\n\n\n\n\n  \t /***************************************************************************************\n\t  * the contour subview\n\t  ****************************************************************************************/\n\n\n\n      that.createContourView = function(fobj,viewer,intent)\n      {\n            var viewer = viewer;\n            var obj = { contour:fobj,\n                        visible:true,\n\t\t\t\t\t\tuid: KObject3DTool.uidCnter++,\n\t\t\t\t\t\tfibcut_thres:3.5,\n\t\t\t\t\t\tfib_cut:-1,\n\t\t\t\t\t\tselect:0,\n\t\t\t\t\t\tcolor: (viewer.objects3D.length)%KColor.list.length,\t\t\n            };\n\n\n       \t    var colors = [];\n       \t    colors = colors.concat(KColor.list);\n\n\t\t\tif (intent != undefined && intent.color != undefined)\n\t\t\t\tobj.color = intent.color%colors.length ;\n\n\n\t\t\t////////////// color context menu\n\t\t\tvar $colselector = KColorSelector(colors,\t\n\t\t\t\t function(c) {\tif (c==\"dir\") return \"\"; else return \"background:\"+RGB2HTML(c[0],c[1],c[2])+\";\"; },\n\t\t\t\t function (col)\n\t\t\t\t {\n\t\t\t\t \tif (obj.fiberDirColor_shader != undefined)\n\t\t\t\t \t{\n\t\t\t\t\t   viewer.gl.activateRenderLoop();\n\t\t\t\t\t\tif (col == 'dir')\n\t\t\t\t\t\t\tobj.fiberDirColor_shader.setVector4(\"col\",new BABYLON.Vector4(0,0,0,0));\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\tobj.fiberDirColor_shader.setVector4(\"col\",new BABYLON.Vector4(col[0]/255,col[1]/255,col[2]/255,1));\n\t\t\t\t \t}\n\t\t\t\t \tobj.update()\n\t\t\t\t },\n\t\t\t\t obj);\n\n\t\t\tif (intent.gl) delete intent.gl;\n\t\t\tobj = $.extend(obj,intent);\n\n \t\t    /***************************************************************************************\n\t\t    * the viewer toolbar\n\t\t\t****************************************************************************************/\n\n\t\t\n\t\t\tvar $captiondiv,$cutdiv,$dragdiv,$visdiv,$roidiv,$fibercutselector;\n\n            var name;// = obj.contour.filename\n\n            if (intent.select != undefined)\n                name = obj.contour.content.Contours[intent.select].name;\n            \n            name = name || obj.contour.filename\n\n\n            obj.divs = [  $(\"<br style='clear:both' />\"),\n                          $(\"<div  class='KViewPort_tool cmat persistent'>  <i class='fa fa-close fa-1x'></i></div>\").click( close  ),\n                          $captiondiv = $(\"<div  class='KViewPort_tool cmat caption'> \"+name+\"</div>\"),\n                          $colselector.appendTooltip(\"selectcolor\"),\n                           $fibercutselector = $(\"<div  class='KViewPort_tool cmat' >  <i   class='fa fa-cut fa-1x'></i></div>\"),\n                           $roidiv = $(\"<div  class='KViewPort_tool cmat' >  <i   class='fa fa-pencil fa-1x'></i></div>\"),\n                          $dragdiv = $(\"<div  class='KViewPort_tool draganddrop'>  <i class='fa fa-hand-paper-o fa-1x'></i></div>\"),\n                          \n                       ];\n\n            $roidiv.click(function() {\n\t\t\t\t$(document.body).addClass(\"wait\");\n\t\t\t\tviewer.viewport.progressSpinner(\"creating ROI from rtstruct ...\")\n\n  \t\t\t    var c = obj.contour.content.Contours[intent.select].ContourSequence.node;\n            \tsetTimeout(function() {\n\t\t\t\t\tmaster.roiTool.pushROI(viewer.currentFileID,name, undefined, function(fobj){\n\t\t\t\t\tfor (var k = 0; k < c.length;k++)\n\t\t\t\t\t//for (var k = 200; k < 205;k++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar p = c[k].ContourData;\n\t\t\t\t\t\tvar pts = [];\n\t\t\t\t\t\tfor (var i = 0; i < p.length/3;i++)\n\t\t\t\t\t\t\tpts.push([-p[3*i],-p[3*i+1],p[3*i+2],1]);\n\t\t\t\t\t\t// close the polygon with first point\n\t\t\t\t\t\tvar i = 0;\n\t\t\t\t\t\tpts.push([-p[3*i],-p[3*i+1],p[3*i+2],1])\t\t\t\t\t\t\t\n\n\t\t\t\t\t\tfillPolygon(pts,fobj.content, false)\n\n\t\t\t\t\t}\n\t\t\t\t\tviewer.setContent(fobj, {\n\t\t\t\t\t\tintent: {\n\t\t\t\t\t\t\tROI: true,\n\t\t\t\t\t\t\tcolor:obj.color\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t\t$(document.body).removeClass(\"wait\");\n\t\t\t\t\tviewer.viewport.progressSpinner()\n\n\t\t\t\t\t});\n\n                },0);\n            });\n\n\t\t\tviewer.toolbar.append(obj.divs,'cmat');\n\n            $dragdiv.attr(\"draggable\",'true');\n            $dragdiv.on(\"dragstart\", dragstarter({ type:'file', mime: 'contour',   filename: obj.contour.filename,  \n            fileID: obj.contour.fileID,close:close, intent:'color:'+obj.color+',select:'+intent.select+''     }));\n            \n\t\t\tobj.createShader = function()\n\t\t\t{\n\t\t\t\tvar fiberDirColor_shader = viewer.gl.createFiberShader()\n\t\t\t\tfiberDirColor_shader.setFloat(\"planesThres\",obj.fibcut_thres);   \t\n\t\t\t\tfiberDirColor_shader.setFloat(\"planesNum\",obj.fib_cut);\n\t\t\t\tfiberDirColor_shader.setFloat(\"planesProj\",obj.fibcut_proj);\n\t\t\t\tobj.fiberDirColor_shader = fiberDirColor_shader;\n\t\t\t}\n\n            if (viewer.gl != undefined)\n            {\n            \tobj.createShader()\n            }\n            \t\t\n     \t\tvar fibcut_contextmenu = new KContextMenu(\n\t\t\t\t  function() { \n\t\t\t\t\t var $menu = $(\"<ul class='menu_context'>\");\n\t\t\t\t\t var name = ['No cut','Coronal','Transversal','Saggital'];\n\t\t\t\t\t var sel = ['','','','']; sel[obj.fibcut+1] = 'dot-';\n\t\t\t\t\t for (var k = -1;k <3;k++)\n \t\t\t\t\t \t$menu.append($(\"<li  onchoice='\"+k+\"' > \"+name[k+1]+\"  <i  onchoice='\"+k+\"' class='fa fa-\"+sel[k+1]+\"circle-o'></i> </li>\"));\n\t\t\t\t      if (obj.fibcut != -1)\n\t\t\t\t      {\n\n\t\t\t\t\t\t  var $thres = $(\"<input onchoice='preventSelection' type='number' min='0.01' step='0.1' max='20'>\").val(obj.fibcut_thres).\n\t\t\t\t\t\t  on('change',function(ev){\n\t\t\t\t\t\t\tvar $input = $(ev.target);\n\t\t\t\t\t\t\tobj.fibcut_thres = $input.val();\n\t\t\t\t\t\t\tobj.fiberDirColor_shader.setFloat(\"planesThres\",parseFloat(obj.fibcut_thres));   \t\n\t\t\t\t\t\t\t viewer.gl.activateRenderLoop();\n\t\t\t\t\t\t  });\n\t\t\t\t\t\t  $menu.append($(\"<li  onchoice='preventSelection'> Width: </li>\").append($thres));\n\t\t\t\t      }\n\t\t\t\t    $menu.append($(\"<hr width='100%'> \")); \t\t\n\t\t\t\t    var sel = '';\n\t\t\t\t    if (obj.fibcut_proj>0) sel = '-check';\t\t\t \t\t\t\t       \n \t\t\t\t    $menu.append($(\"<li onchoice='project'> Projection  <i onchoice='project' class='fa fa\"+sel+\"-square-o'></i> </li>\"));\n\t\t\t\t\treturn $menu; \n\t\t\t\t  },\n\t\t\t\t  function(str,ev)\n\t\t\t\t  {\n\n\t\t\t\t  \t  if (str == '' | str == undefined)\n\t\t\t\t  \t  \treturn;\n\t\t\t\t  \t  if (str == '-1' | str == '0' | str == '1' | str == '2' )\n\t\t\t\t  \t  {\n\t\t\t\t         obj.fibcut = parseInt(str);\n\t\t\t\t         obj.fiberDirColor_shader.setFloat(\"planesNum\",obj.fibcut);\n\t\t\t\t         obj.fiberDirColor_shader.setFloat(\"planesProj\",obj.fibcut_proj);\n\t\t\t\t  \t  }\n\t\t\t\t  \t  if (str == 'project')\n\t\t\t\t  \t  {\n\t\t\t\t  \t  \t  obj.fibcut_proj = -obj.fibcut_proj;\n\t\t\t\t          obj.fiberDirColor_shader.setFloat(\"planesProj\",obj.fibcut_proj);\n\t\t\t\t  \t  }\n\t\t\t\t  \t  viewer.gl.activateRenderLoop();\n\t\t\t\t  }\n\t\t\t\t  );\n\t\t\t $fibercutselector.click(fibcut_contextmenu);\n\n\n\n\n\n                  \t\n\t\t    /***************************************************************************************\n\t\t    * rendering and updates\n\t\t\t****************************************************************************************/                  \t\n\t\t \t function update()\n\t\t\t {\n\t\t\t \tif (viewer.gl != undefined)\n\t\t\t\t\tviewer.gl.createContour(obj,colors[obj.color]);\n\t\t\t\tif (obj.outlines != undefined)\n\t\t\t\t\tobj.outlines.update(viewer)\n\t\t\t }\n\t\t\t obj.update = update;\n\n\n\t\t    /***************************************************************************************\n\t\t    * close the view\n\t\t\t****************************************************************************************/                  \t\n  \t\t\t function close()\n             {             \t  \n\n                  if (obj.outlines) \n                      obj.outlines.close()\n\n                  for (var k = 0; k< obj.divs.length;k++)\n                     obj.divs[k].remove();\n\n                  for (var k = 0; k < viewer.objects3D.length;k++)\n                  {\n                  \tif (obj == viewer.objects3D[k])\n                  \t{\n                  \t\tviewer.objects3D.splice(k,1);\n                  \t\tbreak;\n                  \t}\n                  }\t\t\t\t\t\n\t\t\t\t  if (viewer.gl)\n                  \tviewer.gl.activateRenderLoop();\n                  \n\t\t\t\t  if (viewer.objects3D.length == 0 & viewer.nii == undefined)\n\t\t\t\t  \tviewer.$canvas3D.hide();\n\n\t\t\t\t  if (obj.gl != undefined)\n\t\t\t\t  {\n\t\t\t\t  \t  if (obj.gl.dispose)\n\t\t\t\t\t  \tobj.gl.dispose();\n\t\t\t\t\t  obj.gl = undefined;\n\t\t\t\t  }\n             }\n             obj.close = close;\n             signalhandler.attach(\"close\",close);\n\n\n\t\t     obj.update();\n\n             return obj;\n        }\n\n\n\n\n    function statistics_dialog(parent)\n    {\n    \tvar objtool = parent;\n        var that = new dialog_generic();\n        that.$frame.hide()\n        $(\"<li><a>Object statistics</a></li>\").appendTo(that.$menu)\n        $(\"<li><a> <i class='fa fa-refresh'></i> </a>  </li>\").click(dostats).appendTo(that.$menu);\n\n        //that.$container.append($(\"<div id='roistatsdialog'></div>\"));\n\n        function computeStats(roi, img)\n        {\n        }\n\n\n\n        /***************************************************************************************\n        * new statistics table\n        ****************************************************************************************/\n        function dostats()\n        {\n            var objs = objtool.objs;\n\n\n            that.$container.find(\".KRoistats_tablecontainer\").remove();\n            \n            var $div = $(\"<div class='KRoistats_tablecontainer'></div>\").appendTo(that.$container);\n\n            var $table = $(\"<table class='KRoistats_table text_selectable'></table>\").appendTo($div);\n            \n            var $row = $(\"<tr> <td>Object</td> <td>#tracts</td>   </tr>\").appendTo( $(\"<thead></thead>\").appendTo($table ));\n            //var $row0 = $(\"<tr> <td></td> <td></td>   </tr>\").appendTo($table0);\n            var $tbody = $(\"<tbody></tbody>\").appendTo($table);\n\n            for (var id in objs)\n            {\n\n                var x= objs[id];\n\n\n\t\t\t\tvar $trow = $(\"<tr></tr>\").appendTo($tbody);\n                $(\"<td >\" + x.filename + \"</td>\").appendTo($trow);\n                 $(\"<td>\" + x.content.tracts.length      +\"</td>\").appendTo($trow);\n\n                 if (x.content.selections != undefined)\n                 {\n                 \tvar selections = x.content.selections\n                 \tfor (var j = 0 ; j < selections.length; j++)\n                 \t{\n\t\t\t\t\t\tvar $trow = $(\"<tr></tr>\").appendTo($tbody);\n\t\t\t\t\t\t$(\"<td >\" +selections[j].name + \"</td>\").appendTo($trow);\n\t\t\t\t\t\t$(\"<td>\" +selections[j].subset.length      +\"</td>\").appendTo($trow);\n\n                 \t}\n                 }\n\n\n            }\n\n\n            \n\n        }\n\n        that.dostats = dostats;\n        \n        return that;\n    }\n\n    var fibhist =  {\n    \tqsize:10,\n    \tqueue:[],\n    \twhich:undefined, \n    \tlast:0,    \n    \tcurrent:0,\n    \tcurw:0,\n    \tinit: function(which)\n    \t{\n    \t\t    fibhist.queues = [];\n    \t\t    fibhist.current = 0;\n    \t\t    fibhist.which = which\n\n    \t},\n\n    \tadd: function(which,selection)\n    \t{\n    \t\tvar now = new Date().getTime()\n    \t\tif (Math.abs(fibhist.last-now) < 100 | selection.length == 0)\n    \t\t    return;\n\n            fibhist.last = now;\n    \t\tif (which != fibhist.which)\n    \t\t{\n    \t\t    fibhist.init(which)\n    \t\t}\n\t\t\tfibhist.current = (fibhist.current+1)%fibhist.qsize\n\t\t\tfibhist.queue[fibhist.current] = selection\n\t\t\tfibhist.curw=0;\n    \t},\n\n   \t    goto: function(x)\n    \t{\n            if (fibhist.which.isCurrent)\n            {\n            \tif (fibhist.curw+x > 0 | fibhist.curw+x<=-fibhist.qsize)\n            \t    return;\n\n            \tfibhist.curw+=x;\n\t\t\t\tfibhist.current = fibhist.current+x;\n\t\t\t\tif (fibhist.current < 0)\n\t\t\t\t\tfibhist.current += fibhist.qsize;\n\t\t\t\tfibhist.current = fibhist.current%fibhist.qsize\n\t\t\t\tvar s = fibhist.queue[fibhist.current]\n\t\t\t\tif (s==undefined)\n\t\t\t\t{\n\t\t\t\t\tif (fibhist.which.Selection)\n\t\t\t\t\t  s = fibhist.which.Selection.subset\n\t\t\t\t}\n\t\t\t\tfibhist.which.subsetToDisplay=s;\n\t\t\t\tfibhist.which.updateFibers()\n\t\t\t\t\n            }\n    \t}\n\n\n    }\n    that.fiberHistory = fibhist\n\n\n    document.addEventListener(\"keydown\", function(evt)\n    {\n        evt = evt || window.event;\n\n        if ($(evt.target).is(\"textarea\") || $(evt.target).is(\"input\"))\n            return;\n        if ((evt.which == 90 || evt.keyCode == 90) && evt.ctrlKey && !evt.shiftKey)\n        {\n         \n             that.fiberHistory.goto(-1);\n             evt.preventDefault();evt.stopPropagation();return false;\n\n        }\n        else if ((evt.which == 90 || evt.keyCode == 90) && evt.ctrlKey && evt.shiftKey)\n        {\n            that.fiberHistory.goto(+1);\n            evt.preventDefault();evt.stopPropagation();return false;\n        }\n    });\n\n\n\n\n  that.update();\n\n\n  return that;\n}\n \nKObject3DTool.uidCnter = 0;\n \n\n\n\n\n\n\n\n\n\n\n\n\n/***************************************************************************************\n*  Octree wrapper\n****************************************************************************************/\n\n\nfunction myOctree(min,max,acc)\n{\n\tthis.min = min;\n\tthis.max = max;\n\tthis.cnt = 0;\n\tthis.acc = 0;\n\tthis.trees = [];\n\tthis.addTree();\n}\n\nmyOctree.chunksize = 100000;\nmyOctree.fiberstep = 1;\n\nmyOctree.prototype.addTree = function()\n{\n\tvar min = this.min;\n\tvar max = this.max;\n\tthis.trees.push(new Octree([min[0],min[1],min[2]],[max[0]-min[0],max[1]-min[1],max[2]-min[2]]));\n}\n\nmyOctree.prototype.add = function (tract, label) {\n\n\tvar octree = this.trees[this.trees.length-1];\n\tfor (var k = 0; k < tract.length/3;k+=myOctree.fiberstep)\n\t{\n\t\tvar dif =  [(tract[3*k]  -tract[3*(k-1)]),\n\t\t            (tract[3*k+1]-tract[3*(k-1)+1]),\n\t\t            (tract[3*k+2]-tract[3*(k-1)+2])];\n\t\tvar mdif = math.sqrt(dif[0]*dif[0]+dif[1]*dif[1]+dif[2]*dif[2]);\n\t\toctree.add([tract[3*k],tract[3*k+1],tract[3*k+2]], [label,dif[0]/mdif,dif[1]/mdif,dif[2]/mdif]);\n\t}\n\tif (octree.numPoints > myOctree.chunksize)\n\t\tthis.addTree();\t\t\t\t\n}\n\n\nmyOctree.prototype.findFibers = function(p,radius,dirsel)\n{\n\tvar subset = {};\n\tfor (var k = 0; k < this.trees.length;k++)\n\t{\n\t\tvar r;\n\t\tif (p._data == undefined)\n\t\t\tr = this.trees[k].findNearbyPoints([p[0],p[1],p[2]], radius, {includeData:true});\n\t\telse\n\t\t\tr = this.trees[k].findNearbyPoints([p._data[0],p._data[1],p._data[2]], radius, {includeData:true});\n\t\t\n\t\tvar d = r.data;\n\t\tvar len = d.length;\n\t\tif (dirsel == undefined)\n\t\t{\n\t\t\tfor (var j=0;j < len;j++)\n\t\t\t\tsubset[d[j][0]] = true;\n\t\t}\n\t\telse\n\t\t{\n\t\t\tvar dir = dirsel._data;\n\t\t\tvar thres = 0.9*math.sqrt(dir[0]*dir[0]+dir[1]*dir[1]+dir[2]*dir[2]);\n\t\t\tfor (var j=0;j < len;j++)\n\t\t\t{\n\t\t\t\tif (math.abs(d[j][1]*dir[0]+d[j][2]*dir[1]+d[j][3]*dir[2]) > thres)\n\t\t\t\t   subset[d[j][0]] = true;\n\t\t\t}\n\n\t\t}\n\n\t\t\n\t}\n\treturn Object.keys(subset);\n}\n\n\n\n\n\nfunction kunique(x)\n{\n\tvar obj = {};\n\tvar len = x.length;\n\tfor (var k = 0; k < len;k++)\n\t\tobj[x[k]] = true;\n\treturn Object.keys(obj);\n\n}\n\nfunction kintersect(x,y)\n{\n\tvar obj = {};\n\tvar res = [];\n\tvar len = x.length;\n\tfor (var k = 0; k < len;k++)\n\t\tobj[x[k]] = true;\n\tvar len = y.length;\n\tfor (var k = 0; k < len;k++)\n\t{\n\t\tif (obj[y[k]])\n\t\t\tres.push(y[k]);\n\t}\n\treturn res;\n\n}\n\n\n\nfunction kunion(x,y)\n{\n\treturn [].concat(x).concat(y);\n\n}\n\n\n\nfunction kdiff(x,y)\n{\n\tvar obj = {};\n\tvar res = [];\n\tvar len = y.length;\n\tfor (var k = 0; k < len;k++)\n\t\tobj[y[k]] = true;\n\tif (x.all)\n\t{\n\t\tfor (var k = 0; k < x.all;k++)\n\t\t    if (!obj[k])\n\t\t\t   res.push(k);\t\t\t\n\t}\t\n\telse\n\t{\n   \t    var len = x.length;\n\t\tfor (var k = 0; k < len;k++)\n\t\t{\n\t\t\tif (!obj[x[k]])\n\t\t\t\tres.push(x[k]);\n\t\t}\n\t}\n\treturn res;\n\n}\n\nfunction importTCK(fileObject,uint8Response,processinfo,arrived)\n{\n\t  \n\t  var view = new DataView(uint8Response.buffer);\n\t  var hdr = view.getUTF8String(0,1024);\n\t  var toks = hdr.split('\\n');\n\t  if (toks[0].trim() == 'mrtrix tracks')\n\t  {\n\t\t var header = {};\n\t\t for (var k = 0; k < toks.length-1;k++)\n\t\t {\n\t\t\tif (toks[k+1].search(\"^datatype:\") >=0)\n\t\t\t\theader.datatype = toks[k+1].substring(9).trim();\n\t\t\telse if (toks[k+1].search(\"^count:\") >=0)\n\t\t\t\theader.count = parseInt(toks[k+1].substring(7));\n\t\t\telse if (toks[k+1].search(\"^file:\")>=0)\n\t\t\t\theader.offset = parseInt(toks[k+1].substring(7));\n\t\t }\n\n         if (header.count == 0 | header.count == undefined)\n         {\n         \tarrived()\n         \treturn;\n         }\n\n\t\t var LE = true;\n\n\t\t var pos = 0;\n\t\t var tot_points = 0;\n\n\t\t var max = [-100000,-100000,-100000];\n\t\t var min = [100000,100000,100000];\n\n\t\t var tmax = [-100000,-100000,-100000];\n\t\t var tmin = [100000,100000,100000];\n\n\n\t\t var dummy = new Array(header.count);\n\t\t var tract_buffer = new Float32Array((uint8Response.byteLength-header.offset-header.count*4)/4);\n\n\t\t var tracts = [];\n\t\t var tracts_max = new Float32Array(header.count*3);\n\t\t var tracts_min = new Float32Array(header.count*3);\n\n\t\t var tracts_len = new Float32Array(header.count);\n\n\n\t\t var tractlen = 0;\n\t\t var totlen = 0;\n\t\t var tract_cnt = 0;\n\n\t\t dummy.chunk(function(el,j,arr)\n\t\t\t{\n\t\t\t\t var tract = [];\n\t\t\t\t var pos = arr.pos;\n\t\t\t\t if (pos == undefined) pos = 0;\n\n\t\t\t\t while(true)\n\t\t\t\t {\n\t\t\t\t\tvar val = view.getFloat32(header.offset+4*pos,LE);\n\t\t\t\t\t//if (pos%3==0)\n\t\t\t\t\t//\tval += 1700;\n\t\t\t\t\tif (max[pos%3] < val) max[pos%3] = val;\n\t\t\t\t\tif (min[pos%3] > val) min[pos%3] = val;\n\t\t\t\t\tif (tmax[pos%3] < val) tmax[pos%3] = val;\n\t\t\t\t\tif (tmin[pos%3] > val) tmin[pos%3] = val;\n\n\t\t\t\t\tif (!isNaN(val))\n\t\t\t\t\t{\n\t\t\t\t\t\ttract.push(val);\n\t\t\t\t\t\tpos++;\n\t\t\t\t\t\ttot_points++;\n\t\t\t\t\t\ttractlen++;\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tpos+=3;\n\t\t\t\t\t\ttracts_max[3*tract_cnt] =(tmax[0]);\n\t\t\t\t\t\ttracts_max[3*tract_cnt+1] =(tmax[1]);\n\t\t\t\t\t\ttracts_max[3*tract_cnt+2] =(tmax[2]);\n\t\t\t\t\t\ttracts_min[3*tract_cnt] =(tmin[0]);\n\t\t\t\t\t\ttracts_min[3*tract_cnt+1] =(tmin[1]);\n\t\t\t\t\t\ttracts_min[3*tract_cnt+2] =(tmin[2]);\n\t\t\t\t\t\ttmax = [-100000,-100000,-100000];\n\t\t\t\t\t\ttmin = [100000,100000,100000];\t\t\t\t\t\t\n\t\t\t\t\t\ttracts_len[tract_cnt] = (tractlen/3);\t\t\t\t\t\n\t\t\t\t\t\ttract_buffer.set(tract,totlen);\n\t\t\t\t\t\tvar tmp = new Float32Array(tract_buffer.buffer,totlen*4,tractlen);\n\t\t\t\t\t\ttracts.push(tmp);\n\n\t\t\t\t\t\ttotlen += tractlen;\n\t\t\t\t\t\ttract_cnt++;\n\t\t\t\t\t\n\n\t\t\t\t\t\ttractlen = 0;\n\t\t\t\t\t//\tstart = 0;\n\t\t\t\t\t//\ttracts.push(new Float32Array(uint8Response.buffer,header.offset+4*(start),pos-start));\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t }\t\n\t\t\t\t arr.pos = pos;\n\n\t\t\t},1024*4,0,\n\t\t\tfunction(i)\n\t\t\t{ \n\t\t\t  processinfo(\"reading \" + math.round(i/header.count*100) +\"%\");\n\t\t\t},\n\t\t\tfunction()\n\t\t\t{\n\t\t\t  if (tracts.length>0)\n\t\t\t  {\n/*\n\t\t\t\tfor (var k = 0; k < tracts.length; k++)\n\t\t\t\t{\n\t\t\t\t\ttracts[k] =  reparam_track_constPcnt(tracts[k],undefined,5);\n\t\t\t\t\t//tracts[k] = reparam_track(tracts[k],20 );\n\t\t\t\t}\n*/\n\n\n\t\t\t\tfileObject.content = {tracts:tracts,   // these are just pointer on tract_buffer\n\t\t\t\t\t\t\t\t\ttract_buffer:tract_buffer,\n\t\t\t\t\t\t\t\t\ttracts_len:tracts_len,\n\t\t\t\t\t\t\t\t\ttot_points:tot_points,\n\t\t\t\t\t\t\t\t\toctree:new myOctree(min,max,0),\n\t\t\t\t\t\t\t\t\ttracts_max:tracts_max,tracts_min:tracts_min,\n\t\t\t\t\t\t\t\t\tmin:min,max:max,\n\t\t\t\t\t\t\t\t\tbuffer:uint8Response.buffer};\n\t\t\t  }\n\t\t\t   arrived(fileObject);\n\n\t\t\t});\n\t  }\n}\n/*\n0 id_string[6]\tchar\t6\tID string for track file. The first 5 characters must be \"TRACK\".\n6 dim[3]\tshort int    \t6\tDimension of the image volume.\n12 voxel_size[3]\tfloat\t12\tVoxel size of the image volume.\n24 origin[3]\tfloat\t    12\tOrigin of the image volume. This field is not yet being used by TrackVis. That means the origin is always (0, 0, 0).\n36 n_scalars\tshort int\t2\tNumber of scalars saved at each track point (besides x, y and z coordinates).\n38 scalar_name[10][20]\tchar\t200\tName of each scalar. Can not be longer than 20 characters each. Can only store up to 10 names.\n238 n_properties\tshort int\t2\tNumber of properties saved at each track.\n240 property_name[10][20]\tchar\t200\tName of each property. Can not be longer than 20 characters each. Can only store up to 10 names.\n440 vox_to_ras[4][4]\tfloat\t64\t4x4 matrix for voxel to RAS (crs to xyz) transformation. If vox_to_ras[3][3] is 0, it means the matrix is not recorded. This field is added from version 2.\n504 reserved[444]\tchar\t444\tReserved space for future version.\n948 voxel_order[4]\tchar\t4\tStoring order of the original image data. Explained here.\n952 pad2[4]\tchar\t4\tPaddings.\n956 image_orientation_patient[6]\tfloat\t24\tImage orientation of the original image. As defined in the DICOM header.\n980 pad1[2]\tchar\t2\tPaddings.\n982 invert_x\tunsigned char\t1\tInversion/rotation flags used to generate this track file. For internal use only.\n983 invert_y\tunsigned char\t1\tAs above.\n984 invert_x\tunsigned char\t1\tAs above.\n985 swap_xy\tunsigned char\t1\tAs above.\n986 swap_yz\tunsigned char\t1\tAs above.\n987 swap_zx\tunsigned char\t1\tAs above.\n988 n_count\tint\t4\tNumber of tracks stored in this track file. 0 means the number was NOT stored.\n992 version\tint\t4\tVersion number. Current version is 2.\nhdr_size\tint\t4\tSize of the header. Used to determine byte swap. Should be 1000.\n*/\nfunction importTRK(fileObject,uint8Response,processinfo,arrived)\n{\n\t  \n\t  var view = new DataView(uint8Response.buffer);\n\t  if (ab2str(uint8Response.slice(0,5)) == \"TRACK\")\n\t  {\n\t\t var header = {};\n\n\t\t var LE = true;\n\t\t  header.offset = 1000;\n\t\t\n          header.n_scalars = view.getUint16(36,LE);\n          header.n_props = view.getUint16(238,LE);\n          header.count = view.getInt32(988,LE);\n\n          header.voxSize = view.getFloat32(12,LE);\n\n\t\t  var vox_to_ras = math.diag([0,0,0,0]);\n\t\t  for (var k = 0; k < 16;k++)\n\t\t  \t    vox_to_ras._data[math.floor(k/4)][k%4] = view.getFloat32(440+k*4,LE);\n\t\t  var e = vox_to_ras._data;\n\t\t  if (e[3][3] == 0)\n\t\t  \te = undefined;\n\n\t\t  var ie = math.inv(vox_to_ras)._data;\n\n\n\t\t var pos = 0;\n\t\t var tot_points = 0;\n\n\t\t var max = [-100000,-100000,-100000];\n\t\t var min = [100000,100000,100000];\n\n\t\t var tmax = [-100000,-100000,-100000];\n\t\t var tmin = [100000,100000,100000];\n\n\n\t\t var dummy = new Array(header.count);\n\t\t var tract_buffer = new Float32Array((uint8Response.byteLength-header.offset-header.count*4)/4);\n\n\t\t var tracts = [];\n\t\t var tracts_max = new Float32Array(header.count*3);\n\t\t var tracts_min = new Float32Array(header.count*3);\n\n\t\t var tracts_len = new Float32Array(header.count);\n\n\n\t\t var tractlen = 0;\n\t\t var totlen = 0;\n\t\t var tract_cnt = 0;\n\n\t\t dummy.chunk(function(el,j,arr)\n\t\t\t{\n\t\t\t\tvar tract = [];\n\t\t\t\tvar pos = arr.pos;\n\t\t\t\tif (pos == undefined) pos = 1000;\n\n\n\t\t\t\tvar num_p = view.getInt32(pos,LE); pos+=4;\n\n\t\t\t\tvar c = [0,0,0];\n\t\t\t\tfor (var k = 0; k < num_p;k++)\n\t\t\t\t{\n\t\t\t\t\tfor (var j = 0; j < 3;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tc[j] =  (view.getFloat32(pos,LE))+1;\n\t\t\t\t\t\tpos += 4;\n\t\t\t\t\t\ttot_points++;\n\t\t\t\t\t\ttractlen++;\n\n\t\t\t\t\t}\n\n\t\t\t\t\tc[0]  = c[0] / header.voxSize;\n\t\t\t\t\tc[1]  = c[1] / header.voxSize;\n\t\t\t\t\tc[2]  = c[2] / header.voxSize;\n\t\t\t\t\tfor (var j = 0; j < 3;j++)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar val;\n\t\t\t\t\t\tif (e)\t\t\t\t\t\t \t\n\t\t\t\t\t\t \tval = (e[j][0]*c[0]+e[j][1]*c[1]+e[j][2]*c[2]+e[j][3]);\n\t\t\t\t\t\telse\n\t\t\t\t\t \t\tval = c[j];\n\t\t\t\t\t \t//if (j==0) val = -val;\n\t\t\t\t\t\tif (max[j] < val) max[j] = val;\n\t\t\t\t\t\tif (min[j] > val) min[j] = val;\n\t\t\t\t\t\tif (tmax[j] < val) tmax[j] = val;\n\t\t\t\t\t\tif (tmin[j] > val) tmin[j] = val;\n\n\t\t\t\t\t\ttract.push(val);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t\ttracts_max[3*tract_cnt] =(tmax[0]);\n\t\t\t\ttracts_max[3*tract_cnt+1] =(tmax[1]);\n\t\t\t\ttracts_max[3*tract_cnt+2] =(tmax[2]);\n\t\t\t\ttracts_min[3*tract_cnt] =(tmin[0]);\n\t\t\t\ttracts_min[3*tract_cnt+1] =(tmin[1]);\n\t\t\t\ttracts_min[3*tract_cnt+2] =(tmin[2]);\n\t\t\t\ttmax = [-100000,-100000,-100000];\n\t\t\t\ttmin = [100000,100000,100000];\t\t\t\t\t\t\n\t\t\t\ttracts_len[tract_cnt] = (tractlen/3);\t\t\t\t\t\n\t\t\t\ttract_buffer.set(tract,totlen);\n\t\t\t\tvar tmp = new Float32Array(tract_buffer.buffer,totlen*4,tractlen);\n\t\t\t\ttracts.push(tmp);\n\n\t\t\t\ttotlen += tractlen;\n\t\t\t\ttract_cnt++;\t\t\t\t\t\n\t\t\t\ttractlen = 0;\n\n\n\n\t\t\t\tarr.pos = pos;\n\n\t\t\t},1024*4,0,\n\t\t\tfunction(i)\n\t\t\t{ \n\t\t\t  processinfo(\"reading \" + math.round(i/header.count*100) +\"%\");\n\t\t\t},\n\t\t\tfunction()\n\t\t\t{\n\t\t\t  if (tracts.length>0)\n\t\t\t  {\n\n\t\t\t\tfileObject.content = {tracts:tracts,   // these are just pointer on tract_buffer\n\t\t\t\t\t\t\t\t\ttract_buffer:tract_buffer,\n\t\t\t\t\t\t\t\t\ttracts_len:tracts_len,\n\t\t\t\t\t\t\t\t\ttot_points:tot_points,\n\t\t\t\t\t\t\t\t\toctree:new myOctree(min,max,0),\n\t\t\t\t\t\t\t\t\ttracts_max:tracts_max,tracts_min:tracts_min,\n\t\t\t\t\t\t\t\t\tmin:min,max:max,\n\t\t\t\t\t\t\t\t\tbuffer:uint8Response.buffer};\n\t\t\t  }\n\t\t\t   arrived(fileObject);\n\n\t\t\t});\n\t  }\n}\n\n\n\n\nfunction createFiberVisitMap(lines,subset,endpoints,fileObject,progress,done,persistent)\n{\n\tif (progress)\n\t\tprogress(\"rendering fiber visits\");\n  \n\tif (subset)\n\t  subset = subset.slice(0,subset.length)\n\n\tvar worker;\n\tif (persistent && persistent.worker)\n\t{\n\t\tworker = persistent.worker;\n\t\tlines = undefined;\n\t}\n\n \tworker = executeImageWorker({func:'createFiberVisitMap',\n \t    lines:lines,subset:subset,\n \t    endpoints:endpoints,\n \t\tdata:fileObject.content.data,\n \t\tsize:fileObject.content.sizes,\n \t\tbuffer:fileObject.buffer, keepOpen:true,\n\n \t\tedges:math.inv(fileObject.content.edges)._data},\n \t[\tfileObject.buffer],\n \t \tfunction(e)\n \t \t{\n\t\t\tif (progress) \n\t\t\t\tprogress(e);\n \t \t}\n \t \t,\n \t \tfunction(e)\n \t \t{\n \t \t\tif (progress)\n\t\t\t\tprogress(); \t \t\t\n\t\t\tfileObject.buffer = e.execObj.buffer;\n\t\t\tdone();\n\t\t\n \t \t},worker\n \t \t);\n\n \treturn worker\n \n\n}\n\n\nKObject3DTool.packTractsForTransfer = function(tracts)\n{\n\tfunction rmchnk(a)\n\t{\n\t\treturn a;\n\t}\n\n//\tvar tracts_data = tracts.content.tracts;\n//\tif (tracts_data != undefined)\n//\t\ttracts_data = tracts_data.slice(0);\n\n\treturn {tract_buffer: tracts.content.tract_buffer, \n\t\t\ttot_points:tracts.content.tot_points,\n\t\t\ttracts_len:tracts.content.tracts_len, \n\t\t\ttracts_min:rmchnk(tracts.content.tracts_min),\n\t\t\ttracts_max:rmchnk(tracts.content.tracts_max),\n\t\t\ttracts:rmchnk(tracts.content.tracts),\n\t\t\tmax:rmchnk(tracts.content.max),\n\t\t\tmin:rmchnk(tracts.content.min)};\n}\n\nKObject3DTool.unpackTracts = function(tracts)\n{\n\tif (tracts.tracts == undefined)\n\t{\n\t\tvar tr = [];\n\t\tvar offset = 0;\n\t\tvar tot_points = 0;\n\t\tfor (var k = 0; k < tracts.tracts_len.length;k++)\n\t\t{\n\t\t\tvar tmp = new Float32Array(tracts.tract_buffer.buffer,offset*4,tracts.tracts_len[k]*3);\n\t\t\ttot_points += tracts.tracts_len[k]\n\t\t\toffset += 3*tracts.tracts_len[k];\n\t\t\ttr.push(tmp);\n\t\t}\n\t\ttracts.tot_points = tot_points;\n\t\ttracts.tracts = tr;\n\t}\n}\n\n\n\nKObject3DTool.useOctreeWorker = true;\n\nfunction realtimeTracking(seeding,nii,params)\n{\n\t\tvar M = 256;\n\t\tvar cosLUT = new Array(M)\n\t\tvar sinLUT = new Array(M)\n\t\tfor (var l = 0; l < M;l++)\n\t\t{\n\t\t\tcosLUT[l] = Math.cos(Math.PI*2*l/M);\n\t\t\tsinLUT[l] = Math.sin(Math.PI*2*l/M);\n\t\t}\n\n\t\tfunction cos(x)\n\t\t{\n\t\t\treturn cosLUT[Math.floor(x*M)];\n\t\t}\n\t\tfunction sin(x)\n\t\t{\n\t\t\treturn sinLUT[Math.floor(x*M)];\n\t\t}\n\n\n\n\t\tfunction minmax(x,max,min)\n\t\t{\n\t\t\tif (x[0] > max[0])\n\t\t\t\tmax[0] =x[0];\n\t\t\tif (x[0] < min[0])\n\t\t\t\tmin[0] =x[0];\n\t\t\tif (x[1] > max[1])\n\t\t\t\tmax[1] =x[1];\n\t\t\tif (x[1] < min[1])\n\t\t\t\tmin[1] =x[1];\n\t\t\tif (x[2] > max[2])\n\t\t\t\tmax[2] =x[2];\n\t\t\tif (x[2] < min[2])\n\t\t\t\tmin[2] =x[2];\n\t\t}\n\n\n\t\tfunction getSeed()\n\t\t{\n\t\t\tif (seeding.radius != undefined)\n\t\t\t{\n\t\t\t\tvar p = seeding.seed._data;\n\t\t\t\tvar r = seeding.radius;\n\t\t\t\tvar delta = getDisplacement(1);\n\t\t\t\tvar nor = seeding.radius*Math.pow(Math.random(),1/3)/Math.sqrt(delta[0]*delta[0] + delta[1]*delta[1] +delta[2]*delta[2]);\t\t\t\n\t\t\t\treturn  [p[0] +delta[0]*nor ,p[1] +delta[1]*nor ,p[2] +delta[2]*nor ];\n\t\t\t}\n\t\t\telse if (seeding.threshold != undefined)\n\t\t\t{\n\t\t\t\t/*\n\t\t\t\tvar r = Math.floor(Math.random()*seedvoxels.length);\n\t\t\t\tvar p = seedvoxels[r]\n\t\t\t\treturn math.multiply(nii.edges,[p[0]+Math.random(),p[1]+Math.random(),p[2]+Math.random(),1])._data;\n\t\t\t\t*/\n\n\t\t\t\tvar seednii = seeding.vol;\n\t\t\t\tvar sz = seednii.sizes;\n\t\t\t\tvar totsz = sz[0]*sz[1]*sz[2];\n\t\t\t\tvar best = -100000;\n\t\t\t\tvar best_idx = -1\n\t\t\t\tfor (var k = 0; k < 500;k++)\n\t\t\t\t{\n\t\t\t\t\tvar x = Math.floor(Math.random()*sz[0]);\n\t\t\t\t\tvar y = Math.floor(Math.random()*sz[1]);\n\t\t\t\t\tvar z = Math.floor(Math.random()*sz[2]);\n\t\t\t\t\tvar mag;\n\t\t\t\t\tif (sz[3] == 3)\n\t\t\t\t\t{\n\t\t\t\t\t\tvar d   = [Math.abs(seednii.data[sz[0] * sz[1] * z + sz[0] * y + x]),\n\t\t\t\t\t\t\t\t  Math.abs(seednii.data[sz[0] * sz[1] * z + sz[0] * y + x +totsz]),\n\t\t\t\t\t\t\t\t  Math.abs(seednii.data[sz[0] * sz[1] * z + sz[0] * y + x +2*totsz])];\n\t\t\t\t\t\tmag = Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tmag = (seednii.data[sz[0] * sz[1] * z + sz[0] * y + x]);\n\n\t\t\t\t\t}\n\t\t\t\t\tif (mag > seeding.threshold)\t\t\t\t\t\n\t\t\t\t\t\treturn math.multiply(seednii.edges,[x+Math.random(),y+Math.random(),z+Math.random(),1])._data;\t\t\t\t\t\t\n\t\t\t\t\tif (mag > best)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest = mag;\n\t\t\t\t\t\tbest_idx = [x,y,z];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t    return false;\n\t\t\t    //return math.multiply(seednii.edges,[best_idx[0]+Math.random(),best_idx[1]+Math.random(),best_idx[2]+Math.random(),1])._data;\t\t\t\t\t\t\n\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\t\t\t\tvar r = Math.floor(Math.random()*seedvoxels.length);\n\t\t\t\tvar p = seedvoxels[r]\n\t\t\t\treturn math.multiply(seeding.roi.content.edges,[p[0]+Math.random(),p[1]+Math.random(),p[2]+Math.random(),1])._data;\n\n\t\t\t}\n\t\t}\n\n\n\n\n\n\n\t    var maxlen = params.Maxlen;\n\t    var minlen = params.Minlen;\n\t    var dens = params.Density;\n\t\tvar stepwidth = params.Stepwidth;\n\t\t\n\t\tvar thres =params.Threshold;\t\n\t\tif (seeding.threshold_term != undefined && params.Threshold == 0)\n\t\t\tthres = seeding.threshold_term;\n\t\n\t\tvar jitter_stength = params.Jitter;\n\t\tvar ang_thres = params.AngularThreshold;\n\t\tvar ang_thres_ = Math.cos(ang_thres/180*Math.PI);\n\t\tvar smooth_dist = params.SmoothWidth;\t\t\t\t\t\n\t\tvar seedvoxels = [];\n\n\t    var numfibs;\n\t\tif (seeding.radius != undefined)\n\t\t{\n\t   \t\t numfibs = Math.floor(dens * Math.sqrt(4/3*Math.PI * Math.pow(seeding.radius,3)));\n\t\t}\n\t\telse if (seeding.threshold != undefined)\n\t\t{\n\t\t\t/*var edges = nii.edges;\n\t\t\tvar sz = nii.sizes;\n\t\t\tif (seeding.seedvoxels == undefined)\n\t\t\t{\n\t\t\t\tvar totsz = sz[0]*sz[1]*sz[2];\n\t\t\t\tfor (var z = 0; z < sz[2]; z++)\n\t\t\t\t\tfor (var y = 0; y < sz[1]; y++)\n\t\t\t\t\t\tfor (var x = 0; x < sz[0]; x++)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar d   = [Math.abs(nii.data[sz[0] * sz[1] * z + sz[0] * y + x]),\n\t\t\t\t\t\t\t          Math.abs(nii.data[sz[0] * sz[1] * z + sz[0] * y + x +totsz]),\n\t\t\t\t\t\t\t          Math.abs(nii.data[sz[0] * sz[1] * z + sz[0] * y + x +2*totsz])];\n\t\t\t\t\t\t\tvar mag = Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);\n\t\t\t\t\t\t\tif (mag > seeding.threshold)\n\t\t\t\t\t\t\t\tseedvoxels.push([x, y, z]);\n\n\t\t\t\t\t\t}\n\t\t\t\tseeding.seedvoxels = seedvoxels;\n\t\t\t}\n\t\t\telse\n\t\t\t\tseedvoxels = seeding.seedvoxels;*/\n\t\t\tnumfibs = seeding.numfibs;\n\t\t}\n\t\telse\n\t\t{\n\n\t\t\tvar roi = seeding.roi;\n\n\t\t\tvar edges = roi.content.edges;\n\t\t\tvar sz = roi.content.sizes;\n\t\t\tfor (var z = 0; z < sz[2]; z++)\n\t\t\t\tfor (var y = 0; y < sz[1]; y++)\n\t\t\t\t\tfor (var x = 0; x < sz[0]; x++)\n\t\t\t\t\t\tif (roi.content.data[sz[0] * sz[1] * z + sz[0] * y + x] > 0.5)\n\t\t\t\t\t\t\tseedvoxels.push([x, y, z]);\n\t\t\tnumfibs = dens*seedvoxels.length/10;\n\n\t\t\t\n\t\t}\n\n\n\t\tvar totsz = nii.sizes[2]*nii.sizes[1]*nii.sizes[0]\n\n\t\tvar tracts = [];\n\t\tvar tracts_min = [];\n\t\tvar tracts_max = [];\n\t\tvar tracts_len = [];\n\t\tvar tot_points = 0;\n\t\tvar bb_max = [-100000,-100000,-100000];\n\t\tvar bb_min = [100000,100000,100000];\n\n\t\tvar ie = math.inv(nii.edges)._data;\n\t\tvar e = math.multiply(nii.edges,math.diag([1/nii.voxSize[0],1/nii.voxSize[1],1/nii.voxSize[2],1]))._data;\n\n\n        if (typeof nii.descrip == \"string\" && nii.descrip.substring(0,6).toLowerCase() == \"mrtrix\")\n        {\n            e = math.diag([1,1,1,1])._data;\n        }\n\n\n\n\t\tvar numdirs = nii.sizes[3]/3;\n\n\n\n\n\t\tvar getNextDir;\n\n\t    if (numdirs > 1)\n\t    {\n\t  \n\t\t\tgetNextDir = function(p,last_d)\n\t\t\t{\t\t\n\t\t\t\tvar best = undefined;\n\t\t\t\tvar maxp = -1;\n\t\t\t\tfor (var i = 0 ; i < numdirs;i++)\n\t\t\t\t{\n\t\t\t\t\tvar d =  NNInterp3_n(nii, p[0], p[1], p[2], ie,nii.widheidep,nii.widheidep*3*i,3); \n\t\t\t\t\tif (d == undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tbest = undefined;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tvar dn = Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);\n\t\t\t\t\tvar proj = (last_d[0]*d[0]+last_d[1]*d[1]+last_d[2]*d[2])/dn;\t\t\t\t\t\t\n\t\t\t\t\tif (Math.abs(proj) > maxp )\n\t\t\t\t\t{\n\t\t\t\t\t\tbest = [d,dn,proj];\n\t\t\t\t\t\tmaxp = Math.abs(proj);\n\t\t\t\t\t}\n\n\t\t\t\t}\n\t\t\t\treturn best;\n\t\t\t}\n\n\n\t    }\n\t    else\n\t    {\n\t    \t\n\t\t\tgetNextDir = function(p,last_d)\n\t\t\t{\t\t\n\t\t\t\tvar best = undefined;\n\t\t\t\tvar d = NNInterp3_n(nii, p[0], p[1], p[2], ie,nii.widheidep,0,3); \n\n\t\t\t\tif (d == undefined)\n\t\t\t\t\treturn;\n\t\t\t\tvar dn = Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);\n\t\t\t\tvar proj = (last_d[0]*d[0]+last_d[1]*d[1]+last_d[2]*d[2])/dn;\t\t\t\t\t\t\n\t\t\t\treturn [d,dn,proj];\n\t\t\t}\n/*\n\t\t\tgetNextDir = function(p,last_d)\n\t\t\t{\t\t\n\t\t\t\tvar best = undefined;\n\t\t\t\tvar d = NNInterp3_n(nii, p[0], p[1], p[2], ie,nii.widheidep,0,3); \n\n\t\t\t\tif (d == undefined)\n\t\t\t\t\treturn;\n\t\t\t\tvar proj = (last_d[0]*d[0]+last_d[1]*d[1]+last_d[2]*d[2]);\n                for (var k = 0; k < 3;k++)\n\t\t\t\t    d[k] = last_d[k] + 0.00001*d[k]*proj;\n\t\t\t\tvar dn = Math.sqrt(d[0]*d[0]+d[1]*d[1]+d[2]*d[2]);\n\t\t\t\tvar proj = (last_d[0]*d[0]+last_d[1]*d[1]+last_d[2]*d[2])/dn;\t\t\t\t\t\t\t    \n\t\t\t\treturn [d,dn,proj];\n\t\t\t}\n*/\n\n\t    }\n\n\t\t//console.log('start where mag>' + seeding.threshold + \"   stop when mag<\" + thres);\n\n\t\tvar previous_seed;\n\t\tvar max_tries = numfibs*10;\n\t\tvar tries = 0;\n\n\t\tfor (var j = 0; j < numfibs; j++)\n\t\t{\n\t\t\tvar tract = [];\n\n\t\t\tvar num = 0;\n\t\t\tvar p,last_d,min,max;\n\n\t\t\tfor (var s = 0; s < 2; s++)\n\t\t\t{\n\t\t\t\tif (s == 0)\n\t\t\t\t{\n\t\t\t\t   p = getSeed();\n\t\t\t\t   if ( p==false)\n\t\t\t\t   \t break;\n\t\t\t\t   last_d = getDisplacement(1)\n\t\t\t\t   previous_seed = {p:p.slice(0),last_d:last_d.slice(0)};\n\n\t\t\t\t   min = [p[0],p[1],p[2]]\n\t\t\t\t   max = [p[0],p[1],p[2]]\n\t\t\t\t   tract.push(p[0],p[1],p[2]);\n\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t   p = previous_seed.p;\n\t\t\t\t   last_d = [-previous_seed.last_d[0],-previous_seed.last_d[1],-previous_seed.last_d[2]];\n\t\t\t\t}\n\n\t\t\t\tif (p == false)\n\t\t\t\t\tcontinue;\n\n\n\n\t\t\t\tvar sm_acc = [];\n\t\t\t\tvar smoother = [0,0,0];\n\t\t\t\tvar sm_acc = [];\n\n\n\t\t\t\tfor (var k = 0; k < maxlen; k++)\n\t\t\t\t{\n\t\t\t\t\tvar best =  getNextDir(p,last_d);\n\n\t\t\t\t\tif (best != undefined)\t\t\t\t\n\t\t\t\t\t{\n\t\t\t\t\t\tvar jitter = getDisplacement(jitter_stength);\n\t\t\t\t\t\tvar d = best[0];\n\t\t\t\t\t\tvar dn = best[1];\n\t\t\t\t\t\tvar proj = best[2];\n\t\t\t\t\t\tif (dn < thres ||  Math.abs(proj) < ang_thres_)\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\tvar d_w = [ e[0][0]*d[0] + e[0][1]*d[1] + e[0][2]*d[2] ,\n\t\t\t\t\t\t\t\t\te[1][0]*d[0] + e[1][1]*d[1] + e[1][2]*d[2] ,\n\t\t\t\t\t\t\t\t\te[2][0]*d[0] + e[2][1]*d[1] + e[2][2]*d[2] ];\n\t\t\t\t\t\tvar sg = Math.sign(proj);\n\t\t\t\t\t\tvar alpha = stepwidth*sg/Math.sqrt(d_w[0]*d_w[0]+d_w[1]*d_w[1]+d_w[2]*d_w[2]);\n\t\t\t\t\t\tp[0] += alpha*d_w[0] + jitter[0];\n\t\t\t\t\t\tp[1] += alpha*d_w[1] + jitter[1];\n\t\t\t\t\t\tp[2] += alpha*d_w[2] + jitter[2];\t\t\t\t\n\t\t\t\t\t\tlast_d = [sg*d[0]/dn,sg*d[1]/dn,sg*d[2]/dn];\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tif (smooth_dist > 1)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (k < smooth_dist)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tsmoother[0] += p[0];\n\t\t\t\t\t\t\tsmoother[1] += p[1];\n\t\t\t\t\t\t\tsmoother[2] += p[2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tvar x = [smoother[0]/smooth_dist,smoother[1]/smooth_dist,smoother[2]/smooth_dist];\n\n\t\t\t\t\t\t\tif (s == 0)\n\t\t\t\t\t\t\t\ttract.push(x[0],x[1],x[2]);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\ttract.unshift(x[0],x[1],x[2]);\n\n\t\t\t\t\t\t\tminmax(x,max,min);\n\n\t\t\t\t\t\t\tvar idx = (k)%smooth_dist;\n\t\t\t\t\t\t\tsmoother[0] += p[0] - sm_acc[idx][0];\n\t\t\t\t\t\t\tsmoother[1] += p[1] - sm_acc[idx][1];\n\t\t\t\t\t\t\tsmoother[2] += p[2] - sm_acc[idx][2];\n\t\t\t\t\t\t}\n\t\t\t\t\t\tsm_acc[k%smooth_dist] = p.slice(0);\n\t\t\t\t\t\t\n\t\t\t\t\t}\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tif (s == 0)\n\t\t\t\t\t\t\ttract.push(p[0],p[1],p[2]);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\ttract.unshift(p[0],p[1],p[2]);\n\n\t\t\t\t\t}\n\n\t\t\t\t}\n\n\n\t\t\t}\n\t\t\tif (tract.length/3 > minlen)\n\t\t\t{\n\t\t\t\ttracts.push(new Float32Array(tract));\n\t\t\t\ttracts_min.push(min[0],min[1],min[2]);\n\t\t\t\ttracts_max.push(max[0],max[1],max[2]);\n\t\t\t\ttracts_len.push(tract.length/3);\n\t\t\t\tminmax(min,bb_max,bb_min);\n\t\t\t\tminmax(max,bb_max,bb_min);\n\t\t\t\ttot_points += tract.length/3;\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (tries++ > max_tries)\n\t\t\t\t\tbreak;\n\t\t\t \tj--;\n\t\t\t}\n\t\t}\n\n\t\treturn {tracts:tracts,tot_points:tot_points,tracts_len:tracts_len,tracts_min:tracts_min,tracts_max:tracts_max,min:bb_min,max:bb_max};\n\n\n\n\n\n\tfunction getDisplacement(fac)\n\t{\n\t\tvar u1 = Math.random();\n\t\tvar u2 = Math.random();\n\t\tvar h = Math.sqrt(-2*Math.log(u2))\n\n\t\tvar x = h*cos(u1);\n\t\tvar y = h*sin(u1);\n\t\t\n\t\tvar u1 = Math.random();\n\t\tvar u2 = Math.random();\n\t\tvar h = Math.sqrt(-2*Math.log(u2))\n\n\t\tvar z = h*cos(u1);\n\n\t\treturn [fac*x,fac*y,fac*z];\n\n\t\t\n\t}\n\n\n}\n\n\n\n\nfunction KTrackingPanel(tck)\n{\n\n    var panel = KPanel($(document.body),\"someid\",\"Tracking panel\");\n    panel.closeOnCloseAll = true\n\tvar $container = panel.$container;\n\t$container.addClass(\"DBSpanel\");\n\tpanel.$container.width(400);\n\n    var $fileRow = $(\"<div ></div>\").appendTo(panel.$container);\n    var $fileRow2 = $(\"<div class='panel'></div>\").appendTo(panel.$container);\n\n\n\t$fileRow.append($(\"<hr>\")).append($(\"<i class='flexspacer'></i>\"));\n\n\tvar params = {};\n\tpanel.params = params;\n\tvar params_ = {};\n\tpanel.params_ = params_;\n\n\tfunction inputParam(name,defaultval,unit,$div)\n\t{\n\t\tif (unit == undefined)\n\t\t\tunit = \"\";\n\t\telse\n\t\t\tunit = \"(\"+unit+\")\";\n\n\t\tif ($div == undefined)\n\t\t\t$div = $fileRow2;\n\n\t\tvar $param = $(\"<span class='DBS_paramname'> \"+name+\" </span> <input class='DBS_paraminput'  min=0 step=1 type='number' value='\"+defaultval+\"'> \"+unit+\"<br>\")\n\t\t$div.append($param).append($(\"<i class='flexspacer'></i>\"));\n\t\tparams[name] = defaultval;\n\t\tparams_[name] = $param;\n\t\t$($param[2]).on(\"change\",function(){\n\t\t\tparams[name] = parseFloat($(this).val());\t\t\t\n\t\t});\n\t}\n\n\tfunction update()\n\t{\n\t\tfor (var k in params)\n\t\t\t$(params_[k]).val(params[k]);\n\t}\n\tpanel.update = update;\n\n\n\n\tinputParam(\"Density\",10,\"#walker\");\n\tinputParam(\"Maxlen\",250);\n\tinputParam(\"Minlen\",70);\n\tinputParam(\"Stepwidth\",0.5);\n\tinputParam(\"Threshold\",0);\n\tinputParam(\"AngularThreshold\",75,\"deg\");\n\tinputParam(\"Jitter\",0.1);\n\tinputParam(\"SmoothWidth\",10);\n\tinputParam(\"numChunks\",25);\n\tinputParam(\"climcon\",0, \"0-bgnd,1-tensor\");\n\n\n\n\n\t$fileRow2.append($(\"<hr>\"))\n\n\treturn panel;\n}\n\n\n\nfunction KNiceFibPanel()\n{\n\n\n\tif (KPanel.currentPanels[\"nicefibs\"] != undefined)\n\t\treturn KPanel.currentPanels[\"nicefibs\"];\n\n\n    var panel = KPanel($(document.body),\"nicefibs\",\"Nice Fibers\");\n    panel.closeOnCloseAll = true\n\tvar $container = panel.$container;\n\tpanel.$container.width(400);\n\n    var $fileRow = $(\"<div ></div>\").appendTo(panel.$container);\n    var $fileRow2 = $(\"<div class='panel'></div>\").appendTo(panel.$container);\n\n\n\t$fileRow.append($(\"<hr>\")).append($(\"<i class='flexspacer'></i>\"));\n\n\tvar params = {};\n\tpanel.params = params;\n\tvar params_ = {};\n\tpanel.params_ = params_;\n\n\tfunction inputParam(name,defaultval,unit,$div)\n\t{\n\t\tif (unit == undefined)\n\t\t\tunit = \"\";\n\t\telse\n\t\t\tunit = \"(\"+unit+\")\";\n\n\t\tif ($div == undefined)\n\t\t\t$div = $fileRow2;\n\n\t\tvar $param = $(\"<span class='DBS_paramname'> \"+name+\" </span> <input class='DBS_paraminput'  min=0 step=1 type='number' value='\"+defaultval+\"'> \"+unit+\"<br>\")\n\t\t$div.append($param).append($(\"<i class='flexspacer'></i>\"));\n\t\tparams[name] = defaultval;\n\t\tparams_[name] = $param;\n\t\t$($param[2]).on(\"change\",function(){\n\t\t\tparams[name] = parseFloat($(this).val());\t\t\t\n\t\t});\n\t}\n\n\tfunction update()\n\t{\n\t\tfor (var k in params)\n\t\t\t$(params_[k]).val(params[k]);\n\t}\n\tpanel.update = update;\n\n\n\n\tinputParam(\"Radius\",0.5,\"mm\");\n\tinputParam(\"SpecularPower\",3,\"pow\");\n\tinputParam(\"Tessellation\",5,\"#\");\n\tinputParam(\"Simplification\",5,\"0-100\");\n\n\n    var $update = $(\"<a style='width:80px;' class='KViewPort_tool'> Update </a>\").click(\n\t\tfunction(e)\n\t\t{\n\t\t\tfor (var k = 0; k < panel.currentlyNice.length;k++  )\n\t\t\t\tpanel.currentlyNice[k].showNiceFibs();\n\n\t\t}\n    )\n    $fileRow2.append($update)\n\n\n\tpanel.currentlyNice = [];\n\n\tpanel.hide();\n\n\t$fileRow2.append($(\"<hr>\"))\n\n\treturn panel;\n}\n\n\n\nfunction track_length(track)\n{\n\tvar d = 0;\n \tvar cnt = track.length/3;\n\tfor (var k = 0; k < cnt-1;k++)\n\t{\n\t\td += Math.sqrt(\n\t\t\t (track[3*k]-track[3*k+3])*(track[3*k]-track[3*k+3]) +\n\t\t\t (track[3*k+1]-track[3*k+4])*(track[3*k+1]-track[3*k+4]) +\n\t\t\t (track[3*k+2]-track[3*k+5])*(track[3*k+2]-track[3*k+5]) );\n\t}\n\treturn d;\n}\n\nfunction reparam_track_constPcnt(track,len,pc)\n{\n\tif (len == undefined)\n\t\tlen = track_length(track);\n\treturn reparam_track(track,(len/(pc-1))+0.1);\n}\n\nfunction reparam_track(track,len)\n{\n\t\tvar pcnt = track.length/3;\n\t\tvar Leng = 0;\n\n\t\tvar dtau = 0;\n\t\tvar cur_p = 1;\n\t\tvar cur_i = 1;\n\t\tvar dR,normdR;\n\t\tvar new_track = [track[0],track[1],track[2]];\n\t\tfor (;;)\n\t\t{\n\t\t\twhile (dtau <= len && cur_p < pcnt)\n\t\t\t{\n\t\t\t\tdR  = [track[cur_p*3]- track[cur_p*3 -3],track[cur_p*3+1]- track[cur_p*3 -2],track[cur_p*3+2]- track[cur_p*3 -1]];\n\t\t\t\tnormdR = Math.sqrt(dR[0]*dR[0] + dR[1]*dR[1] + dR[2]*dR[2]);\n\t\t\t\tdtau += normdR;\n                Leng += normdR;\n\t\t\t\tcur_p++;\n\t\t\t}\n\n\t\t\tif (dtau >= len)\n\t\t\t{\n\t\t\t\tnew_track.push(track[cur_p*3 -3] - dR[0] *( (dtau-len)/normdR ),\n\t\t\t\t  \t\t\t   track[cur_p*3 -2] - dR[1] *( (dtau-len)/normdR ),\n\t\t\t\t\t\t\t   track[cur_p*3 -1] - dR[2] *( (dtau-len)/normdR ) );\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tnew_track.push(track[3*pcnt-3 ],\n\t\t\t\t\t\t\t\ttrack[3*pcnt -2 ],\n\t\t\t\t\t\t\t\ttrack[3*pcnt- 1 ]);\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tdtau = dtau-len;\n\n\t\t\tcur_i++;\n\t\t\tif (cur_i >= 10000)\n\t\t\t{\n\t\t\t\tconsole.log(\"bugy\");\n\t\t\t\tbreak;\n\t\t\t}\t\t\t\n\n\t\t}\n\n\t\treturn new_track;\n\n\n}\n\n\nfunction createFibTrackWorker(trackVol)\n{\n\tfunction packNiiForTransfer(nii)\n\t{\n\t\treturn {data:nii.data,\n\t\tedges:nii.edges,descrip:nii.descrip,sizes:nii.sizes,voxSize:nii.voxSize,widheidep:nii.widheidep,wid:nii.wid,widhei:nii.widhei};\n\t}\n\n\n    var scriptname = 'KFibtrackWorker.js' + '?' +  static_info.softwareversion;;\n    if (typeof url_pref != \"undefined\")\n       scriptname = url_pref + scriptname;\n\n\tvar worker =  new Worker(scriptname);\n\tworker.postMessage = worker.webkitPostMessage || worker.postMessage;\n\tworker.addEventListener('message', function(e) {\n\t\te = e.data;\n\t\tif (e.msg == 'tracts')\n\t\t{\n\t\t\tworker.callback(e.result);\n\t\t}\n\t\tworker.istracking = false;\n\t}, false);\n\tworker.kill = function()\n\t{\n\t\tworker.postMessage({message:'kill'},[]);\n\n\t}\t\t\t\t\t\t\t\t\n\tworker.postMessage({message:'trackvol',nii:packNiiForTransfer(trackVol)},\t\t[]);\n\n\tworker.track = function (seeding,params,callback)\n\t{\n\t\tworker.istracking = true;\n\t\tif (seeding.vol)\n\t\t{\n\t\t\tif (this.lastSeedingVol == seeding.vol)\n\t\t\t\tseeding.vol = 'last'\n\t\t\telse\n\t\t\t\tseeding.vol = packNiiForTransfer(seeding.vol);\n\t\t}\n\t\tthis.callback = callback;\n\t\tthis.postMessage({message:'start',seeding:seeding,params:params },[]);\n\t}\n\n\treturn worker;\n}"},function(t,n){t.exports='\n// ======================================================================================\n// ======================================================================================\n// ============= KCacheManager\n// ======================================================================================\n// ======================================================================================\n\n\nfunction KCacheManager(master)\n{\n   /** the tool to manage local files/uploads/downloads etc\n   * @class \n   * @alias KCacheManager\n   * @augments KToolWindow\n   */\n  var that = new KToolWindow(master,\n  $("<div class=\'KView_tool \'><i class=\'fa fa-institution fa-1x\'></i></div>")\n  .append( $("<ul class=\'KView_tool_menu\'></ul>").append($("<li>Workspace</li>")) ) );\n\n  var dataman = master.dataManager;\n\n\n  that.name = \'Workspace\';\n\n\n  var $menu = $("<ul ></ul>");\n\n  if (electron)\n  {\n\n\n  \n\n\t\tvar filters = [\n\t\t\t{ name: \'All Supported Formats\', extensions: [\'nii\', \'mgh\',\'mgz\',\'nrrd\',\'tck\', \'trk\',\'gii\',\'gz\', \'jpg\', \'png\' , \'json\' , \'txt\'  ] },\n\t\t\t{ name: \'NIFTI/MGH\', extensions: [\'nii\',\'nii.gz\', \'mgh\',\'mgz\',\'nrrd\'] },\n\t\t\t{ name: \'Streamline Formats\', extensions: [\'tck\',\'trk\'  ] },\n\t\t\t{ name: \'Json\', extensions: [\'json\' ] },\n\t\t\t{ name: \'Dicoms/Bruker\', extensions: [\'*\'] },\n\t\t\t{ name: \'All Files\', extensions: [\'*\'] }\n\t\t  ]\n\n\t\tfunction loadit(f)\n\t\t{\t\t\n\t\t\t\tif (f.filePaths)\n\t\t\t\t\tf = f.filePaths;\n\n\t\t\t\tf = f.map(function(s) {return s.replace(/\\\\/g,"/");}); // for windows\n\t\t\t\tfileLoad(f); \n\t\t\t\tupdateRecent(f); \n\t\t}\n\n\n\t\tfunction loadfiles()\n\t\t{\n\t\t\tvar res = dialog.showOpenDialog(null,{ title: \'open files\',\n\t\t\t\t\t\t\tproperties: [\'openFile\',\'multiSelections\'], filters:filters,\n\t\t\t\t\t\t\tdefaultPath: defaultOpenPath\n\t\t\t\t\t\t})\n\t\t\tif (res)\n\t\t\t{\t\t\t\t\t\t\n\t\t\t\tif (res.then)\n\t\t\t\t\tres.then(loadit);\n\t\t\t\telse \n\t\t\t\t\tloadit(res);\n\t\t\t}\n\t\t}\n\n\t\tfunction loaddirs() \n\t\t{\t\t\n\t\t\tvar res = dialog.showOpenDialog({ title: \'open directories\',\n\t\t\t\t\t\t\tproperties: [\'openDirectory\',\'multiSelections\'],\n\t\t\t\t\t\t\tdefaultPath: defaultOpenPath\n\t\t\t\t\t\t})\n\t\t\tif (res)\n\t\t\t{\t\t\t\t\t\t\n\t\t\t\tif (res.then)\n\t\t\t\t\tres.then(loadit);\n\t\t\t\telse \n\t\t\t\t\tloadit(res);\n\t\t\t}\n  \t\t}\n\n  \t\t \n  \t\tvar ipc = require(\'electron\').ipcRenderer;\n\t    ipc.on(\'loadfiles\', loadfiles)\n\t    ipc.on(\'loadrecent\', function(event,args) {\n\t\t\tfileLoad([args]);\n\t    \t})\n\t    ipc.on(\'loaddirs\', loaddirs)\n\t    ipc.on(\'saveworkstate\', saveWorkstate)\n\n  \t\t\n\t\t$("<li><a>Load Files</a></li>").click(loadfiles).appendTo($menu);\n\t\t\t\t\t\t\n\t\t$("<li><a>Load Directory</a></li>").click(loaddirs).appendTo($menu);\n\n\t\t$("<li><a>Save Workstate</a></li>").click(saveWorkstate).appendTo($menu);\n\t\t\t\t\t\t\n\t\tthat.loadFile = fileLoad;\n\n\t\tfunction fileLoad(files,callback) {\n\t\t\t\tif (files !== undefined && files.length > 0) {\n\t\t\t\t\tvar loadedFobj = []\n\t\t\t\t\tvar fobj = [];\n\t\t\t\t\tfor (var k = 0; k < files.length;k++)\n\t\t\t\t\t\tfobj.push( {\n\t\t\t\t \t\t\t webkitGetAsEntry: KFileEntry(files[k])\n\n\t\t\t\t\t\t});\n\n\t\t\t\t\tdefaultOpenPath = files[0].split("/").slice(0,-1).join("/");\n\t\t\t\t\tcreateLoadParamsFileDrop( {dataTransfer: { items:fobj,types:["Files"]  } },\n\t\t\t\t\t\t\t\tfunction (loadparams)\n\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\tvar aboutoabort = false;\n\t\t\t\t\t\t\t\t\tfunction serialize(k)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tif (k>= loadparams.length || aboutoabort)\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (callback)\n\t\t\t\t\t\t\t\t\t\t\t\tcallback(loadedFobj);\n\t\t\t\t\t\t\t\t\t\t\treturn\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\tif (loadparams[k].error)\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tloadedFobj.push(loadparams[k]);\n\t\t\t\t\t\t\t\t\t\t\t\tserialize(k+1);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\tvar cb = loadparams[k].callback;\n\t\t\t\t\t\t\t\t\t\t\t\tloadparams[k].callback = function(fob)\n\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (cb)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcb();\n\t\t\t\t\t\t\t\t\t\t\t\t\tif (fob != undefined)\n\t\t\t\t\t\t\t\t\t\t\t\t\t{\n\t\t \t\t\t\t\t\t\t\t\t\t\t\tlogProcess(\'loaded \' + fob.filename);\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\tloadedFobj.push(fob);\n\t\t\t\t\t\t\t\t\t\t\t\t\tserialize(k+1);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\tthat.progressSpinner(k/loadparams.length,function() { aboutoabort = true});\n\t\t\t\t\t\t\t\t\t\t\t\tKViewer.dataManager.loadData(loadparams[k]);\n\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\tserialize(0);\n\n/*\n\t\t\t\t\t\t\t\t\tfor (var k = 0; k < loadparams.length;k++)\n\t\t\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\t\t\tloadparams[k].progressSpinner = that.progressSpinner;\t\n\t\t\t\t\t\t\t\t\t\tKViewer.dataManager.loadData(loadparams[k]);\n\t\t\t\t\t\t\t\t\t}\n*/\n\t\t\t\t\t\t\t\t\t\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t , that.progressSpinner)\n\n\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse if (callback)\n\t\t\t\t\tcallback(loadedFobj);\n\t\t\t}\n\n\n\t\t\tfunction updateRecent(files)\n\t\t\t{\n\t\t\t\t if (files == undefined)\n\t\t\t\t \treturn;\n\t\t\t\t fs.readFile("./recent.json",undefined, function(err,content)\n\t\t\t\t\t {\n\t\t\t\t\t\tvar recent = {};\n\t\t\t\t\t\tvar offs = 0;\n\t\t\t\t\t \tif (content != undefined)\n\t\t\t\t\t \t{\n\t\t\t\t\t \t\tvar names= JSON.parse(content);\t\t\t\t\t \t\t\t\n\t\t\t\t\t \t\tfor (var k = 0;k < names.length;k++)\n\t\t\t\t\t \t\t\trecent[names[k]] = k;\n\t\t\t\t\t \t\toffs = names.length;\n\t\t\t\t\t \t}\n\n\t\t\t\t\t\tif (files.length > 5)\n\t\t\t\t\t\t\tfiles = files.slice(0,5);\n\n\t\t\t\t\t\tfor (var k = 0;k < files.length;k++)\n\t\t\t\t\t\t    recent[files[k]] = offs+k;\n\n\t\t\t\t\t\tvar recent = Object.keys(recent);\t\t\t\t\t    \n\t\t\t\t\t \tif (recent.length>10)\n\t\t\t\t\t\t\trecent = recent.slice(recent.length-10,recent.length);\n\n\t\t\t\t\t\tfs.writeFile("./recent.json",JSON.stringify(recent),undefined,function(){\n\t\t\t\t\t\t\tipc.send(\'rebuild-menu\');\n\t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n\t\t\t\t\t });\n \t\t\t }\n\t\t\t\n\n\n  }\n\n\n\n  that.runningBlobIndex=0\n  that.loadBlob = function(blob,name,callback)\n  {\n\t\tthat.runningBlobIndex++;\n\t\tvar id = "blob" + that.runningBlobIndex;\n\t\tKViewer.dataManager.loadData({URLType:\'cachefile\',\n\t\t\tfileID:id,\n\t\t\tfileinfo:{Filename:name,ID:id},\n\t\t\tfile:blob,\n\t\t\tcallback: callback\n\t\t\t})\n \n  }\n\n\n\n\n  $("<li><a>Close All</a></li>").click(function(){\n    signalhandler.send("close");\n    dataman.clearMemory();\n    master.roiTool.clearAll();\n    that.update();\n   }  ).appendTo($menu);\n\t \n  $menu.append($("<hr width=\'100%\'> ")); \t\t\t\t\t \t\t\t\t\t\n\n  if (!electron)\n  {\n\n\t  $("<li><a>Upload local files</a></li>").click(function() { uploadAll() } ).appendTo($menu);\n\t  $("<li><a>Upload local files with native PID</a></li>").click(function() { uploadAll(\'useinternalPSID\') } ).appendTo($menu);\n\t  $menu.append($("<hr width=\'100%\'> ")); \t\t\t\t\t \t\t\t\t\t\n  }\n\n  var sel = \'\';\n  if (state.viewer.zippedUpload)\n\t  sel = \'check-\';\n  var $zup;\n   $menu.append($zup = $("<li> zipped upload/save <i class=\'fa fa-"+sel+"circle-o\'></i> </li>").click(\n   function()\n   {\n\t\tvar $fa = $zup.find(".fa");\n   \t    if (state.viewer.zippedUpload)\n   \t    {\n   \t      state.viewer.zippedUpload = false;\n   \t      $fa.removeClass("fa-check-circle-o").addClass("fa-circle-o");\n   \t    }\n   \t    else\n   \t    {\n   \t      state.viewer.zippedUpload = true;\n   \t      $fa.addClass("fa-check-circle-o").removeClass("fa-circle-o");\n   \t    }\n\n\n   }))\n\n   that.$topRow.on(\'mouseenter\',\n   function()\n   {\n\t\tvar $fa = $zup.find(".fa");\n   \t    if (state.viewer.zippedUpload)\n   \t      $fa.addClass("fa-check-circle-o").removeClass("fa-circle-o");\n   \t    else\n   \t      $fa.removeClass("fa-check-circle-o").addClass("fa-circle-o");\n   });\n\n\n  that.$topRow.append( $("<li><a>Workspace</a></li>").append($menu) );\n\n  var $menu2 = $("<ul ></ul>");\n  var $diskcache =  $("<a></a>").appendTo($("<li></li>").appendTo($menu2));  \n  $("<li><a>Clear Disk Cache</a></li>").click(function(){storage.clear().then(that.update); }).appendTo($menu2);\n  var $diskcachehead = $("<li><a> DiskCache</a> </li>");\n  that.$topRow.append($diskcachehead.append($menu2) );\n \n  that.$topRow.append( $("<li><a>DicomWeb</a></li>").click(function(e)\n  {\n         var prompt = "Paste a dicomweb link to a series or a study";\n         if (typeof lastDicomWebLink == "undefined")\n          lastDicomWebLink="";\n         alertify.prompt(prompt, function(e,str)\n         {\n         \tif (e)\n         \t{\n                loadDICOMwebURL(str);\n                lastDicomWebLink = str;\n         \t}\n         },lastDicomWebLink );\n  \t\n   } ))\n\n\n  var $innerDIV = $("<div ondragover=\'event.preventDefault();\' class=\'annotation_tool_listDIV\'></div>").appendTo(that.$container);\n \n\n  if (!KViewer.standalone && userinfo.username==guestuser)\n  {\n  \t    that.$leftToolistDiv.remove();\n        $innerDIV.css("width","100%");\n  }\n \n\n  if (userinfo.username == guestuser)\n  {\n     //that.$leftToolistDiv.remove();\n     //$innerDIV.css("width","100%");\n  }\n\n  var $table = $("<table cellspacing=0 class=\'localfiletable\'></table>").appendTo($innerDIV);\n  that.handleDrop = function(e)\n  {\n  \t//if (e.isDefaultPrevented && e.isDefaultPrevented()) // what\'s this???\n\t//\treturn;\n   \n    e.preventDefault();\n    e.stopPropagation();\n\n\tcreateLoadParamsFileDrop(e, function (loadparams)\n\t{\n\t\tfor (var k = 0; k < loadparams.length;k++)\n\t\t{\n\t\t\tloadparams[k].progressSpinner = that.progressSpinner;\t\t \n\t\t\tif (userinfo.username == guestuser | $.isNumeric(loadparams[k].fileID) | loadparams[k].buffer != undefined)\n\t\t\t\tKViewer.dataManager.loadData(loadparams[k]);\n\t\t\telse      \n\t\t\t\tKViewer.dataManager.loadProxy(loadparams[k],false);\n\t\t}\n\n\t\tKViewer.cacheManager.update();\n\n\t},that.progressSpinner);\n\n    cleanAllDropIndicators();\n  \n  }\n  that.$container[0].ondrop = that.handleDrop;\n  that.$container.on("dragover",function(e)\n  {\n  \treturn false;\n  });\n\n\n\n\n  /***************************************************************************************\n   * resize callback\n   ****************************************************************************************/\n\n  that.resize = function(hei)\n  {\n      that.$container.height(hei);\n      $innerDIV.height(hei-that.$container.find(\'.KToolsTopMenu\').height());\n  }\n\n\n  /***************************************************************************************\n   * update the tool table\n   ****************************************************************************************/\n\n\n  that.update = function()\n  {\n    $table.children().remove();\n  \n  \tvar $thead = $("<thead>").appendTo($table);\n    var $row = $("<tr ></tr>").appendTo($thead);\n    $row.append($("<td class=\'fixedwidth\' preventsortable=\'1\' fixedwidth=\'7\' ><i class=\'fa fa-square-o\'></i></td>").click(function(e){ toggle_all(); }));\n    $row.append($("<td class=\'fixedwidth\' preventsortable=\'1\' fixedwidth=\'7\'></td>"));\n    $row.append($("<td class=\'fixedwidth\' preventsortable=\'1\' fixedwidth=\'7\'></td>"));\n    $row.append($("<td>FID </td>"));\n    $row.append($("<td>filename&nbsp&nbsp&nbsp</td>"));\n    $row.append($("<td>subfolder</td>"));\n    $row.append($("<td>type</td>"));\n    $row.append($("<td>size</td>"));\n    $row.append($("<td>PID</td>"));\n    $row.append($("<td>SID</td>"));\n\n  \tvar $tbody = $("<tbody>").appendTo($table);\n    var filelist = dataman.getFileList();\n    for  (var k =0; k < filelist.length; k++)\n    {\n\n       var fobj = dataman.getFile(filelist[k]);\n       var id = fobj.fileID;\n\n       if (id == undefined) // probably a bad bug, if this happens\n       \t\tcontinue;\n\n       if (id.substring(0,5) == "atlas")\n       \t  continue;\n \n       var dragstuff = "draggable=\'true\' data-type=\'file\' data-piz=\'\' data-sid=\'\' data-tag=\'"+fobj.fileinfo.Tag+"\' data-filename=\'"+fobj.filename+"\' data-subfolder=\'\' data-fileID=\'"+fobj.fileID+"\' data-mime=\'"+fobj.contentType+"\'";\n       dragstuff = dragstuff + " ondragstart=\'setdragstart(event);\' ondragend=\'setdragend(event);\' ";\n       \n       // dblclick makes problems for example with delete button. No solution so far\n       var $row = $("<tr  ondblclick=\'loadDataOndblClick(event);\' class=\'filecache\' " + dragstuff + "></tr>").appendTo($tbody);\n       if (fobj.modified) \n           $row.addClass("modified");\n       $row.on("contextmenu", function (ev) { fileCacheContextMenu(ev); });\n       $row.append($("<td><i class=\'fa fa-square-o\'></i> </td>").dblclick(function(e) {return false;}).click(function(e){ toggle_file(e.target); return false; }));\n\n\n\t   //var editable = id.substring(0,9) == "localfile" | id.substring(0,5) == "proxy" | fobj.modified;\n       $row.append($("<td> <i class=\'tablebutton fa fa-fw fa-trash\'></td>").click(function(k) {return function(ev){ev.preventDefault();ev.stopPropagation();\n\t\t\tignoreDblClickBeforeClose(ev);\n\t  \t\t master.dataManager.delFile(k); that.update();  return false;} }(fobj.fileID) ));\n\n\n       if (fobj.editable | fobj.proxyev != undefined)\n       {\n         var $up = $("<i class=\'tablebutton fa fa-fw fa-upload\'></i>").on(\'click\', function(e) { prepTarget(e.target); uploadFiles(); });\n         if (userinfo.username != guestuser)\n              $row.append($("<td></td>").append($up));\n         else\n              $row.append($("<td></td>"));\n       }\n       else\n         $row.append($("<td> </td>"));\n\n\n       if (id.substring(0,9) == "localfile" || id.substring(0,5) == "proxy" )\n          $row.append($("<td>local</td>"));\n       else\n          $row.append($("<td>" + id + "</td>"));\n\n\n\t   //var editable = id.substring(0,9) == "localfile" | id.substring(0,5) == "proxy" | fobj.modified;\n\n\t   var types = {\n\t   \t nii: "image imgTag",\n\t   \t bmp: "file-image-o",\n\t   \t ano: \'comment-o AnoTag\',\n\t   \t form: "file-text-o FormTag",\n\t   \t json: "file-o",\t   \t \n\t   \t pdf: "file-pdf-o",\n\t   \t txt: "file-text-o",\n\t   \t tracts: "tree fiberTag"\n\t   };\n\n\n\t\tvar symbol = "??";\n\t\tif (types[fobj.contentType] != "undefined")\n\t\t  symbol = "<i class=\'KTreeSymbol fa fa-" + types[fobj.contentType] +  " fa-fw\' ></i>  ";\n\n\n\n\t\n\n      var $namediv = $("<div >" + symbol + fobj.filename + " </div>").appendTo($("<td></td>").appendTo($row));\n      if (fobj.editable)\n\t\t\tKSetContentEditable($namediv,function(sel) { return  function($el) \n\t\t\t   {\n\t\t\t\t\t\tsel.filename = $el.text().trim(); \n\t\t\t\t\t\tif (sel.namedivs != undefined)\n\t\t\t\t\t\t\tfor (var i = 0; i < sel.namedivs.length;i++)\n\t\t\t\t\t\t\t\t$(sel.namedivs[i]).text(sel.filename);\n\t\t\t   } }(fobj),undefined,true);\n\t\t\t   \n\t  \n\n\t  var subf = (fobj.fileinfo.SubFolder || "/");\n      var $subdiv = $("<div>" + subf + " </div>").appendTo($("<td></td>").appendTo($row));\n      if (fobj.editable)\n\t\t\tKSetContentEditable($subdiv,function(sel) { return  function($el) \n\t\t\t   {\n\t\t\t\t\t\tsel.fileinfo.SubFolder = $el.text().trim(); \n\t\t\t   } }(fobj),undefined,true);\n\n       \n       if ((fobj.fileinfo.Tag || "").search("/mask/") >= 0)\n          $row.append($("<td> ROI </td>"));\n       else\n       {\n\t\t  if (fobj.contentType == "nii")\n\t\t  {\n\t\t\t$row.append($("<td> " + fobj.content.filetype +" (" +fobj.content.sizes+")</td>")); \n\t\t  } \n\t\t  else       \n            $row.append($("<td>" + fobj.contentType +"</td>"));\n       }\n \n\n       $row.append($("<td>" + toFileSize(fobj.fileinfo.filesize) + " </td>"));\n\n\n\n    \n          \n  \n       $row.append($("<td>" + fobj.fileinfo.patients_id + "</td>"));\n       $row.append($("<td>" + fobj.fileinfo.studies_id + "</td>"));\n\n     }\n     if (electron)\n\t \tthat.tablestate = {viscol:[true, false, false, true, false, true, true, true, false, false] };\n\t else \t\n\t    if (that.tablestate == undefined)\n\t     \tthat.tablestate = {viscol:[true, true, true, false, true, true, true, true, false, false] };\n\n     that.attachTableOperator($table.parent(),undefined,true);\n\n     if (storage != undefined)\n     {\n       $diskcachehead.show();\n       function showsum(sum)\n       {        \n          var used = 100*sum/storage.getCapacity();\n//          $diskcache.text("used " + used.toFixed(0) + "%");\n          $diskcache.text("used " + (sum/1024/1024).toFixed(0) + " MB");\n          if (used > 95)\n          { \n              $diskcachehead.css(\'color\',\'red\');\n              $diskcache.css(\'color\',\'red\');\n          }\n          else\n          { \n              $diskcachehead.css(\'color\',\'\');\n              $diskcache.css(\'color\',\'\');\n          }\n\n       }\n\n       storage.ls().then(function(docKeys) {\n          var sum = 0;\n          var fun = function () {storage.getContents(docKeys[0]).then(\n              function(content)\n              {\n                  if (docKeys.length > 0)\n                  {\n                    docKeys.splice(0,1);\n                    if (content != "")\n                    {\n                    \tvar finfo = JSON.parse(content);\n                    \tif (finfo.filesize != undefined)                    \t\n                    \t\tsum += finfo.filesize\n                    }\n                    fun();\n                  }\n                  else\n                  {\n                    showsum(sum);\n                    storage.size = sum;\n                  }\n              }) };  fun(); })\n    }\n    else\n      $diskcachehead.hide();\n\n\n    function toggle_file(target)\n    {\n      if (!$(target).hasClass("fa"))\n         target = $(target).parent().find(".fa");\n      toggle(target);\n    }\n\n    function toggle(target)\n    {\n      $(target).toggleClass("fa-square-o");\n      $(target).toggleClass("fa-check-square-o");\n      $(target).parent().parent().toggleClass("selected");\n    }\n\n    function toggle_all()\n    {\n       var rows = $table.find("tr");\n       for (var k = 1; k < rows.length;k++)\n          toggle($(rows[k]).find(".fa-square-o,.fa-check-square-o"));\n    }\n\n    function getVisible()\n    {\n       var visible = [];\n       for (var fid in visibleROIs)\n       {\n          visible.push(master.dataManager.files[fid].content);\n       }\n       return visible;\n    }\n    that.getVisible = getVisible;\n\n \tsignalhandler.send(\'cacheManagerUpdate\')\n\n  }\n  \n\n  /***************************************************************************************\n   * update the tool table\n   ****************************************************************************************/  \n\n  function uploadAll(usenativePID)\n  {\n      var fids = KViewer.dataManager.getFileList();\n      tempObjectInfo = [];\n      for (var k = 0; k < fids.length ;k++)\n      {\n \t\t  var modified = false;\n \t\t  var fobj = KViewer.dataManager.getFile(fids[k]);\n \t\t  if (fobj.modified)\n \t\t  \tmodified = true;\n      \t  \n          if (fids[k].substring(0,5) == \'local\' | fids[k].substring(0,5) == \'proxy\' | modified)\n              tempObjectInfo.push({fileID:fids[k]});\n      }\n      uploadFiles(that.progressSpinner,usenativePID);\n  }\n\n\n\n  /***************************************************************************************\n   * upload files\n   ****************************************************************************************/  \n\n\n  function uploadFiles(progress,usenativePID)\n  {\n     var filesToUpload = tempObjectInfo;\n     tempObjectInfo = [];\n\n\t if (progress == undefined)\n\t \tprogress = that.progressSpinner;\n\n\n     function doTheUpload()\n     {\n      \n          var fi = KViewer.dataManager.getFile(filesToUpload[0].fileID);\n\t\t  var finfo = {SubFolder:"",Tag:"",permission:"rwp"};\n\t\t  if (fi.fileinfo && fi.fileinfo.SubFolder)\n\t\t  \t\tfinfo.SubFolder = fi.fileinfo.SubFolder.replace(/^\\/|\\/$/g, "");\n\n\t\t  var zip = false;\n\t\t  if (state.viewer.zippedUpload)\n\t\t  \tzip = true;\n\n          if (!uploadBinary(fi,finfo,\n          function (id,response)\n          {\n               if (id.substring(0,5) == \'proxy\')\n               {\n                  KViewer.dataManager.delFile(id);  \n               }\n               else\n               {\n                 var newid = response.fileID;\n                 var fi = KViewer.dataManager.getFile(id);\n                 if (newid != id)\n                 {                    \n                   fi.fileID = newid;\n                   KViewer.dataManager.setFile(newid,fi);\n                   KViewer.dataManager.delFile(id,true);\n                 }\n                 fi.modified = false;\n               }\n\n               KViewer.cacheManager.update();\n               if (ViewerSettings.selectionMode[1] == \'f\')\n\t\t\t\t   refreshButton();\n               else\n               \t   patientTableMirror.mirrorState();\n               filesToUpload.splice(0,1);\n               if (filesToUpload.length > 0)\n                   doTheUpload();\n\n          },progress,zip,usenativePID)) { filesToUpload.splice(0); }\n     }\n     doTheUpload();\n  \n  }\n  that.uploadFiles = uploadFiles;\n\n  function prepTarget(target)\n  {\n      for (var k = 0;k< 3;k++)\n      {\n        if ($(target).is("tr"))\n           break;\n        target = $(target).parent();\n      }\n      prepObjectInfo(target);\n      return target;\n  }\n  that.prepTarget = prepTarget;\n\n\n\n  /***************************************************************************************\n   * filecontext menu\n   ****************************************************************************************/ \n \n  var fileCacheContextMenu = KContextMenu(\n  function(ev) {\n      var target = prepTarget(ev.target)\n      var $menu = $("<ul class=\'menu_context\'>")\n\n      if (tempObjectInfo[0].mime == "nii")\n      {\n          $menu.append($("<li onchoice=\'openasroi\' >Open as ROI </li>"));\n          $menu.append($("<li onchoice=\'cloneasroi\' >Clone as ROI </li>"));\n      }\n      if (tempObjectInfo[0].mime == "json")\n      {\n          $menu.append($("<li onchoice=\'openasanno\' >Open as annotation</li>"));\n          $menu.append($("<li onchoice=\'openastrans\' >Open as transformation</li>"));\n      }\n      if (userinfo.username != guestuser & (tempObjectInfo[0].fileID.search(\'local\')>-1 | tempObjectInfo[0].fileID.search(\'proxy\')>-1))\n      {\n//        $menu.append($("<li onchoice=\'assignpid\' >Assign PID </li>"));\n//        $menu.append($("<li onchoice=\'assignsid\' >Assign SID </li>"));\n        $menu.append($("<li onchoice=\'upload\' >Upload </li>"));\n      }\n      $menu.append($("<li onchoice=\'download\' >Download </li>"));\n      $menu.append($("<li onchoice=\'remove\' >Remove </li>"));\n\n\n      return $menu;\n  },\n  function (str,ev)\n  {\n      if (str=="openasroi")\n      {\n          for (var k = 0; k < tempObjectInfo.length;k++)\n              KViewer.roiTool.pushROI(tempObjectInfo[k].fileID,tempObjectInfo[k].filename,\'frommaskfile\');\n      } \n      if (str=="cloneasroi")\n      {\n          for (var k = 0; k < tempObjectInfo.length;k++)\n              KViewer.roiTool.pushROI(tempObjectInfo[k].fileID,\'untitled\');\n      } \n      if (str=="openasanno")\n      {\n          for (var k = 0; k < tempObjectInfo.length;k++)\n          {\n               var c = KViewer.dataManager.getFile(tempObjectInfo[k].fileID).content;\n               KViewer.annotationTool.loadAnnotations({content:c});\n          }\n          if (!KViewer.annotationTool.$toggle.hasClass("KView_tool_enabled"))\n               KViewer.annotationTool.$toggle.trigger("click");\n      }\n      else if (str=="assignpid" | str == "assignsid")\n      {\n         var prompt = "Enter " + (str=="assignpid")?"PID":"SID";\n         var field = (str=="assignpid")?"patients_id":"studies_id";\n         alertify.prompt(prompt, function(e,str)\n         {\n            for (var k = 0; k < tempObjectInfo.length;k++)\n              KViewer.dataManager.getFile(tempObjectInfo[k].fileID).fileinfo[field] = str;\n            KViewer.cacheManager.update();\n         } );\n\n      }\n      else if (str=="upload")\n      {\n        uploadFiles();\n      }\n      else if (str=="download")\n      {\n          for (var k = 0; k < tempObjectInfo.length;k++)\n             saveNiftilocal(KViewer.dataManager.getFile(tempObjectInfo[k].fileID));\n         \n      }\n      else if (str=="remove")\n      {\n         for (var k = 0; k < tempObjectInfo.length;k++)\n         {\t  \n            KViewer.dataManager.delFile(tempObjectInfo[k].fileID);\n            if (KViewer.roiTool.ROIs[tempObjectInfo[k].fileID])\n                delete  KViewer.roiTool.ROIs[tempObjectInfo[k].fileID];\n         }\t   \n         KViewer.cacheManager.update();\n         KViewer.roiTool.update();\n      }\n\n  }, true);\n\n\n // that.update();\n  return that;\n}\n\n\nfunction KFileEntry(filepath)\n{\n\treturn function ()\n\t {\n\t \ttry \n\t \t{\n\t\t\tvar stat = fs.statSync(filepath);\n\t \t}\n\t \tcatch(err)\n\t \t{\n\t \t\treturn {error:err};\n\t \t}\n\t\tif (stat.isDirectory())\n\t\t{\n\t\t   return { name: filepath, local:true ,isDir:true,\n\t\t\t createReader: function() {\n\t\t\t\treturn { readEntries: function (cb)\n\t\t\t\t{\n\t\t\t\t\tif (this.isread)\n\t\t\t\t\t\tcb([]);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tthis.isread = true;\n\t\t\t\t\t\tfs.readdir(filepath,function(err,files) { \n\t\t\t\t\t\t\tfor (var k = 0;k < files.length; k++)\n\t\t\t\t\t\t\t\tfiles[k] = KFileEntry(filepath + "/" + files[k])();\n\t\t\t\t\t\t\tcb(files); \n\n\t\t\t\t\t\t} );\n\t\t\t\t\t}\n\t\t\t\t}\n\n\n\t\t\t } } }\n\t\t}\n\t\telse \n\t\t   return { name: filepath, local:true };\n\t } \n}'},function(t,n){t.exports='\n   \n// ======================================================================================\n// ======================================================================================\n// ============= KAtlasTool\n// ======================================================================================\n// ======================================================================================\n\n\nfunction KAtlasTool(master)\n{\n  /** the atlas tool\n   * @class \n   * @alias KAtlasTool\n   * @augments KToolWindow\n   */\n  var that = new KToolWindow(master,\n  $("<div class=\'KView_tool \'><i class=\'fa fa-cubes fa-1x\'></i></div>")\n  .append( $("<ul ></ul>").append($("<li><a>Atlas</a></li>")) ) );\n  var fibertool = master.obj3dTool;\n\n  that.name = \'Atlas\';\n  that.point = master.currentPoint;\n  \n  that.$topRow.addClass("AtlasTool_topmenu")\n  \n  // the list of 3D objects as key/value pairs\n  that.objs = {};\n  var atlass = that.objs;\n\n  // the top menu\n  var $menu = $("<ul></ul>");\n  if (static_info != undefined) if (static_info.atlas != undefined)\n  {\n \t  var subfolder = {};\n\t  for (var k = 0; k < static_info.atlas.available.length;k++)\n\t  \tif (static_info.atlas.available[k].Tag.search("atlas")>-1)\n\t  \t{\n\t\t\tvar subname;\t  \t\t\n\t  \t\tif (static_info.atlas.available[k].SubFolder != "")\n\t  \t\t\tsubname = static_info.atlas.available[k].SubFolder;\n\t  \t    else\n\t  \t    \tsubname = \'root\';\n\t\t    if (subfolder[subname] == undefined)\n\t\t    \tsubfolder[subname] = [];\n\t\t    subfolder[subname].push(static_info.atlas.available[k]);\n\n\t  \t}\n\t  for (var subs in subfolder)\n\t  {\n\t  \tvar $menuhead = $("<li><a> <span>"+subs+" </span><i class=\'fa fa-caret-right\'></i></a></li>").appendTo($menu);\n    \tvar $submenu = $("<ul></ul>").appendTo($menuhead);\n    \t\t   \n\t    var items = subfolder[subs];\n\t    for (var k = 0; k < items.length;k++)\n\t    {\n\t      new function() {\n\t      \tvar item = items[k];\n\t\t\tif (item.Tag.search("atlas")>-1)\n\t\t\t{\n\t\t\t\tvar name = item.Filename.replace(".nii","");\n\t\t\t\tvar id = item.ID;\n\t\t\t\t$("<li><a>"+name+"</a></li>").click(function(){\n\t\t\t\t\tKViewer.dataManager.loadData({URLtype:\'serverfile\', fileID:id, json:{project:static_info.atlas.project},\n\t\t\t\t\t\t\tprogressSpinner:that.progressSpinner,\n\t\t\t\t\t\t\tcallback: function(fobj)\n\t\t\t\t\t\t\t\t{  \n\t\t\t\t\t\t\t\t   that.progressSpinner();\n\t\t\t\t\t\t\t\t   fobj.project = static_info.atlas.project;\n\t\t\t\t\t\t\t\t   that.addAtlas(fobj);\n\t\t\t\t\t\t\t\t   that.update();\n\t\t\t\t\t\t\t\t   KViewer.dataManager.setFile(fobj.fileID,fobj);\n\t\t\t\t\t\t\t\t   KViewer.cacheManager.update();\n\t\t\t\t\t\t\t\t}});\n\t\t\t\t\t}).appendTo($submenu);\n\t\t\t} } \n\t    }\n\t  }\n  }\n  that.$topRow.append( $("<li><a>Atlas</a></li>").append($menu) );\n\n  // that tool table \n  var $innerDIV = $("<div ondragover=\'event.preventDefault();\' class=\'annotation_tool_listDIV\'></div>").appendTo(that.$container);\n\n  var $table = $("<table  class=\'localfiletable\'></table>").appendTo($innerDIV);\n  $("<div><br></div>").appendTo($innerDIV);\n  var $deffield = $("<table  class=\'localfiletable\'></table>").appendTo($innerDIV);\n\n\n  \n  var colors = [[255,0,0],[0,255,0],[0,0,255],[255,255,0],[255,0,255],[0,255,255]];\n\n\n  function extendBySlicerTXT(fobj,dest)\n  {\n\t\tvar labels = {};\n\t\tvar data = fobj.content.split(/\\r?\\n/);\n\t\tfor (var j = 0; j < data.length;j++)\n\t\t{\n\t\t\tvar line = data[j].trim();\n\t\t\tif (line[0] == \'#\') continue;\n\t\t\tvar lab = $(line.split(/[ \\t]/)).not([""]);\n\t\t\tif (isNaN(parseInt(lab[0])))\n\t\t\t\tcontinue;\n\t\t    var col = [parseInt(lab[2]),parseInt(lab[3]),parseInt(lab[4])];\n\t\t    if (isNaN(col[0]) | isNaN(col[1]) | isNaN(col[2]))\n\t\t    \tcol = colors[Object.keys(that.objs).length%colors.length];\n\t\t\tlabels[lab[0]] = {key:parseInt(lab[0]), name: lab[1], color:  col};\n\n\t\t}\n\t\tdest.content.labels = labels;\n  }\n\n\n\n\n  // load atlas from drop into tool\n  function loadFromDrop(handler)\n  {\n  \treturn function(e)\n    {\n\t\te.preventDefault();\n\t\te.stopPropagation();\n\t\tvar params = getloadParamsFromDrop(e.originalEvent,undefined);\n\t\t/*if (params.length > 2)\n\t\t{\n  \t       loadingQueue.execQueue(params, function (fobjs) \n  \t       { \n\t\t\t  var fileObject =  cloneNifti(fobjs[0],"atlas1","uint16");\n\t\t\t  fileObject.fileID = "atlas111";\n\t\t\t  fileObject.filename += ".nii";\n\t\t\t  fileObject.fileinfo.Tag = "/atlas/";\n\t\t\t  var tot = fileObject.content.sizes[0]*fileObject.content.sizes[1]*fileObject.content.sizes[2]\n\t\t\t  for (var k = 0; k < fileObject.content.sizes;k++)\n\t\t\t  {\n\t\t\t  \t if (fobjs[0].content.data[k]>0)\n\t\t\t  \t \tfileObject.content.data[k] = 1;\n\t\t\t  \t else\n\t\t\t  \t \tfileObject.content.data[k] = 0;\n\n\t\t\t  }\n\n\n\t\t\t  KViewer.dataManager.setFile(fileObject.fileID,fileObject);\n\t\t\t  that.addAtlas(fileObject); \n\n  \t       } );\n\n\n\t\t}\n\t\telse */\n\t\tif (params.length == 2)\n\t\t{\n\t\t   var p1 = params[0].fileID;\n\t\t   var p2 = params[1].fileID;\n  \t       loadingQueue.execQueue(params, function () \n  \t       { \n  \t       \t\tp1 = master.dataManager.getFile(p1);\n  \t       \t\tp2 = master.dataManager.getFile(p2);\n\t\t\t\tif (p1.contentType == \'txt\' & p2.contentType == \'nii\')\n\t\t\t\t{\n\t\t\t\t\t that.addAtlas(p2); \n\t\t\t\t\t extendBySlicerTXT(p1,p2);\n\t\t\t\t\t that.update();\n\t\t\t\t}\n\t\t\t\telse if (p2.contentType == \'txt\' & p1.contentType == \'nii\')\n\t\t\t\t{\n\t\t\t\t\t that.addAtlas(p1); \n\t\t\t\t\t extendBySlicerTXT(p2,p1);\n\t\t\t\t\t that.update();\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t\talertify.error("Select a text and a nifti file for atlas drop");\n\t\t\n  \t       } );\n\n\t\t}\n\t\telse if (params.length > 0)\n\t\t{\n\t\t\tparams[0].progressSpinner = that.progressSpinner;\n\t\t\tparams[0].callback = function(imageStruct)\n\t\t\t{\n\t\t\t\thandler(imageStruct,e);\n\t\t\t\tthat.hideSpinner();\n\t\t\t}\n\t\t\tthat.progressSpinner("Retrieving Data");\n\t\t\tmaster.dataManager.loadData(params[0]);\n\t\t}\n  \t};\n  }\n\n\n\n  // resize handler\n  that.resize = function(hei)\n  {\n      that.$container.height(hei);\n      $innerDIV.height(hei-that.$container.find(\'.KToolsTopMenu\').height());\n      \n  }\n\n\n  /***************************************************************************************\n   *  object management\n   ****************************************************************************************/\n\n \n  that.addAtlas = function (fobj)\n  {\n       if (fobj.contentType == \'nii\')\n       {\n\t\t   if (!that.enabled)\n\t\t\t  that.show();\n\t\t   if (fobj.content.sizes[3] == 3 | fobj.content.sizes[4] == 3)\n\t\t   {\n\t\t\t  that.defField = fobj;\n\t\t   }\n\t\t   else\n\t\t   {\n\t\t   \t   if (that.objs[fobj.fileID] != undefined)\n\t\t\t\t\treturn that.objs[fobj.fileID];\n\t\t\t   that.objs[fobj.fileID] = fobj;\n\t\t\t   fobj.content.alpha = 0.7;\n\t\t\t   if ( fobj.content.extension != undefined &&  fobj.content.labels == undefined)\n\t\t\t   {\n\t\t\t\t   var labelshtml = fobj.content.extension.content.getElementsByTagName(\'Label\');\n\t\t\t\t   var labels = {};\n\t\t\t\t   for (var k = 0; k < labelshtml.length;k++)\n\t\t\t\t   {\n\t\t\t\t\t\tvar x = labelshtml[k];\n\t\t\t\t\t\tvar col = math.round([255*parseFloat(x.getAttribute(\'Red\')),255*parseFloat(x.getAttribute(\'Green\')),255*parseFloat(x.getAttribute(\'Blue\'))]);\n\t\t\t\t\t\tlabels[x.getAttribute(\'Key\')] =  { key:x.getAttribute(\'Key\'),name:x.textContent, color:col  };\n\t\t\t\t   }\n\t\t\t\t   fobj.content.labels = labels;\n\t\t\t   }\n\t\t\t   else if ((fobj.filename.search("\\\\.mgz") > -1 || fobj.filename.search("\\\\.mgh") > -1) &&  fobj.content.labels == undefined)\n\t\t\t   {\n\t\t\t   \t\tfobj.content.labels = static_info.FSLUT;\n\t\t\t   }\n\t\t\t   else\n\t\t\t   {\n\n\t\t\t   }\n\t\t\t   computeBBoxes(fobj.content);\n\t\t   }\n\t\t   signalhandler.send(\'positionChange\');\n       }\n\n       return fobj;\n  }\n \n  // drop handler \n  that.$container.on("drop",loadFromDrop(that.addAtlas));\n\n\n\n  that.clearAll = function ()\n  {\n      var obs = Object.keys(that.objs);\n      for (var k = 0; k< obs.length;k++)\n      \t\tdelete that.objs[obs[k]].content;\n      that.objs = {};\n      atlass = that.objs;\n\t  that.update();\n  }\n\n\n  /***************************************************************************************\n   *  table updater \n   ****************************************************************************************/\n\n  that.update = function()\n  {\n    $table.children().remove();\n    $deffield.children().remove();\n\n\n\n\tvar $wrap = $("<div>").appendTo($deffield);\n    var $row = $("<tr ><td> Template mapping (iy)</td></tr>").appendTo($wrap);\n    var $row = $("<tr ></tr>").appendTo($wrap);\n\tif (that.defField != undefined)\n\t{\n\t     $row.append($("<td> "+that.defField.filename +" </td>"));\n\n\t     that.$mnicoord = $("<td> </td>");\n\t\t var def = that.defField.content;\n\t\t var p = math.multiply(math.inv(def.edges),KViewer.currentPoint)._data;\t   \t  \n\t\t var str = [];\n\t\t var diag =math.diag([1,1,1,1])._data;\n\t\t for (var j=0;j<3;j++ )\n\t\t {\n\t\t \tvar tmp = trilinInterp(def,p[0],p[1],p[2],diag,def.sizes[0]*def.sizes[1]*def.sizes[2]*j);\n\t\t \tif (tmp != undefined)\n\t\t        str[j] = trilinInterp(def,p[0],p[1],p[2],diag,def.sizes[0]*def.sizes[1]*def.sizes[2]*j).toFixed(1);\n\t\t    else\n\t\t        str[j] = "?";\n\t\t }\n\t\t str = "(" + str.join(",") + ")";\n\t\t that.$mnicoord.text(str);\n\n\t     $row.append(that.$mnicoord);\n         $row.append($("<td> <i class=\'fa  fa-close\'></td>").click(function() { that.defField = undefined;  signalhandler.send(\'positionChange\'); } ));\n\t}\n\telse\t\n\t     $row.append($("<td> none </td>"));\n\n\n\n\tvar $thead = $("<thead>").appendTo($table);\n    var $row = $("<tr ></tr>").appendTo($thead);\n    $row.append($("<td class=\'fixedwidth\' fixedwidth=\'6\'><i class=\'fa fa-fw fa-square-o\'></i> </td>"));\n    $row.append($("<td>Atlas  </td>"));\n    $row.append($("<td class=\'fixedwidth\' fixedwidth=\'6\'>  </td>"));\n    $row.append($("<td class=\'fixedwidth\' fixedwidth=\'6\'>  </td>"));\n\t\t\n    if (Object.keys(that.objs).length == 0)\n    {\n    \t$table.append($("<span> select an atlas from menu or drop a custom one </span>"));\n    }\n\n\tvar $tbody = $("<tbody>").appendTo($table);\n    for  (var k in that.objs)\n    {\n\t   var id = that.objs[k].fileID;\n\n\t   \n       function drophandler(fobj,dropevent)\n       {\t\t\t\n\t\t\tif (fobj.contentType == \'txt\')\n\t\t\t{\n\t\t \t\textendBySlicerTXT(fobj,that.objs[k]);\n\t\t\t\tthat.update();\n\t\t\t}\n\t\t\telse\n\t\t\t\tthat.addAtlas(fobj);\n       }\n       var dragstuff = "draggable=\'true\' data-type=\'file\' data-mime=\'nii\' data-tag=\'/atlas/\' data-fileID=\'"+that.objs[k].fileID+"\' data-filename=\'"+that.objs[k].filename+"\' ";\n       dragstuff = dragstuff + " ondragstart=\'setdragstart(event);\' ondragend=\'setdragend(event);\' ondblclick=\'loadDataOndblClick(event);\'";\n\n\t   var nii = that.objs[k].content;\n\n       var $row = $("<tr " + dragstuff + "></tr>").appendTo($tbody).on("drop",loadFromDrop(drophandler));\n       $row.append($("<td><i class=\'fa fa-fw fa-square-o\'></i> </td>").click(function(e){ toggle_file(e.target); return false; }));      \n       $row.on("contextmenu", function (ev) { formContextMenu(ev); });\n       if (nii.labels != undefined)\n       \t\t$row.append($("<td >" + that.objs[k].filename + "</td>"));\n       else\n       \t\t$row.append($("<td >" + that.objs[k].filename + " (no label info) </td>"));\n       $row.append($("<td> <i class=\'tablebutton fa fa-fw fa-wrench\'></td>").click(function(k_) { return function() { \n\t\t   if (that.objs[k_].panel == undefined)\n\t\t\t\tthat.objs[k_].panel = KAtlasPanel(that.objs[k_]);\n\t\t\telse\n\t\t\t\tthat.objs[k_].panel.toggle();\n\t\t\t} }(k) ));\n       $row.append($("<td> <i class=\'tablebutton fa fa-fw fa-close\'></td>").click(function(k_) { return function() { delete that.objs[k_]; that.update(); } }(k) ));\n\n       var $row = $("<tr " + dragstuff + "></tr>").appendTo($table).on("drop",loadFromDrop(drophandler));\n\n\t   var key = 0;\n\t   var point = that.point;\n\n\t   if (that.defField != undefined)\n\t   {\n\t   \t   var ps = [0,0,0,1];\n\t   \t   var def = that.defField.content;\n \t       var p = math.multiply(math.inv(def.edges),point)._data;\t   \t  \n \t       var diag =math.diag([1,1,1,1])._data;\n\t\t   for (var j=0;j<3;j++ )\n               ps[j] = trilinInterp(def,p[0],p[1],p[2],diag,def.sizes[0]*def.sizes[1]*def.sizes[2]*j);\n           if (ps[0] != undefined & ps[0] != undefined & ps[0] != undefined)\n           {\n\t\t\t   ps =math.round(math.multiply(math.inv(nii.edges),ps)._data);\n\t\t\t   key = nii.data[nii.sizes[0]*nii.sizes[1]*ps[2] + ps[1]*nii.sizes[0] + ps[0]];\n           }\n\t   }\n\t   else\n\t   {\n  \t       var einv = math.inv(nii.edges);\n \t       var p = math.round(math.multiply(einv,point)._data);\n\t       if (p[0] != undefined & p[0] != undefined & p[0] != undefined)\n           {\n\t\t \t   key = nii.data[nii.sizes[0]*nii.sizes[1]*p[2] + p[1]*nii.sizes[0] + p[0]];\n           }\n\t   }\n\t   if (nii.labels != undefined)\t   \n\t   {\n\t\t   var label = nii.labels[key];\n\t\t   if (label != undefined)\n\t\t   {\n\t\t\t   $row.append($("<td style=\'background-color:"+RGB2HTML(label.color[0],label.color[1],label.color[2])+";\'  ></td>"));\n\t\t\t   $row.append($("<td > " + label.name + " (" + key + ")</td>"));\n\t\t\t   that.objs[k].currentLabel = nii.labels[key]; \n\t\t   }\n\t\t   else\n\t\t   {\n\t\t       $row.append($("<td></td>"));\n  \t\t       $row.append($("<td > key=" + key + " (undefined)</td>"));\n\t\t\t   that.objs[k].currentLabel =  {key:-1, name:"undefined", color:[255,0,0]};\t  \n\t\t   }\n\n\t   }\n\t   else\n\t   {\n\t\t   $row.append($("<td></td>"));\n\t\t   $row.append($("<td > key=" + key + "</td>"));\n\t\t   var idx = (parseInt(key)*32)%256;\n\t\t   var col = [KColormap.jet[0][idx],KColormap.jet[1][idx],KColormap.jet[2][idx]];\n\t\t   that.objs[k].currentLabel = {key:key, name:"key="+key, color:col};\t   \t   \n\t   }       \n\n\t   if (that.objs[k].panel)\n\t   {\n\t\t\tthat.objs[k].panel.setCurrentLabel( that.objs[k].currentLabel.key,true);\n\n\t   }\n\n    }     \n    that.attachTableOperator($table.parent());\n   \n  }\n\n  that.update();\n  that.updatePoint = function()\n  {\n\t\tthat.point = master.currentPoint;\n\t\tthat.update();\n\t\t\n\n  }\n\n  signalhandler.attach(\'positionChange\',function()\n  {\n\tif (master.crosshairMode)  \t\n  \t \tthat.updatePoint();\n  });\n  \n\n  function computeBBoxes(atlas_nii)\n  {\n      \tvar bboxes = {}\n        var max = [-100000, -100000, -100000];\n        var min = [100000, 100000, 100000];\n\n        var edges = atlas_nii.edges;\n        var e = edges._data;\n        var sz = atlas_nii.sizes;\n        for (var z = 0; z < sz[2]; z++)\n            for (var y = 0; y < sz[1]; y++)\n                for (var x = 0; x < sz[0]; x++)\n                {\n                \tvar key = atlas_nii.data[sz[0] * sz[1] * z + sz[0] * y + x];\n                    if (key > 0)\n                    {\n                    \tvar b = bboxes[key];\n                    \tif (b == undefined)\n                    \t{\n                    \t\tb = { max: [-100000, -100000, -100000],  min:[100000, 100000, 100000]};\n                    \t\tbboxes[key] = b;\n                    \t}\n                        //var p = math.multiply(edges, [x, y, z, 1]);\n                       \tvar X = e[0][0]*x + e[0][1]*y +e[0][2]*z + e[0][3];\n                       \tvar Y = e[1][0]*x + e[1][1]*y +e[1][2]*z + e[1][3];\n                       \tvar Z = e[2][0]*x + e[2][1]*y +e[2][2]*z + e[2][3];\n                        if (b.max[0] < X)\n                            b.max[0] = X;\n                        if (b.min[0] > X)\n                            b.min[0] = X;\n                        if (b.max[1] < Y)\n                            b.max[1] = Y;\n                        if (b.min[1] > Y)\n                            b.min[1] = Y;\n                        if (b.max[2] < Z)\n                            b.max[2] = Z;\n                        if (b.min[2] > Z)\n                            b.min[2] = Z;\n                    }\n                }\n\t\tif (atlas_nii.labels != undefined)\n\t\t\tfor (var k in atlas_nii.labels)\n\t\t\t{\n\t\t\t\tatlas_nii.labels[k].bbox = bboxes[k];\n\t\t\t}\n\t\telse\n\t\t{\n\t\t\tatlas_nii.labels = {};\n\t\t\tfor (var k in bboxes)\n\t\t\t{\n\t\t\t    var idx = (parseInt(k)*32)%256;\n\t\t\t    var col = [KColormap.jet[0][idx],KColormap.jet[1][idx],KColormap.jet[2][idx]];\n\t\t\t\t\n\t\t\t\tatlas_nii.labels[k] = {bbox:bboxes[k], key:k , name:"key="+k , color:col}\n\t\t\t}\n\n\t\t}\n\t\treturn;\n\n\n\n  }\n\n\n\n\n\n\n\t\tfunction ready4Clone(x,withbuffer)\n\t\t{\n\t\t\tif (x != undefined)\n\t\t\t{\n\t\t\t   var res = {data:x.data,\n\t\t\t\t\t\tsizes:x.sizes,\n\t\t\t\t\t\tedges:x.edges,\n\t\t\t\t\t\twid:x.wid,\n\t\t\t\t\t\twidhei:x.widhei,\n\t\t\t\t\t\twidheidep:x.widheidep,\n\t\t\t\t\t\tdetsign:x.detsign};\n\t\t\t   if (withbuffer)\n\t\t\t\t  res.buffer = x.buffer;\n\t\t\t   return res;\n\t\t\t}\n\t\t\telse\n\t\t\t\treturn undefined;\n\t\t}\n\n\n\n\n\t\tfunction renderROIfromLabel(obj,fobj,val,done)\n\t\t{\n\t\t\tif (val == undefined)\n\t\t\t\tval = 1;\n\t\t\telse if (Array.isArray(val))\n\t\t\t{\n\t\t\t\tvar labs = {};\n\t\t\t\tfor (var k = 0;k < val.length;k++)\n\t\t\t\t\tlabs[val[k]] = true;\n\t\t\t\tval = labs;\n\t\t\t}\n\n\t\t\tvar img = fobj.content;\n\n\n\t\t\tthat.progressSpinner("rendering volume");\n\n\t\t\tvar deffield;\n\t\t\tif (that.defField)\n\t\t\t{\n\t\t\t\tdeffield = that.defField.content;\n\t\t\t\tfobj.fileinfo.patients_id = that.defField.fileinfo.patients_id;\n\t\t\t\tfobj.fileinfo.studies_id = that.defField.fileinfo.studies_id;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif (typeof patientTableMirror != "undefined")\n\t\t\t\t{\n\t\t\t\t\tvar finfo = patientTableMirror.getCurrentUniquePSID();\n\t\t\t\t\tif (finfo != false)\n\t\t\t\t\t\tfobj.fileinfo = $.extend(fobj.fileinfo, finfo);\n\t\t\t\t\telse\n\t\t\t\t\t{\n\t\t\t\t\t\tfobj.fileinfo.patients_id =undefined;\n\t\t\t\t\t\tfobj.fileinfo.studies_id = undefined;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\texecuteImageWorker({func:\'atlasToRoi\', \n\t\t\t\t\t\t   atlas:ready4Clone(obj.content),\n\t\t\t\t\t\t   deffield:ready4Clone(deffield),\n\t\t\t\t\t\t   img:ready4Clone(img,true), key:val },[img.buffer],that.progressSpinner,\n\t\t\t\tfunction(e)\n\t\t\t\t{\n\t\t\t\t\tfobj.content = prepareMedicalImageData(parse(e.execObj.buffer), fobj);\n\t\t\t\t\tdone(fobj);\n\t\t\t\t\tKViewer.cacheManager.update();\n\t\t\t\t\tKViewer.roiTool.update();\n\t\t\t\t}\n\t\t\t\t);\n\t\t}\n\n\n\n\t\tfunction createISOfromLabel(atlas,label,ondone)\n\t\t{\n\n\n\t\t\t\t\tvar tmp_label = {name:label.name,key:label.key};\n\t\t\t\t\tif (that.defField != undefined)\n\t\t\t\t\t{\n\t\t\t\t\t\tthat.progressSpinner("rendering isosurface");\n\t\t\t\t\t\tvar tmp = cloneNifti(that.defField,\'tmp\',\'uint8\');\n\t\t\t\t\t\trenderROIfromLabel(atlas,tmp,parseInt(label.key),function()\n\t\t\t\t\t\t{\t\n\t\t\t\t\t\t\tKViewer.obj3dTool.createSurfaceFromAtlas(tmp, undefined, function(fobj)\n\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\tlabel.surfacereference = fobj;\n\t\t\t\t\t\t\t\tif (ondone) ondone(fobj) \n\t\t\t\t\t\t\t});\n\n\t\t\t\t\t\t});\n\t\t\t\t\t}\t\t\t\n\t\t\t\t\telse\n\t\t\t\t\t{\n\n\t\t\t\t\t\t\tif (label.surfacereference == undefined)\n\t\t\t\t\t\t\t\tKViewer.obj3dTool.createSurfaceFromAtlas(atlas, tmp_label ,function(fobj)\n\t\t\t\t\t\t\t\t{ \n\t\t\t\t\t\t\t\t\tlabel.surfacereference = tmp_label.surfacereference;\n\t\t\t\t\t\t\t\t\tif (ondone) ondone(fobj)\n\t\t\t\t\t\t\t\t });\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tif (ondone) ondone(label.surfacereference)\n\t\t\t\t\t}\t\t\t\t\t\n\n\t\t}\n\t\t\t\n\n\n\n\n\n\n\tthat.createISOfromLabel = createISOfromLabel;\n\tthat.renderROIfromLabel = renderROIfromLabel;\n\n\n\n\n\n\tthat.attachSurf= function(atlas,label,viewer) \n\t{ attachSurfaceRef(atlas,label,function()\n\t\t{\n\t\t\t loadSurfIntoViewport(label,viewer);\n\t\t}); \n\t}\n\n\n\n\tthat.attachSurfaceRef  = attachSurfaceRef;\n\tfunction attachSurfaceRef(atlas,label,cb)\n\t{\n\t\tcreateISOfromLabel(atlas,label, function(fobj) { \n\t\t\tlabel.surfacereference = fobj;\n\t\t\tfobj.atlasref = {atlas:atlas,label:label.key};\t\t\t\t\n\t\t\tif (cb)\n\t\t\t\tcb();\n\n\t\t});\n\t}\n\n\n\n\n\t\tfunction loadSurfIntoViewport(label,viewer)\n\t\t{\n\n\t\t\tif (viewer == undefined)\n\t\t\t{\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfunction append() {\n\t\t\t\tvar alreadyInVP = false;\n\t\t\t\tfor (var k = 0; k < viewer.objects3D.length; k++)\n\t\t\t\t\tif (label.surfacereference == viewer.objects3D[k].surf)\n\t\t\t\t\t{\n\t\t\t\t\t\talreadyInVP = true;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\tif (!alreadyInVP)\n\t\t\t\t{\n\t\t\t\t\tvar surfView = viewer.appendObject3D(label.surfacereference , {\n\t\t\t\t\t\tcolor:   label.color\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (!viewer.isGLenabled())\n\t\t\t\tviewer.toggle3D(undefined, append);\n\t\t\telse\n\t\t\t\tappend();\n\t\t}\n\n\n\n\n\n\n\tthat.getROIfromSinglelabel = function(atlas,key,name,bgndcontrast,callback,progress)\n\t{\n\t \t  var fid = "ROI_ATLAS_" + atlas.fileID + "_" +key;\n\t\t  var roi = KViewer.dataManager.getFile(fid);\n\t\t  if (roi != undefined)\n\t\t\tcallback(roi);\n\t\t  else\n\t\t  {\n\t\t\t\tbgndcontrast.intendedROIid = fid;\t                                         \t\n\t\t\t\tmaster.roiTool.pushROI(bgndcontrast.fileID,name,undefined,function(roi)\n\t\t\t\t{          \t\t\t  \t  \n\t\t\t\t\t progress("rendering ROI");\n\t\t\t\t\t renderROIfromLabel(atlas,roi,parseInt(key),function()\n\t\t\t\t\t {\n\t\t\t\t\t\t callback(roi);\n\t\t\t\t\t\t progress();\n\t\t\t\t\t });\n\n\t\t\t\t},progress);\n\t\t  }\n\t}\n\n\n\n  /***************************************************************************************\n  * create ATLAS subview\n  ***************************************************************************************/  \n\n  that.createView  = function(fobj,viewer,intent)\n\t{\n\t\tvar viewer = viewer;\n\t\tvar obj = { atlas:fobj,\n\t\t\t\t\tnii:fobj.content,\n\t\t            type:\'atlas\',\n\t\t\t\t\tcolor:0\t};\n\n\n\t   /***************************************************************************************\n\t\t* the subviews toolbar\n\t\t****************************************************************************************/  \n\t\tvar $captiondiv,$dragdiv,$createIso,$createOutlines;\n\t\tobj.divs = [ $("<br style=\'clear:both\' />"),\n\t\t\t\t\t $("<div  class=\'KViewPort_tool atlas persistent\'>  <i class=\'fa fa-close fa-1x\'></i></div>").click( close  ).mousedown(viewer.viewport.closeContextMenu(obj)),\n\t\t\t\t\t $createIso = $("<div  class=\'KViewPort_tool atlas\'>  <i class=\'fa fa-1x\'><span>3D</span></i></div>").appendTooltip("isosurfatlas"),\n                     $createOutlines = $("<div  class=\'KViewPort_tool atlas\'>  <i class=\'fa fa-1x\'><span>outline</span></i></div>").appendTooltip("isosurfatlas").hide(),\n                     $("<div  class=\'KViewPort_tool atlas\'>  <i class=\'fa fa-pencil fa-1x\'> </div>")\n          \t\t\t .click(function(viewer) { return function() { \n\n\t\t\t\t\t\tthat.getROIfromSinglelabel(obj.atlas,obj.atlas.currentLabel.key,obj.atlas.currentLabel.name,viewer.content,\n\t\t\t\t\t\t\t\tfunction(roi) { viewer.viewport.setContent(roi,{}) },viewer.viewport.progressSpinner);\n\n\n          \t\t\t   }}(viewer)),\n  \t\t\t\t\t $captiondiv = $("<div  class=\'KViewPort_tool atlas caption\' contenteditable=\'true\'> "+obj.atlas.filename+"</div>"),\n\t\t\t\t\t $dragdiv = $("<div  class=\'KViewPort_tool draganddrop\'>  <i class=\'fa fa-hand-paper-o fa-1x\'></i></div>")\n\t\t\t\t   ];\n\n\n\t\t$dragdiv.attr("draggable",\'true\');\n\t\t$dragdiv.on("dragstart", dragstarter({ type:\'file\', tag: \'/mask/\', mime: \'nii\', filename: obj.atlas.filename, intent:\'atlas:true\', close:close,fileID: obj.atlas.fileID }));\n\n\t\tviewer.toolbar.append(obj.divs,\'atlas\');\n\n\t\tfunction update()\n\t\t{\t\n\t\t\tif (obj.atlas.currentLabel != undefined)\n\t\t\t\t$captiondiv.text(obj.atlas.currentLabel.name); \t\t\t\n\t\t}\n        obj.updateid = signalhandler.attach(\'labelChange\',update);\n        obj.updateid = signalhandler.attach(\'positionChange\',update);\n\n\n\t\t$createOutlines.click(function(ev) {\n\t\t\tif (obj.outlines == undefined)\n\t\t\t\tobj.outlines = Outlines(obj)\n\t\t\tobj.outlines.update(viewer);\n\n\t\t});\n\n\n\n\n        if(state.viewer.showOutlines)\n            obj.outlines = Outlines(obj);\n\n        $createIso.click(function(ev) {\n\n\n\t\t\tvar keys = [];\n\t\t\tif (obj.atlas.panel)\n\t\t\t\tkeys = Object.keys(obj.atlas.panel.persistentLabels);\n\n\t\t\tif (keys.length == 0)\n\t\t\t{\n\t\t\t\tif (obj.atlas.currentLabel.surfacereference != undefined)\n\t\t\t\t{\n\t\t\t\t\t loadSurfIntoViewport(obj.atlas.currentLabel,viewer);\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tattachSurfaceRef(obj.atlas,obj.atlas.currentLabel,function()\n\t\t\t\t\t{\n\t\t\t\t\t\t loadSurfIntoViewport(obj.atlas.currentLabel,viewer);\n\t\t\t\t\t});\n\t\t\t\t\t/*\n\t\t\t\t\tcreateISOfromLabel(obj.atlas,obj.atlas.currentLabel, function(fobj) { \n\t\t\t\t\t\tobj.atlas.currentLabel.surfacereference = fobj;\n\t\t\t\t\t\tfobj.atlasref = {atlas:obj.atlas,label:obj.atlas.currentLabel};\n\t\t\t\t\t\tloadSurfIntoViewport(obj.atlas.currentLabel) \n\n\t\t\t\t\t});*/\n\t\t\t\t}\n\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\n\t\t\t\tcreateISO(0);\n\t\t\t\tfunction createISO(k)\n\t\t\t\t{\n\t\t\t\t\tif (k >= keys.length)\n\t\t\t\t\t\treturn;\n\t\t\t\t\telse\n\n\t\t\t\t\t{\n\t\t\t\t\t\tattachSurfaceRef(obj.atlas,obj.atlas.content.labels[keys[k]],function()\n\t\t\t\t\t\t{\n\t\t\t\t\t\t  loadSurfIntoViewport(obj.atlas.content.labels[keys[k]],viewer);\n\t\t\t\t\t\t  createISO(k+1); \t\t\t\t\t\t\t\n\t\t\t\t\t\t});\n/*\t\t\t\t\t\tKViewer.atlasTool.createISOfromLabel(obj.atlas, obj.atlas.content.labels[keys[k]], function(){  \n\t\t\t\t\t\t  loadSurfIntoViewport(obj.atlas.content.labels[keys[k]]);\n\t\t\t\t\t\t  createISO(k+1); \n\t\t\t\t\t\t  });*/\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t}\n\n\n\n\n\n        });\n\n\n\t\tthat.computeIsoSurf2 = function(fobj,label,progress,done)\n\t\t{\n\t\t\tprogress("creating isosurface");\n\n\t\t\texecuteImageWorker({func:\'createISOSurf\', \n\t\t\t\t\tdata:fobj.content.nifti.data,\n\t\t\t\t\tsizes:fobj.content.nifti.sizes,\n\t\t\t\t\tedges:fobj.content.nifti.edges,\n\t\t\t\t\tdetsign:fobj.content.nifti.detsign,\n\t\t\t\t\tlabel:{name:label.name,key:label.key,color:label.color,bbox:label.bbox}\n\n\t\t\t},[],\n\t\t\t\tfunction(e)\n\t\t\t\t{\n\t\t\t\t\tif (progress)\n\t\t\t\t\t\tprogress(e);\n\t\t\t\t}\n\t\t\t\t,\n\t\t\t\tfunction(e)\n\t\t\t\t{\n\t\t\t\t\tif (progress)\n\t\t\t\t\t\tprogress(); \n\t\t\t\t\t$.extend(fobj.content,e.execObj);\n\n\t\t\t\t\tdone(fobj);\n\n\t\t\t\t}\n\t\t\t\t);\n\n\n\t\t}\n\n\n\n\n\t\tfunction updateGetPixelFunction(nii,R)\n\t\t{\n\n  \t\t\t var Labels = {} ;\n\t\t\t if (obj.atlas.panel)\n\t\t\t  \t Labels = $.extend(false,Labels,obj.atlas.panel.persistentLabels);\n\t\t\t if (obj.atlas.currentLabel)\n\t\t\t\t if (obj.atlas.currentLabel.key != "0")\n\t\t\t\t \tLabels[obj.atlas.currentLabel.key] = obj.atlas.currentLabel;\n\n\n\t\t\tif (Object.keys(Labels).length == 0)\n\t\t\t\tobj.getPixel = function () { return [0,0,0,0];}\n\t\t\telse\n\t\t\t{\n\t \t\t\tif (that.defField != undefined)\n\t \t\t\t\tobj.getPixel = KAtlasTool.updateGetPixelFun(obj.atlas.content,nii,Labels,R,that.defField.content);\n\t \t\t\telse\n\t \t\t\t\tobj.getPixel = KAtlasTool.updateGetPixelFun(obj.atlas.content,nii,Labels,R);\n\t\t\t}\n\t \t\treturn obj.getPixel ;\n\t\t}\n\n\n        obj.updateGetPixelFunction = updateGetPixelFunction;\n\n\t   /***************************************************************************************\n\t\t* close the view\n\t\t****************************************************************************************/  \n\t\tfunction close()\n\t\t {             \t  \n\t\t      signalhandler.detach(\'positionChange\',obj.updateid);\n\n\t\t\t  for (var k = 0; k< obj.divs.length;k++)\n\t\t\t\t obj.divs[k].remove();\n\n\t\t\t  for (var k = 0; k < viewer.atlas.length;k++)\n\t\t\t  {\n\t\t\t\tif (obj == viewer.atlas[k])\n\t\t\t\t{\n\t\t\t\t\tviewer.atlas.splice(k,1);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t  }\t\t\t\n\n\t\t\t  if (obj.surfacecolref)\n\t\t\t  {\n\t\t\t  \t\tfor (var k = 0; k < obj.surfacecolref.overlays.length;k++)\n\t\t\t  \t\t{\n\t\t\t  \t\t\t if (obj.surfacecolref.overlays[k] == obj)\n\t\t\t  \t\t\t {\n\t\t\t  \t\t\t \tobj.surfacecolref.overlays.splice(k,1);\n\t\t\t  \t\t\t \tobj.surfacecolref.update();\n\t\t\t  \t\t\t \tbreak;\n\t\t\t  \t\t\t }\n\t\t\t  \t\t}\n\t\t\t  }\n\n\t\t\t  \n\t\t      if (obj.outlines != undefined)\n\t\t\t\t{\n\t\t\t\t\tobj.outlines.close();\n\t\t\t\t\tobj.outlines = undefined;\n\t\t\t\t}\n\n\n\n\n\n\t\t\t  viewer.drawSlice({mosaicdraw:true});\t\n\t\t }\n\t\t obj.close = close;\n\t\t signalhandler.attach("close",close);\n\t\n\t \t if (intent!=undefined & intent.hasPanel != undefined & obj.atlas.panel == undefined)\n\t\t\tobj.atlas.panel = KAtlasPanel(obj.atlas,intent.hasPanel );\n\n\t\t return obj;\n\t}\n\n\n\n\n\n\n\n\n\n    $menu.append($("<li><a>Statistics</a> </i></li>").click(function() {\n         that.statdlg.toggle();\n         that.statdlg.dostats(); }\n    ));\n   \n    that.statdlg = new statistics_dialog();\n\n\n  /***************************************************************************************\n   * statistics dialog\n   ****************************************************************************************/  \n\n\n\n\n \tthat.computeStats = computeStats;\n\tfunction computeStats(atlasobject,img,map)\n\t{\n\t\t  var m = 0;\n\t\t  var m2 = 0;\n\t\t  var cnt = 0;\n\t\t  var atl  = atlasobject.content;\n\t\t  var w = atl.sizes[0];\n\t\t  var wh = atl.sizes[0]*atl.sizes[1];\n\n\t\t  if (map == undefined)\n\t\t  \t map = function(x) {return x;}\n\n\t\t  var stats = {};\n\n\n\t\t  var getPixel = KAtlasTool.updateGetPixelFun(atl,img);\n\n\t\t  for (var z = 0; z < img.sizes[2];z++)\n\t\t\tfor (var y = 0; y < img.sizes[1];y++)\n\t\t\t  for (var x = 0; x < img.sizes[0];x++)\n\t\t\t  {\n\t\t\t\t\tvar lab = getPixel(x,y,z);\n\t\t\t\t\tif (lab > 0)\n\t\t\t\t\t{\n\t\t\t\t\t\tif (stats[lab] == undefined)\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tstats[lab] = {m:0,m2:0,cnt:0};\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar v = img.data[x+img.sizes[0]*y + img.sizes[0]*img.sizes[1]*z];\n\n\t\t\t\t\t\tif (!isNaN(v))\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tv = map(v);\n\t\t\t\t\t\t\tstats[lab].m += v;\n\t\t\t\t\t\t\tstats[lab].m2 += v*v;\n\t\t\t\t\t\t\tstats[lab].cnt++;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t  }         \n\n\t\t var labels = Object.keys(stats);\n\t\t for (var k = 0; k < labels.length;k++)\n\t\t {   var s = stats[labels[k]];\n\n\t\t\t s.mean = s.m/s.cnt;\n\t\t\t s.quad = s.m2/s.cnt;\n\t\t\t s.std =  math.sqrt(s.quad- s.mean*s.mean);\n\t\t\t s.vol_mm = img.voxSize[0]*img.voxSize[1]*img.voxSize[2]*s.cnt;\n\t\t\t s.label = atl.labels[labels[k]];\n\t\t }\n\n\n\n\t\t return stats;\n\t}\n\n\n\n\n\n\n\n\n    function statistics_dialog()\n    {\n        var that = new dialog_generic();\n        that.$frame.hide();\n        $("<li><a>Atlas statistics</a></li>").appendTo(that.$menu)\n//              .append( $("<ul></ul>") .append($("<li>Send kill signal</li>").click( ))\n//                                      .append($("<li>Clear errorenous jobs</li>").click(  ) )\n//                      );\n        $("<li><a> <i class=\'fa fa-refresh\'></i> </a>  </li>").click(dostats  ).appendTo(that.$menu);\n\n        //that.$container.append($("<div id=\'roistatsdialog\'></div>"));\n\n\n\t\tfunction dostats(which)\n\t\t{\n     \t   $(document.body).addClass("wait");\n     \t   setTimeout(function()\n     \t   {\n     \t   \t dostats_(which);\n     \t     $(document.body).removeClass("wait");\n     \t   },100);\n\t\t}\n\n\t\n        function dostats_(which)\n        {\n\n\n           var _imgs = {};\n           for (var k = 0; k< KViewer.viewports.length;k++)\n               if (KViewer.viewports[k] != undefined && KViewer.viewports[k].medViewer != undefined && KViewer.viewports[k].medViewer.nii != undefined)\n               {\n                  var v = KViewer.viewports[k].getCurrentViewer();\n                  _imgs[v.currentFileID] = KViewer.viewports[k].getCurrentViewer();\n\n               }\n\n           var ats = Object.keys(atlass);\n           var imgs = Object.keys(_imgs);\n\n\t\t\t\n\t\t   that.$container.find(".KRoistat").remove();\n\n\n           for (var k = 0; k < ats.length; k++)\n           {\n                \n                var atl = atlass[ats[k]];\n                var $sdiv = $("<div class=\'KRoistat\'> <h2>"+atl.filename+"</h2></div>").appendTo(that.$container);\n\t\t\t\t\n\t\t\t\tvar r = atl.content;\n\t\t\t\tvar totsz = r.sizes[0]*r.sizes[1]*r.sizes[2];\t\t\t\t\t\n\t\t\t\n\t\t\t\tvar $idiv = $("<div class=\'KRoistat_sub\'> </div>").appendTo($sdiv);\n\n                for (var j=0;j< imgs.length;j++)\n                {\n\t\t\t\t\t    $("<h3>" + _imgs[imgs[j]].currentFilename + "</h3>").appendTo($idiv);\t\t\t\n\n\t\t\t\t\t    var $div = $("<div class=\'KViewPort_tableViewer_outerDiv\'>").appendTo($idiv);\n\t\t\t\t\t    var $table =  $("<table class=\'KViewPort_tableViewer\' ></table>").appendTo($div);\n\t\t\t\t\t\tvar $head = $("<thead>")\n\t\t\t\t\t\tvar $body = $("<tbody>")\n\n\t\t\t\t\t\tvar $row = $("<tr ></tr>");\n\t\t\t\t\t\t$row.appendTo($head);\n\t\t\t\t\t\tvar $span = $("<span> Name </span>");\n\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\n\t\t\t\t\t\tvar $span = $("<span> Size (mm) </span>");\n\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\n\t\t\t\t\t\tvar $span = $("<span> mean </span>");\n\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\n\t\t\t\t\t\tvar $span = $("<span> stdev </span>");\n\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\n\t\t\t\t\t\tvar $span = $("<span> z </span>");\n\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\n\n\n\n\t\t\t\t\t\tvar stats = computeStats(atl,_imgs[imgs[j]].nii);\n\t\t\t\t\t\tvar scale = _imgs[imgs[j]].nii.datascaling.e;\n\t\t\t\t\t\tvar keys = Object.keys(stats);\n\t\t\t\t\t\tfor (var k = 0; k <keys.length;k++)\n\t\t\t\t\t\t{\n\n\n\t\t\t\t\t\t\tvar $row = $("<tr ></tr>");\n\t\t\t\t\t\t\t$row.appendTo($body);\n\n\n\t\t\t\t\t\t\tvar s = stats[keys[k]];\n\n\t\t\t\t\t\t\tvar $span = $("<span> "+ s.label.name+"</span>");\n\t\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\t    \n\t\t\t\t\t\t\tvar $span = $("<span> "+ niceFormatNumber(s.cnt*r.voxSize[0]*r.voxSize[1]*r.voxSize[2]) +"</span>");\n\t\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\t    \n\t\t\t\t\t\t\tvar $span = $("<span> "+ niceFormatNumber(s.mean) + " / " + niceFormatNumber(scale(s.mean)) +"</span>");\n\t\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\t    \n\t\t\t\t\t\t\tvar $span = $("<span> "+  niceFormatNumber(s.std) + " / " + niceFormatNumber(scale(s.std))+"</span>");\n\t\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\t    \n\t\t\t\t\t\t\tvar $span = $("<span> "+  niceFormatNumber(s.std/s.mean) +"</span>");\n\t\t\t\t\t\t\t$row.append($("<td></td>").append($span));\t\t    \n\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t$table.append($head);\n\t\t\t\t\t\t$table.append($body);\n\t\t\t\t\t\tattachTableOperator($div,undefined,true);\t\n\t\t\t\t\t\t$table.show();\n\t\t\t\t     \n\n                }\n           }\n\n        }\n        that.dostats = dostats;\n\n        return that;\n    }\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n  \n    return that;\n}\n\n\nKAtlasTool.isAtlas = function(fobj)\n{\n\tif (fobj.content.extension != undefined)\n\t{\n\t\tif (fobj.content.extension.content.contentType == "application/xml" | fobj.content.extension.content.contentType ==  "text/xml")\n\t\t{\n\t\t\tif (fobj.content.extension.content.getElementsByTagName(\'Label\').length > 0)\n\t\t\t\treturn true;\n\t\t}\n\n\t}\n\n\tif (fobj.fileinfo && fobj.fileinfo.Tag && fobj.fileinfo.Tag.search("/atlas/")>-1)\n\t\treturn true;\n\n\treturn false;\n}\n\n\n\n\n\nKAtlasTool.updateGetPixelFun = function(atlas_nii,nii,Labels,R,def,fromWorld)\n  {\n\n\t\t var edges;\n\t\t if (fromWorld)\n\t\t \tedges = math.diag([1,1,1,1]);\n\t\t else\n\t\t\tedges = nii.edges;\n\n\t\n\t\t if (def != undefined)\n\t\t  {\n\t\t\t   var A;\n\t\t\t   if (def.invedges == undefined)\n\t\t\t   \t\tdef.invedges = math.inv(def.edges);\n\n\t\t\t   if (R == undefined)\n\t\t\t\t   A = ( math.multiply(def.invedges, edges ) )._data;\n\t\t\t   else\n\t\t\t\t   A = (math.multiply(math.multiply( math.multiply(def.invedges, master.reorientationMatrix.matrix), edges ),R) )._data;\n\t\t\t\n\t\t\t   var B;\n\t\t\t   if (atlas_nii.invedges)\t\t\t   \n\t\t\t\t   B = atlas_nii.invedges;\n\t\t\t   else\n\t\t\t   \t   B = math.inv(atlas_nii.edges)._data;\n\t\t\t   if (Labels == undefined)\n\t\t\t   {\n\t\t\t\t   return function(px,py,pz)\n\t\t\t\t   {\n\t\t\t\t\t  var ps = [0,0,0,1];\n\t\t\t\t\t  for (var j=0;j<3;j++ )\n\t\t\t\t\t\t ps[j] = trilinInterp(def,px,py,pz,A,def.sizes[0]*def.sizes[1]*def.sizes[2]*j); \n\t\t\t\t\t  return NNInterp(atlas_nii,ps[0],ps[1],ps[2],B,0); \n\t\t\t\t   }  \t\n\t\t\t   }\n\t\t\t   else if (Object.keys(Labels).length > 0)\n\t\t\t   {\n\t\t\t\t   \n\t\t\t\t   return function(px,py,pz)\n\t\t\t\t   {\n\t\t\t\t\t  var ps = [0,0,0,1];\n\t\t\t\t\t  for (var j=0;j<3;j++ )\n\t\t\t\t\t\t ps[j] = trilinInterp(def,px,py,pz,A,def.sizes[0]*def.sizes[1]*def.sizes[2]*j); \n\t\t\t\t\t  //return trilinInterp_MAP(atlas_nii,ps[0],ps[1],ps[2],B,0,label); \n\t\t\t\t\t  return trilinInterp_atlas(atlas_nii,ps[0],ps[1],ps[2],B,0,Labels);     \n\t\t\t\t   }\n\t\t\t   }\n\t\t\t   else\n\t\t\t\t  return function(px,py,pz)\n\t\t\t\t  {\n\t\t\t\t\t return [0,0,0,0];\n\t\t\t\t  }\n\n\t\t  }\n\t\t  else\n\t\t  {\n\t\t\t  var A;\n\t\t\t  if (R == undefined)\n\t\t\t\t  A = ( math.multiply(math.inv(atlas_nii.edges), edges ) )._data;\n\t\t\t  else\n\t\t\t\t  A = (math.multiply(math.multiply( math.multiply(math.inv(atlas_nii.edges), KViewer.reorientationMatrix.matrix), edges ),R) )._data;\n\t\t\t\n\n\n\t\t\t  if (Labels == undefined)\n\t\t\t  {\n\t\t\t  \t return function(px,py,pz)\n\t\t\t\t  {\n\n                     return NNInterp(atlas_nii,px,py,pz,A,0);     \n    \t\t\t\t        \n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  else if (typeof Labels == "number")\n\t\t\t  {\n\t\t\t  \t return function(px,py,pz)\n\t\t\t\t  {\n\n                      return trilinInterp_MAP(atlas_nii,px,py,pz,A,0,Labels);     \n    \t\t\t\t        \n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  else if (Object.keys(Labels).length > 0)\n\t\t\t  {\n\t\t\t\t  return function(px,py,pz)\n\t\t\t\t  {\n\n                     return trilinInterp_atlas(atlas_nii,px,py,pz,A,0,Labels);     \n    \t\t\t\t        \n\t\t\t\t  }\n\t\t\t  }\n\t\t\t  else\n\t\t\t\t  return function(px,py,pz)\n\t\t\t\t  {\n\t\t\t\t\t return [0,0,0,0];\n\t\t\t\t  }\n\n\t\t  }\n\t}\n\n\n\n\n\n\n\n\nfunction KAtlasPanel(atlas,state)\n{\n\n    var panel = KPanel($(document.body),atlas.filename,"Atlas: " + atlas.filename.replace(".nii","").replace(".gz",""));\n \tpanel.closeOnCloseAll = true\n \tpanel.persistentLabels={};\n\n\tpanel.getState = function()\n\t{\n\t\treturn {persistentLabels:panel.persistentLabels};\n\t}\n\n\t\n\n    //////// compute centroids\n\tvar hasCentroids = false;\n \tfor (var k in atlas.content.labels)\n    {\n    \tvar label =  atlas.content.labels[k];\n    \tif (label.centroid)\n    \t{\n    \t\thasCentroids = true\n    \t\tbreak;\n    \t}\n    }\n\tif (!hasCentroids)\n\t{\n\t\tvar nii = atlas.content;\n\t\tfor (var z = 0; z < nii.sizes[2]; z++)\n\t\tfor (var y = 0; y < nii.sizes[1]; y++)\n\t\tfor (var x = 0; x < nii.wid; x++)\n\t\t{\n\t\t\tvar l = nii.data[x+nii.wid*y+nii.widhei*z];\n\t\t\tif (nii.labels[l])\n\t\t\t{\n\t\t\t\tif (nii.labels[l].centroid == undefined)\n\t\t\t\t{\n\t\t\t\t\tnii.labels[l].centroid = [0,0,0];\n\t\t\t\t\tnii.labels[l].firstvoxel = [x,y,z];\n\t\t\t\t\tnii.labels[l].size = 0;\n\t\t\t\t}\n\t\t\t\tnii.labels[l].centroid[0] += x;\n\t\t\t\tnii.labels[l].centroid[1] += y;\n\t\t\t\tnii.labels[l].centroid[2] += z;\n\t\t\t\tnii.labels[l].size++;\n\t\t\t}\n\t\t}\n\n\t\tfor (var x in nii.labels)\n\t\t{\n\t\t\tif (nii.labels[x].centroid  != undefined)\n\t\t\t{\n\t\t\t\tnii.labels[x].centroid[0] = Math.round(nii.labels[x].centroid[0]/nii.labels[x].size);\n\t\t\t\tnii.labels[x].centroid[1] = Math.round(nii.labels[x].centroid[1]/nii.labels[x].size);\n\t\t\t\tnii.labels[x].centroid[2] = Math.round(nii.labels[x].centroid[2]/nii.labels[x].size);\n\n\t\t\t\tif  (nii.data[nii.labels[x].centroid[0]+nii.wid*nii.labels[x].centroid[1]+nii.widhei*nii.labels[x].centroid[2]] != x)\n\t\t\t\t\tnii.labels[x].centroid = nii.labels[x].firstvoxel;\n\t\t\t\t\n\t\t\t\tnii.labels[x].centroid  = math.multiply(nii.edges,\t\t\n\t\t\t\t\t\t[nii.labels[x].centroid[0],nii.labels[x].centroid[1],nii.labels[x].centroid[2],1])._data;\n\t\t\t\tnii.labels[x].size = nii.labels[x].size*nii.voxSize[0]*nii.voxSize[1]*nii.voxSize[2];\n\t\t\t}\n\t\t\telse\n\t\t\t\tdelete nii.labels[x];\n\t\t}\n\n\t}\n\n\n\n\tpanel.setPersistent = function (labels)\n\t{\t\t\n\t\t\tpanel.persistentLabels = {};\n\t\t\tfor (x in labels)\n\t\t\t\tpanel.persistentLabels[x] = atlas.content.labels[x];\n\t\t\tupdatePersistentLabels(false);\n//\t\t\tsignalhandler.send(\'positionChange\');\n\t    \tsignalhandler.send("updateImage",{id:atlas.fileID});\n\t}\n\n    var $fileRow = $("<div class=\'roiTool_panel_flex_persistent\'></div>").appendTo(panel.$container);\n    var $showAll = $("<a class=\'KViewPort_tool\'><span> Show all </span></a>").appendTooltip("show all regions permanently").click(\n\t\tfunction(e)\n\t\t{\n\t\t\tpanel.persistentLabels = {};\n\t\t\t$body.find("tr:visible").map(function() { var key = $(this).attr("value"); panel.persistentLabels[key] = atlas.content.labels[key]; });\n\t\t\tupdatePersistentLabels(false);\n\t\t\tatlas;\n//\t    \tsignalhandler.send(\'positionChange\');\n\t    \tsignalhandler.send("updateImage",{id:atlas.fileID});\n\t\t}\n    )\n    $fileRow.append($showAll).append($("<i class=\'flexspacer\'></i>"));\n    var $hideAll = $("<a class=\'KViewPort_tool\'><span> Hide all </span></a>").appendTooltip("hide all regions").click(\n\t\tfunction(e)\n\t\t{\n\t\t\tpanel.persistentLabels = {};\n\t\t\tupdatePersistentLabels(false);\n//\t\t    \tsignalhandler.send(\'positionChange\');\n\t    \tsignalhandler.send("updateImage",{id:atlas.fileID});\n\t\t}\n    )\n    $fileRow.append($hideAll).append($("<i class=\'flexspacer\'></i>"));\n/*\n    var $showISO = $("<a class=\'KViewPort_tool\'><span> 3D </span></a>").appendTooltip("show3d").click(\n\t\tfunction(e)\n\t\t{\n\t\t\t\n\t\t\tvar keys = Object.keys(panel.persistentLabels);\n\t\t\tcreateISO(0);\n\t\t\tfunction createISO(k)\n\t\t\t{\n\t\t\t\tif (k >= keys.length)\n\t\t\t\t\treturn;\n\t\t\t\telse\n\t\t\t\t\tKViewer.atlasTool.createISOfromLabel(atlas.content.labels[keys[k]], function(){    createISO(k+1); });\n\t\t\t}\n\t\t}\n    )\n    $fileRow.append($showISO).append($("<i class=\'flexspacer\'></i>"));*/\n    var $toROI = $("<a class=\'KViewPort_tool\'><span> toROI </span></a>").appendTooltip("toroi").click(\n\t\tfunction(e)\n\t\t{\n\t\t\t var fileID = atlas.fileID;\n\t\t\t //if (KViewer.atlasTool.defField)\n\t\t\t //\tfileID = KViewer.atlasTool.defField.fileID;\n\n\t\t\t var labels;\n\t\t\t var name;\n\t\t\t if (Object.keys(panel.persistentLabels).length > 0)\n\t\t\t {\n\t\t\t \tname = "collection";\n\t\t\t \tlabels = Object.keys(panel.persistentLabels);\n\t\t\t \tif (labels.length ==1)\n\t\t\t \t\tname = atlas.content.labels[labels[0]].name;\n\t\t\t }\n\t\t\t else\n\t\t\t {\n\t\t\t \tname = atlas.content.labels[panel.currentLabel].name;\n\t\t\t \tlabels = [panel.currentLabel];\n\t\t\t }\n\n\n\n\t\t\t KViewer.roiTool.pushROI(fileID,name,undefined,function(roi)\n\t\t\t\t  {          \t\t\t  \t  \n\t\t\t\t\t panel.progressSpinner("rendering ROI");\n\n\t\t\t\t\t KViewer.atlasTool.renderROIfromLabel(atlas,roi,labels,function()\n\t\t\t\t\t {\n\t\t\t\t\t\t if (!KViewer.roiTool.enabled)\n\t\t\t\t\t\t    KViewer.roiTool.toggle();\n\t\t\t\t\t\t panel.progressSpinner();\n\t\t\t\t\t });\n\n\t\t\t\t\t},panel.progressSpinner);\n\n\n\n\t\t}\n    )\n    $fileRow.append($toROI).append($("<i class=\'flexspacer\'></i>"));\n\n    var $stats = $("<a class=\'KViewPort_tool\'><span> Stats </span></a>").appendTooltip("compute statistics over contrasts").click(function(){ \n    \t KViewer.atlasTool.statdlg.toggle();\n         KViewer.atlasTool.statdlg.dostats();})\n    $fileRow.append($stats).append($("<i class=\'flexspacer\'></i>"));\n \n    var $alpha = $("<a class=\'KViewPort_tool\'><span> alpha </span> <input style=\'height:15px;width:40px\' min=0.1 max=1 step=0.1 type=\'number\' value=\'"+atlas.content.alpha+"\'> </a>")\n    $fileRow.append($alpha).append($("<i class=\'flexspacer\'></i>"));\n\tvar $input = $alpha.find("input");\n\t$input.on("change",function(){\n\t\tatlas.content.alpha = parseFloat($input.val())\n\t\tsignalhandler.send("positionChange");\n\t});\n\n\n    var $div = $("<div class=\'atlaslabeltable  KViewPort_tableViewer_outerDiv\'>").appendTo(panel.$container);\n\tvar $table =  $("<table class=\'KViewPort_tableViewer\' ></table>").appendTo($div);\n\tvar $head = $("<thead class=\'atlaslabelhead\'>")\n\tvar $body = $("<tbody>")\n\n\tvar $row = $("<tr ></tr>");\n\t$row.appendTo($head);\n    $row.append($("<td class=\'fixedwidth\' fixedwidth=\'6\'><i class=\'fa fa-fw \'></i> </td>"));\n\tvar $span = $("<input class=\'KSearchHTML\'> </input>");\n\t$row.append($("<td ></td>").append($span));\t\n\t$row.append($("<td ></td>"));\t\n\n\tvar $row = $("<tr ></tr>");\n\t$row.appendTo($head);\n    $row.append($("<td class=\'fixedwidth\' fixedwidth=\'6\'><i class=\'fa fa-fw \'></i> </td>"));\n\tvar $span = $("<span> Name </span>");\n\t$row.append($("<td ></td>").append($span));\t\n\tvar $span = $("<span> Size </span>");\n\t$row.append($("<td ></td>").append($span));\t\n\n\t\n\n\n\t\n\tfunction setCurrentLabel(k,scrollTo)\n\t{\n\t\tif (k != -1)\n\t\t{\n\t\t\t$body.find(".selected").removeClass("selected");\n\t\t\tvar $row = $body.find("tr[value="+k+"]")\n\t\t\t$row.addClass("selected");\t\n\t\t\tif (scrollTo && panel.currentLabel != k)\n\t\t\t{\n\t\t\t\tpanel.currentLabel = k;\n\t\t\t\tif ($row.position().top != 0)\n\t\t\t\t\t$row.parent().parent().parent().scrollTop($row.position().top-65);\n\t\t\t}\n\t\t\telse\n\t\t\t\tpanel.currentLabel = k;\n\t\t}\n\t}\n\tpanel.setCurrentLabel = setCurrentLabel;\n\n\n\tfunction updatePersistentLabels(updateWMQLquery)\n\t{\n\t\t$body.find(".selectedBold").removeClass("selectedBold");\n\t\tfor (x in panel.persistentLabels)\n\t\t{\n\t\t\tvar $row = $body.find("tr[value="+x+"]")\n\t\t\t$row.addClass("selectedBold");\t\n\t\t}\n\n\t\tif (typeof KWMQLPanel != "undefined")\n\t\t{\n\t\t\tvar keys = Object.keys(KWMQLPanel.panels);\n\t\t\tkeys = keys.filter(function(x) {return (x.search(atlas.fileID+"_")>-1)})\n\t\t\tvar q = Object.keys(panel.persistentLabels).join(" and ")\n\t\t\tfor (var k = 0; k < keys.length;k++)\n\t\t\t{\n\t\t\t\tvar wmqlpanel = KWMQLPanel.panels[keys[k]];\n\t\t\t\twmqlpanel.$query_area.val(q);\n\t\t\t\twmqlpanel.$query_area.trigger("keyup");\n\n\t\t\t}\n\t\t}\n\t}\n\t\n\n\n\n    for (var k in atlas.content.labels)\n    {\n    \tvar label =  atlas.content.labels[k];\n    \t\n\n       var dragstuff = "draggable=\'true\' data-type=\'file\' data-mime=\'nii\' data-tag=\'/roi/\' data-intent=\'labelname:\\""+label.name+"\\",atlaskey:"+label.key+"\'  data-fileID=\'"+atlas.fileID+"\' data-filename=\'"+atlas.filename+":"+label.name+"\' ";\n       dragstuff = dragstuff + " ondragstart=\'setdragstart(event);\' ondragend=\'setdragend(event);\' ondblclick=\'loadDataOndblClick(event);\'";\n\n    \t\n\t\tvar $row = $("<tr  "+dragstuff+" value="+k+"></tr>");\n\t\t$row.click(function(k,$row) { return  function(e){\n\t\t\n\t\t    if (e.ctrlKey)\n\t\t    {\n\t\t    \tif (panel.persistentLabels[k])\n\t\t    \t\tdelete panel.persistentLabels[k];\n\t\t    \telse\n\t\t    \t\tpanel.persistentLabels[k] = atlas.content.labels[k];\n\t\t    \tupdatePersistentLabels(true);\n\t\t\t\tsignalhandler.send("updateImage",{id:atlas.fileID});\n\n\t//\t    \tsignalhandler.send(\'positionChange\');\n\t\t    }\n\t\t    else if (e.shiftKey)\n\t\t    {\n\t\t\t\t$row.prevUntil(".selected").addBack().each(function(x,y) {\n\t\t\t\t\tvar a = $(y).attr(\'value\');\n\t\t\t\t\tif (panel.persistentLabels[a])\n\t\t\t\t\t\tdelete panel.persistentLabels[a];\n\t\t\t\t\telse\n\t\t\t\t\t\tpanel.persistentLabels[a] =atlas.content.labels[a];\n\t\t\t\t } )\n\t\t\t\t updatePersistentLabels(true);\n\t\t    \tsignalhandler.send("updateImage",{id:atlas.fileID});\n\n\t//\t\t\t signalhandler.send(\'positionChange\');\n\t\t    }\n\t\t    else\n\t\t    {\n\t\t\t\tsetCurrentLabel(k)\n\t\t\t\tvar label = atlas.content.labels[k]\n\t\t\t\tKViewer.currentPoint = math.matrix(label.centroid);\n\t\t\t\t\n\t\t\t\tsignalhandler.send(\'positionChange\');\n\t\t\t\tsignalhandler.send(\'labelChange\');\t\t\t\t\t\t\t\t\n\t\t    }\n\n\t\t} }(k,$row));\n\t\n\t\t$row.appendTo($body);\n\t    $row.append($("<td style=\'background-color:"+RGB2HTML(label.color[0],label.color[1],label.color[2])+";\'  ></td>"));\n\n\t\tvar $span = $("<span> "+label.name+" </span>");\n\t\t$row.append($("<td></td>").append($span));\t\n\t\tvar $span = $("<span> "+label.size+" </span>");\n\t\t$row.append($("<td></td>").append($span));\t\n\n    }\n\n\n\n\n    $table.append($head);\n\t$table.append($body);\n\tattachTableOperator($div,undefined,true);\t\n\t$table.show();\n\tpanel.$container.width($table.width()+10);\n\n\tif (state != undefined)\n    {\n    \tif (state.persistentLabels)\n    \t{\n    \t\tpanel.persistentLabels = state.persistentLabels;\n    \t\tupdatePersistentLabels(false);\n    \t}\n    }\n\n\n\treturn panel;\n\n}'},function(t,n){t.exports='\n\n/** The table operator managing resizing/stickyhead/hidingcols \n * @param {div} $div - the table\n * @param {object} initstate - initiable state if table\n * @param {logical} sortable - html-based sorting of table is possible\n */\nfunction attachTableOperator($div, initstate, sortable)\n{\n    var $table = $div.find("table");\n    var $head  = $div.find("thead");\n    var $body  = $div.find("tbody");\n\n    var viscol = [];\n    var widths = [];\n\n    var tstate = { \n        viscol: viscol,\n        widths: widths\n    };\n\n\n    $table.attr("cellspacing", 0);\n\n\n    initialWidthLayout();\n    $div.on(\'scroll\', stickHead);\n    $head.on("contextmenu", colShowHide);\n\n\n    attachResizer($head);\n    attachResizer($body);\n\n    \n    if (sortable)\n    {\n        var $cols = $head.find("tr:last").children();\n        for (var k = 0; k < $cols.length; k++)\n        {\n            // works best with mousedown, otherwise sizes are different\n            $($cols[k]).mousedown(function(idx) {\n                return function(e)\n                {\n                    if (!e.shiftKey && !e.ctrlKey)\n                    {\n                        var left = isOnSeparatorLeft(e);\n                        var right = isOnSeparatorRight(e);\n                        var donotsort = $(e.target).attr(\'preventsortable\') || $(e.target).parent().attr(\'preventsortable\'); // for check or delete or similar cells;\n                        if(! (left|right|donotsort|e.button==2) )\n                            sortbycolumn($cols[idx], idx)\n                    }\n                }\n            }(k));\n\n        }\n\n    }    \n    \n    \n    function sortbycolumn(target, idx)\n    {\n        target.sorted = (target.sorted > 0) ? -1 : 1;\n        console.log(target.sorted );\n        // the caret indicator\n        $head.find("i.fa-caret-up").remove();\n        $head.find("i.fa-caret-down").remove();\n        $(target).css(\'position\', \'relative\');\n        var fastyle = target.sorted==1?"fa-caret-up":"fa-caret-down";\n        $("<i class=\'fa "+ fastyle +"\' style=\'position:absolute;right:9px\'></i>)").appendTo($(target));\n\n\n        var sorted = target.sorted;\n        var rows = $body.find("td:nth-child(" + (idx + 1) + ")");\n        var vals = [];\n        function convert(a)\n        {\n            var v = parseFloat(a);\n            if (isNaN(v))\n                return a;\n            else\n                return v;\n        }\n\n        for (var k = 0; k < rows.length; k++)\n        {\n            // should work with content directly in td, but also with subdivs (span ...)\n            if( $(rows[k]).children().length > 0)\n                var text =  $(rows[k]).children().eq(0).text().trim();\n            else \n                var text =  $(rows[k]).text().trim();\n\n            vals[k] = {\n                val: convert(text),\n                div: $(rows[k]).parent()\n            };\n        }\n\n        $body.children().detach();\n        vals = vals.sort(function(a, b) \n        {\n            // differnet types or same val makes problems\n            if( typeof(a.val) != typeof(b.val) || a.val == b.val )\n                return -1;\n            else\n                return (a.val > b.val) ? sorted : -sorted;\n        });\n\n        for (var k = 0; k < vals.length; k++)\n            $body.append($(vals[k].div));\n\n    }\n\n\n    var sfields = $div.find(".KSearchHTML");\n    if (sfields.length>0)\n    {\n        for (var k = 0 ;k  < sfields.length; k++)\n        {\n            \n            $(sfields[k]).on("keyup",function(e)\n            {\n                var index = $(e.target).parent().index();\n                var rows = $body.find("td:nth-child(" + (index+1) + ")");\n                var search_re = $(e.target).val().toLowerCase().split(" ");\n                for (var j = 0; j < rows.length; j++)\n                {\n                    var str = $($(rows[j]).children()[0]).text().trim().toLowerCase();\n                    var found = true;\n                    for (var l = 0;l < search_re.length;l++)\n                    {\n                        if (str.search(search_re[l]) == -1)\n                        {\n                            found = false;\n                            break;\n                        }                        \n                    }\n                    if (found)\n                       $(rows[j]).parent().show();\n                    else\n                       $(rows[j]).parent().hide();\n                        \n                }\n                 \n            });\n        }\n    }\n\n\n\n    return {\n        state: tstate,\n        dumpWidths:dumpWidths,\n        toggleColVisibility: toggleColVisibility\n    };\n\n\n\n    function dumpWidths()\n    {\n        var $cols = $head.find("tr:first").children();\n\n        if ($cols.length == 0)\n            return\n\n        var twid = 0;\n        for (var k = 0; k < $cols.length; k++)\n        {\n            var $col = $($cols[k]);\n            var w = $col.width()-1;\n            widths[k] = w;\n        }\n\n    }\n\n\n    function initialWidthLayout()\n    {\n        var max_width = 250;\n\n        $table.removeClass("tablelayoutfixed");\n        var $cols = $head.find("tr:first").children();\n\n        if ($cols.length == 0)\n            return\n\n        var twid = 0;\n        for (var k = 0; k < $cols.length; k++)\n        {\n            var $col = $($cols[k]);\n            var w = $col.width();\n            w += 5;\n            if (w > max_width)\n                w = max_width;\n\n\n            function viscol_acc(vis)\n            {\n                if (vis == true | vis == undefined)\n                {\n                    twid += w;\n                    viscol.push(true);\n                }\n                else\n                {\n                    toggleColbyIdx(k);\n                    viscol.push(false);\n                }\n            }\n            // this only makes problems on different browsers\n            // why do we refer here to a \'fixedwidth\' attribute, but declare css-classes!??!\n            if( $col.attr("fixedwidth") != undefined)\n            {\n                w = parseInt($col.attr("fixedwidth"))+2;\n                if ($col.find("i").length > 0)\n                    $col.css(\'text-overflow\',\'clip\');\n                    \n                $col.width(w);\n                widths.push(NaN);\n                if (initstate != undefined)\n                    viscol_acc(initstate.viscol[k]);\n                else\n                    viscol_acc(true);\n\n            }\n            else if (initstate != undefined)\n            {\n                if (initstate.widths && !isNaN(initstate.widths[k]) && initstate.widths[k] != null )\n                {\n                    w = initstate.widths[k];\n                    $col.width(w);\n                    widths.push(w);\n                }\n                else\n                {\n                    $col.width(w);\n                    widths.push(NaN);\n                }\n                viscol_acc(initstate.viscol[k]);\n            }\n            else\n            {\n                $col.width(w);\n                twid += w;\n                widths.push(NaN);\n                viscol.push(true);\n            }\n        }\n       \n     //   $table.width(twid);  // mrc, no fixed table layout, let\'s think ....\n\n        $table.addClass("tablelayoutfixed");\n\n    }\n\n\n    function stickHead(e)\n    {\n        //$head.css(\'top\', e.target.scrollTop);\n        $head.find("td").css(\'top\', e.target.scrollTop);\n        $head.find("tr").css(\'top\', e.target.scrollTop);\n    }\n\n\n    function getTD(target)\n    {\n        for (var k = 0; k < 3; k++)\n        {\n            if (!$(target).is("td"))\n                target = $(target).parent();\n            else\n                break;\n        }\n        return target;\n    }\n\n\n    function isOnSeparatorLeft(e)\n    {\n        var target = getTD(e.target);\n        var off = (e.pageX - $(target).offset().left);\n        if (math.abs(off) < 4)\n            return true;\n        else\n            return false;\n    }\n\n    function isOnSeparatorRight(e)\n    {\n        var target = getTD(e.target);\n        var off = (e.pageX - $(target).offset().left - $(target).outerWidth());\n        if (math.abs(off) < 4)\n            return true;\n        else\n            return false;\n    }\n    function colShowHide(e)\n    {\n        e.preventDefault();\n        $cols = $head.find("tr:last").children();\n\n\n\n        var menu = KContextMenu(\n        function(ev) {\n            var $menu = $("<ul class=\'menu_context\'>")\n            for (var k = 0; k < $cols.length; k++)\n            {\n                var $icons = $("<span ></span>");\n\n                $(" <i  class=\'fa " + (viscol[k] ? "fa-check-square-o" : "fa-square-o") + " fa-1x\'></i>").appendTo($icons);\n                var colname = $($cols[k]).attr(\'colkey\');\n                if (colname != undefined)\n                    if (colname.substring(0, 5) == \'META_\' && state.metaindices[colname.substring(5)] != undefined)\n                    {\n                        $("<i onchoice=\'refresh_" + $($cols[k]).attr(\'colkey\') + "\' class=\'fa fa-refresh fa-1x\'>   </i>").appendTo($icons);\n                        $("<i onchoice=\'del_" + $($cols[k]).attr(\'colkey\') + "\' class=\'fa fa-trash fa-1x\'>   </i>").appendTo($icons);\n                    }\n                if ($($cols[k]).text().trim() != "")\n                    $menu.append($("<li onchoice=" + k + ">" + $($cols[k]).text() + "</li>").append($icons));\n            }\n            return $menu;\n        },\n        function(str, ev)\n        {\n            if (str)\n            {\n                if (str.substring(0, 4) == \'del_\')\n                {\n                    var jsonString = JSON.stringify({\n                        name: str.substring(9)\n                    });\n                    ajaxRequest(\'command=delMetaIndex\' + \'&json=\' + jsonString, function(e) {\n                        state.metaindices = e.metaindices;\n                        refreshButton();\n                    });\n                }\n                else if (str.substring(0, 8) == \'refresh_\')\n                {\n                    var jsonString = JSON.stringify({\n                        name: str.substring(13)\n                    });\n\n                    var pbar = KProgressBar("updateing metaindex " + str.substring(13),"fa-submit",undefined,true);\n\n                    ajaxRequest(\'command=updateMetaIndex\' + \'&json=\' + jsonString, function(e) {\n                        pbar.done();\n                        refreshButton();\n                    });\n                }\n                else\n                {\n                    toggleColbyIdx(parseInt(str));\n                    viscol[str] = !viscol[str];\n                }\n            }\n        }, true,true);\n\n        menu(e);\n\n    }\n\n\n\n    function toggleColbyIdx(idx)\n    {\n        var $totoggle = $table.find("td:nth-child(" + (idx + 1) + ")");\n        $totoggle.toggle();\n    }\n\n\n    function toggleColVisibility($tr)\n    {\n        for (var k = 0; k < viscol.length; k++)\n        {\n            var $td = $tr.find("td:nth-child(" + (k + 1) + ")");\n            if (viscol[k])\n                $td.show();\n            else\n                $td.hide();\n        }\n    }\n\n\n    function attachResizer($part)\n    {\n\n        $part.children().on("mousemove", function(e)\n        {\n            if (isOnSeparatorLeft(e) | isOnSeparatorRight(e))\n            {\n                var t = getTarget(e);\n                if (t.colidx == -1)\n                    return;\n                var $target = $($head.find("td")[t.colidx]);\n                if ($target.attr(\'fixedwidth\') != undefined)\n                    return;\n         \n\n                $part.css(\'cursor\', \'ew-resize\');\n                $part.addClass(\'nohover\');\n            }\n            else\n            {\n                $part.css(\'cursor\', \'\');\n                $part.removeClass(\'nohover\');\n            }\n        });\n        $part.children().on("mouseleave", function(e)\n        {\n            $part.css(\'cursor\', \'\');\n            $part.removeClass(\'nohover\');\n        });\n\n        function getTarget(e)\n        {\n\n            var left = isOnSeparatorLeft(e);\n            var right = isOnSeparatorRight(e);\n            if (!(left | right))\n                return ;\n\n            var td = getTD(e.target);\n\n            var $targetcol = $(td);\n            if (left)\n                $targetcol = $(td).prevAll(":visible:first");\n\n            var initialWidth = $targetcol.outerWidth();\n            var colidx = $targetcol.prevAll().length;\n           // if (left | right)\n              return {colidx:colidx,targetcol:$targetcol};\n        }\n\n\n\n        $part.children().on("mousedown", function(e)\n        {\n            \n            var left = isOnSeparatorLeft(e);\n            var right = isOnSeparatorRight(e);\n\n            var td = getTD(e.target);\n\n            var $targetcol = $(td);\n            if (left)\n                $targetcol = $(td).prevAll(":visible:first");\n\n            var colidx = $targetcol.prevAll().length;\n            \n            var t = getTarget(e);\n            if (t == undefined)\n                return;\n\n            var initialWidth = $(t.targetcol).outerWidth();\n            var $target = $($head.find("td")[t.colidx]);\n\n           \n           // if (1) //left | right)\n            {\n                e.preventDefault();\n                e.stopPropagation();\n\n                if ($target.attr(\'fixedwidth\') != undefined)\n                    return;\n\n\n                //var $dom = $(document.body);\n                var $dom = $div;\n                $dom.on("click", function() {\n                    attachTableOperator.fromResizingPhase = false;\n                });\n\n                $dom.on("mouseup mouseleave", function(ev)\n                {\n                    ev.preventDefault();\n                    ev.stopImmediatePropagation();\n                    $dom.off("mouseup mousemove mouseleave")\n                    attachTableOperator.fromResizingPhase = true;\n                });\n                $dom.on("mousemove", function(ev)\n                {\n                    var minwidth = 24;\n                    var dif = ev.clientX - e.clientX;\n                    var w = (initialWidth + dif > minwidth) ? (initialWidth + dif) : minwidth;\n                   \n                    $target.outerWidth(w);\n                    dif = w-$target.outerWidth()\n                    widths[t.colidx] = $target.width();\n\n\n                    // this will set a minimum size on columns on fixed width tables ....?\n                    // => removed\n                    $table.width($table.width()+dif);\n                  //  $table.width("");\n                    // no interference with width of table ..\n                });\n                e.stopImmediatePropagation();\n                return false;\n            }\n\n        });\n    }\n\n}\n\n\nattachTableOperator.fromResizingPhase = false;\n'},function(t,n){t.exports="\n\n// ======================================================================================\n// ======================================================================================\n// ============= KView\n// ======================================================================================\n// ======================================================================================\n\nvar myeps = 0.00000001;\nvar runningID = 0;\nfunction KView($parentContainer)\n{\n /**  @class \n   *  The main KViewer object\n   *  @alias KView   */\n  var that = new Object();\n  KViewer = that;\n\n  if ($parentContainer == undefined)\n  {\n\t  $parentContainer = $('#myKView').css('overflow', 'none');\n\t  that.standalone = false;\n  }\n  else \t\t\n  \t  that.standalone = true;\n\n  var $container = $(\"<div id='KView_mainFrame'></div>\").appendTo($parentContainer);\n  var $toolbarCell    = $(\"<div class='KView_DIVCell'></div>\").appendTo($container);\n  var $viewportCell   = $(\"<div class='KView_DIVCell' style='width:100%'></div>\").appendTo($container);\n  var $spinner  = $(\"<div id='KView_mainSpinner' class='KViewPort_spinner' ><i class='fa fa-spinner fa-spin'></i> <span >Loading</span></div>\").appendTo($container);\n\n\n  that.progressSpinner = theSpinner($spinner);\n  that.$container = $container;\n  that.$parentContainer = $parentContainer;\n  that.setReorientationMatrix = setReorientationMatrix;\n  that.reorientationMenu = reorientationMenu;\n  that.reorientationMatrix = {notID:false, matrix: math.matrix(math.diag([1,1,1,1])), name: \"\"};\n\n\n  var controlsOn = true;\n  that.hasControlsOn = function() {return controlsOn};\n  that.navigationMode = 2;\n\n\n\t\n  //markerPanel = that.markerPanel = KMarkerPanel();\n\n\n  that.dataManager = KDataManager();\n\n\n  ///  ---------- The viewport container\n  var $viewportContainer   = $(\"<div id='KView_viewportContainer'></div>\").appendTo($viewportCell);\n  that.$viewportContainer = $viewportContainer;\n  \n\n  ///  ---------- The left toolbar\n  var $toolbarContainer    = $(\"<div id='KView_toolBarLeft'></div>\").appendTo($toolbarCell);\n  that.$toolbarContainer = $toolbarContainer;\n\n  if(!KViewer.standalone)\n  \tvar $leftresizer = $(\"<div id='patient_table_resizer' class='resizer_vertical'><div><div></div></div></div>\").appendTo($container).mousedown(resizeViewer);\n\n  that.mainViewport = -1;\n\n  that.zoomLims = [];\n\n  that.defaults = { overlay:{}, ROI:{} };\n\n  that.globalScrollSpeed = 1;\n\n  // ======================================================================================\n  // Layout selector\n  // ======================================================================================   \n  /** the layout matrix for selection of viewport layout\n   * @inner */\n  var $layoutParent = $(\"<div class='KView_tool_menu_layoutSelectorParent'></div>\")\n  var $vertport =  $(\"<div class='vertport' ></div>\").appendTo($layoutParent).click(function()\n  {\n  \t  if (ViewerSettings.nVisibleVertports > 0) ViewerSettings.nVisibleVertports = 0;\n  \t  else ViewerSettings.nVisibleVertports = 1;\n\t  layoutMatrix_update();\n\t  setViewPortLayout(); \n\t     \t\t\t\n\n  }\t);\n  var $layoutMatrix =  $(\"<table class='KView_tool_menu_layoutSelectorTable'></table>\").appendTo($layoutParent).mouseleave(layoutMatrixLeave)\n\n\n\n    \n  for (var k = 0; k < 3; k++)\n  {\n  \t  var $tr =  $(\"<tr></tr>\").appendTo($layoutMatrix);  \t\n\t  for (var j = 0; j < 4; j++)\n\t     $tr.append( $(\"<td myrow=\"+(k+1)+\" mycol=\"+(j+1)+\"></td>\").click(function(l){ return function()\n\t     \t\t{\n\t     \t\t\t\n\t     \t\t\tsetViewPortLayout(l); \n\t     \t\t\tsetViewPortLayout();\n\t     \t\t\tsignalhandler.send('positionChange'); \n\t     \t\t\t layoutMatrix_update();\n\t     \t\t} }([k+1,j+1]) ).mouseenter(layoutMatrixEnter) )\n\t \t \n  }\n  var $bars = [];\n  for (var k = 0; k < 3; k++)\n  {\n    $bars[k] =  $(\"<tr><td colspan='4'></td></tr>\").appendTo($layoutMatrix).mouseenter(layoutMatrixEnter).click(\n\t  function(k) { return function()\n\t  {\n\t  \t  if ($bars[k].hasClass('KView_tool_menu_layoutSelectorTable_active'))\n\t\t  \t ViewerSettings.nVisibleBarports--;\n\t\t  else\n\t\t     ViewerSettings.nVisibleBarports++;\n\t\t  setViewPortLayout(); \n\t\t  signalhandler.send('positionChange'); \n\t\t  layoutMatrix_update();\n\t  } }(k) );\n  }\n\n  var $addfloat = $(\"<i class='fa fa-plus fa-1x'></i>\")\n \n  var floating_viewports = {};\n\n  $layoutParent.append($(\"<div class='floatports'> floating </div>\").append($addfloat))\n\n  $addfloat.click(function() {\n \tvar panelview = KPanelView(KViewer,\"\",{showElements:true,addClass:\"floatingViewporthidetitle\"});\n\n\t\n  });\n  \n  function layoutMatrix_update()\n  {\n  \t\t$vertport.removeClass('KView_tool_menu_layoutSelectorTable_active');\n\t\t  $layoutMatrix.find('td').removeClass('KView_tool_menu_layoutSelectorTable_active')\n\t      $layoutMatrix.find('td').each( function(k, e){ a = $(e);\n\t  \t  if( a.attr('myrow') <= ViewerSettings.nVisibleRows  & a.attr('mycol') <= ViewerSettings.nVisibleCols)\n\t  \t    \t$(a).addClass( 'KView_tool_menu_layoutSelectorTable_active' );\t     });\n\n\t\t  $.each($bars,function(k,e) { \n\t\t  \t$(e).removeClass('KView_tool_menu_layoutSelectorTable_active');\n\t\t\tif (k < ViewerSettings.nVisibleBarports )\n\t\t\t\t$(e).addClass('KView_tool_menu_layoutSelectorTable_active');\n\t\t  } )\t  \t  \n\n\t\t  if (ViewerSettings.nVisibleVertports > 0)\n\t\t  \t$vertport.addClass('KView_tool_menu_layoutSelectorTable_active');\n\n  }\n\n  function layoutMatrixEnter()\n  {\n\t  var myrow = $(this).attr('myrow');\n\t  var mycol = $(this).attr('mycol');\n\t  $layoutMatrix.find('td').removeClass('KView_tool_menu_layoutSelectorTable_td_hovered')\n\t  if (myrow == undefined)\n  \t      return;\n  \t  else\n\t\t  $layoutMatrix.find('td').each( function(k, e){ a = $(e);\t      \n\t\t\t  if( a.attr('myrow') <= myrow  & a.attr('mycol') <= mycol)\n\t\t\t\t $(a).addClass( 'KView_tool_menu_layoutSelectorTable_td_hovered' );\n\t\t  });\n  }\n  \n  function layoutMatrixLeave()\n  {\n\t  $layoutMatrix.find('td').removeClass('KView_tool_menu_layoutSelectorTable_td_hovered')\n  }\n\n  // ======================================================================================\n  // KView tools bar\n  // ======================================================================================\n\n\n  var $closeAll =  $(\"<div class='KView_tool KView_tool_enabled'><i class='fa fa-close fa-1x'></i></div>\").appendTo($toolbarContainer)\n                          .click(function() { closeAll(); })\n                          .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Close all</li>\") ));\n\n\n  var $layoutSelector   = $(\"<div data-tooltip='change the number of viewports' class='KView_tool'><i  class='fa fa-th-large fa-1x'></i></div>\")\n\t\t\t\t\t\t   .click(function() { \n\t\t\t\t\t\t   \t\t\tsetViewPortLayout([ViewerSettings.nVisibleRows,ViewerSettings.nVisibleCols]);  \n\t\t\t\t\t     \t\t\tsetViewPortLayout();\n\t\t\t\t\t\t   \t\t\t}) \n  \t\t\t\t\t\t   .appendTo($toolbarContainer)\n                          .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Layout Selector </li>\") )\n                         .append($layoutParent)                          \n                        );\n  that.$layoutSelector = $layoutSelector;\n  $layoutSelector.mouseenter(function() { layoutMatrix_update(); });\n\n\n\n  var $fullscreenToggle =   $('#fullscreentoggle');\n  $fullscreenToggle.click(function()\n  {\n        var icon = this.children[0];\n        if (isFullScreen())\n        {\n            $(icon).addClass(\"fa-expand\"); $(icon).removeClass(\"fa-compress\");\n            exitFullScreen();\n        }\n        else\n        {\n            $(icon).removeClass(\"fa-expand\"); $(icon).addClass(\"fa-compress\");\n            requestFullScreen(document.documentElement);\n        }\n  } )\n\n\n  function toggleControls(e)\n  {\n\t   if ($('.KViewPort_container').hasClass('noBorder'))\n\t   {\n\t\t\t//$controlstext.text(\"Turn off controls\")\n\t   }\n\t   else                           \t      \t\t\n\t   {\n\t\t    //$controlstext.text(\"Turn on controls\")\n\t   }\n       $controlsToggle.toggleClass('KView_tool_enabled');\t   \n\t   toggleElementsForScreenShot();\n  }  \n  \n  var $histoToggle =    $(\"<div class='KView_tool KView_tool_enabled'><i class='fa fa-area-chart fa-1x'></i></div>\").appendTo($toolbarContainer)\n                          .click(toggleHistogram)\n                          .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Histograms</li>\") )\n                              );\n\n  var $crossHairToggle =  $(\"<div class='KView_tool KView_tool_enabled'><i class='fa fa-crosshairs fa-1x'></i></div>\").appendTo($toolbarContainer)\n                          .click(toggleCrossHair)\n                          .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Crosshair</li>\") ));\n\n  var $infobarToggle =  $(\"<div class='KView_tool KView_tool_enabled'><i class='fa fa-info-circle fa-1x'></i></div>\").appendTo($toolbarContainer)\n                          .click(toggleInfobar)\n                          .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Infobar</li>\") ));\n\n  var $controlsToggle =  $(\"<div class='KView_tool KView_tool_enabled'><i class='fa fa-th-list fa-1x'></i></div>\").appendTo($toolbarContainer)\n                          .click(toggleControls)\n                          .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Toggle Image Controls</li>\") ));\n\n  var $pixelated =  $(\"<div  style='margin-bottom:20px'  class='KView_tool '><i class='fa fa-th fa-1x'></i></div>\").appendTo($toolbarContainer)                          \n                          .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>pixelated</li>\"))).click( function(e) {\n                                  if (ViewerSettings.pixelated)\n                                  {\n                                        ViewerSettings.pixelated = false;\n                                        $pixelated.removeClass(\"KView_tool_enabled\");\n                                    //  $(e.target).text(\"pixelated\")\n                                      $('.KViewPort_canvas').removeClass('KViewPort_canvas_pixelated');   \n                                  }\n                                  else\n                                  {                 \n                                        $pixelated.addClass(\"KView_tool_enabled\");\n                                        ViewerSettings.pixelated = true;          \t      \t\t\n                                                //      $(e.target).text(\"interpolated\")\n                                                      $('.KViewPort_canvas').addClass('KViewPort_canvas_pixelated');   \n                                  }\n                                    }\n                                    ) ;\n                          \n/*\n  var $pixelated,$controlstext;\n\n  var $toolviewSettings =  $(\"<div class='KView_tool '><i  class='fa fa-bars fa-1x'></i></div>\").appendTo($toolbarContainer)\n                           .append( $(\"<ul class='KView_tool_menu'></ul>\")\n                           .append($(\"<li>Settings</li>\") )\n                           .append($pixelated = $(\"<li>Not pixelated</li>\")\n                                .click( function(e) {\n                                  if (ViewerSettings.pixelated)\n                                  {\n                                        ViewerSettings.pixelated = false;\n                                      $(e.target).text(\"pixelated\")\n                                      $('.KViewPort_canvas').removeClass('KViewPort_canvas_pixelated');   \n                                  }\n                                  else\n                                  {                 \n                                        ViewerSettings.pixelated = true;          \t      \t\t\n                                                      $(e.target).text(\"interpolated\")\n                                                      $('.KViewPort_canvas').addClass('KViewPort_canvas_pixelated');   \n                                  }\n                                    }\n                                    ) )\n                           .append($controlstext = $(\"<li>Turn off controls</li>\").click( toggleControls) )\n                           .append($(\"<li>Screenshot</li>\").click( function(e) {\n                               \ttakeScreenshot(e);\n\t \t\t\t\t\t\t\t                }      ) )   ); */\n    KViewer.$pixelated = $pixelated;\n\n\n  // ======================================================================================\n  // Dedicated Annotation Marker Menu\n  // ======================================================================================\n    var $annotationMenu =  $(\"<div  class='KView_tool '><i  class='fa fa-adn fa-1x'></i></div>\").appendTo($toolbarContainer)\n    var $annotationMenuUL = $(\"<ul class='KView_tool_menu'></ul>\").appendTo($annotationMenu).append($(\"<li>Annotation Panels</li>\"))\n\n\tif (typeof KMarkerTool != \"undefined\")\n\t{\t\n\t\t//var $ttt = KToolWindow.$thetoggle.find(\".KView_tool_menu\")\n\t\tvar $ttt = $annotationMenuUL;\n\n\t\t$(\"<li>Boxes</li>\").click(function(){ KMarkerPanel_boxes(); }).appendTo($ttt);\n\t\t$(\"<li>Circles</li>\").click(function(){ KMarkerPanel_circles(); }).appendTo($ttt);\n\t\t$(\"<li>2DRuler</li>\").click(function(){ KMarkerPanel_2Drulers(); }).appendTo($ttt);\n\t\t$(\"<li>3DRuler</li>\").click(function(){ KMarkerPanel_3Drulers(); }).appendTo($ttt);\n\t\t$(\"<li>Scribble</li>\").click(function(){ KMarkerPanel_scribble(); }).appendTo($ttt);\n\t\t$(\"<li>RenalStones</li>\").click(function(){ KPointRoiTool(); }).appendTo($ttt);\n\t\t$(\"<li style='border-top:1px solid gray'>Configurator ...</li>\").click(function(){ KMarkerPanel_configurator(); }).appendTo($ttt);\n\n\t}\n\n\n    \n  // ======================================================================================\n  // Global coords and other buttons\n  // ======================================================================================\n   var $crossHairReset =  $(\"<div  class='KView_tool '><i  class='fa fa-reply fa-1x'></i></div>\").appendTo($toolbarContainer)\n                           .click(resetCrossHair)\n                           .append($crossHairReset_ul= $(\"<ul class='KView_tool_menu'></ul>\")\n                           .append($(\"<li>View</li>\"))\n                           .append($(\"<li>Reset view <i class='fa fa-reply fa-1x'></i></li>\").click(resetCrossHair) )\n                           .append($(\"<li>Center at haircross<i class='fa fa-crosshairs fa-1x'></i></li>\").click(function(e){\n                           \t\te.stopPropagation();\n                           \t\te.preventDefault();\n\t\t\t\t\t\t\t\tsignalhandler.send(\"centralize\");  }))\t\t\n\t\t\t\t\t\t   .append($(\"<li>Global coordinates<i class='toggleGlobalCoordinates fa fa-check fa-1x'></i></li>\").click(toggleGlobalCoordinates) )\t\t\t\t\t\t\t\t                           \n                           );\n\n    if (typeof presetForm_viewer_permorder != \"undefined\")\n    {\n        var $Csystem =  $(\"<div  class='KView_tool '><i  class='fa fa-globe fa-1x'></i></div>\").appendTo($toolbarContainer)\n        var $Csystem_ul =  $(\"<ul class='KView_tool_menu'></ul>\").appendTo($Csystem)\n\t\t$Csystem_ul.append($(\"<li>Coordinate System</li>\"))\n\t\tvar l = presetForm_viewer_permorder.choices;\n\t\tfor (var k=0;k < l.length;k++)\n\t\t{\n\t\t\tvar check = \"\";\n\t\t\tif (presetForm_viewer_permorder.ids[k] == state.viewer.permOrder)\n\t\t\t\tcheck = \"fa-check\"\n\t\t\t$Csystem_ul.append($(\"<li id=\"+presetForm_viewer_permorder.ids[k]+\">\"+ l[k]+  \"<i class='fa \"+check+\" fa-1x'></i></li>\").click(function()\n\t\t\t{\n\t\t\t\t$(this).parent().find(\"i\").removeClass(\"fa-check\")\n\t\t\t\t$(this).children().addClass(\"fa-check\")\n\t\t\t\tvar id = $(this).attr(\"id\")\n\t\t\t\tstate.viewer.permOrder = id\n\n        \t\tvar tlist = KViewer.dataManager.getFileList();\n        \t\tfor (var j in tlist)\n        \t\t{\n        \t\t\tvar f = KViewer.dataManager.getFile(tlist[j])\n        \t\t\tif (f && f.content && f.content.applyReordering)\n        \t\t\t{\n\t\t\t\t\t\tf.content.applyReordering(id);\n\t\t\t\t\t\tsignalhandler.send(\"updateImage\",{id:f.fileID});\n        \t\t\t}\n        \t\t}\n\n\t\t\t}))\n\n\t\t}\n    }\n\n//\tif (typeof html2canvas != \"undefined\")\n      var $screenShot =  $(\"<div class='KView_tool '><i class='fa fa-camera fa-1x'></i></div>\").appendTo($toolbarContainer)                          \n                          .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Screenshot</li>\")\n                           ).append($(\"<li>Still PNG</li>\").click(takeScreenshot)).append($(\"<li>Animated GIF</li>\").click(createGif.createPanel)));\n\n    {                            \n\t\tvar $saveprojectstate =  $(\"<div  class='KView_tool '><i  class='fa fa-save fa-1x'></i></div>\").appendTo($toolbarContainer)\n\n\t\t\t\t\t\t.append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Save working state</li>\")) )\n\n\t\t\t\t\t\t\t\t.click(function() { saveWorkstate(that) });\n\n\t\tif (typeof ajaxRequest != \"undefined\")\n\t\t\tvar $refreshFiles =  $(\"<div  class='KView_tool '><i  class='fa fa-refresh fa-1x'></i></div>\").appendTo($toolbarContainer)\n\t\t\t\t\t\t\t.append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Refresh files</li>\")) )\n\t\t\t\t\t\t\t.click(function()\n\t\t\t\t\t\t\t{\n\t\t\t\t\t\t\t\tKViewer.dataManager.refetchAllFiles();\n\t\t\t\t\t\t\t});\n\n    }\n    that.$screenShot = $screenShot;\n    var $globalCoordinatesToggle = $crossHairReset.find('.toggleGlobalCoordinates');\n\n    if (!electron && application != \"webview\")\n\t{\n\t\tvar $Batch =  $(\"<div class='KView_tool'><i class='fa fa-cogs fa-1x'></i></div>\").appendTo($toolbarContainer)\n\t\t  .click(function() {\n\t\t\t  var icon = this;\n\t\t\t  commandDialog.toggle();\n\t\t\t  //if (commandDialog.toggle())\n\t\t\t  //\t$(icon).toggleClass(\"KView_tool_enabled\");\n\t\t   })\n\t\t  .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Batchtool</li>\") ));\n\t}\n\n    // ======================================================================================\n    //  Autoloader\n    // ======================================================================================\n\n\tvar $autoLoaderMenu =  $(\"<div id='autoloaderButtonDIV' style='margin-bottom:10px;' class='KView_tool KView_tool_enabled_green '><i  class='fa fa-car fa-1x'></i></div>\")\n\t\n\t// appending to top menu does not work so simply, this one is refreshed on project change ...\n// \tvar $target = $(\"<li>ddddd</li>\");\n// \t$target.appendTo( $('#patientTableTopTools').find(\"ul\") );\n//\t$autoLoaderMenu.appendTo($target);\n\t//$autoLoaderMenu.appendTo($toolbarContainer);\n\n\t$autoLoaderMenu.insertAfter($closeAll);\n/*\n\tvar $dummy =  $(\"<div id='autoloaderButtonDIV' style='margin-bottom:20px' class='KView_tool'><i  class='fa fa-car fa-1x'></i></div>\")\n\t\t.append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Item went to top of menubar! </li>\")))\n        .appendTo($toolbarContainer)\n        .click(function(){alert('Item went to top of menubar, use that new button!')})\n*/\n\tthat.$autoLoaderMenu = $autoLoaderMenu;\n\t$autoLoaderMenu .click(function(ev) {autoloader_toggle()})\n\t   \n\tfunction autoloader_toggle(what)\n\t{\n\t\tif(what !== undefined)\n\t\t\tstate.viewer.enableAutoloaders = what;\n\t\telse\n\t\t\tstate.viewer.enableAutoloaders = state.viewer.enableAutoloaders===true?false:true; \n\n\t\tif(state.viewer.enableAutoloaders)\n\t\t{\n\t\t\t$autoLoaderMenu.addClass('KView_tool_enabled_green');\n\t\t\t$autoLoaderMenu.find('.atoggler').addClass('fa-check'); \n\t\t\n\t\t}\n\t\telse\n\t\t{\n\t\t\t$autoLoaderMenu.removeClass('KView_tool_enabled_green');\n\t\t\t$autoLoaderMenu.find('li').eq(0).find('i').css('color', 'initial');\n\t\t\t$autoLoaderMenu.find('.atoggler').removeClass('fa-check'); \n\t\t}\n\t}\n\n\n\tvar autoLoaderLiveEdit_show = false;\n\tfunction autoLoaderLiveEdit_toggle(what)\n\t{\n\t\tif(what !== undefined)\n\t\t\tautoLoaderLiveEdit_show = what;\n\t\telse\n\t\t\tautoLoaderLiveEdit_show = autoLoaderLiveEdit_show?false:true;\n\t\tautoLoaderLiveEdit_update();\n\t}\n\n\n\n\tfunction autoLoaderLiveEdit_update()\n\t{\n\t\t$(document).off('blur', '.KViewPort_autoLoaderLiveEdit');\n\t\t\n\t\t$container.find('.KViewPort_autoLoaderLiveEdit').remove();\n\t\tif(!autoLoaderLiveEdit_show)\n\t\t\treturn;\n\t\n\t\tfor(var k=0;k<state.viewer.autoloaders.length; k++)\n\t\t{\n\t\t\tvar a = state.viewer.autoloaders[k];\n\t\t\tvar ids  = a.viewportID.toString().split(\",\");\n\t\t\tids.forEach(function(part,index,array) { array[index] = parseInt(part); });\n\n\n\t\t\tfor(var i =0; i<ids.length; i++)\n\t\t\t{\n\t\t\t\tvar $loadEdit = viewports[ids[i]].$container.find('.KViewPort_autoLoaderLiveEdit')\n\t\t\t\tif($loadEdit.length == 0)\n\t\t\t\t{\n\n\t\t\t\t\tvar $loadEdit = $(\"<div class='KViewPort_autoLoaderLiveEdit'></div>\").appendTo(viewports[ids[i]].$container);\n\t\t\t\t\t$loadEdit.append($(\"<span class='loadEdit_close'><i class='fa fa-close'></i></span>\").click(function(){autoLoaderLiveEdit_toggle(false) }) );\n\t\t\t\t\t$loadEdit.append($(\"<div class='loadEdit_background'> Background</div>\"));\n\t\t\t\t\t$loadEdit.append($(\"<div class='loadEdit_rois'>Rois</div>\"));\n\t\t\t\t\t$loadEdit.append($(\"<div class='loadEdit_overlays'> Overlays</div>\"));\n\t\t\t\t}\n\n\t\t\t\tvar form = {name:\"temp\", layout: \t\t[ {name:\"pattern\"\t    \t, type: 'textarea',     defaultval:\"FFilename:\"  , class:\"autoloaderitem\"  }\t]};\n\n\t\t\t\tif(a.intent.overlay)\n\t\t\t\t\tvar $form  = KForm.createForm(form, state.viewer.autoloaders[k] , $loadEdit.find('.loadEdit_overlays') );\n\t\t\t\telse if(a.intent.roi)\n\t\t\t\t\tvar $form  = KForm.createForm(form, state.viewer.autoloaders[k] , $loadEdit.find('.loadEdit_rois') );\n\t\t\t\telse\n\t\t\t\t\tvar $form  = KForm.createForm(form, state.viewer.autoloaders[k] , $loadEdit.find('.loadEdit_background') );\n\n\t\t\t\t// remove the labels from the forms\n\t\t\t\t$loadEdit.find('label').remove();\n\n\t\t\t}\n\n\t\t}\n\n\t\tif(state.viewer.autoloaders.length == 0)\n\t\t{\n\t\t\tvar $loadEdit = $(\"<div style = 'width:220px' class='KViewPort_autoLoaderLiveEdit'></div>\").appendTo(viewports[0].$container);\n\t\t\t$loadEdit.append($(\"<div class='loadEdit_background'>No images found for autoload!</div>\"));\n\t\t\t$loadEdit.append($(\"<span class='loadEdit_close'><i class='fa fa-close'></i></span>\").click(function(){autoLoaderLiveEdit_toggle(false) }) );\n\t\t}\n\t\t//$(document).on('blur', '.KViewPort_autoLoaderLiveEdit',autoLoaderLiveEdit_update )\n\t}\n\tthat.autoLoaderLiveEdit_toggle = autoLoaderLiveEdit_toggle;\n\tthat.autoLoaderLiveEdit_update = autoLoaderLiveEdit_update;\n\tthat.autoloader_toggle = autoloader_toggle;\n\t\n\t\n \n    if (KViewer.standalone || electron || application == \"webview\")\n\n\t{\n\t\t$autoLoaderMenu.hide();\t\t\t\t\t\t  \t\t\t\t\t\t   \n\t\t//$screenShot.hide();\n\t\tif (typeof $markerToggle != \"undefined\")\n\t\t\t$markerToggle.hide();\n\t}\n\n\n\n\n\n  // ======================================================================================\n  // viewports creation\n  // ======================================================================================\n\n  var nRows = 3;\n  var nCols = 5;\n  var vpAssignment = [ [0,1,4,5],[2,3,6,7 ],[8,9,10,11]];\n\n  var nViewports = nRows*nCols ;\n  var nVisibleViewports = 1;\n  that.nVisibleViewports = nVisibleViewports;\n\n  /** the viewport grid\n   * @inner */\n  var viewports = new Array();\n  that.viewports = viewports;\n\n\n  for(var k=0;k<2;k++)\n  {  \t\n    viewports[k+20] = new KViewPort(that, k+20);\n    viewports[k+20].$container.hide();\t\n    viewports[k+20].vertport = true;\n    viewports[k+20].right_neighbor = 'cartridge';\n    viewports[k+20].width_in_perc = state.viewer.vertportSizePercent;\n  }\n\n\n  for(var k=0;k<nViewports;k++)\n    viewports[k] = new KViewPort(that, k);\n  for(var k=0;k<3;k++)\n  {  \t\n    viewports[k+nViewports] = new KViewPort(that, k+nViewports);\n    viewports[k+nViewports].$container.hide();\t\n    viewports[k+nViewports].barport = true;\n  }\n\n\n  for (var k = 0; k < 3; k++)\n  {\n\t  for (var j = 0; j < 3; j++)\n\t  {\n\t  \t  viewports[vpAssignment[k][j]].left_neighbor = vpAssignment[k][j-1];\n\t  \t  viewports[vpAssignment[k][j]].right_neighbor = vpAssignment[k][j+1];\n\t  }  \t\n  }\n\n\n  \n  var $dummyPortContainer = $(\"<div> </div>\");\n  that.$dummyPortContainer = $dummyPortContainer;\n\n  var $zoomedPortContainer   = $(\"<div class='KViewPort_zoomedPort'></div>\").appendTo($viewportContainer);\n  $zoomedPortContainer.on(\"dragover\",  function(ev)\n\t  {\n\t\tev.preventDefault(); \n\t\treturn false;\n\t  });\n  that.$zoomedPortContainer = $zoomedPortContainer;\n  that.zoomedViewport = -1;\n  that.zoomPanMode = true;\n\n  that.unZoomViewport = function()\n  {\n  \tif (KViewer.zoomedViewport != -1)\n  \t\tKViewer.viewports[KViewer.zoomedViewport].zoomViewPort();\n  }\n\n  that.setSizeLeftViewportCol = function(t)\n\t{\n\t\t  var tools = KToolWindow.findToolInLowerContainer();\n\t\t  var avail_height =  that.$zoomedPortContainer.height();\n\n\t\t\tvar tools = KToolWindow.findToolInLowerContainer();\n\n\t\t\tvar hs = [];\n\t\t\tvar toth = 0;\n\t\t\tfor (var k = 0; k < tools.length;k++)\n\t\t\t{\n\t\t\t\tvar h = tools[k].$container.height();;\n\t\t\t\ttoth += h;\n\t\t\t\ths.push(h);\n\t\t\t}\n\n\t\t\tif (t == undefined)\n\t\t\t\tt = toth;\n\n\t\t\tfor (var k = 0; k < tools.length;k++)\n\t\t\t\ttools[k].resize(hs[k]/toth*t);\n\n\t\t\t$(\"#patientThumbContainer\").height(avail_height-t);\n\n\t}\n\n\n  /** run over all present medviewers\n   * @function */\n  that.iterateMedViewers = function(callback)\n  {\n  \tvar keys = Object.keys(viewports);\n    for(var k = 0; k < keys.length; k++)\n      if (viewports[keys[k]].medViewer != undefined && !viewports[keys[k]].medViewer.dummyViewer)\n      {\t\n      \t// introduces that only iterate if the medviewer has an nifti inside. Otherwise follow errors\n      \t// maybe something might not work / will not be plotted...?\n      \tif(viewports[keys[k]].medViewer.nii !=undefined  )\n          \tcallback( viewports[keys[k]].medViewer);\n      }\n  }\n\n\n  that.findMedViewer = function(condition)\n  {\n\tif (condition == undefined)\n\t\tcondition = function() {return true};\n\n  \tvar keys = Object.keys(viewports);\n  \tkeys = [20].concat(keys);\n    for(var k = 0; k < keys.length; k++)\n      if (viewports[keys[k]].medViewer != undefined && !viewports[keys[k]].medViewer.dummyViewer)      \n      {\t\n      \tif (condition(viewports[keys[k]].medViewer))\n      \t\treturn viewports[keys[k]].medViewer;\n      }\n\n  }\n\n\n\n  // ======================================================================================\n  // Geometry and  master/interpolation mode\n  // ======================================================================================\n\n  /** the current postion in world coords \n   * @inner */\n  that.currentPoint  = math.matrix([0,0,0,1]);\n  that.currentPoint.reset = true;\n  \n  /** the current time point as global parameter\n   * @inner */\n  that.movie = \n  {\n\t\tcurrentTimePoint:0,\n\t\tisPlayed:false,\n\t\tmaxNumTimePoints:0,\n\t\ttimerId:0  \t\n  }\n\n  /** the center of image matrix of last loaded image\n   * @inner */\n  that.viewcenter = math.matrix([0,0,0,1]);\n  /**  tilt angles of slices\n   * @inner */\n  that.curTilts = new Array();\n  that.curTilts[0]=[{v:0},{v:0}];\n  that.curTilts[1]=[{v:0},{v:0}];\n  that.curTilts[2]=[{v:0},{v:0}];\n  that.currentTilts = function(z) { return function(i,j)\n  {\n    if (z.mainViewport != -1)\n    {\n        var nii = viewports[that.mainViewport].medViewer.nii;\n        \n        if(nii===undefined)\n          return that.curTilts[i][j];\n        var swapXY;\n        if(i == 0) \n             swapXY = (nii.permutationOrder[1] >  nii.permutationOrder[2])?1:0;\n        if(i == 1) \n            swapXY = (nii.permutationOrder[0] >  nii.permutationOrder[2])?1:0;\n        if(i == 2) \n            swapXY  = (nii.permutationOrder[0] >  nii.permutationOrder[1])?1:0;\n        var porder = nii.permutationOrder;\n        if (swapXY)\n          return z.curTilts[porder[i]][1-j];\n        else\n          return z.curTilts[porder[i]][j];\n    }\n    else\n      return that.curTilts[i][j];\n  } }(that);\n\n  that.currentTilts_ = function(z) { return function(i,j)\n  {\n    return z.curTilts[i][j];\n  } }(that);\n\n\n  // reset view/position/tilts of all medviewers\n  // @function \n\n  /** run over all present medviewers\n   * @function */\n  function resetCrossHair()\n  {\n     that.currentTilts(0,0).v = 0;\n     that.currentTilts(0,1).v = 0;\n     that.currentTilts(1,0).v = 0;\n     that.currentTilts(1,1).v = 0;\n     that.currentTilts(2,0).v = 0;\n     that.currentTilts(2,1).v = 0;\n     that.reorientationMatrix.matrix =  math.matrix(math.diag([1,1,1,1]));\n     //that.currentPoint = math.multiply(that.reorientationMatrix.matrix, [0, 0, 0, 1]);\n     that.currentPoint = math.multiply(that.reorientationMatrix.matrix, that.viewcenter);\n     that.toggleMainViewport(-1);\n    \n     signalhandler.send(\"resetHaircrossTilts\");\n     signalhandler.send(\"setZoomLims\",[1,0,0]);\n     signalhandler.send(\"positionChange\",{mosaicdraw:true});\n     signalhandler.send(\"webglresetcam\");\n  }\n\n  that.resetCrossHair =  resetCrossHair;\n\n  that.toggleMainViewport = function(id, keep_enabled)\n  {\n\n\t  if (id == -1) // turn off mainviewport in case, otherwise do nothing\n\t  {\n\t\t  if (that.mainViewport != -1)\n\t\t\t  that.toggleMainViewport( that.mainViewport  );    \n\t\t  return;\n\t  }\n\t  if(that.viewports[id] == undefined || that.viewports[id].medViewer == undefined)\n\t\treturn;\n\n\t  var icon = that.viewports[id].medViewer.toolbar.$mainViewportSelector;\n\n\t  if(that.mainViewport == -1 ) // right now no master is selected. Enable this one.\n\t  {\n\t\tthat.mainViewport = id;\n\t\tif (that.navigationTool)\n\t\t\tthat.navigationTool.updateMasterCaption();\n\t\ticon.addClass('KViewPort_tool_enabled');\n\t  }\n\t  else   // already selected one. test if is itself or another\n\t  {\n\t\tif(that.mainViewport == id) // hit itself. switch off. But only if no keep_enabled was used (startup issues)\n\t\t{\n\t\t  if(keep_enabled == undefined)\n\t\t  {\n\t\t\ticon.removeClass('KViewPort_tool_enabled');\n\t\t\tthat.mainViewport = -1;\n\t\t\tthat.navigationTool.updateMasterCaption();\t\t\t\n\t\t  }\n\t\t}\n\t\telse // anther one is master. switch this one off first.\n\t\t{\n\t\t  that.toggleMainViewport( that.mainViewport  );\n\t\t  that.mainViewport = id;\n\t\t  icon.addClass('KViewPort_tool_enabled');\n\t\t  that.navigationTool.updateMasterCaption();\t\t\t\n\t\t}\n\t  }\n\t  signalhandler.send(\"reslice positionChange\");\n\n  }\n\n\n\n  /** computes rotation matrix from tiltangle\n   * @function */ \n  function getReorientationMatrixFromTiltAngles(sg,old_reorient,old_point)\n   {\n       if (old_point == undefined) \n   \t     old_point = KViewer.currentPoint._data;\n\t\t   if (old_reorient == undefined) \n   \t     old_reorient = that.reorientationMatrix.matrix;\n   \t     \n       var xy = sg*Math.sin(-KViewer.currentTilts_(2,0).v/180*Math.PI);\n       var xz = sg*Math.sin(-KViewer.currentTilts_(1,0).v/180*Math.PI);  // 1er + 0er flipped !!!!\n       var xx = Math.sqrt(1- xy*xy - xz*xz);\n\n       var yx = sg*Math.sin(KViewer.currentTilts_(2,1).v/180*Math.PI);\n       var yz = sg*Math.sin(-KViewer.currentTilts_(0,0).v/180*Math.PI);\n       var yy = Math.sqrt(1-yx*yx-yz*yz);\n\n       var zy = sg*Math.sin(KViewer.currentTilts_(0,1).v/180*Math.PI);\n       var zx = sg*Math.sin(KViewer.currentTilts_(1,1).v/180*Math.PI);\n       var zz = Math.sqrt(1-zy*zy-zx*zx);\n\n       R = math.transpose(math.matrix([ [xx,xy,xz,0], [yx,yy,yz,0],[zx,zy,zz,0],[0,0,0,1]]));\n\n       var t = old_point;\n       var Q = math.matrix([ [1,0,0,t[0]], [0,1,0,t[1]],[0,0,1,t[2]],[0,0,0,1]]);\n\n       var s = math.multiply(math.inv(old_reorient), t);\n       var T = math.matrix([ [1,0,0,s._data[0]], [0,1,0,s._data[1]],[0,0,1,s._data[2]],[0,0,0,1]]);\n\n       var w = math.multiply((R), t);\n       var Z = math.matrix([ [1,0,0,w._data[0]], [0,1,0,w._data[1]],[0,0,1,w._data[2]],[0,0,0,1]]);\n\n       return {Q:Q,T:T,R:R,Z:Z,t:t,s:s};\n\n\n  }\n  that.getReorientationMatrixFromTiltAngles = getReorientationMatrixFromTiltAngles;\n\n  /** sets reorientation matrix based from saved json\n   * @inner */ \n  function setReorientationMatrix(ev)\n  {\n    that.reorientationMatrix.notID = true;\n    var transform = JSON.parse(ev.content);\n    that.reorientationMatrix.name = transform.name;\n    that.reorientationMatrix.matrix = math.matrix(transform.matrix);\n\tKViewer.navigationTool.transform.update();\n    signalhandler.send(\"reslice\");    \n  }\n\n  function reorientationMenu()\n  {\n\n\t   var $menu = $(\"<ul class='KView_tool_menu'>\");\n     $menu.append($(\"<li onchoice='flipx'>Flip X</li>\"));\n     $menu.append($(\"<li onchoice='flipy'>Flip Y</li>\"));\n     $menu.append($(\"<li onchoice='flipz'>Flip Z</li>\"));\n     $menu.append($(\"<li onchoice='cycle'>Cycle permute</li>\"));\n     $menu.append($(\"<li onchoice='pari'>Change Parity</li>\"));\n     $menu.append($(\"<li onchoice='reset'>Reset Transformation</li>\"));\n     $menu.append($(\"<li onchoice='save'>Save Transformation</li>\"));\n\n\t   selFun = function() { return function(ev)\n\t\t\t   {\n\t\t\t\t\tev.preventDefault();\n\t\t\t   \t\tev.stopPropagation();\n\t\t\t\t\tvar str = $(ev.target).attr(\"onchoice\");\n\t\t\t\t\tif (str==\"reset\")\n                    {\n                        KViewer.reorientationMatrix.matrix =  math.matrix(math.diag([1,1,1,1]));\n                        KViewer.reorientationMatrix.notID = false;\n                        signalhandler.send(\"reslice\");\n                        KViewer.resetCrossHair();\n\n                    }\n\t\t\t\t\telse if (str==\"save\")\n                    {\n                        if (KViewer.reorientationMatrix.notID)\n                        {\n                          alertify.prompt(\"Please enter a name\",function (e,name) {\n                            if (e)\n                            {\n                                KViewer.reorientationMatrix.name = name;\n\t\t\t\t\t\t\t\tuploadJSON(name,{matrix: KViewer.reorientationMatrix.matrix._data},{subfolder: \"transforms\", tag:\"RO\"})\n                            }\n                          } );\n                        }\n                    }\n\t\t\t\t\telse\n                    {\t\n\n\n  \t\t\t\t\t\t  var mnii = KViewer.viewports[KViewer.mainViewport].medViewer.nii;\n       \t\t\t\t\t  var edges = math.multiply(1,mnii.edges);\n\t\t\t\t\t\t  edges = math.multiply(edges,permMat(mnii));\n\n\n\n       \t\t\t\t\t  var T = transMat(math.multiply(math.inv(edges),math.multiply(math.inv(KViewer.reorientationMatrix.matrix), KViewer.viewcenter)));\n\t\t\t \n\t\t\t\t\t      var E = math.multiply(edges,T);\n\t\t\t\t\t\t\n\t\t\t\t\t\t  var R;\n                          if (str == 'flipx')\n                          \t R = math.diag([-1,1,1,1]);\n                          if (str == 'flipy')\n                          \t R = math.diag([1,-1,1,1]);\n                          if (str == 'flipz')\n                          \t R = math.diag([1,1,-1,1]);\n                          if (str == 'cycle')\n                          \t R = math.matrix([[0,1,0,0],[0,0,1,0],[1,0,0,0],[0,0,0,1]]);\n                          if (str == 'pari')\n                          \t R = math.matrix([[0,0,1,0],[0,1,0,0],[1,0,0,0],[0,0,0,1]]);\n\n\n\t\t\t\t\t\t  KViewer.reorientationMatrix.matrix = math.multiply(KViewer.reorientationMatrix.matrix, math.inv(math.multiply(E,math.multiply(R,math.inv(E)))));\n\n                          signalhandler.send(\"reslice\");\n                          signalhandler.send(\"positionChange\");\n                         // KViewer.resetCrossHair();\n                    }\n                    \n\n\t\t\t\t\tif (str != undefined | ev.type == \"mousedown\")\n\t\t\t\t\t{\n\t\t\t\t\t\t$(document.body).off(\"mouseup mousedown\");\n\t\t\t\t\t}\n\n\t\t\t   }\n\t   }();\n\n\n\t   $menu.on(\"mousedown\", selFun);\n\n\t   return $menu;\n\n\n\n  }\n\n\n\n  // ======================================================================================\n  // viewer layout\n  // ======================================================================================\n\n\n  function setTableWidth(w)\n  {\n      var pt = $('#patientTableContainer');\n      var $ptable = $('#patientTableWrap');\n      var frame_width = $(document.body).width();\n      if (w == \"full\")\n      \tw = frame_width;\n      pt.width(w);\n\t  pt.children().width(w)\n\t  $ptable.width(w);\n  \t  setPatientTableLayout();\n\t  setViewPortLayout();\n      signalhandler.send(\"patientTableWidthChanged\");\n\n  }\n  KViewer.setTableWidth = setTableWidth;\n\n  /** callback called on grabbing the vertical bar left to viewports\n   * @inner */ \n  function resizeViewer(ev)\n  {\n    ev.preventDefault();\n\t  if (TableHidden)\n\t\t  toggleLeftBar();\n\n    var x = ev.clientX;\n    var pt = $('#patientTableContainer');\n    var $ptable = $('#patientTableWrap');\n    var w = pt.width();\n    var frame_width = $(document.body).width();\n\n    $ptable.css('overflow','hidden');\n    $ptable.css('pointer-events','none');\n    $(\"#KView_toolBarLeft\").css('pointer-events','none');\n\n    $(\".haircrossFocus\").hide();\n \n\n    $(document.body).on(\"mouseup mouseleave\",   mymouseup);\n//    $(document.body).on(\"mousemove\", moveUnlagger(mymousemove)) ;\n    $(document.body).on(\"mousemove\", mymousemove) ;\n    \n    function mymousemove(ev)\n    {\n\t\tif (mymousemove_sub.fired != undefined)\n\t\t{\n\t\t\tclearTimeout(mymousemove_sub.fired)\n\t\t}\n\t\tmymousemove_sub.fired = setTimeout(function() {\n\t\t\tmymousemove_sub(ev);\n\t\t\tmymousemove_sub.fired = undefined;\n\t\t},0);\n    }\n\n    function mymousemove_sub(ev)\n    {\n\n\t\t   var nx =  ev.clientX;\n\t\t   \n\t\t   var jumpPoint = 50;\n\t\t   var _w = w- (x - nx);\n\n\t\t   if (_w < jumpPoint & w > 0)\n\t\t   {\n\t\t\t   //$(\"#patientTableTopTools\").hide();\n\t\t\t\t_w = 1;\n\t\t\t   $('.annotation_tool').css('overflow', 'hidden')\n\t\t   }\n\t\t   else\n\t\t   {\n\t\t   \t\t$('.annotation_tool').css('overflow', 'initial')\n\t\t       //$(\"#patientTableTopTools\").show();\n\t\t   }\n\t\t   \n\t\t   if (w-(x - nx) > 0.95*frame_width)\n\t\t\t  nx = frame_width-w+x-40;\n\n\t\t   if (_w < 1) \n\t\t   \t  _w = 1;\n\t\t   pt.width(_w);\n\t\t   pt.children().width(_w);\n\t\t   $ptable.width(_w);\n\t\t   setPatientTableLayout();\n\t\t   setViewPortLayout();\n\t\t   signalhandler.send(\"positionChange\");\n    \t   signalhandler.send(\"patientTableWidthChanged\"); \n\n\n           if (commandDialog && commandDialog.visible)\n               commandDialog.fitIntoVP();\n\n \n    }\n\n\n    function mymouseup(ev)\n    {\n    \tViewerSettings.sizeTablePercent =  Math.round($ptable.width() / $(document.body).width() * 100);\n    \t\n        $(document.body).off(\"mousemove mouseup mouseleave\");\n        setPatientTableLayout();\n        setViewPortLayout();\n        signalhandler.send(\"positionChange\");\n    \t   signalhandler.send(\"patientTableWidthChanged\"); \n\n        $ptable.css('overflow','auto');\n        $ptable.css('pointer-events','all');\n        $(\"#KView_toolBarLeft\").css('pointer-events','all');\n        \n        ev.preventDefault();\n\n        if (commandDialog && commandDialog.visible)\n             commandDialog.fitIntoVP();\n\n\n    }\n  }\n\n   \n\n\n\n  $(window).resize(function(ev) {\n\n       if (ev.target.toString() == \"[object Window]\" || ev.target.toString() == \"[object global]\")\n       {\n\n          setPatientTableLayout();\n          setViewPortLayout();\n          signalhandler.send(\"positionChange\");\n          if (commandDialog && commandDialog.visible)\n             commandDialog.fitIntoVP();\n          \n       }\n  });\n\n  /** hides first all viewports and shows then only the visible ones\n   * @inner */ \n  function reattachViewports()\n  {\n  \tfor (var k = 0; k < 22;k++)\n  \t{\n  \t\tif (viewports[k] != undefined)\n  \t\t{\n\t\t\tviewports[k].$container.hide();\n\t\t\tviewports[k].visible = false;\n  \t\t}\n  \t}\n\n    nVisibleViewports = ViewerSettings.nVisibleRows*ViewerSettings.nVisibleCols;\n\n    for (var k = 0; k < ViewerSettings.nVisibleVertports; k++)\n    {\n      viewports[20+k].$container.appendTo($viewportContainer);\n      viewports[20+k].$container.css('position',\"absolute\");      \n      viewports[20+k].$container.show();\t\t\t\n      viewports[20+k].visible = true;\t\n    }\n\n    for(var k=0;k<nVisibleViewports;k++)\n    {\n      var ck = math.floor(k/ViewerSettings.nVisibleCols);\n      var rk = k%ViewerSettings.nVisibleCols;\n      viewports[vpAssignment[ck][rk]].$container.appendTo($viewportContainer);\n      viewports[vpAssignment[ck][rk]].$container.show();\t\t\t\n      viewports[vpAssignment[ck][rk]].visible = true;\t\t\t\n    }\n    for (var k = 0; k < ViewerSettings.nVisibleBarports; k++)\n    {\n      viewports[15+k].$container.appendTo($viewportContainer);\n      viewports[15+k].$container.show();\t\t\t\n      viewports[15+k].visible = true;\t\n    }\n\n   \n\n  }\n\n  /** layouts widths and heights of viewports\n   * @inner */ \n  that.setViewPortLayout = setViewPortLayout;\n  function setViewPortLayout(m)\n  {\n  \t\n    if(typeof(m)!=='undefined')\n    {    \n    \tViewerSettings.nVisibleRows = m[0];\n    \tViewerSettings.nVisibleCols = m[1];\n\n\t\tfor(var k=0;k<ViewerSettings.nVisibleRows*ViewerSettings.nVisibleCols;k++)\n\t\t{\n\t\t  var ck = math.floor(k/ViewerSettings.nVisibleCols);\n\t\t  var rk = k%ViewerSettings.nVisibleCols;\n\t\t  viewports[vpAssignment[ck][rk]].width_in_perc = Math.round(100/ViewerSettings.nVisibleCols);\n\t\t}\n\n    }\n\n\n    if (KViewer.zoomedViewport == -1) \n\t\treattachViewports();\n\t\t\n    nVisibleViewports = ViewerSettings.nVisibleRows*ViewerSettings.nVisibleCols;\n\n    var nVisibleBarports = ViewerSettings.nVisibleBarports;\n  \n\n\tif (ViewerSettings.nVisibleVertports >= 1)\n    \tViewerSettings.nVisibleVertports = 1;\n\n\tif (typeof ViewerSettings.barportSizePercent == \"undefined\")\n\t\tViewerSettings.barportSizePercent = 20*ViewerSettings.nVisibleBarports;\n\tif (typeof ViewerSettings.barportSizePercent == \"string\")\n\t\tViewerSettings.barportSizePercent = parseFloat(ViewerSettings.barportSizePercent);\n\n\n    var vwidth;\n    var vheight;\n\n\tvar wid_offs = 0;\n    \n    //if (toolBarLeftVisible)\n    if ($(\"#KView_toolBarLeft\").css('display')!=\"none\")\n     \t\twid_offs= 40;\n \n    if (!that.standalone)\n    {\n    \tvwidth = $(\"#frame\").width()-$(\"#patientTableContainer\").width()-wid_offs;\n    \tvheight = $(\"#frame\").height()-5;\n    }\n    else\n    {\n\t\tvwidth = that.$parentContainer.width()-wid_offs;\n\t\tvheight = that.$parentContainer.height()\n    }\n \n \n    var tWidth  = (vwidth/ViewerSettings.nVisibleCols);\n    var tHeight;\n    if (nVisibleBarports == 0)\n\t\ttHeight = vheight /(ViewerSettings.nVisibleRows);\n    else\n    \ttHeight = (vheight*(1- ViewerSettings.barportSizePercent/100)) /(ViewerSettings.nVisibleRows);\n\n\tvar $vpcontainer = $(\"#KView_viewportContainer\");\n\tvar vertport_width = viewports[20].width_in_perc;\n\tif (ViewerSettings.nVisibleVertports > 0 && KViewer.zoomedViewport == -1)\n\t{\n\t\t$vpcontainer.width((vwidth+1)*(1-vertport_width/100));\n\t\t$vpcontainer.css('left',vertport_width/100*(vwidth+1));\n\t}\n\telse\n\t{\n\t\t$vpcontainer.width((vwidth+1));\n\t\t$vpcontainer.css('left',0);\n\t}\n\t$vpcontainer.height(vheight+1);\n\n\t// not working for ff\n\t//var margin = parseInt(viewports[0].$container.css('border-width')) + parseInt(viewports[0].$container.css('margin'))\n    var margin = 1;\n    \n\tif (!KViewer.standalone)\n\t{\n\n    \t$zoomedPortContainer.width($zoomedPortContainer.parent().width()-margin*2);\n    \t$zoomedPortContainer.height($zoomedPortContainer.parent().height()-margin*2);\n    }\n\telse\n\t{\n\n\t\t$zoomedPortContainer.css(\"top\",0)\n\t\t$zoomedPortContainer.css(\"left\",0)\n\t\t$zoomedPortContainer.width(\"99%\")\n        $zoomedPortContainer.height(\"99%\")\n/*\n\t\t  $zoomedPortContainer.width(window.innerWidth-8 );\n\t\t  $zoomedPortContainer.height(window.innerHeight-8 );\n\t\t  var rec = $zoomedPortContainer.parent().get(0).getBoundingClientRect()\n\t\t  $zoomedPortContainer.css('top',-rec.top-8);\n\t\t  $zoomedPortContainer.css('left',-rec.left+30);*/\n\t}   \n\n    function layoutport(portID,wid,hei)\n    {\n      if (KViewer.zoomedViewport == -1) //!viewports[portID].isZoomed())\n      {\n        viewports[portID].$container.css('width',wid);\n   //     viewports[portID].$container.width(wid);\n        viewports[portID].$container.height(hei);        \n      }\n      else\n      {\n      \t  if (viewports[portID].isZoomed())\n      \t  {\n\t\t\t  viewports[portID].$container.css('width',\"100%\");\n\t\t\t  viewports[portID].$container.css('height',\"100%\");\n\t\t\t  viewports[portID].$container.css('left',0);\n      \t  }\n      \t  else\n      \t  {\n      \t  \t  var w = $(\"#patientTableContainer\").width()-5;\n      \t  \t  var h = (w>220)?220:w;\n\t\t\t  viewports[portID].$container.css('width',w);\n\t\t\t  viewports[portID].$container.css('height',h);\n      \t  }\n      }\n        viewports[portID].visible = true;\n        if (viewports[portID].getCurrentViewer())\n        {\n            viewports[portID].getCurrentViewer().setInnerLayout();        \n        }\n    \n    }\n\n\n\n\n\n    for(var k=0;k<nVisibleViewports;k++)\n    {\n      var ck = math.floor(k/ViewerSettings.nVisibleCols);\n      var rk = k%ViewerSettings.nVisibleCols;\n      var portID = vpAssignment[ck][rk]\n      layoutport(portID,(viewports[portID].width_in_perc  -2) + '%',  tHeight-2*margin)      \n    }\n\n \tfor(var k=0;k<ViewerSettings.nVisibleBarports;k++)\n\t    layoutport(15+k,'98%', vheight*ViewerSettings.barportSizePercent/100/nVisibleBarports-2*margin);\n\n    for(var k=0;k<ViewerSettings.nVisibleVertports;k++)\n    {\n       viewports[20+k].$container.css('left',-vertport_width/100*(vwidth+1));\n\t   layoutport(20+k,vertport_width/100*(vwidth+1)+'px', vheight-2*margin);\n    }\n\n    signalhandler.send(\"layoutHisto\");\n\n  }\n\n\n  // ======================================================================================\n  // state toggler\n  // ======================================================================================\n\n  function togglePixelated()\n  {   \n      $pixelatedToggle.toggleClass('KView_tool_enabled');\n      $('.KViewPort_canvas').toggleClass('KViewPort_canvas_pixelated');                          \n  }\n\n\n  function toggleInfobar()\n  {\n    $infobarToggle.toggleClass('KView_tool_enabled');\n    if(that.showInfoBar == false)\n       that.showInfoBar = true;\n    else\n       that.showInfoBar = false;\n    signalhandler.send(\"updateInfoBar\");\n  }\n  that.toggleInfobar = toggleInfobar;\n\n\n  function toggleGlobalCoordinates()\n  {\n  \t$globalCoordinatesToggle.toggleClass('fa-check');\n    that.globalCoordinates = !that.globalCoordinates;\n\tsignalhandler.send(\"positionChange\", {mosaicdraw: true} );\n  }\n\n\n  function toggleCrossHair()\n  {\n    $crossHairToggle.toggleClass('KView_tool_enabled');\n    if(that.crosshairMode == false)\n       that.crosshairMode = true;\n    else\n       that.crosshairMode = false;\n    signalhandler.send(\"drawHairCross\");\n  }\n\n  function toggleHistogram()\n  {\n    $histoToggle.toggleClass('KView_tool_enabled');\n    if(that.histoMode == false)\n       that.histoMode = true;\n    else\n       that.histoMode = false;\n    signalhandler.send(\"layoutHisto\");\n  }\n\n\n\n  function toggleElementsForScreenShot()\n    {\n      function tog(vis)\n      {\n          $(\".KViewPort_container\").toggleClass('noBorder');\n\t\t  viewports.forEach(function(e) {\n\t\t\tif(e.getCurrentViewer() != undefined)\n\t\t\t{\n\t\t\t if (e.getCurrentViewer().viewerType == 'medViewer')\n\t\t\t {\n\t\t\t   if (vis)\n\t\t\t   \t  e.getCurrentViewer().showControls();\n\t\t\t   else\n\t\t\t   \t  e.getCurrentViewer().hideControls();\n\t\t\t }\n\t\t\t}      \t});\n      }\n      controlsOn = !controlsOn;\n\t  tog(controlsOn);\n    }\n  that.toggleElementsForScreenShot = toggleElementsForScreenShot;\n\n\n\n\n\n  that.getCurrentViewerContent = function(type)\n  {\n    var objs = {};\n    for(var k = 0; k < viewports.length; k++)\n    {\n      var viewer = viewports[k].getCurrentViewer();\n      if (viewer != undefined)\n     \t if(viewer.viewerType == type )\n     \t {\n          \tvar obj = viewer.content;\n          \tobjs[viewer.currentFileID] = obj;\n     \t }\n    }\n    return objs;\n  }\n\n\n\n\n  function toggleLeftBar()\n  {\n    var any_ktool_enabled = false;\n    for (var k = 0; k < ktoolslist.length;k++) any_ktool_enabled = any_ktool_enabled | ktoolslist[k].enabled ;\n\n    toggleTableHide();\n\n    if (!any_ktool_enabled)\n        ktoolslist[0].toggle();\n\n  }\n\n\n  function toggleTableHide()\n  {\n    var tableContainer = $(\"#patientTableContainer\");\n    if (!TableHidden)\n    {\n      tableContainer = $(\"#patientTableContainer\").detach();\n      setViewPortLayout();\n      $(\"#KView_viewportContainer\").css(\"width\",\"100%\");\n      TableHidden = true;\n      signalhandler.send(\"positionChange\")\n    }\n    else\n    {\n\n      $(tableContainer).prependTo($(\"#container\"));\n      setViewPortLayout();\n      setPatientTableLayout();\n      TableHidden = false;\n      signalhandler.send(\"positionChange\")\n\n\n    }\n  }\n  that.toggleTableHide = toggleTableHide;\n\n\n    // some settings we do not want to change ofter. These might go into a general config, or into the viewer settings in future\n\tthat.static = {};\n\tthat.static.mousespeed_zoom = 1;\n\tthat.static.mousespeed_clims  = 1;\n\tthat.static.mousespeed_roipensize = 1;\n\tthat.static.lazydraw_timeout = 150;\n\n  that.applyState = function()\n  { \n\n    // this should be kept as own copy, can be overwritten by auto find \n      that.defaultFOV_mm  = ViewerSettings.defaultFOVwidth_mm;\n      that.crosshairMode = ViewerSettings.crosshairModeDefault;\n      that.histoMode = ViewerSettings.histoModeDefault;\n      that.showInfoBar = ViewerSettings.showInfoBar;\n      that.toggleMainViewport(ViewerSettings.mainViewport, true);\n      that.globalCoordinates = ViewerSettings.globalCoordinates;\n\n\n      if (!that.globalCoordinates) \t\n\t\t\t$globalCoordinatesToggle.removeClass('fa-check');\n      if (!that.histoMode)\t\t  \n        $histoToggle.removeClass('KView_tool_enabled');\n      else \n        $histoToggle.addClass('KView_tool_enabled');        \n      if (!that.crosshairMode) \t\n        $crossHairToggle.removeClass('KView_tool_enabled');\n      else\n        $crossHairToggle.addClass('KView_tool_enabled');\n      if (!that.showInfoBar)\n        $infobarToggle.removeClass('KView_tool_enabled');\n      else \n         $infobarToggle.addClass('KView_tool_enabled');\n\n\n       $Csystem_ul.find(\".fa-check\").removeClass(\"fa-check\");\n       $Csystem_ul.find(\"li[id='\"+ViewerSettings.permOrder +\"']\").children().addClass('fa-check')\n\n\n       autoloader_toggle(state.viewer.enableAutoloaders);\n     \n       reattachViewports(); \n       setViewPortLayout([ViewerSettings.nVisibleRows, ViewerSettings.nVisibleCols]);\n       signalhandler.send(\"positionChange\");\n  }\n\n  // this will put the local settings (that....) to state.viewer such that these variables will be stored in the state\n  that.saveState = function()\n  {\n\t  ViewerSettings.defaultFOV_mm \t \t\t=  that.defaultFOVwidth_mm;\n      ViewerSettings.crosshairModeDefault \t=  that.crosshairMode;\n      ViewerSettings.histoModeDefault \t\t=  that.histoModeDefault;\n      ViewerSettings.showInfoBar\t\t\t=  that.showInfoBar;\n      ViewerSettings.globalCoordinates \t\t=  that.globalCoordinates;\n\n  }\n  \n  that.applyNewViewportLayout = function()\n  { \n    setViewPortLayout([ViewerSettings.nVisibleRows,ViewerSettings.nVisibleCols]);\n    signalhandler.send(\"positionChange\");\n  }\n\n\n\n\n  //////////////////////////////////// take a screenshot /////////////////\n  function takeScreenshot(ev)\n  {\n  \n      toggleElementsForScreenShot();\n      $(\".KViewPort_container\").addClass('noBorder');\n\n      html2canvas($viewportContainer).then(function(canvas)\n      {\n         var blob = dataURItoBlob(canvas.toDataURL());\n\t\t saveScreenShot(blob,{});\n       \n      });\n   \n      toggleElementsForScreenShot();\n      $(\".KViewPort_container\").removeClass('noBorder');\n  }\n\n\n\n  //loadTestFileOnStartup(); /// load a test file\n  function loadTestFileOnStartup()\n  {\n    var myownurl = window.location.href.split('?')[0];\n    var params = new Object();\n    params.URLType  = 'serverfile';\n    params.fileID    = '45';\n    viewports[0].openFile(params);\n\n  }\n\n  /** closes all content \n   * @function\n   */\n  function closeAll(callbackIfYes, whattoclose_in)\n  {\n  \t\n  \t// we can control what to close, can eg be set in autoloader\n  \tvar whattoclose = \n  \t{\n  \t\tmarkerProxy: 1,\n  \t\tdataManager: 1,\n  \t}\n  \twhattoclose = $.extend(0, whattoclose, whattoclose_in)\n\n    var unsaved = unsavedChanges();\n    if(unsaved)\n    {\n\t\talertify.confirm(\"Are you sure to close the current view, there are unsaved \" + unsaved + \"!\",function(e)\n\t\t{\n\t\t\tif (e) {  doIt(); }\n\t\t});\n    }\n\telse\n\t   doIt();\n\n\tfunction doIt()\n\t{\n\n\t\tif (KViewer.zoomedViewport != -1)\n\t\t\tKViewer.unZoomViewport();\n\n\t\tif( whattoclose.markerProxy == 1 && markerProxy != undefined)\n\t\t\tmarkerProxy.reset();  \n\n\t\tsignalhandler.send(\"close\");\n\t\tif ( whattoclose.dataManager && ( userinfo.username != guestuser || electron) )\n\t\t\tKViewer.dataManager.clearMemory();\n\n\t\tthat.defaultFOV_mm = state.viewer.defaultFOVwidth_mm;\n\n\t//\tKViewer.resetCrossHair();\t\t\t\t\n\t\tthat.currentPoint.reset = true\n\t\n\n\t\tfor (var k in KPanel.currentPanels)\n\t\t{\n\t\t\tif (KPanel.currentPanels[k].closeOnCloseAll)\n\t\t\t\tKPanel.currentPanels[k].close();\n\t\t}\n\n\t\tif (KViewer.roiTool && KViewer.roiTool.closePolyTool)\n\t\t    KViewer.roiTool.closePolyTool();\n\n\n        that.movie.currentTimePoint = 0;\n\n\t\tif(callbackIfYes)\n\t\t\tcallbackIfYes();\n\t}\n\n  }  \n  that.closeAll = closeAll;        \n\n\n\tthat.findAllViews = function(type)\n\t{\n\t\tvar fvs = [];\n\t\tthat.iterateMedViewers(function(m)\n\t\t{\n\t\t\tif (m.objects3D)\n\t\t\t\tfor (var k = 0 ; k < m.objects3D.length; k++)\n\t\t\t\t{\n\t\t\t\t\tif (m.objects3D[k][type])\n\t\t\t\t\t\tfvs.push(m.objects3D[k]);\n\t\t\t\t}\n\n\t\t});\n\n\t\treturn fvs;\n\n\t}\n\n\t// ======================================================================================\n\t// Tools\n\t// ======================================================================================\n\t// Tools should in general be defined via the ToolProxy. This way, they are only \"truly\" created when needed -> save memory and startup time\n\n\n\t/** the local files manager {@link KCacheManager} */\n\tthat.cacheManager = ToolProxy('cacheManager',\"KCacheManager\",'Local Files');\n\t/** the local files manager {@link KRoiTool} */\n\tif (typeof KRoiTool != \"undefined\")\n\t\tthat.roiTool = ToolProxy('roiTool',\"KRoiTool\",'ROIs');\n\t/** the 3dobj manager {@link KObject3DTool} */\n\tif (typeof KObject3DTool != \"undefined\")\n\t\tthat.obj3dTool = ToolProxy('obj3dTool',\"KObject3DTool\",'Objects 3D');\n\t/** the atlas tool {@link KAtlasTool} */\n\tif (typeof KAtlasTool != \"undefined\")\n\t\tthat.atlasTool = ToolProxy('atlasTool',\"KAtlasTool\",'Atlas');\n\t/** to manage forms {@link KFormManager} */\n\tif (typeof KFormManager != \"undefined\")\n\t\tthat.formManager = ToolProxy('formManager',\"KFormManager\",'Forms');\n\t/** tha markers points tool {@link KAnnotationTool} */\n\t//that.annotationTool = ToolProxy('annotationTool',KAnnotationTool,'Stereotaxy');\n\t/** tha markers points tool {@link KAnnotationTool} */\n\tif (typeof KMarkerTool != \"undefined\")\n\t\tthat.markerTool = ToolProxy('markerTool',\"KMarkerTool\",'MarkerTool');\n\t/** navi tool {@link KNavigationTool} */\n\tif (typeof KNavigationTool != \"undefined\")\n\t\tthat.navigationTool = ToolProxy('navigationTool',\"KNavigationTool\",'Navigation');\n\t/** curve tool {@link KNavigationTool} */\n\tif (typeof KMedImgCurve != \"undefined\")\n\t\tthat.curveTool = ToolProxy('curveTool',\"KMedImgCurve\",'CurveTool');\n\t/** roi tool {@link KNavigationTool} */\n\n    if (!electron)\n    {\n\t\tif (typeof KReadingTool != \"undefined\")\n\t\t\tthat.readingTool = ToolProxy('readingTool', \"KReadingTool\",'ReadingTool');\n    }\n\n  \t// create the menu with the tools\n  \tKToolWindow.attachToolSelectors($toolbarContainer);\n\n\n\n  // ======================================================================================\n  // Additional tool shortcuts\n  // ======================================================================================\n    var $roiToolToggle =  $(\"<div  class='KView_tool '><i  class='fa fa-pencil fa-1x'></i></div>\").appendTo($toolbarContainer)\n                           .click( function(){that.roiTool.toggle()} )\n                           .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>RoiTool</li>\") )\n                           );\n\n                          \n                               \n    if (!electron && application != \"webview\")\n    {\n\t\tvar $readings =  $(\"<div  class='KView_tool '><i  class='fa fa-registered fa-1x'></i></div>\").appendTo($toolbarContainer)\n\t\t\t\t\t\t\t   .click( function(){that.readingTool.toggle() } )\n\t\t\t\t\t\t\t   .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>ReadingTool</li>\") )\n\t\t\t\t\t\t\t\t   );\n    }\n\n\n\tif (typeof KMarkerTool != \"undefined\")\n\t\tvar $rulerTool =  $(\"<div  class='KView_tool '><i  class='fa fa-arrows-h fa-1x'></i></div>\").appendTo($toolbarContainer)\n\t\t\t\t\t\t\t   .click( function(){markerProxy.addRuler()} )\n\t\t\t\t\t\t\t   .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Ruler</li>\") )\n\t\t\t\t\t\t\t\t   );\n\n\tif (typeof ironSight != \"undefined\")\n\t\tvar $iron =  $(\"<div  class='KView_tool '><i  class='fa fa-crosshairs fa-1x'></i></div>\").appendTo($toolbarContainer)\n\t\t\t\t\t\t\t   .click( function(){ironSight.toggle()} )\n\t\t\t\t\t\t\t   .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>IronSight Tool</li>\") )\n\t\t\t\t\t\t\t\t   );\n    that.$iron = $iron\n\n\tif (electron)\n\t{\n\n\t\tvar $settingsbutton =  $(\"<div  class='KView_tool '><i  class='fa fa-bars fa-1x'></i></div>\").appendTo($toolbarContainer)\n\t\t\t\t\t\t\t   .click( function(){\n\t\t\t\t\t\t\t\tsettingsDialog.dialog.toggle()\n\n\t\t\t\t\t\t\t   } )\n\t\t\t\t\t\t\t   .append( $(\"<ul class='KView_tool_menu'></ul>\").append($(\"<li>Settings</li>\") )\n\t\t\t\t\t\t\t\t   );\n\t\tvar ipc = require('electron').ipcRenderer;\n\t    ipc.on('settings', function() { settingsDialog.dialog.toggle() } )\n\t}\n\n  \n\n\treturn that;\n\n\n}\n\n\n\n/** @function  */\nfunction createParamsLocalFile(file, intent, progressSpinner)\n{\n\n  file.name = file.name.replace(/\\\\/g,\"/\");\n\n\t\n  var params = {};\n  params.URLType  = 'localfile';\n  params.fileID = 'localfile_'   + file.name ;\n\n  runningID++;\n  params.filename = 'localfile://' + file.name;\n  params.file   = file\n  params.intent = intent;\n\n  // drop as roi if filename indicates a roi\n  if(file.name.search('\\\\.nii') > 0 | file.name.search('\\\\.mgh') > 0  | file.name.search('\\\\.mgz') > 0)\n\t  if( file.name.search(/mask/) != -1 || file.name.search(/roi/) != -1 )\n\t  {\n\t\tif(params,intent == undefined)\n\t\t\tparams.intent = {};\n\t\tparams.intent.roi = 1\n\n\t  }\n\n  if(progressSpinner)\n\tparams.progressSpinner = progressSpinner;\n\n  return params;\n\n}\n\n\n\ndocument.addEventListener(\"keydown\", function(evt) {\n  evt = evt || window.event;\n  if ( evt.keyCode == 17)\n  {\n     signalhandler.send(\"hairfocus_receive_event\");\n  }\n});\n\n\ndocument.addEventListener(\"keyup\",function(evt) {\n  evt = evt || window.event;\n  if (evt.keyCode == 17 )\n   \t signalhandler.send(\"hairfocus_ignore_event\");\n});\n\n\n\n"},function(t,n){t.exports="/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright\n notice, this list of conditions and the following disclaimer in\n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS'' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n(function(obj) {\n\t\"use strict\";\n\n\tvar ERR_BAD_FORMAT = \"File format is not recognized.\";\n\tvar ERR_CRC = \"CRC failed.\";\n\tvar ERR_ENCRYPTED = \"File contains encrypted entry.\";\n\tvar ERR_ZIP64 = \"File is using Zip64 (4gb+ file size).\";\n\tvar ERR_READ = \"Error while reading zip file.\";\n\tvar ERR_WRITE = \"Error while writing zip file.\";\n\tvar ERR_WRITE_DATA = \"Error while writing file data.\";\n\tvar ERR_READ_DATA = \"Error while reading file data.\";\n\tvar ERR_DUPLICATED_NAME = \"File already exists.\";\n\tvar CHUNK_SIZE = 512 * 1024;\n\t\n\tvar TEXT_PLAIN = \"text/plain\";\n\n\tvar appendABViewSupported;\n\ttry {\n\t\tappendABViewSupported = new Blob([ new DataView(new ArrayBuffer(0)) ]).size === 0;\n\t} catch (e) {\n\t}\n\n\tfunction Crc32() {\n\t\tthis.crc = -1;\n\t}\n\tCrc32.prototype.append = function append(data) {\n\t\tvar crc = this.crc | 0, table = this.table;\n\t\tfor (var offset = 0, len = data.length | 0; offset < len; offset++)\n\t\t\tcrc = (crc >>> 8) ^ table[(crc ^ data[offset]) & 0xFF];\n\t\tthis.crc = crc;\n\t};\n\tCrc32.prototype.get = function get() {\n\t\treturn ~this.crc;\n\t};\n\tCrc32.prototype.table = (function() {\n\t\tvar i, j, t, table = []; // Uint32Array is actually slower than []\n\t\tfor (i = 0; i < 256; i++) {\n\t\t\tt = i;\n\t\t\tfor (j = 0; j < 8; j++)\n\t\t\t\tif (t & 1)\n\t\t\t\t\tt = (t >>> 1) ^ 0xEDB88320;\n\t\t\t\telse\n\t\t\t\t\tt = t >>> 1;\n\t\t\ttable[i] = t;\n\t\t}\n\t\treturn table;\n\t})();\n\t\n\t// \"no-op\" codec\n\tfunction NOOP() {}\n\tNOOP.prototype.append = function append(bytes, onprogress) {\n\t\treturn bytes;\n\t};\n\tNOOP.prototype.flush = function flush() {};\n\n\tfunction blobSlice(blob, index, length) {\n\t\tif (index < 0 || length < 0 || index + length > blob.size)\n\t\t\tthrow new RangeError('offset:' + index + ', length:' + length + ', size:' + blob.size);\n\t\tif (blob.slice)\n\t\t\treturn blob.slice(index, index + length);\n\t\telse if (blob.webkitSlice)\n\t\t\treturn blob.webkitSlice(index, index + length);\n\t\telse if (blob.mozSlice)\n\t\t\treturn blob.mozSlice(index, index + length);\n\t\telse if (blob.msSlice)\n\t\t\treturn blob.msSlice(index, index + length);\n\t}\n\n\tfunction getDataHelper(byteLength, bytes) {\n\t\tvar dataBuffer, dataArray;\n\t\tdataBuffer = new ArrayBuffer(byteLength);\n\t\tdataArray = new Uint8Array(dataBuffer);\n\t\tif (bytes)\n\t\t\tdataArray.set(bytes, 0);\n\t\treturn {\n\t\t\tbuffer : dataBuffer,\n\t\t\tarray : dataArray,\n\t\t\tview : new DataView(dataBuffer)\n\t\t};\n\t}\n\n\t// Readers\n\tfunction Reader() {\n\t}\n\n\tfunction TextReader(text) {\n\t\tvar that = this, blobReader;\n\n\t\tfunction init(callback, onerror) {\n\t\t\tvar blob = new Blob([ text ], {\n\t\t\t\ttype : TEXT_PLAIN\n\t\t\t});\n\t\t\tblobReader = new BlobReader(blob);\n\t\t\tblobReader.init(function() {\n\t\t\t\tthat.size = blobReader.size;\n\t\t\t\tcallback();\n\t\t\t}, onerror);\n\t\t}\n\n\t\tfunction readUint8Array(index, length, callback, onerror) {\n\t\t\tblobReader.readUint8Array(index, length, callback, onerror);\n\t\t}\n\n\t\tthat.size = 0;\n\t\tthat.init = init;\n\t\tthat.readUint8Array = readUint8Array;\n\t}\n\tTextReader.prototype = new Reader();\n\tTextReader.prototype.constructor = TextReader;\n\n\tfunction Data64URIReader(dataURI) {\n\t\tvar that = this, dataStart;\n\n\t\tfunction init(callback) {\n\t\t\tvar dataEnd = dataURI.length;\n\t\t\twhile (dataURI.charAt(dataEnd - 1) == \"=\")\n\t\t\t\tdataEnd--;\n\t\t\tdataStart = dataURI.indexOf(\",\") + 1;\n\t\t\tthat.size = Math.floor((dataEnd - dataStart) * 0.75);\n\t\t\tcallback();\n\t\t}\n\n\t\tfunction readUint8Array(index, length, callback) {\n\t\t\tvar i, data = getDataHelper(length);\n\t\t\tvar start = Math.floor(index / 3) * 4;\n\t\t\tvar end = Math.ceil((index + length) / 3) * 4;\n\t\t\tvar bytes = obj.atob(dataURI.substring(start + dataStart, end + dataStart));\n\t\t\tvar delta = index - Math.floor(start / 4) * 3;\n\t\t\tfor (i = delta; i < delta + length; i++)\n\t\t\t\tdata.array[i - delta] = bytes.charCodeAt(i);\n\t\t\tcallback(data.array);\n\t\t}\n\n\t\tthat.size = 0;\n\t\tthat.init = init;\n\t\tthat.readUint8Array = readUint8Array;\n\t}\n\tData64URIReader.prototype = new Reader();\n\tData64URIReader.prototype.constructor = Data64URIReader;\n\n\tfunction BlobReader(blob) {\n\t\tvar that = this;\n\n\t\tfunction init(callback) {\n\t\t\tthat.size = blob.size;\n\t\t\tcallback();\n\t\t}\n\n\t\tfunction readUint8Array(index, length, callback, onerror) {\n\t\t\tvar reader = new FileReader();\n\t\t\treader.onload = function(e) {\n\t\t\t\tcallback(new Uint8Array(e.target.result));\n\t\t\t};\n\t\t\treader.onerror = onerror;\n\t\t\ttry {\n\t\t\t\treader.readAsArrayBuffer(blobSlice(blob, index, length));\n\t\t\t} catch (e) {\n\t\t\t\tonerror(e);\n\t\t\t}\n\t\t}\n\n\t\tthat.size = 0;\n\t\tthat.init = init;\n\t\tthat.readUint8Array = readUint8Array;\n\t}\n\tBlobReader.prototype = new Reader();\n\tBlobReader.prototype.constructor = BlobReader;\n\n\t// Writers\n\n\tfunction Writer() {\n\t}\n\tWriter.prototype.getData = function(callback) {\n\t\tcallback(this.data);\n\t};\n\n\tfunction TextWriter(encoding) {\n\t\tvar that = this, blob;\n\n\t\tfunction init(callback) {\n\t\t\tblob = new Blob([], {\n\t\t\t\ttype : TEXT_PLAIN\n\t\t\t});\n\t\t\tcallback();\n\t\t}\n\n\t\tfunction writeUint8Array(array, callback) {\n\t\t\tblob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {\n\t\t\t\ttype : TEXT_PLAIN\n\t\t\t});\n\t\t\tcallback();\n\t\t}\n\n\t\tfunction getData(callback, onerror) {\n\t\t\tvar reader = new FileReader();\n\t\t\treader.onload = function(e) {\n\t\t\t\tcallback(e.target.result);\n\t\t\t};\n\t\t\treader.onerror = onerror;\n\t\t\treader.readAsText(blob, encoding);\n\t\t}\n\n\t\tthat.init = init;\n\t\tthat.writeUint8Array = writeUint8Array;\n\t\tthat.getData = getData;\n\t}\n\tTextWriter.prototype = new Writer();\n\tTextWriter.prototype.constructor = TextWriter;\n\n\tfunction Data64URIWriter(contentType) {\n\t\tvar that = this, data = \"\", pending = \"\";\n\n\t\tfunction init(callback) {\n\t\t\tdata += \"data:\" + (contentType || \"\") + \";base64,\";\n\t\t\tcallback();\n\t\t}\n\n\t\tfunction writeUint8Array(array, callback) {\n\t\t\tvar i, delta = pending.length, dataString = pending;\n\t\t\tpending = \"\";\n\t\t\tfor (i = 0; i < (Math.floor((delta + array.length) / 3) * 3) - delta; i++)\n\t\t\t\tdataString += String.fromCharCode(array[i]);\n\t\t\tfor (; i < array.length; i++)\n\t\t\t\tpending += String.fromCharCode(array[i]);\n\t\t\tif (dataString.length > 2)\n\t\t\t\tdata += obj.btoa(dataString);\n\t\t\telse\n\t\t\t\tpending = dataString;\n\t\t\tcallback();\n\t\t}\n\n\t\tfunction getData(callback) {\n\t\t\tcallback(data + obj.btoa(pending));\n\t\t}\n\n\t\tthat.init = init;\n\t\tthat.writeUint8Array = writeUint8Array;\n\t\tthat.getData = getData;\n\t}\n\tData64URIWriter.prototype = new Writer();\n\tData64URIWriter.prototype.constructor = Data64URIWriter;\n\n\tfunction BlobWriter(contentType) {\n\t\tvar blob, that = this;\n\n\t\tfunction init(callback) {\n\t\t\tblob = new Blob([], {\n\t\t\t\ttype : contentType\n\t\t\t});\n\t\t\tcallback();\n\t\t}\n\n\t\tfunction writeUint8Array(array, callback) {\n\t\t\tblob = new Blob([ blob, appendABViewSupported ? array : array.buffer ], {\n\t\t\t\ttype : contentType\n\t\t\t});\n\t\t\tcallback();\n\t\t}\n\n\t\tfunction getData(callback) {\n\t\t\tcallback(blob);\n\t\t}\n\n\t\tthat.init = init;\n\t\tthat.writeUint8Array = writeUint8Array;\n\t\tthat.getData = getData;\n\t}\n\tBlobWriter.prototype = new Writer();\n\tBlobWriter.prototype.constructor = BlobWriter;\n\n\t/** \n\t * inflate/deflate core functions\n\t * @param worker {Worker} web worker for the task.\n\t * @param initialMessage {Object} initial message to be sent to the worker. should contain\n\t *   sn(serial number for distinguishing multiple tasks sent to the worker), and codecClass.\n\t *   This function may add more properties before sending.\n\t */\n\tfunction launchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror) {\n\t\tvar chunkIndex = 0, index, outputSize, sn = initialMessage.sn, crc;\n\n\t\tfunction onflush() {\n\t\t\tworker.removeEventListener('message', onmessage, false);\n\t\t\tonend(outputSize, crc);\n\t\t}\n\n\t\tfunction onmessage(event) {\n\t\t\tvar message = event.data, data = message.data, err = message.error;\n\t\t\tif (err) {\n\t\t\t\terr.toString = function () { return 'Error: ' + this.message; };\n\t\t\t\tonreaderror(err);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (message.sn !== sn)\n\t\t\t\treturn;\n\t\t\tif (typeof message.codecTime === 'number')\n\t\t\t\tworker.codecTime += message.codecTime; // should be before onflush()\n\t\t\tif (typeof message.crcTime === 'number')\n\t\t\t\tworker.crcTime += message.crcTime;\n\n\t\t\tswitch (message.type) {\n\t\t\t\tcase 'append':\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\toutputSize += data.length;\n\t\t\t\t\t\twriter.writeUint8Array(data, function() {\n\t\t\t\t\t\t\tstep();\n\t\t\t\t\t\t}, onwriteerror);\n\t\t\t\t\t} else\n\t\t\t\t\t\tstep();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'flush':\n\t\t\t\t\tcrc = message.crc;\n\t\t\t\t\tif (data) {\n\t\t\t\t\t\toutputSize += data.length;\n\t\t\t\t\t\twriter.writeUint8Array(data, function() {\n\t\t\t\t\t\t\tonflush();\n\t\t\t\t\t\t}, onwriteerror);\n\t\t\t\t\t} else\n\t\t\t\t\t\tonflush();\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'progress':\n\t\t\t\t\tif (onprogress)\n\t\t\t\t\t\tonprogress(index + message.loaded, size);\n\t\t\t\t\tbreak;\n\t\t\t\tcase 'importScripts': //no need to handle here\n\t\t\t\tcase 'newTask':\n\t\t\t\tcase 'echo':\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tconsole.warn('zip.js:launchWorkerProcess: unknown message: ', message);\n\t\t\t}\n\t\t}\n\n\t\tfunction step() {\n\t\t\tindex = chunkIndex * CHUNK_SIZE;\n\t\t\t// use `<=` instead of `<`, because `size` may be 0.\n\t\t\tif (index <= size) {\n\t\t\t\treader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(array) {\n\t\t\t\t\tif (onprogress)\n\t\t\t\t\t\tonprogress(index, size);\n\t\t\t\t\tvar msg = index === 0 ? initialMessage : {sn : sn};\n\t\t\t\t\tmsg.type = 'append';\n\t\t\t\t\tmsg.data = array;\n\t\t\t\t\t\n\t\t\t\t\t// posting a message with transferables will fail on IE10\n\t\t\t\t\ttry {\n\t\t\t\t\t\tworker.postMessage(msg, [array.buffer]);\n\t\t\t\t\t} catch(ex) {\n\t\t\t\t\t\tworker.postMessage(msg); // retry without transferables\n\t\t\t\t\t}\n\t\t\t\t\tchunkIndex++;\n\t\t\t\t}, onreaderror);\n\t\t\t} else {\n\t\t\t\tworker.postMessage({\n\t\t\t\t\tsn: sn,\n\t\t\t\t\ttype: 'flush'\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\toutputSize = 0;\n\t\tworker.addEventListener('message', onmessage, false);\n\t\tstep();\n\t}\n\n\tfunction launchProcess(process, reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror) {\n\t\tvar chunkIndex = 0, index, outputSize = 0,\n\t\t\tcrcInput = crcType === 'input',\n\t\t\tcrcOutput = crcType === 'output',\n\t\t\tcrc = new Crc32();\n\t\tfunction step() {\n\t\t\tvar outputData;\n\t\t\tindex = chunkIndex * CHUNK_SIZE;\n\t\t\tif (index < size)\n\t\t\t\treader.readUint8Array(offset + index, Math.min(CHUNK_SIZE, size - index), function(inputData) {\n\t\t\t\t\tvar outputData;\n\t\t\t\t\ttry {\n\t\t\t\t\t\toutputData = process.append(inputData, function(loaded) {\n\t\t\t\t\t\t\tif (onprogress)\n\t\t\t\t\t\t\t\tonprogress(index + loaded, size);\n\t\t\t\t\t\t});\n\t\t\t\t\t} catch (e) {\n\t\t\t\t\t\tonreaderror(e);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tif (outputData) {\n\t\t\t\t\t\toutputSize += outputData.length;\n\t\t\t\t\t\twriter.writeUint8Array(outputData, function() {\n\t\t\t\t\t\t\tchunkIndex++;\n\t\t\t\t\t\t\tsetTimeout(step, 1);\n\t\t\t\t\t\t}, onwriteerror);\n\t\t\t\t\t\tif (crcOutput)\n\t\t\t\t\t\t\tcrc.append(outputData);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tchunkIndex++;\n\t\t\t\t\t\tsetTimeout(step, 1);\n\t\t\t\t\t}\n\t\t\t\t\tif (crcInput)\n\t\t\t\t\t\tcrc.append(inputData);\n\t\t\t\t\tif (onprogress)\n\t\t\t\t\t\tonprogress(index, size);\n\t\t\t\t}, onreaderror);\n\t\t\telse {\n\t\t\t\ttry {\n\t\t\t\t\toutputData = process.flush();\n\t\t\t\t} catch (e) {\n\t\t\t\t\tonreaderror(e);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\tif (outputData) {\n\t\t\t\t\tif (crcOutput)\n\t\t\t\t\t\tcrc.append(outputData);\n\t\t\t\t\toutputSize += outputData.length;\n\t\t\t\t\twriter.writeUint8Array(outputData, function() {\n\t\t\t\t\t\tonend(outputSize, crc.get());\n\t\t\t\t\t}, onwriteerror);\n\t\t\t\t} else\n\t\t\t\t\tonend(outputSize, crc.get());\n\t\t\t}\n\t\t}\n\n\t\tstep();\n\t}\n\n\tfunction inflate(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {\n\t\tvar crcType = computeCrc32 ? 'output' : 'none';\n\t\tif (obj.zip.useWebWorkers) {\n\t\t\tvar initialMessage = {\n\t\t\t\tsn: sn,\n\t\t\t\tcodecClass: 'Inflater',\n\t\t\t\tcrcType: crcType,\n\t\t\t};\n\t\t\tlaunchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);\n\t\t} else\n\t\t\tlaunchProcess(new obj.zip.Inflater(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);\n\t}\n\n\tfunction deflate(worker, sn, reader, writer, level, onend, onprogress, onreaderror, onwriteerror) {\n\t\tvar crcType = 'input';\n\t\tif (obj.zip.useWebWorkers) {\n\t\t\tvar initialMessage = {\n\t\t\t\tsn: sn,\n\t\t\t\toptions: {level: level},\n\t\t\t\tcodecClass: 'Deflater',\n\t\t\t\tcrcType: crcType,\n\t\t\t};\n\t\t\tlaunchWorkerProcess(worker, initialMessage, reader, writer, 0, reader.size, onprogress, onend, onreaderror, onwriteerror);\n\t\t} else\n\t\t\tlaunchProcess(new obj.zip.Deflater(), reader, writer, 0, reader.size, crcType, onprogress, onend, onreaderror, onwriteerror);\n\t}\n\n\tfunction copy(worker, sn, reader, writer, offset, size, computeCrc32, onend, onprogress, onreaderror, onwriteerror) {\n\t\tvar crcType = 'input';\n\t\tif (obj.zip.useWebWorkers && computeCrc32) {\n\t\t\tvar initialMessage = {\n\t\t\t\tsn: sn,\n\t\t\t\tcodecClass: 'NOOP',\n\t\t\t\tcrcType: crcType,\n\t\t\t};\n\t\t\tlaunchWorkerProcess(worker, initialMessage, reader, writer, offset, size, onprogress, onend, onreaderror, onwriteerror);\n\t\t} else\n\t\t\tlaunchProcess(new NOOP(), reader, writer, offset, size, crcType, onprogress, onend, onreaderror, onwriteerror);\n\t}\n\n\t// ZipReader\n\n\tfunction decodeASCII(str) {\n\t\tvar i, out = \"\", charCode, extendedASCII = [ '\\u00C7', '\\u00FC', '\\u00E9', '\\u00E2', '\\u00E4', '\\u00E0', '\\u00E5', '\\u00E7', '\\u00EA', '\\u00EB',\n\t\t\t\t'\\u00E8', '\\u00EF', '\\u00EE', '\\u00EC', '\\u00C4', '\\u00C5', '\\u00C9', '\\u00E6', '\\u00C6', '\\u00F4', '\\u00F6', '\\u00F2', '\\u00FB', '\\u00F9',\n\t\t\t\t'\\u00FF', '\\u00D6', '\\u00DC', '\\u00F8', '\\u00A3', '\\u00D8', '\\u00D7', '\\u0192', '\\u00E1', '\\u00ED', '\\u00F3', '\\u00FA', '\\u00F1', '\\u00D1',\n\t\t\t\t'\\u00AA', '\\u00BA', '\\u00BF', '\\u00AE', '\\u00AC', '\\u00BD', '\\u00BC', '\\u00A1', '\\u00AB', '\\u00BB', '_', '_', '_', '\\u00A6', '\\u00A6',\n\t\t\t\t'\\u00C1', '\\u00C2', '\\u00C0', '\\u00A9', '\\u00A6', '\\u00A6', '+', '+', '\\u00A2', '\\u00A5', '+', '+', '-', '-', '+', '-', '+', '\\u00E3',\n\t\t\t\t'\\u00C3', '+', '+', '-', '-', '\\u00A6', '-', '+', '\\u00A4', '\\u00F0', '\\u00D0', '\\u00CA', '\\u00CB', '\\u00C8', 'i', '\\u00CD', '\\u00CE',\n\t\t\t\t'\\u00CF', '+', '+', '_', '_', '\\u00A6', '\\u00CC', '_', '\\u00D3', '\\u00DF', '\\u00D4', '\\u00D2', '\\u00F5', '\\u00D5', '\\u00B5', '\\u00FE',\n\t\t\t\t'\\u00DE', '\\u00DA', '\\u00DB', '\\u00D9', '\\u00FD', '\\u00DD', '\\u00AF', '\\u00B4', '\\u00AD', '\\u00B1', '_', '\\u00BE', '\\u00B6', '\\u00A7',\n\t\t\t\t'\\u00F7', '\\u00B8', '\\u00B0', '\\u00A8', '\\u00B7', '\\u00B9', '\\u00B3', '\\u00B2', '_', ' ' ];\n\t\tfor (i = 0; i < str.length; i++) {\n\t\t\tcharCode = str.charCodeAt(i) & 0xFF;\n\t\t\tif (charCode > 127)\n\t\t\t\tout += extendedASCII[charCode - 128];\n\t\t\telse\n\t\t\t\tout += String.fromCharCode(charCode);\n\t\t}\n\t\treturn out;\n\t}\n\n\tfunction decodeUTF8(string) {\n\t\treturn decodeURIComponent(escape(string));\n\t}\n\n\tfunction getString(bytes) {\n\t\tvar i, str = \"\";\n\t\tfor (i = 0; i < bytes.length; i++)\n\t\t\tstr += String.fromCharCode(bytes[i]);\n\t\treturn str;\n\t}\n\n\tfunction getDate(timeRaw) {\n\t\tvar date = (timeRaw & 0xffff0000) >> 16, time = timeRaw & 0x0000ffff;\n\t\ttry {\n\t\t\treturn new Date(1980 + ((date & 0xFE00) >> 9), ((date & 0x01E0) >> 5) - 1, date & 0x001F, (time & 0xF800) >> 11, (time & 0x07E0) >> 5,\n\t\t\t\t\t(time & 0x001F) * 2, 0);\n\t\t} catch (e) {\n\t\t}\n\t}\n\n\tfunction readCommonHeader(entry, data, index, centralDirectory, onerror) {\n\t\tentry.version = data.view.getUint16(index, true);\n\t\tentry.bitFlag = data.view.getUint16(index + 2, true);\n\t\tentry.compressionMethod = data.view.getUint16(index + 4, true);\n\t\tentry.lastModDateRaw = data.view.getUint32(index + 6, true);\n\t\tentry.lastModDate = getDate(entry.lastModDateRaw);\n\t\tif ((entry.bitFlag & 0x01) === 0x01) {\n\t\t\tonerror(ERR_ENCRYPTED);\n\t\t\treturn;\n\t\t}\n\t\tif (centralDirectory || (entry.bitFlag & 0x0008) != 0x0008) {\n\t\t\tentry.crc32 = data.view.getUint32(index + 10, true);\n\t\t\tentry.compressedSize = data.view.getUint32(index + 14, true);\n\t\t\tentry.uncompressedSize = data.view.getUint32(index + 18, true);\n\t\t}\n\t\tif (entry.compressedSize === 0xFFFFFFFF || entry.uncompressedSize === 0xFFFFFFFF) {\n\t\t\tonerror(ERR_ZIP64);\n\t\t\treturn;\n\t\t}\n\t\tentry.filenameLength = data.view.getUint16(index + 22, true);\n\t\tentry.extraFieldLength = data.view.getUint16(index + 24, true);\n\t}\n\n\tfunction createZipReader(reader, callback, onerror) {\n\t\tvar inflateSN = 0;\n\n\t\tfunction Entry() {\n\t\t}\n\n\t\tEntry.prototype.getData = function(writer, onend, onprogress, checkCrc32) {\n\t\t\tvar that = this;\n\n\t\t\tfunction testCrc32(crc32) {\n\t\t\t\tvar dataCrc32 = getDataHelper(4);\n\t\t\t\tdataCrc32.view.setUint32(0, crc32);\n\t\t\t\treturn that.crc32 == dataCrc32.view.getUint32(0);\n\t\t\t}\n\n\t\t\tfunction getWriterData(uncompressedSize, crc32) {\n\t\t\t\tif (checkCrc32 && !testCrc32(crc32))\n\t\t\t\t\tonerror(ERR_CRC);\n\t\t\t\telse\n\t\t\t\t\twriter.getData(function(data) {\n\t\t\t\t\t\tonend(data);\n\t\t\t\t\t});\n\t\t\t}\n\n\t\t\tfunction onreaderror(err) {\n\t\t\t\tonerror(err || ERR_READ_DATA);\n\t\t\t}\n\n\t\t\tfunction onwriteerror(err) {\n\t\t\t\tonerror(err || ERR_WRITE_DATA);\n\t\t\t}\n\n\t\t\treader.readUint8Array(that.offset, 30, function(bytes) {\n\t\t\t\tvar data = getDataHelper(bytes.length, bytes), dataOffset;\n\t\t\t\tif (data.view.getUint32(0) != 0x504b0304) {\n\t\t\t\t\tonerror(ERR_BAD_FORMAT);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t\treadCommonHeader(that, data, 4, false, onerror);\n\t\t\t\tdataOffset = that.offset + 30 + that.filenameLength + that.extraFieldLength;\n\t\t\t\twriter.init(function() {\n\t\t\t\t\tif (that.compressionMethod === 0)\n\t\t\t\t\t\tcopy(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);\n\t\t\t\t\telse\n\t\t\t\t\t\tinflate(that._worker, inflateSN++, reader, writer, dataOffset, that.compressedSize, checkCrc32, getWriterData, onprogress, onreaderror, onwriteerror);\n\t\t\t\t}, onwriteerror);\n\t\t\t}, onreaderror);\n\t\t};\n\n\t\tfunction seekEOCDR(eocdrCallback) {\n\t\t\t// \"End of central directory record\" is the last part of a zip archive, and is at least 22 bytes long.\n\t\t\t// Zip file comment is the last part of EOCDR and has max length of 64KB,\n\t\t\t// so we only have to search the last 64K + 22 bytes of a archive for EOCDR signature (0x06054b50).\n\t\t\tvar EOCDR_MIN = 22;\n\t\t\tif (reader.size < EOCDR_MIN) {\n\t\t\t\tonerror(ERR_BAD_FORMAT);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tvar ZIP_COMMENT_MAX = 256 * 256, EOCDR_MAX = EOCDR_MIN + ZIP_COMMENT_MAX;\n\n\t\t\t// In most cases, the EOCDR is EOCDR_MIN bytes long\n\t\t\tdoSeek(EOCDR_MIN, function() {\n\t\t\t\t// If not found, try within EOCDR_MAX bytes\n\t\t\t\tdoSeek(Math.min(EOCDR_MAX, reader.size), function() {\n\t\t\t\t\tonerror(ERR_BAD_FORMAT);\n\t\t\t\t});\n\t\t\t});\n\n\t\t\t// seek last length bytes of file for EOCDR\n\t\t\tfunction doSeek(length, eocdrNotFoundCallback) {\n\t\t\t\treader.readUint8Array(reader.size - length, length, function(bytes) {\n\t\t\t\t\tfor (var i = bytes.length - EOCDR_MIN; i >= 0; i--) {\n\t\t\t\t\t\tif (bytes[i] === 0x50 && bytes[i + 1] === 0x4b && bytes[i + 2] === 0x05 && bytes[i + 3] === 0x06) {\n\t\t\t\t\t\t\teocdrCallback(new DataView(bytes.buffer, i, EOCDR_MIN));\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\teocdrNotFoundCallback();\n\t\t\t\t}, function() {\n\t\t\t\t\tonerror(ERR_READ);\n\t\t\t\t});\n\t\t\t}\n\t\t}\n\n\t\tvar zipReader = {\n\t\t\tgetEntries : function(callback) {\n\t\t\t\tvar worker = this._worker;\n\t\t\t\t// look for End of central directory record\n\t\t\t\tseekEOCDR(function(dataView) {\n\t\t\t\t\tvar datalength, fileslength;\n\t\t\t\t\tdatalength = dataView.getUint32(16, true);\n\t\t\t\t\tfileslength = dataView.getUint16(8, true);\n\t\t\t\t\tif (datalength < 0 || datalength >= reader.size) {\n\t\t\t\t\t\tonerror(ERR_BAD_FORMAT);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\treader.readUint8Array(datalength, reader.size - datalength, function(bytes) {\n\t\t\t\t\t\tvar i, index = 0, entries = [], entry, filename, comment, data = getDataHelper(bytes.length, bytes);\n\t\t\t\t\t\tfor (i = 0; i < fileslength; i++) {\n\t\t\t\t\t\t\tentry = new Entry();\n\t\t\t\t\t\t\tentry._worker = worker;\n\t\t\t\t\t\t\tif (data.view.getUint32(index) != 0x504b0102) {\n\t\t\t\t\t\t\t\tonerror(ERR_BAD_FORMAT);\n\t\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\treadCommonHeader(entry, data, index + 6, true, onerror);\n\t\t\t\t\t\t\tentry.commentLength = data.view.getUint16(index + 32, true);\n\t\t\t\t\t\t\tentry.directory = ((data.view.getUint8(index + 38) & 0x10) == 0x10);\n\t\t\t\t\t\t\tentry.offset = data.view.getUint32(index + 42, true);\n\t\t\t\t\t\t\tfilename = getString(data.array.subarray(index + 46, index + 46 + entry.filenameLength));\n\t\t\t\t\t\t\tentry.filename = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(filename) : decodeASCII(filename);\n\t\t\t\t\t\t\tif (!entry.directory && entry.filename.charAt(entry.filename.length - 1) == \"/\")\n\t\t\t\t\t\t\t\tentry.directory = true;\n\t\t\t\t\t\t\tcomment = getString(data.array.subarray(index + 46 + entry.filenameLength + entry.extraFieldLength, index + 46\n\t\t\t\t\t\t\t\t\t+ entry.filenameLength + entry.extraFieldLength + entry.commentLength));\n\t\t\t\t\t\t\tentry.comment = ((entry.bitFlag & 0x0800) === 0x0800) ? decodeUTF8(comment) : decodeASCII(comment);\n\t\t\t\t\t\t\tentries.push(entry);\n\t\t\t\t\t\t\tindex += 46 + entry.filenameLength + entry.extraFieldLength + entry.commentLength;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tcallback(entries);\n\t\t\t\t\t}, function() {\n\t\t\t\t\t\tonerror(ERR_READ);\n\t\t\t\t\t});\n\t\t\t\t});\n\t\t\t},\n\t\t\tclose : function(callback) {\n\t\t\t\tif (this._worker) {\n\t\t\t\t\tthis._worker.terminate();\n\t\t\t\t\tthis._worker = null;\n\t\t\t\t}\n\t\t\t\tif (callback)\n\t\t\t\t\tcallback();\n\t\t\t},\n\t\t\t_worker: null\n\t\t};\n\n\t\tif (!obj.zip.useWebWorkers)\n\t\t\tcallback(zipReader);\n\t\telse {\n\t\t\tcreateWorker('inflater',\n\t\t\t\tfunction(worker) {\n\t\t\t\t\tzipReader._worker = worker;\n\t\t\t\t\tcallback(zipReader);\n\t\t\t\t},\n\t\t\t\tfunction(err) {\n\t\t\t\t\tonerror(err);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\t// ZipWriter\n\n\tfunction encodeUTF8(string) {\n\t\treturn unescape(encodeURIComponent(string));\n\t}\n\n\tfunction getBytes(str) {\n\t\tvar i, array = [];\n\t\tfor (i = 0; i < str.length; i++)\n\t\t\tarray.push(str.charCodeAt(i));\n\t\treturn array;\n\t}\n\n\tfunction createZipWriter(writer, callback, onerror, dontDeflate) {\n\t\tvar files = {}, filenames = [], datalength = 0;\n\t\tvar deflateSN = 0;\n\n\t\tfunction onwriteerror(err) {\n\t\t\tonerror(err || ERR_WRITE);\n\t\t}\n\n\t\tfunction onreaderror(err) {\n\t\t\tonerror(err || ERR_READ_DATA);\n\t\t}\n\n\t\tvar zipWriter = {\n\t\t\tadd : function(name, reader, onend, onprogress, options) {\n\t\t\t\tvar header, filename, date;\n\t\t\t\tvar worker = this._worker;\n\n\t\t\t\tfunction writeHeader(callback) {\n\t\t\t\t\tvar data;\n\t\t\t\t\tdate = options.lastModDate || new Date();\n\t\t\t\t\theader = getDataHelper(26);\n\t\t\t\t\tfiles[name] = {\n\t\t\t\t\t\theaderArray : header.array,\n\t\t\t\t\t\tdirectory : options.directory,\n\t\t\t\t\t\tfilename : filename,\n\t\t\t\t\t\toffset : datalength,\n\t\t\t\t\t\tcomment : getBytes(encodeUTF8(options.comment || \"\"))\n\t\t\t\t\t};\n\t\t\t\t\theader.view.setUint32(0, 0x14000808);\n\t\t\t\t\tif (options.version)\n\t\t\t\t\t\theader.view.setUint8(0, options.version);\n\t\t\t\t\tif (!dontDeflate && options.level !== 0 && !options.directory)\n\t\t\t\t\t\theader.view.setUint16(4, 0x0800);\n\t\t\t\t\theader.view.setUint16(6, (((date.getHours() << 6) | date.getMinutes()) << 5) | date.getSeconds() / 2, true);\n\t\t\t\t\theader.view.setUint16(8, ((((date.getFullYear() - 1980) << 4) | (date.getMonth() + 1)) << 5) | date.getDate(), true);\n\t\t\t\t\theader.view.setUint16(22, filename.length, true);\n\t\t\t\t\tdata = getDataHelper(30 + filename.length);\n\t\t\t\t\tdata.view.setUint32(0, 0x504b0304);\n\t\t\t\t\tdata.array.set(header.array, 4);\n\t\t\t\t\tdata.array.set(filename, 30);\n\t\t\t\t\tdatalength += data.array.length;\n\t\t\t\t\twriter.writeUint8Array(data.array, callback, onwriteerror);\n\t\t\t\t}\n\n\t\t\t\tfunction writeFooter(compressedLength, crc32) {\n\t\t\t\t\tvar footer = getDataHelper(16);\n\t\t\t\t\tdatalength += compressedLength || 0;\n\t\t\t\t\tfooter.view.setUint32(0, 0x504b0708);\n\t\t\t\t\tif (typeof crc32 != \"undefined\") {\n\t\t\t\t\t\theader.view.setUint32(10, crc32, true);\n\t\t\t\t\t\tfooter.view.setUint32(4, crc32, true);\n\t\t\t\t\t}\n\t\t\t\t\tif (reader) {\n\t\t\t\t\t\tfooter.view.setUint32(8, compressedLength, true);\n\t\t\t\t\t\theader.view.setUint32(14, compressedLength, true);\n\t\t\t\t\t\tfooter.view.setUint32(12, reader.size, true);\n\t\t\t\t\t\theader.view.setUint32(18, reader.size, true);\n\t\t\t\t\t}\n\t\t\t\t\twriter.writeUint8Array(footer.array, function() {\n\t\t\t\t\t\tdatalength += 16;\n\t\t\t\t\t\tonend();\n\t\t\t\t\t}, onwriteerror);\n\t\t\t\t}\n\n\t\t\t\tfunction writeFile() {\n\t\t\t\t\toptions = options || {};\n\t\t\t\t\tname = name.trim();\n\t\t\t\t\tif (options.directory && name.charAt(name.length - 1) != \"/\")\n\t\t\t\t\t\tname += \"/\";\n\t\t\t\t\tif (files.hasOwnProperty(name)) {\n\t\t\t\t\t\tonerror(ERR_DUPLICATED_NAME);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\t\t\t\t\tfilename = getBytes(encodeUTF8(name));\n\t\t\t\t\tfilenames.push(name);\n\t\t\t\t\twriteHeader(function() {\n\t\t\t\t\t\tif (reader)\n\t\t\t\t\t\t\tif (dontDeflate || options.level === 0)\n\t\t\t\t\t\t\t\tcopy(worker, deflateSN++, reader, writer, 0, reader.size, true, writeFooter, onprogress, onreaderror, onwriteerror);\n\t\t\t\t\t\t\telse\n\t\t\t\t\t\t\t\tdeflate(worker, deflateSN++, reader, writer, options.level, writeFooter, onprogress, onreaderror, onwriteerror);\n\t\t\t\t\t\telse\n\t\t\t\t\t\t\twriteFooter();\n\t\t\t\t\t}, onwriteerror);\n\t\t\t\t}\n\n\t\t\t\tif (reader)\n\t\t\t\t\treader.init(writeFile, onreaderror);\n\t\t\t\telse\n\t\t\t\t\twriteFile();\n\t\t\t},\n\t\t\tclose : function(callback) {\n\t\t\t\tif (this._worker) {\n\t\t\t\t\tthis._worker.terminate();\n\t\t\t\t\tthis._worker = null;\n\t\t\t\t}\n\n\t\t\t\tvar data, length = 0, index = 0, indexFilename, file;\n\t\t\t\tfor (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {\n\t\t\t\t\tfile = files[filenames[indexFilename]];\n\t\t\t\t\tlength += 46 + file.filename.length + file.comment.length;\n\t\t\t\t}\n\t\t\t\tdata = getDataHelper(length + 22);\n\t\t\t\tfor (indexFilename = 0; indexFilename < filenames.length; indexFilename++) {\n\t\t\t\t\tfile = files[filenames[indexFilename]];\n\t\t\t\t\tdata.view.setUint32(index, 0x504b0102);\n\t\t\t\t\tdata.view.setUint16(index + 4, 0x1400);\n\t\t\t\t\tdata.array.set(file.headerArray, index + 6);\n\t\t\t\t\tdata.view.setUint16(index + 32, file.comment.length, true);\n\t\t\t\t\tif (file.directory)\n\t\t\t\t\t\tdata.view.setUint8(index + 38, 0x10);\n\t\t\t\t\tdata.view.setUint32(index + 42, file.offset, true);\n\t\t\t\t\tdata.array.set(file.filename, index + 46);\n\t\t\t\t\tdata.array.set(file.comment, index + 46 + file.filename.length);\n\t\t\t\t\tindex += 46 + file.filename.length + file.comment.length;\n\t\t\t\t}\n\t\t\t\tdata.view.setUint32(index, 0x504b0506);\n\t\t\t\tdata.view.setUint16(index + 8, filenames.length, true);\n\t\t\t\tdata.view.setUint16(index + 10, filenames.length, true);\n\t\t\t\tdata.view.setUint32(index + 12, length, true);\n\t\t\t\tdata.view.setUint32(index + 16, datalength, true);\n\t\t\t\twriter.writeUint8Array(data.array, function() {\n\t\t\t\t\twriter.getData(callback);\n\t\t\t\t}, onwriteerror);\n\t\t\t},\n\t\t\t_worker: null\n\t\t};\n\n\t\tif (!obj.zip.useWebWorkers)\n\t\t\tcallback(zipWriter);\n\t\telse {\n\t\t\tcreateWorker('deflater',\n\t\t\t\tfunction(worker) {\n\t\t\t\t\tzipWriter._worker = worker;\n\t\t\t\t\tcallback(zipWriter);\n\t\t\t\t},\n\t\t\t\tfunction(err) {\n\t\t\t\t\tonerror(err);\n\t\t\t\t}\n\t\t\t);\n\t\t}\n\t}\n\n\tfunction resolveURLs(urls) {\n\t\tvar a = document.createElement('a');\n\t\treturn urls.map(function(url) {\n\t\t\ta.href = url;\n\t\t\treturn a.href;\n\t\t});\n\t}\n\n\tvar DEFAULT_WORKER_SCRIPTS = {\n\t\tdeflater: ['z-worker.js', 'deflate.js'],\n\t\tinflater: ['z-worker.js', 'inflate.js']\n\t};\n\tfunction createWorker(type, callback, onerror) {\n\t\tif (obj.zip.workerScripts !== null && obj.zip.workerScriptsPath !== null) {\n\t\t\tonerror(new Error('Either zip.workerScripts or zip.workerScriptsPath may be set, not both.'));\n\t\t\treturn;\n\t\t}\n\t\tvar scripts;\n\t\tif (obj.zip.workerScripts) {\n\t\t\tscripts = obj.zip.workerScripts[type];\n\t\t\tif (!Array.isArray(scripts)) {\n\t\t\t\tonerror(new Error('zip.workerScripts.' + type + ' is not an array!'));\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tscripts = resolveURLs(scripts);\n\t\t} else {\n\t\t\tscripts = DEFAULT_WORKER_SCRIPTS[type].slice(0);\n\t\t\tscripts[0] = (obj.zip.workerScriptsPath || '') + scripts[0];\n\t\t}\n\t\tvar worker = new Worker(scripts[0]);\n\t\t// record total consumed time by inflater/deflater/crc32 in this worker\n\t\tworker.codecTime = worker.crcTime = 0;\n\t\tworker.postMessage({ type: 'importScripts', scripts: scripts.slice(1) });\n\t\tworker.addEventListener('message', onmessage);\n\t\tfunction onmessage(ev) {\n\t\t\tvar msg = ev.data;\n\t\t\tif (msg.error) {\n\t\t\t\tworker.terminate(); // should before onerror(), because onerror() may throw.\n\t\t\t\tonerror(msg.error);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tif (msg.type === 'importScripts') {\n\t\t\t\tworker.removeEventListener('message', onmessage);\n\t\t\t\tworker.removeEventListener('error', errorHandler);\n\t\t\t\tcallback(worker);\n\t\t\t}\n\t\t}\n\t\t// catch entry script loading error and other unhandled errors\n\t\tworker.addEventListener('error', errorHandler);\n\t\tfunction errorHandler(err) {\n\t\t\tworker.terminate();\n\t\t\tonerror(err);\n\t\t}\n\t}\n\n\tfunction onerror_default(error) {\n\t\tconsole.error(error);\n\t}\n\tobj.zip = {\n\t\tReader : Reader,\n\t\tWriter : Writer,\n\t\tBlobReader : BlobReader,\n\t\tData64URIReader : Data64URIReader,\n\t\tTextReader : TextReader,\n\t\tBlobWriter : BlobWriter,\n\t\tData64URIWriter : Data64URIWriter,\n\t\tTextWriter : TextWriter,\n\t\tcreateReader : function(reader, callback, onerror) {\n\t\t\tonerror = onerror || onerror_default;\n\n\t\t\treader.init(function() {\n\t\t\t\tcreateZipReader(reader, callback, onerror);\n\t\t\t}, onerror);\n\t\t},\n\t\tcreateWriter : function(writer, callback, onerror, dontDeflate) {\n\t\t\tonerror = onerror || onerror_default;\n\t\t\tdontDeflate = !!dontDeflate;\n\n\t\t\twriter.init(function() {\n\t\t\t\tcreateZipWriter(writer, callback, onerror, dontDeflate);\n\t\t\t}, onerror);\n\t\t},\n\t\tuseWebWorkers : true,\n\t\t/**\n\t\t * Directory containing the default worker scripts (z-worker.js, deflate.js, and inflate.js), relative to current base url.\n\t\t * E.g.: zip.workerScripts = './';\n\t\t */\n\t\tworkerScriptsPath : null,\n\t\t/**\n\t\t * Advanced option to control which scripts are loaded in the Web worker. If this option is specified, then workerScriptsPath must not be set.\n\t\t * workerScripts.deflater/workerScripts.inflater should be arrays of urls to scripts for deflater/inflater, respectively.\n\t\t * Scripts in the array are executed in order, and the first one should be z-worker.js, which is used to start the worker.\n\t\t * All urls are relative to current base url.\n\t\t * E.g.:\n\t\t * zip.workerScripts = {\n\t\t *   deflater: ['z-worker.js', 'deflate.js'],\n\t\t *   inflater: ['z-worker.js', 'inflate.js']\n\t\t * };\n\t\t */\n\t\tworkerScripts : null,\n\t};\n\n})(this);\n"},function(t,n){t.exports='/*\n Copyright (c) 2013 Gildas Lormeau. All rights reserved.\n\n Redistribution and use in source and binary forms, with or without\n modification, are permitted provided that the following conditions are met:\n\n 1. Redistributions of source code must retain the above copyright notice,\n this list of conditions and the following disclaimer.\n\n 2. Redistributions in binary form must reproduce the above copyright \n notice, this list of conditions and the following disclaimer in \n the documentation and/or other materials provided with the distribution.\n\n 3. The names of the authors may not be used to endorse or promote products\n derived from this software without specific prior written permission.\n\n THIS SOFTWARE IS PROVIDED ``AS IS\'\' AND ANY EXPRESSED OR IMPLIED WARRANTIES,\n INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL JCRAFT,\n INC. OR ANY CONTRIBUTORS TO THIS SOFTWARE BE LIABLE FOR ANY DIRECT, INDIRECT,\n INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT\n LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,\n OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF\n LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,\n EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n */\n\n/*\n * This program is based on JZlib 1.0.2 ymnk, JCraft,Inc.\n * JZlib is based on zlib-1.1.3, so all credit should go authors\n * Jean-loup Gailly(jloup@gzip.org) and Mark Adler(madler@alumni.caltech.edu)\n * and contributors of zlib.\n */\n\n(function(global) {\n\t"use strict";\n\n\t// Global\n\tvar MAX_BITS = 15;\n\n\tvar Z_OK = 0;\n\tvar Z_STREAM_END = 1;\n\tvar Z_NEED_DICT = 2;\n\tvar Z_STREAM_ERROR = -2;\n\tvar Z_DATA_ERROR = -3;\n\tvar Z_MEM_ERROR = -4;\n\tvar Z_BUF_ERROR = -5;\n\n\tvar inflate_mask = [ 0x00000000, 0x00000001, 0x00000003, 0x00000007, 0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f, 0x000000ff, 0x000001ff, 0x000003ff,\n\t\t\t0x000007ff, 0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff, 0x0000ffff ];\n\n\tvar MANY = 1440;\n\n\t// JZlib version : "1.0.2"\n\tvar Z_NO_FLUSH = 0;\n\tvar Z_FINISH = 4;\n\n\t// InfTree\n\tvar fixed_bl = 9;\n\tvar fixed_bd = 5;\n\n\tvar fixed_tl = [ 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9, 192, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 160, 0, 8, 0,\n\t\t\t0, 8, 128, 0, 8, 64, 0, 9, 224, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 144, 83, 7, 59, 0, 8, 120, 0, 8, 56, 0, 9, 208, 81, 7, 17, 0, 8, 104, 0, 8, 40,\n\t\t\t0, 9, 176, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 240, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8, 227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 200, 81, 7, 13,\n\t\t\t0, 8, 100, 0, 8, 36, 0, 9, 168, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 232, 80, 7, 8, 0, 8, 92, 0, 8, 28, 0, 9, 152, 84, 7, 83, 0, 8, 124, 0, 8, 60,\n\t\t\t0, 9, 216, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 184, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9, 248, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7,\n\t\t\t35, 0, 8, 114, 0, 8, 50, 0, 9, 196, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 164, 0, 8, 2, 0, 8, 130, 0, 8, 66, 0, 9, 228, 80, 7, 7, 0, 8, 90, 0, 8,\n\t\t\t26, 0, 9, 148, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 212, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9, 180, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 244, 80,\n\t\t\t7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 204, 81, 7, 15, 0, 8, 102, 0, 8, 38, 0, 9, 172, 0, 8, 6, 0, 8, 134, 0,\n\t\t\t8, 70, 0, 9, 236, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 156, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9, 220, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 188, 0,\n\t\t\t8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 252, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0, 8, 113, 0, 8, 49, 0, 9, 194, 80, 7, 10, 0, 8, 97,\n\t\t\t0, 8, 33, 0, 9, 162, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 226, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9, 146, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 210,\n\t\t\t81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 178, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 242, 80, 7, 4, 0, 8, 85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117,\n\t\t\t0, 8, 53, 0, 9, 202, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 170, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9, 234, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 154,\n\t\t\t84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 218, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 186, 0, 8, 13, 0, 8, 141, 0, 8, 77, 0, 9, 250, 80, 7, 3, 0, 8, 83,\n\t\t\t0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 198, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9, 166, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 230,\n\t\t\t80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 150, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 214, 82, 7, 19, 0, 8, 107, 0, 8, 43, 0, 9, 182, 0, 8, 11, 0, 8, 139,\n\t\t\t0, 8, 75, 0, 9, 246, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9, 206, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 174,\n\t\t\t0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 238, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 158, 84, 7, 99, 0, 8, 127, 0, 8, 63, 0, 9, 222, 82, 7, 27, 0, 8, 111,\n\t\t\t0, 8, 47, 0, 9, 190, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 254, 96, 7, 256, 0, 8, 80, 0, 8, 16, 84, 8, 115, 82, 7, 31, 0, 8, 112, 0, 8, 48, 0, 9,\n\t\t\t193, 80, 7, 10, 0, 8, 96, 0, 8, 32, 0, 9, 161, 0, 8, 0, 0, 8, 128, 0, 8, 64, 0, 9, 225, 80, 7, 6, 0, 8, 88, 0, 8, 24, 0, 9, 145, 83, 7, 59, 0, 8,\n\t\t\t120, 0, 8, 56, 0, 9, 209, 81, 7, 17, 0, 8, 104, 0, 8, 40, 0, 9, 177, 0, 8, 8, 0, 8, 136, 0, 8, 72, 0, 9, 241, 80, 7, 4, 0, 8, 84, 0, 8, 20, 85, 8,\n\t\t\t227, 83, 7, 43, 0, 8, 116, 0, 8, 52, 0, 9, 201, 81, 7, 13, 0, 8, 100, 0, 8, 36, 0, 9, 169, 0, 8, 4, 0, 8, 132, 0, 8, 68, 0, 9, 233, 80, 7, 8, 0, 8,\n\t\t\t92, 0, 8, 28, 0, 9, 153, 84, 7, 83, 0, 8, 124, 0, 8, 60, 0, 9, 217, 82, 7, 23, 0, 8, 108, 0, 8, 44, 0, 9, 185, 0, 8, 12, 0, 8, 140, 0, 8, 76, 0, 9,\n\t\t\t249, 80, 7, 3, 0, 8, 82, 0, 8, 18, 85, 8, 163, 83, 7, 35, 0, 8, 114, 0, 8, 50, 0, 9, 197, 81, 7, 11, 0, 8, 98, 0, 8, 34, 0, 9, 165, 0, 8, 2, 0, 8,\n\t\t\t130, 0, 8, 66, 0, 9, 229, 80, 7, 7, 0, 8, 90, 0, 8, 26, 0, 9, 149, 84, 7, 67, 0, 8, 122, 0, 8, 58, 0, 9, 213, 82, 7, 19, 0, 8, 106, 0, 8, 42, 0, 9,\n\t\t\t181, 0, 8, 10, 0, 8, 138, 0, 8, 74, 0, 9, 245, 80, 7, 5, 0, 8, 86, 0, 8, 22, 192, 8, 0, 83, 7, 51, 0, 8, 118, 0, 8, 54, 0, 9, 205, 81, 7, 15, 0, 8,\n\t\t\t102, 0, 8, 38, 0, 9, 173, 0, 8, 6, 0, 8, 134, 0, 8, 70, 0, 9, 237, 80, 7, 9, 0, 8, 94, 0, 8, 30, 0, 9, 157, 84, 7, 99, 0, 8, 126, 0, 8, 62, 0, 9,\n\t\t\t221, 82, 7, 27, 0, 8, 110, 0, 8, 46, 0, 9, 189, 0, 8, 14, 0, 8, 142, 0, 8, 78, 0, 9, 253, 96, 7, 256, 0, 8, 81, 0, 8, 17, 85, 8, 131, 82, 7, 31, 0,\n\t\t\t8, 113, 0, 8, 49, 0, 9, 195, 80, 7, 10, 0, 8, 97, 0, 8, 33, 0, 9, 163, 0, 8, 1, 0, 8, 129, 0, 8, 65, 0, 9, 227, 80, 7, 6, 0, 8, 89, 0, 8, 25, 0, 9,\n\t\t\t147, 83, 7, 59, 0, 8, 121, 0, 8, 57, 0, 9, 211, 81, 7, 17, 0, 8, 105, 0, 8, 41, 0, 9, 179, 0, 8, 9, 0, 8, 137, 0, 8, 73, 0, 9, 243, 80, 7, 4, 0, 8,\n\t\t\t85, 0, 8, 21, 80, 8, 258, 83, 7, 43, 0, 8, 117, 0, 8, 53, 0, 9, 203, 81, 7, 13, 0, 8, 101, 0, 8, 37, 0, 9, 171, 0, 8, 5, 0, 8, 133, 0, 8, 69, 0, 9,\n\t\t\t235, 80, 7, 8, 0, 8, 93, 0, 8, 29, 0, 9, 155, 84, 7, 83, 0, 8, 125, 0, 8, 61, 0, 9, 219, 82, 7, 23, 0, 8, 109, 0, 8, 45, 0, 9, 187, 0, 8, 13, 0, 8,\n\t\t\t141, 0, 8, 77, 0, 9, 251, 80, 7, 3, 0, 8, 83, 0, 8, 19, 85, 8, 195, 83, 7, 35, 0, 8, 115, 0, 8, 51, 0, 9, 199, 81, 7, 11, 0, 8, 99, 0, 8, 35, 0, 9,\n\t\t\t167, 0, 8, 3, 0, 8, 131, 0, 8, 67, 0, 9, 231, 80, 7, 7, 0, 8, 91, 0, 8, 27, 0, 9, 151, 84, 7, 67, 0, 8, 123, 0, 8, 59, 0, 9, 215, 82, 7, 19, 0, 8,\n\t\t\t107, 0, 8, 43, 0, 9, 183, 0, 8, 11, 0, 8, 139, 0, 8, 75, 0, 9, 247, 80, 7, 5, 0, 8, 87, 0, 8, 23, 192, 8, 0, 83, 7, 51, 0, 8, 119, 0, 8, 55, 0, 9,\n\t\t\t207, 81, 7, 15, 0, 8, 103, 0, 8, 39, 0, 9, 175, 0, 8, 7, 0, 8, 135, 0, 8, 71, 0, 9, 239, 80, 7, 9, 0, 8, 95, 0, 8, 31, 0, 9, 159, 84, 7, 99, 0, 8,\n\t\t\t127, 0, 8, 63, 0, 9, 223, 82, 7, 27, 0, 8, 111, 0, 8, 47, 0, 9, 191, 0, 8, 15, 0, 8, 143, 0, 8, 79, 0, 9, 255 ];\n\tvar fixed_td = [ 80, 5, 1, 87, 5, 257, 83, 5, 17, 91, 5, 4097, 81, 5, 5, 89, 5, 1025, 85, 5, 65, 93, 5, 16385, 80, 5, 3, 88, 5, 513, 84, 5, 33, 92, 5,\n\t\t\t8193, 82, 5, 9, 90, 5, 2049, 86, 5, 129, 192, 5, 24577, 80, 5, 2, 87, 5, 385, 83, 5, 25, 91, 5, 6145, 81, 5, 7, 89, 5, 1537, 85, 5, 97, 93, 5,\n\t\t\t24577, 80, 5, 4, 88, 5, 769, 84, 5, 49, 92, 5, 12289, 82, 5, 13, 90, 5, 3073, 86, 5, 193, 192, 5, 24577 ];\n\n\t// Tables for deflate from PKZIP\'s appnote.txt.\n\tvar cplens = [ // Copy lengths for literal codes 257..285\n\t3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0 ];\n\n\t// see note #13 above about 258\n\tvar cplext = [ // Extra bits for literal codes 257..285\n\t0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0, 112, 112 // 112==invalid\n\t];\n\n\tvar cpdist = [ // Copy offsets for distance codes 0..29\n\t1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577 ];\n\n\tvar cpdext = [ // Extra bits for distance codes\n\t0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13 ];\n\n\t// If BMAX needs to be larger than 16, then h and x[] should be uLong.\n\tvar BMAX = 15; // maximum bit length of any code\n\n\tfunction InfTree() {\n\t\tvar that = this;\n\n\t\tvar hn; // hufts used in space\n\t\tvar v; // work area for huft_build\n\t\tvar c; // bit length count table\n\t\tvar r; // table entry for structure assignment\n\t\tvar u; // table stack\n\t\tvar x; // bit offsets, then code stack\n\n\t\tfunction huft_build(b, // code lengths in bits (all assumed <=\n\t\t// BMAX)\n\t\tbindex, n, // number of codes (assumed <= 288)\n\t\ts, // number of simple-valued codes (0..s-1)\n\t\td, // list of base values for non-simple codes\n\t\te, // list of extra bits for non-simple codes\n\t\tt, // result: starting table\n\t\tm, // maximum lookup bits, returns actual\n\t\thp,// space for trees\n\t\thn,// hufts used in space\n\t\tv // working area: values in order of bit length\n\t\t) {\n\t\t\t// Given a list of code lengths and a maximum table size, make a set of\n\t\t\t// tables to decode that set of codes. Return Z_OK on success,\n\t\t\t// Z_BUF_ERROR\n\t\t\t// if the given code set is incomplete (the tables are still built in\n\t\t\t// this\n\t\t\t// case), Z_DATA_ERROR if the input is invalid (an over-subscribed set\n\t\t\t// of\n\t\t\t// lengths), or Z_MEM_ERROR if not enough memory.\n\n\t\t\tvar a; // counter for codes of length k\n\t\t\tvar f; // i repeats in table every f entries\n\t\t\tvar g; // maximum code length\n\t\t\tvar h; // table level\n\t\t\tvar i; // counter, current code\n\t\t\tvar j; // counter\n\t\t\tvar k; // number of bits in current code\n\t\t\tvar l; // bits per table (returned in m)\n\t\t\tvar mask; // (1 << w) - 1, to avoid cc -O bug on HP\n\t\t\tvar p; // pointer into c[], b[], or v[]\n\t\t\tvar q; // points to current table\n\t\t\tvar w; // bits before this table == (l * h)\n\t\t\tvar xp; // pointer into x\n\t\t\tvar y; // number of dummy codes added\n\t\t\tvar z; // number of entries in current table\n\n\t\t\t// Generate counts for each bit length\n\n\t\t\tp = 0;\n\t\t\ti = n;\n\t\t\tdo {\n\t\t\t\tc[b[bindex + p]]++;\n\t\t\t\tp++;\n\t\t\t\ti--; // assume all entries <= BMAX\n\t\t\t} while (i !== 0);\n\n\t\t\tif (c[0] == n) { // null input--all zero length codes\n\t\t\t\tt[0] = -1;\n\t\t\t\tm[0] = 0;\n\t\t\t\treturn Z_OK;\n\t\t\t}\n\n\t\t\t// Find minimum and maximum length, bound *m by those\n\t\t\tl = m[0];\n\t\t\tfor (j = 1; j <= BMAX; j++)\n\t\t\t\tif (c[j] !== 0)\n\t\t\t\t\tbreak;\n\t\t\tk = j; // minimum code length\n\t\t\tif (l < j) {\n\t\t\t\tl = j;\n\t\t\t}\n\t\t\tfor (i = BMAX; i !== 0; i--) {\n\t\t\t\tif (c[i] !== 0)\n\t\t\t\t\tbreak;\n\t\t\t}\n\t\t\tg = i; // maximum code length\n\t\t\tif (l > i) {\n\t\t\t\tl = i;\n\t\t\t}\n\t\t\tm[0] = l;\n\n\t\t\t// Adjust last length count to fill out codes, if needed\n\t\t\tfor (y = 1 << j; j < i; j++, y <<= 1) {\n\t\t\t\tif ((y -= c[j]) < 0) {\n\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif ((y -= c[i]) < 0) {\n\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t}\n\t\t\tc[i] += y;\n\n\t\t\t// Generate starting offsets into the value table for each length\n\t\t\tx[1] = j = 0;\n\t\t\tp = 1;\n\t\t\txp = 2;\n\t\t\twhile (--i !== 0) { // note that i == g from above\n\t\t\t\tx[xp] = (j += c[p]);\n\t\t\t\txp++;\n\t\t\t\tp++;\n\t\t\t}\n\n\t\t\t// Make a table of values in order of bit lengths\n\t\t\ti = 0;\n\t\t\tp = 0;\n\t\t\tdo {\n\t\t\t\tif ((j = b[bindex + p]) !== 0) {\n\t\t\t\t\tv[x[j]++] = i;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t} while (++i < n);\n\t\t\tn = x[g]; // set n to length of v\n\n\t\t\t// Generate the Huffman codes and for each, make the table entries\n\t\t\tx[0] = i = 0; // first Huffman code is zero\n\t\t\tp = 0; // grab values in bit order\n\t\t\th = -1; // no tables yet--level -1\n\t\t\tw = -l; // bits decoded == (l * h)\n\t\t\tu[0] = 0; // just to keep compilers happy\n\t\t\tq = 0; // ditto\n\t\t\tz = 0; // ditto\n\n\t\t\t// go through the bit lengths (k already is bits in shortest code)\n\t\t\tfor (; k <= g; k++) {\n\t\t\t\ta = c[k];\n\t\t\t\twhile (a-- !== 0) {\n\t\t\t\t\t// here i is the Huffman code of length k bits for value *p\n\t\t\t\t\t// make tables up to required level\n\t\t\t\t\twhile (k > w + l) {\n\t\t\t\t\t\th++;\n\t\t\t\t\t\tw += l; // previous table always l bits\n\t\t\t\t\t\t// compute minimum size table less than or equal to l bits\n\t\t\t\t\t\tz = g - w;\n\t\t\t\t\t\tz = (z > l) ? l : z; // table size upper limit\n\t\t\t\t\t\tif ((f = 1 << (j = k - w)) > a + 1) { // try a k-w bit table\n\t\t\t\t\t\t\t// too few codes for\n\t\t\t\t\t\t\t// k-w bit table\n\t\t\t\t\t\t\tf -= a + 1; // deduct codes from patterns left\n\t\t\t\t\t\t\txp = k;\n\t\t\t\t\t\t\tif (j < z) {\n\t\t\t\t\t\t\t\twhile (++j < z) { // try smaller tables up to z bits\n\t\t\t\t\t\t\t\t\tif ((f <<= 1) <= c[++xp])\n\t\t\t\t\t\t\t\t\t\tbreak; // enough codes to use up j bits\n\t\t\t\t\t\t\t\t\tf -= c[xp]; // else deduct codes from patterns\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tz = 1 << j; // table entries for j-bit table\n\n\t\t\t\t\t\t// allocate new table\n\t\t\t\t\t\tif (hn[0] + z > MANY) { // (note: doesn\'t matter for fixed)\n\t\t\t\t\t\t\treturn Z_DATA_ERROR; // overflow of MANY\n\t\t\t\t\t\t}\n\t\t\t\t\t\tu[h] = q = /* hp+ */hn[0]; // DEBUG\n\t\t\t\t\t\thn[0] += z;\n\n\t\t\t\t\t\t// connect to last table, if there is one\n\t\t\t\t\t\tif (h !== 0) {\n\t\t\t\t\t\t\tx[h] = i; // save pattern for backing up\n\t\t\t\t\t\t\tr[0] = /* (byte) */j; // bits in this table\n\t\t\t\t\t\t\tr[1] = /* (byte) */l; // bits to dump before this table\n\t\t\t\t\t\t\tj = i >>> (w - l);\n\t\t\t\t\t\t\tr[2] = /* (int) */(q - u[h - 1] - j); // offset to this table\n\t\t\t\t\t\t\thp.set(r, (u[h - 1] + j) * 3);\n\t\t\t\t\t\t\t// to\n\t\t\t\t\t\t\t// last\n\t\t\t\t\t\t\t// table\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tt[0] = q; // first table is returned result\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// set up table entry in r\n\t\t\t\t\tr[1] = /* (byte) */(k - w);\n\t\t\t\t\tif (p >= n) {\n\t\t\t\t\t\tr[0] = 128 + 64; // out of values--invalid code\n\t\t\t\t\t} else if (v[p] < s) {\n\t\t\t\t\t\tr[0] = /* (byte) */(v[p] < 256 ? 0 : 32 + 64); // 256 is\n\t\t\t\t\t\t// end-of-block\n\t\t\t\t\t\tr[2] = v[p++]; // simple code is just the value\n\t\t\t\t\t} else {\n\t\t\t\t\t\tr[0] = /* (byte) */(e[v[p] - s] + 16 + 64); // non-simple--look\n\t\t\t\t\t\t// up in lists\n\t\t\t\t\t\tr[2] = d[v[p++] - s];\n\t\t\t\t\t}\n\n\t\t\t\t\t// fill code-like entries with r\n\t\t\t\t\tf = 1 << (k - w);\n\t\t\t\t\tfor (j = i >>> w; j < z; j += f) {\n\t\t\t\t\t\thp.set(r, (q + j) * 3);\n\t\t\t\t\t}\n\n\t\t\t\t\t// backwards increment the k-bit code i\n\t\t\t\t\tfor (j = 1 << (k - 1); (i & j) !== 0; j >>>= 1) {\n\t\t\t\t\t\ti ^= j;\n\t\t\t\t\t}\n\t\t\t\t\ti ^= j;\n\n\t\t\t\t\t// backup over finished tables\n\t\t\t\t\tmask = (1 << w) - 1; // needed on HP, cc -O bug\n\t\t\t\t\twhile ((i & mask) != x[h]) {\n\t\t\t\t\t\th--; // don\'t need to update q\n\t\t\t\t\t\tw -= l;\n\t\t\t\t\t\tmask = (1 << w) - 1;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\t// Return Z_BUF_ERROR if we were given an incomplete table\n\t\t\treturn y !== 0 && g != 1 ? Z_BUF_ERROR : Z_OK;\n\t\t}\n\n\t\tfunction initWorkArea(vsize) {\n\t\t\tvar i;\n\t\t\tif (!hn) {\n\t\t\t\thn = []; // []; //new Array(1);\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t\tc = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t\tr = []; // new Array(3);\n\t\t\t\tu = new Int32Array(BMAX); // new Array(BMAX);\n\t\t\t\tx = new Int32Array(BMAX + 1); // new Array(BMAX + 1);\n\t\t\t}\n\t\t\tif (v.length < vsize) {\n\t\t\t\tv = []; // new Array(vsize);\n\t\t\t}\n\t\t\tfor (i = 0; i < vsize; i++) {\n\t\t\t\tv[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < BMAX + 1; i++) {\n\t\t\t\tc[i] = 0;\n\t\t\t}\n\t\t\tfor (i = 0; i < 3; i++) {\n\t\t\t\tr[i] = 0;\n\t\t\t}\n\t\t\t// for(int i=0; i<BMAX; i++){u[i]=0;}\n\t\t\tu.set(c.subarray(0, BMAX), 0);\n\t\t\t// for(int i=0; i<BMAX+1; i++){x[i]=0;}\n\t\t\tx.set(c.subarray(0, BMAX + 1), 0);\n\t\t}\n\n\t\tthat.inflate_trees_bits = function(c, // 19 code lengths\n\t\tbb, // bits tree desired/actual depth\n\t\ttb, // bits tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\t\t\tinitWorkArea(19);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, 19, 19, null, null, tb, bb, hp, hn, v);\n\n\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\tz.msg = "oversubscribed dynamic bit lengths tree";\n\t\t\t} else if (result == Z_BUF_ERROR || bb[0] === 0) {\n\t\t\t\tz.msg = "incomplete dynamic bit lengths tree";\n\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t}\n\t\t\treturn result;\n\t\t};\n\n\t\tthat.inflate_trees_dynamic = function(nl, // number of literal/length codes\n\t\tnd, // number of distance codes\n\t\tc, // that many (total) code lengths\n\t\tbl, // literal desired/actual bit depth\n\t\tbd, // distance desired/actual bit depth\n\t\ttl, // literal/length tree result\n\t\ttd, // distance tree result\n\t\thp, // space for trees\n\t\tz // for messages\n\t\t) {\n\t\t\tvar result;\n\n\t\t\t// build literal/length tree\n\t\t\tinitWorkArea(288);\n\t\t\thn[0] = 0;\n\t\t\tresult = huft_build(c, 0, nl, 257, cplens, cplext, tl, bl, hp, hn, v);\n\t\t\tif (result != Z_OK || bl[0] === 0) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = "oversubscribed literal/length tree";\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = "incomplete literal/length tree";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\t// build distance tree\n\t\t\tinitWorkArea(288);\n\t\t\tresult = huft_build(c, nl, nd, 0, cpdist, cpdext, td, bd, hp, hn, v);\n\n\t\t\tif (result != Z_OK || (bd[0] === 0 && nl > 257)) {\n\t\t\t\tif (result == Z_DATA_ERROR) {\n\t\t\t\t\tz.msg = "oversubscribed distance tree";\n\t\t\t\t} else if (result == Z_BUF_ERROR) {\n\t\t\t\t\tz.msg = "incomplete distance tree";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t} else if (result != Z_MEM_ERROR) {\n\t\t\t\t\tz.msg = "empty distance tree with lengths";\n\t\t\t\t\tresult = Z_DATA_ERROR;\n\t\t\t\t}\n\t\t\t\treturn result;\n\t\t\t}\n\n\t\t\treturn Z_OK;\n\t\t};\n\n\t}\n\n\tInfTree.inflate_trees_fixed = function(bl, // literal desired/actual bit depth\n\tbd, // distance desired/actual bit depth\n\ttl,// literal/length tree result\n\ttd// distance tree result\n\t) {\n\t\tbl[0] = fixed_bl;\n\t\tbd[0] = fixed_bd;\n\t\ttl[0] = fixed_tl;\n\t\ttd[0] = fixed_td;\n\t\treturn Z_OK;\n\t};\n\n\t// InfCodes\n\n\t// waiting for "i:"=input,\n\t// "o:"=output,\n\t// "x:"=nothing\n\tvar START = 0; // x: set up for LEN\n\tvar LEN = 1; // i: get length/literal/eob next\n\tvar LENEXT = 2; // i: getting length extra (have base)\n\tvar DIST = 3; // i: get distance next\n\tvar DISTEXT = 4;// i: getting distance extra\n\tvar COPY = 5; // o: copying bytes in window, waiting\n\t// for space\n\tvar LIT = 6; // o: got literal, waiting for output\n\t// space\n\tvar WASH = 7; // o: got eob, possibly still output\n\t// waiting\n\tvar END = 8; // x: got eob and all data flushed\n\tvar BADCODE = 9;// x: got error\n\n\tfunction InfCodes() {\n\t\tvar that = this;\n\n\t\tvar mode; // current inflate_codes mode\n\n\t\t// mode dependent information\n\t\tvar len = 0;\n\n\t\tvar tree; // pointer into tree\n\t\tvar tree_index = 0;\n\t\tvar need = 0; // bits needed\n\n\t\tvar lit = 0;\n\n\t\t// if EXT or COPY, where and how much\n\t\tvar get = 0; // bits to get for extra\n\t\tvar dist = 0; // distance back to copy from\n\n\t\tvar lbits = 0; // ltree bits decoded per branch\n\t\tvar dbits = 0; // dtree bits decoder per branch\n\t\tvar ltree; // literal/length/eob tree\n\t\tvar ltree_index = 0; // literal/length/eob tree\n\t\tvar dtree; // distance tree\n\t\tvar dtree_index = 0; // distance tree\n\n\t\t// Called with number of bytes left to write in window at least 258\n\t\t// (the maximum string length) and number of input bytes available\n\t\t// at least ten. The ten bytes are six bytes for the longest length/\n\t\t// distance pair plus four bytes for overloading the bit buffer.\n\n\t\tfunction inflate_fast(bl, bd, tl, tl_index, td, td_index, s, z) {\n\t\t\tvar t; // temporary pointer\n\t\t\tvar tp; // temporary pointer\n\t\t\tvar tp_index; // temporary pointer\n\t\t\tvar e; // extra bits or operation\n\t\t\tvar b; // bit buffer\n\t\t\tvar k; // bits in bit buffer\n\t\t\tvar p; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\t\t\tvar ml; // mask for literal/length tree\n\t\t\tvar md; // mask for distance tree\n\t\t\tvar c; // bytes to copy\n\t\t\tvar d; // distance back to copy from\n\t\t\tvar r; // copy source pointer\n\n\t\t\tvar tp_index_t_3; // (tp_index+t)*3\n\n\t\t\t// load input, output, bit values\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = s.bitb;\n\t\t\tk = s.bitk;\n\t\t\tq = s.write;\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t// initialize masks\n\t\t\tml = inflate_mask[bl];\n\t\t\tmd = inflate_mask[bd];\n\n\t\t\t// do until not enough input or output space for fast loop\n\t\t\tdo { // assume called with m >= 258 && n >= 10\n\t\t\t\t// get literal/length code\n\t\t\t\twhile (k < (20)) { // max bits for literal/length code\n\t\t\t\t\tn--;\n\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\tk += 8;\n\t\t\t\t}\n\n\t\t\t\tt = b & ml;\n\t\t\t\ttp = tl;\n\t\t\t\ttp_index = tl_index;\n\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\n\t\t\t\t\tm--;\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\t\t\t\tdo {\n\n\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\tif ((e & 16) !== 0) {\n\t\t\t\t\t\te &= 15;\n\t\t\t\t\t\tc = tp[tp_index_t_3 + 2] + (/* (int) */b & inflate_mask[e]);\n\n\t\t\t\t\t\tb >>= e;\n\t\t\t\t\t\tk -= e;\n\n\t\t\t\t\t\t// decode distance base of block to copy\n\t\t\t\t\t\twhile (k < (15)) { // max bits for distance code\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tt = b & md;\n\t\t\t\t\t\ttp = td;\n\t\t\t\t\t\ttp_index = td_index;\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\te = tp[tp_index_t_3];\n\n\t\t\t\t\t\tdo {\n\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\t\t\tif ((e & 16) !== 0) {\n\t\t\t\t\t\t\t\t// get extra bits to add to distance base\n\t\t\t\t\t\t\t\te &= 15;\n\t\t\t\t\t\t\t\twhile (k < (e)) { // get extra bits (up to 13)\n\t\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\td = tp[tp_index_t_3 + 2] + (b & inflate_mask[e]);\n\n\t\t\t\t\t\t\t\tb >>= (e);\n\t\t\t\t\t\t\t\tk -= (e);\n\n\t\t\t\t\t\t\t\t// do the copy\n\t\t\t\t\t\t\t\tm -= c;\n\t\t\t\t\t\t\t\tif (q >= d) { // offset before dest\n\t\t\t\t\t\t\t\t\t// just copy\n\t\t\t\t\t\t\t\t\tr = q - d;\n\t\t\t\t\t\t\t\t\tif (q - r > 0 && 2 > (q - r)) {\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // minimum\n\t\t\t\t\t\t\t\t\t\t// count is\n\t\t\t\t\t\t\t\t\t\t// three,\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++]; // so unroll\n\t\t\t\t\t\t\t\t\t\t// loop a\n\t\t\t\t\t\t\t\t\t\t// little\n\t\t\t\t\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + 2), q);\n\t\t\t\t\t\t\t\t\t\tq += 2;\n\t\t\t\t\t\t\t\t\t\tr += 2;\n\t\t\t\t\t\t\t\t\t\tc -= 2;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} else { // else offset after destination\n\t\t\t\t\t\t\t\t\tr = q - d;\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\tr += s.end; // force pointer in window\n\t\t\t\t\t\t\t\t\t} while (r < 0); // covers invalid distances\n\t\t\t\t\t\t\t\t\te = s.end - r;\n\t\t\t\t\t\t\t\t\tif (c > e) { // if source crosses,\n\t\t\t\t\t\t\t\t\t\tc -= e; // wrapped copy\n\t\t\t\t\t\t\t\t\t\tif (q - r > 0 && e > (q - r)) {\n\t\t\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\n\t\t\t\t\t\t\t\t\t\t\t} while (--e !== 0);\n\t\t\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + e), q);\n\t\t\t\t\t\t\t\t\t\t\tq += e;\n\t\t\t\t\t\t\t\t\t\t\tr += e;\n\t\t\t\t\t\t\t\t\t\t\te = 0;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\tr = 0; // copy rest from start of window\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// copy all or what\'s left\n\t\t\t\t\t\t\t\tif (q - r > 0 && c > (q - r)) {\n\t\t\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\t\t\ts.window[q++] = s.window[r++];\n\t\t\t\t\t\t\t\t\t} while (--c !== 0);\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\ts.window.set(s.window.subarray(r, r + c), q);\n\t\t\t\t\t\t\t\t\tq += c;\n\t\t\t\t\t\t\t\t\tr += c;\n\t\t\t\t\t\t\t\t\tc = 0;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t} else if ((e & 64) === 0) {\n\t\t\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\n\t\t\t\t\t\t\t\tt += (b & inflate_mask[e]);\n\t\t\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\t\t\te = tp[tp_index_t_3];\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tz.msg = "invalid distance code";\n\n\t\t\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\t\t\tn += c;\n\t\t\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} while (true);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((e & 64) === 0) {\n\t\t\t\t\t\tt += tp[tp_index_t_3 + 2];\n\t\t\t\t\t\tt += (b & inflate_mask[e]);\n\t\t\t\t\t\ttp_index_t_3 = (tp_index + t) * 3;\n\t\t\t\t\t\tif ((e = tp[tp_index_t_3]) === 0) {\n\n\t\t\t\t\t\t\tb >>= (tp[tp_index_t_3 + 1]);\n\t\t\t\t\t\t\tk -= (tp[tp_index_t_3 + 1]);\n\n\t\t\t\t\t\t\ts.window[q++] = /* (byte) */tp[tp_index_t_3 + 2];\n\t\t\t\t\t\t\tm--;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t} else if ((e & 32) !== 0) {\n\n\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\tn += c;\n\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\treturn Z_STREAM_END;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tz.msg = "invalid literal/length code";\n\n\t\t\t\t\t\tc = z.avail_in - n;\n\t\t\t\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\t\t\t\tn += c;\n\t\t\t\t\t\tp -= c;\n\t\t\t\t\t\tk -= c << 3;\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\n\t\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\t\t}\n\t\t\t\t} while (true);\n\t\t\t} while (m >= 258 && n >= 10);\n\n\t\t\t// not enough input or output--restore pointers and return\n\t\t\tc = z.avail_in - n;\n\t\t\tc = (k >> 3) < c ? k >> 3 : c;\n\t\t\tn += c;\n\t\t\tp -= c;\n\t\t\tk -= c << 3;\n\n\t\t\ts.bitb = b;\n\t\t\ts.bitk = k;\n\t\t\tz.avail_in = n;\n\t\t\tz.total_in += p - z.next_in_index;\n\t\t\tz.next_in_index = p;\n\t\t\ts.write = q;\n\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.init = function(bl, bd, tl, tl_index, td, td_index) {\n\t\t\tmode = START;\n\t\t\tlbits = /* (byte) */bl;\n\t\t\tdbits = /* (byte) */bd;\n\t\t\tltree = tl;\n\t\t\tltree_index = tl_index;\n\t\t\tdtree = td;\n\t\t\tdtree_index = td_index;\n\t\t\ttree = null;\n\t\t};\n\n\t\tthat.proc = function(s, z, r) {\n\t\t\tvar j; // temporary storage\n\t\t\tvar tindex; // temporary pointer\n\t\t\tvar e; // extra bits or operation\n\t\t\tvar b = 0; // bit buffer\n\t\t\tvar k = 0; // bits in bit buffer\n\t\t\tvar p = 0; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\t\t\tvar f; // pointer to copy strings from\n\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = s.bitb;\n\t\t\tk = s.bitk;\n\t\t\tq = s.write;\n\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t// process input and output based on current state\n\t\t\twhile (true) {\n\t\t\t\tswitch (mode) {\n\t\t\t\t// waiting for "i:"=input, "o:"=output, "x:"=nothing\n\t\t\t\tcase START: // x: set up for LEN\n\t\t\t\t\tif (m >= 258 && n >= 10) {\n\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\tr = inflate_fast(lbits, dbits, ltree, ltree_index, dtree, dtree_index, s, z);\n\n\t\t\t\t\t\tp = z.next_in_index;\n\t\t\t\t\t\tn = z.avail_in;\n\t\t\t\t\t\tb = s.bitb;\n\t\t\t\t\t\tk = s.bitk;\n\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\tif (r != Z_OK) {\n\t\t\t\t\t\t\tmode = r == Z_STREAM_END ? WASH : BADCODE;\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tneed = lbits;\n\t\t\t\t\ttree = ltree;\n\t\t\t\t\ttree_index = ltree_index;\n\n\t\t\t\t\tmode = LEN;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase LEN: // i: get length/literal/eob next\n\t\t\t\t\tj = need;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\n\n\t\t\t\t\tb >>>= (tree[tindex + 1]);\n\t\t\t\t\tk -= (tree[tindex + 1]);\n\n\t\t\t\t\te = tree[tindex];\n\n\t\t\t\t\tif (e === 0) { // literal\n\t\t\t\t\t\tlit = tree[tindex + 2];\n\t\t\t\t\t\tmode = LIT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 16) !== 0) { // length\n\t\t\t\t\t\tget = e & 15;\n\t\t\t\t\t\tlen = tree[tindex + 2];\n\t\t\t\t\t\tmode = LENEXT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 64) === 0) { // next table\n\t\t\t\t\t\tneed = e;\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 32) !== 0) { // end of block\n\t\t\t\t\t\tmode = WASH;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = BADCODE; // invalid code\n\t\t\t\t\tz.msg = "invalid literal/length code";\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase LENEXT: // i: getting length extra (have base)\n\t\t\t\t\tj = get;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tlen += (b & inflate_mask[j]);\n\n\t\t\t\t\tb >>= j;\n\t\t\t\t\tk -= j;\n\n\t\t\t\t\tneed = dbits;\n\t\t\t\t\ttree = dtree;\n\t\t\t\t\ttree_index = dtree_index;\n\t\t\t\t\tmode = DIST;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DIST: // i: get distance next\n\t\t\t\t\tj = need;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttindex = (tree_index + (b & inflate_mask[j])) * 3;\n\n\t\t\t\t\tb >>= tree[tindex + 1];\n\t\t\t\t\tk -= tree[tindex + 1];\n\n\t\t\t\t\te = (tree[tindex]);\n\t\t\t\t\tif ((e & 16) !== 0) { // distance\n\t\t\t\t\t\tget = e & 15;\n\t\t\t\t\t\tdist = tree[tindex + 2];\n\t\t\t\t\t\tmode = DISTEXT;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((e & 64) === 0) { // next table\n\t\t\t\t\t\tneed = e;\n\t\t\t\t\t\ttree_index = tindex / 3 + tree[tindex + 2];\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = BADCODE; // invalid code\n\t\t\t\t\tz.msg = "invalid distance code";\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase DISTEXT: // i: getting distance extra\n\t\t\t\t\tj = get;\n\n\t\t\t\t\twhile (k < (j)) {\n\t\t\t\t\t\tif (n !== 0)\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\telse {\n\n\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tdist += (b & inflate_mask[j]);\n\n\t\t\t\t\tb >>= j;\n\t\t\t\t\tk -= j;\n\n\t\t\t\t\tmode = COPY;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase COPY: // o: copying bytes in window, waiting for space\n\t\t\t\t\tf = q - dist;\n\t\t\t\t\twhile (f < 0) { // modulo window size-"while" instead\n\t\t\t\t\t\tf += s.end; // of "if" handles invalid distances\n\t\t\t\t\t}\n\t\t\t\t\twhile (len !== 0) {\n\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ts.window[q++] = s.window[f++];\n\t\t\t\t\t\tm--;\n\n\t\t\t\t\t\tif (f == s.end)\n\t\t\t\t\t\t\tf = 0;\n\t\t\t\t\t\tlen--;\n\t\t\t\t\t}\n\t\t\t\t\tmode = START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase LIT: // o: got literal, waiting for output space\n\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\t\t\tq = s.write;\n\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\t\t\tif (q == s.end && s.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t\ts.window[q++] = /* (byte) */lit;\n\t\t\t\t\tm--;\n\n\t\t\t\t\tmode = START;\n\t\t\t\t\tbreak;\n\t\t\t\tcase WASH: // o: got eob, possibly more output\n\t\t\t\t\tif (k > 7) { // return unused byte, if any\n\t\t\t\t\t\tk -= 8;\n\t\t\t\t\t\tn++;\n\t\t\t\t\t\tp--; // can always return one\n\t\t\t\t\t}\n\n\t\t\t\t\ts.write = q;\n\t\t\t\t\tr = s.inflate_flush(z, r);\n\t\t\t\t\tq = s.write;\n\t\t\t\t\tm = q < s.read ? s.read - q - 1 : s.end - q;\n\n\t\t\t\t\tif (s.read != s.write) {\n\t\t\t\t\t\ts.bitb = b;\n\t\t\t\t\t\ts.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\ts.write = q;\n\t\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tmode = END;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase END:\n\t\t\t\t\tr = Z_STREAM_END;\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tcase BADCODE: // x: got error\n\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\n\t\t\t\tdefault:\n\t\t\t\t\tr = Z_STREAM_ERROR;\n\n\t\t\t\t\ts.bitb = b;\n\t\t\t\t\ts.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\ts.write = q;\n\t\t\t\t\treturn s.inflate_flush(z, r);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.free = function() {\n\t\t\t// ZFREE(z, c);\n\t\t};\n\n\t}\n\n\t// InfBlocks\n\n\t// Table for deflate from PKZIP\'s appnote.txt.\n\tvar border = [ // Order of the bit length code lengths\n\t16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15 ];\n\n\tvar TYPE = 0; // get type bits (3, including end bit)\n\tvar LENS = 1; // get lengths for stored\n\tvar STORED = 2;// processing stored block\n\tvar TABLE = 3; // get table lengths\n\tvar BTREE = 4; // get bit lengths tree for a dynamic\n\t// block\n\tvar DTREE = 5; // get length, distance trees for a\n\t// dynamic block\n\tvar CODES = 6; // processing fixed or dynamic block\n\tvar DRY = 7; // output remaining window bytes\n\tvar DONELOCKS = 8; // finished last block, done\n\tvar BADBLOCKS = 9; // ot a data error--stuck here\n\n\tfunction InfBlocks(z, w) {\n\t\tvar that = this;\n\n\t\tvar mode = TYPE; // current inflate_block mode\n\n\t\tvar left = 0; // if STORED, bytes left to copy\n\n\t\tvar table = 0; // table lengths (14 bits)\n\t\tvar index = 0; // index into blens (or border)\n\t\tvar blens; // bit lengths of codes\n\t\tvar bb = [ 0 ]; // bit length tree depth\n\t\tvar tb = [ 0 ]; // bit length decoding tree\n\n\t\tvar codes = new InfCodes(); // if CODES, current state\n\n\t\tvar last = 0; // true if this block is the last block\n\n\t\tvar hufts = new Int32Array(MANY * 3); // single malloc for tree space\n\t\tvar check = 0; // check on output\n\t\tvar inftree = new InfTree();\n\n\t\tthat.bitk = 0; // bits in bit buffer\n\t\tthat.bitb = 0; // bit buffer\n\t\tthat.window = new Uint8Array(w); // sliding window\n\t\tthat.end = w; // one byte after sliding window\n\t\tthat.read = 0; // window read pointer\n\t\tthat.write = 0; // window write pointer\n\n\t\tthat.reset = function(z, c) {\n\t\t\tif (c)\n\t\t\t\tc[0] = check;\n\t\t\t// if (mode == BTREE || mode == DTREE) {\n\t\t\t// }\n\t\t\tif (mode == CODES) {\n\t\t\t\tcodes.free(z);\n\t\t\t}\n\t\t\tmode = TYPE;\n\t\t\tthat.bitk = 0;\n\t\t\tthat.bitb = 0;\n\t\t\tthat.read = that.write = 0;\n\t\t};\n\n\t\tthat.reset(z, null);\n\n\t\t// copy as much as possible from the sliding window to the output area\n\t\tthat.inflate_flush = function(z, r) {\n\t\t\tvar n;\n\t\t\tvar p;\n\t\t\tvar q;\n\n\t\t\t// local copies of source and destination pointers\n\t\t\tp = z.next_out_index;\n\t\t\tq = that.read;\n\n\t\t\t// compute number of bytes to copy as far as end of window\n\t\t\tn = /* (int) */((q <= that.write ? that.write : that.end) - q);\n\t\t\tif (n > z.avail_out)\n\t\t\t\tn = z.avail_out;\n\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\n\t\t\t\tr = Z_OK;\n\n\t\t\t// update counters\n\t\t\tz.avail_out -= n;\n\t\t\tz.total_out += n;\n\n\t\t\t// copy as far as end of window\n\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\n\t\t\tp += n;\n\t\t\tq += n;\n\n\t\t\t// see if more to copy at beginning of window\n\t\t\tif (q == that.end) {\n\t\t\t\t// wrap pointers\n\t\t\t\tq = 0;\n\t\t\t\tif (that.write == that.end)\n\t\t\t\t\tthat.write = 0;\n\n\t\t\t\t// compute bytes to copy\n\t\t\t\tn = that.write - q;\n\t\t\t\tif (n > z.avail_out)\n\t\t\t\t\tn = z.avail_out;\n\t\t\t\tif (n !== 0 && r == Z_BUF_ERROR)\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t// update counters\n\t\t\t\tz.avail_out -= n;\n\t\t\t\tz.total_out += n;\n\n\t\t\t\t// copy\n\t\t\t\tz.next_out.set(that.window.subarray(q, q + n), p);\n\t\t\t\tp += n;\n\t\t\t\tq += n;\n\t\t\t}\n\n\t\t\t// update pointers\n\t\t\tz.next_out_index = p;\n\t\t\tthat.read = q;\n\n\t\t\t// done\n\t\t\treturn r;\n\t\t};\n\n\t\tthat.proc = function(z, r) {\n\t\t\tvar t; // temporary storage\n\t\t\tvar b; // bit buffer\n\t\t\tvar k; // bits in bit buffer\n\t\t\tvar p; // input data pointer\n\t\t\tvar n; // bytes available there\n\t\t\tvar q; // output window write pointer\n\t\t\tvar m; // bytes to end of window or read pointer\n\n\t\t\tvar i;\n\n\t\t\t// copy input/output information to locals (UPDATE macro restores)\n\t\t\t// {\n\t\t\tp = z.next_in_index;\n\t\t\tn = z.avail_in;\n\t\t\tb = that.bitb;\n\t\t\tk = that.bitk;\n\t\t\t// }\n\t\t\t// {\n\t\t\tq = that.write;\n\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t// }\n\n\t\t\t// process input based on current state\n\t\t\t// DEBUG dtree\n\t\t\twhile (true) {\n\t\t\t\tswitch (mode) {\n\t\t\t\tcase TYPE:\n\n\t\t\t\t\twhile (k < (3)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\t\t\t\t\tt = /* (int) */(b & 7);\n\t\t\t\t\tlast = t & 1;\n\n\t\t\t\t\tswitch (t >>> 1) {\n\t\t\t\t\tcase 0: // stored\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tt = k & 7; // go to byte boundary\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\tk -= (t);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tmode = LENS; // get length of stored block\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 1: // fixed\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tvar bl = []; // new Array(1);\n\t\t\t\t\t\tvar bd = []; // new Array(1);\n\t\t\t\t\t\tvar tl = [ [] ]; // new Array(1);\n\t\t\t\t\t\tvar td = [ [] ]; // new Array(1);\n\n\t\t\t\t\t\tInfTree.inflate_trees_fixed(bl, bd, tl, td);\n\t\t\t\t\t\tcodes.init(bl[0], bd[0], tl[0], 0, td[0], 0);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tmode = CODES;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 2: // dynamic\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tmode = TABLE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase 3: // illegal\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = "invalid block type";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tbreak;\n\t\t\t\tcase LENS:\n\n\t\t\t\t\twhile (k < (32)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((((~b) >>> 16) & 0xffff) != (b & 0xffff)) {\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = "invalid stored block lengths";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tleft = (b & 0xffff);\n\t\t\t\t\tb = k = 0; // dump bits\n\t\t\t\t\tmode = left !== 0 ? STORED : (last !== 0 ? DRY : TYPE);\n\t\t\t\t\tbreak;\n\t\t\t\tcase STORED:\n\t\t\t\t\tif (n === 0) {\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\n\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\n\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\tr = that.inflate_flush(z, r);\n\t\t\t\t\t\t\tq = that.write;\n\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t\tif (q == that.end && that.read !== 0) {\n\t\t\t\t\t\t\t\tq = 0;\n\t\t\t\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tif (m === 0) {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\n\t\t\t\t\tt = left;\n\t\t\t\t\tif (t > n)\n\t\t\t\t\t\tt = n;\n\t\t\t\t\tif (t > m)\n\t\t\t\t\t\tt = m;\n\t\t\t\t\tthat.window.set(z.read_buf(p, t), q);\n\t\t\t\t\tp += t;\n\t\t\t\t\tn -= t;\n\t\t\t\t\tq += t;\n\t\t\t\t\tm -= t;\n\t\t\t\t\tif ((left -= t) !== 0)\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tmode = last !== 0 ? DRY : TYPE;\n\t\t\t\t\tbreak;\n\t\t\t\tcase TABLE:\n\n\t\t\t\t\twhile (k < (14)) {\n\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tn--;\n\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\tk += 8;\n\t\t\t\t\t}\n\n\t\t\t\t\ttable = t = (b & 0x3fff);\n\t\t\t\t\tif ((t & 0x1f) > 29 || ((t >> 5) & 0x1f) > 29) {\n\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\tz.msg = "too many length or distance symbols";\n\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tt = 258 + (t & 0x1f) + ((t >> 5) & 0x1f);\n\t\t\t\t\tif (!blens || blens.length < t) {\n\t\t\t\t\t\tblens = []; // new Array(t);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tfor (i = 0; i < t; i++) {\n\t\t\t\t\t\t\tblens[i] = 0;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// {\n\t\t\t\t\tb >>>= (14);\n\t\t\t\t\tk -= (14);\n\t\t\t\t\t// }\n\n\t\t\t\t\tindex = 0;\n\t\t\t\t\tmode = BTREE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase BTREE:\n\t\t\t\t\twhile (index < 4 + (table >>> 10)) {\n\t\t\t\t\t\twhile (k < (3)) {\n\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tblens[border[index++]] = b & 7;\n\n\t\t\t\t\t\t// {\n\t\t\t\t\t\tb >>>= (3);\n\t\t\t\t\t\tk -= (3);\n\t\t\t\t\t\t// }\n\t\t\t\t\t}\n\n\t\t\t\t\twhile (index < 19) {\n\t\t\t\t\t\tblens[border[index++]] = 0;\n\t\t\t\t\t}\n\n\t\t\t\t\tbb[0] = 7;\n\t\t\t\t\tt = inftree.inflate_trees_bits(blens, bb, tb, hufts, z);\n\t\t\t\t\tif (t != Z_OK) {\n\t\t\t\t\t\tr = t;\n\t\t\t\t\t\tif (r == Z_DATA_ERROR) {\n\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\n\t\t\t\t\tindex = 0;\n\t\t\t\t\tmode = DTREE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DTREE:\n\t\t\t\t\twhile (true) {\n\t\t\t\t\t\tt = table;\n\t\t\t\t\t\tif (index >= 258 + (t & 0x1f) + ((t >> 5) & 0x1f)) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tvar j, c;\n\n\t\t\t\t\t\tt = bb[0];\n\n\t\t\t\t\t\twhile (k < (t)) {\n\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// if (tb[0] == -1) {\n\t\t\t\t\t\t// System.err.println("null...");\n\t\t\t\t\t\t// }\n\n\t\t\t\t\t\tt = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 1];\n\t\t\t\t\t\tc = hufts[(tb[0] + (b & inflate_mask[t])) * 3 + 2];\n\n\t\t\t\t\t\tif (c < 16) {\n\t\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\t\tk -= (t);\n\t\t\t\t\t\t\tblens[index++] = c;\n\t\t\t\t\t\t} else { // c == 16..18\n\t\t\t\t\t\t\ti = c == 18 ? 7 : c - 14;\n\t\t\t\t\t\t\tj = c == 18 ? 11 : 3;\n\n\t\t\t\t\t\t\twhile (k < (t + i)) {\n\t\t\t\t\t\t\t\tif (n !== 0) {\n\t\t\t\t\t\t\t\t\tr = Z_OK;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\tn--;\n\t\t\t\t\t\t\t\tb |= (z.read_byte(p++) & 0xff) << k;\n\t\t\t\t\t\t\t\tk += 8;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tb >>>= (t);\n\t\t\t\t\t\t\tk -= (t);\n\n\t\t\t\t\t\t\tj += (b & inflate_mask[i]);\n\n\t\t\t\t\t\t\tb >>>= (i);\n\t\t\t\t\t\t\tk -= (i);\n\n\t\t\t\t\t\t\ti = index;\n\t\t\t\t\t\t\tt = table;\n\t\t\t\t\t\t\tif (i + j > 258 + (t & 0x1f) + ((t >> 5) & 0x1f) || (c == 16 && i < 1)) {\n\t\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t\t\tz.msg = "invalid bit length repeat";\n\t\t\t\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tc = c == 16 ? blens[i - 1] : 0;\n\t\t\t\t\t\t\tdo {\n\t\t\t\t\t\t\t\tblens[i++] = c;\n\t\t\t\t\t\t\t} while (--j !== 0);\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\ttb[0] = -1;\n\t\t\t\t\t// {\n\t\t\t\t\tvar bl_ = []; // new Array(1);\n\t\t\t\t\tvar bd_ = []; // new Array(1);\n\t\t\t\t\tvar tl_ = []; // new Array(1);\n\t\t\t\t\tvar td_ = []; // new Array(1);\n\t\t\t\t\tbl_[0] = 9; // must be <= 9 for lookahead assumptions\n\t\t\t\t\tbd_[0] = 6; // must be <= 9 for lookahead assumptions\n\n\t\t\t\t\tt = table;\n\t\t\t\t\tt = inftree.inflate_trees_dynamic(257 + (t & 0x1f), 1 + ((t >> 5) & 0x1f), blens, bl_, bd_, tl_, td_, hufts, z);\n\n\t\t\t\t\tif (t != Z_OK) {\n\t\t\t\t\t\tif (t == Z_DATA_ERROR) {\n\t\t\t\t\t\t\tblens = null;\n\t\t\t\t\t\t\tmode = BADBLOCKS;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tr = t;\n\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tcodes.init(bl_[0], bd_[0], hufts, tl_[0], hufts, td_[0]);\n\t\t\t\t\t// }\n\t\t\t\t\tmode = CODES;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase CODES:\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\n\t\t\t\t\tif ((r = codes.proc(that, z, r)) != Z_STREAM_END) {\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tr = Z_OK;\n\t\t\t\t\tcodes.free(z);\n\n\t\t\t\t\tp = z.next_in_index;\n\t\t\t\t\tn = z.avail_in;\n\t\t\t\t\tb = that.bitb;\n\t\t\t\t\tk = that.bitk;\n\t\t\t\t\tq = that.write;\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\n\t\t\t\t\tif (last === 0) {\n\t\t\t\t\t\tmode = TYPE;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tmode = DRY;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DRY:\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\tr = that.inflate_flush(z, r);\n\t\t\t\t\tq = that.write;\n\t\t\t\t\tm = /* (int) */(q < that.read ? that.read - q - 1 : that.end - q);\n\t\t\t\t\tif (that.read != that.write) {\n\t\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\t\tthat.write = q;\n\t\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t\t}\n\t\t\t\t\tmode = DONELOCKS;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DONELOCKS:\n\t\t\t\t\tr = Z_STREAM_END;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\tcase BADBLOCKS:\n\t\t\t\t\tr = Z_DATA_ERROR;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\n\t\t\t\tdefault:\n\t\t\t\t\tr = Z_STREAM_ERROR;\n\n\t\t\t\t\tthat.bitb = b;\n\t\t\t\t\tthat.bitk = k;\n\t\t\t\t\tz.avail_in = n;\n\t\t\t\t\tz.total_in += p - z.next_in_index;\n\t\t\t\t\tz.next_in_index = p;\n\t\t\t\t\tthat.write = q;\n\t\t\t\t\treturn that.inflate_flush(z, r);\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.free = function(z) {\n\t\t\tthat.reset(z, null);\n\t\t\tthat.window = null;\n\t\t\thufts = null;\n\t\t\t// ZFREE(z, s);\n\t\t};\n\n\t\tthat.set_dictionary = function(d, start, n) {\n\t\t\tthat.window.set(d.subarray(start, start + n), 0);\n\t\t\tthat.read = that.write = n;\n\t\t};\n\n\t\t// Returns true if inflate is currently at the end of a block generated\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH.\n\t\tthat.sync_point = function() {\n\t\t\treturn mode == LENS ? 1 : 0;\n\t\t};\n\n\t}\n\n\t// Inflate\n\n\t// preset dictionary flag in zlib header\n\tvar PRESET_DICT = 0x20;\n\n\tvar Z_DEFLATED = 8;\n\n\tvar METHOD = 0; // waiting for method byte\n\tvar FLAG = 1; // waiting for flag byte\n\tvar DICT4 = 2; // four dictionary check bytes to go\n\tvar DICT3 = 3; // three dictionary check bytes to go\n\tvar DICT2 = 4; // two dictionary check bytes to go\n\tvar DICT1 = 5; // one dictionary check byte to go\n\tvar DICT0 = 6; // waiting for inflateSetDictionary\n\tvar BLOCKS = 7; // decompressing blocks\n\tvar DONE = 12; // finished check, done\n\tvar BAD = 13; // got an error--stay here\n\n\tvar mark = [ 0, 0, 0xff, 0xff ];\n\n\tfunction Inflate() {\n\t\tvar that = this;\n\n\t\tthat.mode = 0; // current inflate mode\n\n\t\t// mode dependent information\n\t\tthat.method = 0; // if FLAGS, method byte\n\n\t\t// if CHECK, check values to compare\n\t\tthat.was = [ 0 ]; // new Array(1); // computed check value\n\t\tthat.need = 0; // stream check value\n\n\t\t// if BAD, inflateSync\'s marker bytes count\n\t\tthat.marker = 0;\n\n\t\t// mode independent information\n\t\tthat.wbits = 0; // log2(window size) (8..15, defaults to 15)\n\n\t\t// this.blocks; // current inflate_blocks state\n\n\t\tfunction inflateReset(z) {\n\t\t\tif (!z || !z.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tz.total_in = z.total_out = 0;\n\t\t\tz.msg = null;\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\tz.istate.blocks.reset(z, null);\n\t\t\treturn Z_OK;\n\t\t}\n\n\t\tthat.inflateEnd = function(z) {\n\t\t\tif (that.blocks)\n\t\t\t\tthat.blocks.free(z);\n\t\t\tthat.blocks = null;\n\t\t\t// ZFREE(z, z->state);\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflateInit = function(z, w) {\n\t\t\tz.msg = null;\n\t\t\tthat.blocks = null;\n\n\t\t\t// set window size\n\t\t\tif (w < 8 || w > 15) {\n\t\t\t\tthat.inflateEnd(z);\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t}\n\t\t\tthat.wbits = w;\n\n\t\t\tz.istate.blocks = new InfBlocks(z, 1 << w);\n\n\t\t\t// reset state\n\t\t\tinflateReset(z);\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflate = function(z, f) {\n\t\t\tvar r;\n\t\t\tvar b;\n\n\t\t\tif (!z || !z.istate || !z.next_in)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tf = f == Z_FINISH ? Z_BUF_ERROR : Z_OK;\n\t\t\tr = Z_BUF_ERROR;\n\t\t\twhile (true) {\n\t\t\t\t// System.out.println("mode: "+z.istate.mode);\n\t\t\t\tswitch (z.istate.mode) {\n\t\t\t\tcase METHOD:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tif (((z.istate.method = z.read_byte(z.next_in_index++)) & 0xf) != Z_DEFLATED) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = "unknown compression method";\n\t\t\t\t\t\tz.istate.marker = 5; // can\'t try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif ((z.istate.method >> 4) + 8 > z.istate.wbits) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = "invalid window size";\n\t\t\t\t\t\tz.istate.marker = 5; // can\'t try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tz.istate.mode = FLAG;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase FLAG:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tb = (z.read_byte(z.next_in_index++)) & 0xff;\n\n\t\t\t\t\tif ((((z.istate.method << 8) + b) % 31) !== 0) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.msg = "incorrect header check";\n\t\t\t\t\t\tz.istate.marker = 5; // can\'t try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\n\t\t\t\t\tif ((b & PRESET_DICT) === 0) {\n\t\t\t\t\t\tz.istate.mode = BLOCKS;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tz.istate.mode = DICT4;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT4:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need = ((z.read_byte(z.next_in_index++) & 0xff) << 24) & 0xff000000;\n\t\t\t\t\tz.istate.mode = DICT3;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT3:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 16) & 0xff0000;\n\t\t\t\t\tz.istate.mode = DICT2;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT2:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += ((z.read_byte(z.next_in_index++) & 0xff) << 8) & 0xff00;\n\t\t\t\t\tz.istate.mode = DICT1;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DICT1:\n\n\t\t\t\t\tif (z.avail_in === 0)\n\t\t\t\t\t\treturn r;\n\t\t\t\t\tr = f;\n\n\t\t\t\t\tz.avail_in--;\n\t\t\t\t\tz.total_in++;\n\t\t\t\t\tz.istate.need += (z.read_byte(z.next_in_index++) & 0xff);\n\t\t\t\t\tz.istate.mode = DICT0;\n\t\t\t\t\treturn Z_NEED_DICT;\n\t\t\t\tcase DICT0:\n\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\tz.msg = "need dictionary";\n\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\n\t\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t\tcase BLOCKS:\n\n\t\t\t\t\tr = z.istate.blocks.proc(z, r);\n\t\t\t\t\tif (r == Z_DATA_ERROR) {\n\t\t\t\t\t\tz.istate.mode = BAD;\n\t\t\t\t\t\tz.istate.marker = 0; // can try inflateSync\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\tif (r == Z_OK) {\n\t\t\t\t\t\tr = f;\n\t\t\t\t\t}\n\t\t\t\t\tif (r != Z_STREAM_END) {\n\t\t\t\t\t\treturn r;\n\t\t\t\t\t}\n\t\t\t\t\tr = f;\n\t\t\t\t\tz.istate.blocks.reset(z, z.istate.was);\n\t\t\t\t\tz.istate.mode = DONE;\n\t\t\t\t\t/* falls through */\n\t\t\t\tcase DONE:\n\t\t\t\t\treturn Z_STREAM_END;\n\t\t\t\tcase BAD:\n\t\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t\tdefault:\n\t\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\t\t}\n\t\t\t}\n\t\t};\n\n\t\tthat.inflateSetDictionary = function(z, dictionary, dictLength) {\n\t\t\tvar index = 0;\n\t\t\tvar length = dictLength;\n\t\t\tif (!z || !z.istate || z.istate.mode != DICT0)\n\t\t\t\treturn Z_STREAM_ERROR;\n\n\t\t\tif (length >= (1 << z.istate.wbits)) {\n\t\t\t\tlength = (1 << z.istate.wbits) - 1;\n\t\t\t\tindex = dictLength - length;\n\t\t\t}\n\t\t\tz.istate.blocks.set_dictionary(dictionary, index, length);\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\tthat.inflateSync = function(z) {\n\t\t\tvar n; // number of bytes to look at\n\t\t\tvar p; // pointer to bytes\n\t\t\tvar m; // number of marker bytes found in a row\n\t\t\tvar r, w; // temporaries to save total_in and total_out\n\n\t\t\t// set up\n\t\t\tif (!z || !z.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tif (z.istate.mode != BAD) {\n\t\t\t\tz.istate.mode = BAD;\n\t\t\t\tz.istate.marker = 0;\n\t\t\t}\n\t\t\tif ((n = z.avail_in) === 0)\n\t\t\t\treturn Z_BUF_ERROR;\n\t\t\tp = z.next_in_index;\n\t\t\tm = z.istate.marker;\n\n\t\t\t// search\n\t\t\twhile (n !== 0 && m < 4) {\n\t\t\t\tif (z.read_byte(p) == mark[m]) {\n\t\t\t\t\tm++;\n\t\t\t\t} else if (z.read_byte(p) !== 0) {\n\t\t\t\t\tm = 0;\n\t\t\t\t} else {\n\t\t\t\t\tm = 4 - m;\n\t\t\t\t}\n\t\t\t\tp++;\n\t\t\t\tn--;\n\t\t\t}\n\n\t\t\t// restore\n\t\t\tz.total_in += p - z.next_in_index;\n\t\t\tz.next_in_index = p;\n\t\t\tz.avail_in = n;\n\t\t\tz.istate.marker = m;\n\n\t\t\t// return no joy or set up to restart on a new block\n\t\t\tif (m != 4) {\n\t\t\t\treturn Z_DATA_ERROR;\n\t\t\t}\n\t\t\tr = z.total_in;\n\t\t\tw = z.total_out;\n\t\t\tinflateReset(z);\n\t\t\tz.total_in = r;\n\t\t\tz.total_out = w;\n\t\t\tz.istate.mode = BLOCKS;\n\t\t\treturn Z_OK;\n\t\t};\n\n\t\t// Returns true if inflate is currently at the end of a block generated\n\t\t// by Z_SYNC_FLUSH or Z_FULL_FLUSH. This function is used by one PPP\n\t\t// implementation to provide an additional safety check. PPP uses\n\t\t// Z_SYNC_FLUSH\n\t\t// but removes the length bytes of the resulting empty stored block. When\n\t\t// decompressing, PPP checks that at the end of input packet, inflate is\n\t\t// waiting for these length bytes.\n\t\tthat.inflateSyncPoint = function(z) {\n\t\t\tif (!z || !z.istate || !z.istate.blocks)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn z.istate.blocks.sync_point();\n\t\t};\n\t}\n\n\t// ZStream\n\n\tfunction ZStream() {\n\t}\n\n\tZStream.prototype = {\n\t\tinflateInit : function(bits) {\n\t\t\tvar that = this;\n\t\t\tthat.istate = new Inflate();\n\t\t\tif (!bits)\n\t\t\t\tbits = MAX_BITS;\n\t\t\treturn that.istate.inflateInit(that, bits);\n\t\t},\n\n\t\tinflate : function(f) {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflate(that, f);\n\t\t},\n\n\t\tinflateEnd : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\tvar ret = that.istate.inflateEnd(that);\n\t\t\tthat.istate = null;\n\t\t\treturn ret;\n\t\t},\n\n\t\tinflateSync : function() {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflateSync(that);\n\t\t},\n\t\tinflateSetDictionary : function(dictionary, dictLength) {\n\t\t\tvar that = this;\n\t\t\tif (!that.istate)\n\t\t\t\treturn Z_STREAM_ERROR;\n\t\t\treturn that.istate.inflateSetDictionary(that, dictionary, dictLength);\n\t\t},\n\t\tread_byte : function(start) {\n\t\t\tvar that = this;\n\t\t\treturn that.next_in.subarray(start, start + 1)[0];\n\t\t},\n\t\tread_buf : function(start, size) {\n\t\t\tvar that = this;\n\t\t\treturn that.next_in.subarray(start, start + size);\n\t\t}\n\t};\n\n\t// Inflater\n\n\tfunction Inflater() {\n\t\tvar that = this;\n\t\tvar z = new ZStream();\n\t\tvar bufsize = 512;\n\t\tvar flush = Z_NO_FLUSH;\n\t\tvar buf = new Uint8Array(bufsize);\n\t\tvar nomoreinput = false;\n\n\t\tz.inflateInit();\n\t\tz.next_out = buf;\n\n\t\tthat.append = function(data, onprogress) {\n\t\t\tvar err, buffers = [], lastIndex = 0, bufferIndex = 0, bufferSize = 0, array;\n\t\t\tif (data.length === 0)\n\t\t\t\treturn;\n\t\t\tz.next_in_index = 0;\n\t\t\tz.next_in = data;\n\t\t\tz.avail_in = data.length;\n\t\t\tdo {\n\t\t\t\tz.next_out_index = 0;\n\t\t\t\tz.avail_out = bufsize;\n\t\t\t\tif ((z.avail_in === 0) && (!nomoreinput)) { // if buffer is empty and more input is available, refill it\n\t\t\t\t\tz.next_in_index = 0;\n\t\t\t\t\tnomoreinput = true;\n\t\t\t\t}\n\t\t\t\terr = z.inflate(flush);\n\t\t\t\tif (nomoreinput && (err === Z_BUF_ERROR)) {\n\t\t\t\t\tif (z.avail_in !== 0)\n\t\t\t\t\t\tthrow new Error("inflating: bad input");\n\t\t\t\t} else if (err !== Z_OK && err !== Z_STREAM_END)\n\t\t\t\t\tthrow new Error("inflating: " + z.msg);\n\t\t\t\tif ((nomoreinput || err === Z_STREAM_END) && (z.avail_in === data.length))\n\t\t\t\t\tthrow new Error("inflating: bad input");\n\t\t\t\tif (z.next_out_index)\n\t\t\t\t\tif (z.next_out_index === bufsize)\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf));\n\t\t\t\t\telse\n\t\t\t\t\t\tbuffers.push(new Uint8Array(buf.subarray(0, z.next_out_index)));\n\t\t\t\tbufferSize += z.next_out_index;\n\t\t\t\tif (onprogress && z.next_in_index > 0 && z.next_in_index != lastIndex) {\n\t\t\t\t\tonprogress(z.next_in_index);\n\t\t\t\t\tlastIndex = z.next_in_index;\n\t\t\t\t}\n\t\t\t} while (z.avail_in > 0 || z.avail_out === 0);\n\t\t\tarray = new Uint8Array(bufferSize);\n\t\t\tbuffers.forEach(function(chunk) {\n\t\t\t\tarray.set(chunk, bufferIndex);\n\t\t\t\tbufferIndex += chunk.length;\n\t\t\t});\n\t\t\treturn array;\n\t\t};\n\t\tthat.flush = function() {\n\t\t\tz.inflateEnd();\n\t\t};\n\t}\n\n\t// \'zip\' may not be defined in z-worker and some tests\n\tvar env = global.zip || global;\n\tenv.Inflater = env._jzlib_Inflater = Inflater;\n})(this);\n'},function(t,n,e){"use strict";e.r(n);var i={};e.r(i),e.d(i,"VERSION",(function(){return r.e})),e.d(i,"restArguments",(function(){return a})),e.d(i,"isObject",(function(){return o})),e.d(i,"isNull",(function(){return s})),e.d(i,"isUndefined",(function(){return l})),e.d(i,"isBoolean",(function(){return d})),e.d(i,"isElement",(function(){return c})),e.d(i,"isString",(function(){return p})),e.d(i,"isNumber",(function(){return u})),e.d(i,"isDate",(function(){return h})),e.d(i,"isRegExp",(function(){return m})),e.d(i,"isError",(function(){return v})),e.d(i,"isSymbol",(function(){return g})),e.d(i,"isArrayBuffer",(function(){return b})),e.d(i,"isDataView",(function(){return I})),e.d(i,"isArray",(function(){return D})),e.d(i,"isFunction",(function(){return y})),e.d(i,"isArguments",(function(){return z})),e.d(i,"isFinite",(function(){return O})),e.d(i,"isNaN",(function(){return P})),e.d(i,"isTypedArray",(function(){return L})),e.d(i,"isEmpty",(function(){return U})),e.d(i,"isMatch",(function(){return q})),e.d(i,"isEqual",(function(){return Z})),e.d(i,"isMap",(function(){return rt})),e.d(i,"isWeakMap",(function(){return at})),e.d(i,"isSet",(function(){return ot})),e.d(i,"isWeakSet",(function(){return st})),e.d(i,"keys",(function(){return B})),e.d(i,"allKeys",(function(){return W})),e.d(i,"values",(function(){return lt})),e.d(i,"pairs",(function(){return dt})),e.d(i,"invert",(function(){return ct})),e.d(i,"functions",(function(){return ft})),e.d(i,"methods",(function(){return ft})),e.d(i,"extend",(function(){return ut})),e.d(i,"extendOwn",(function(){return ht})),e.d(i,"assign",(function(){return ht})),e.d(i,"defaults",(function(){return mt})),e.d(i,"create",(function(){return gt})),e.d(i,"clone",(function(){return bt})),e.d(i,"tap",(function(){return wt})),e.d(i,"get",(function(){return kt})),e.d(i,"has",(function(){return Tt})),e.d(i,"mapObject",(function(){return Ot})),e.d(i,"identity",(function(){return St})),e.d(i,"constant",(function(){return R})),e.d(i,"noop",(function(){return Pt})),e.d(i,"toPath",(function(){return xt})),e.d(i,"property",(function(){return $t})),e.d(i,"propertyOf",(function(){return Rt})),e.d(i,"matcher",(function(){return It})),e.d(i,"matches",(function(){return It})),e.d(i,"times",(function(){return At})),e.d(i,"random",(function(){return Et})),e.d(i,"now",(function(){return Mt})),e.d(i,"escape",(function(){return Lt})),e.d(i,"unescape",(function(){return Nt})),e.d(i,"templateSettings",(function(){return Kt})),e.d(i,"template",(function(){return Gt})),e.d(i,"result",(function(){return Yt})),e.d(i,"uniqueId",(function(){return Wt})),e.d(i,"chain",(function(){return Xt})),e.d(i,"iteratee",(function(){return Ct})),e.d(i,"partial",(function(){return tn})),e.d(i,"bind",(function(){return nn})),e.d(i,"bindAll",(function(){return an})),e.d(i,"memoize",(function(){return on})),e.d(i,"delay",(function(){return sn})),e.d(i,"defer",(function(){return ln})),e.d(i,"throttle",(function(){return dn})),e.d(i,"debounce",(function(){return cn})),e.d(i,"wrap",(function(){return fn})),e.d(i,"negate",(function(){return pn})),e.d(i,"compose",(function(){return un})),e.d(i,"after",(function(){return hn})),e.d(i,"before",(function(){return mn})),e.d(i,"once",(function(){return vn})),e.d(i,"findKey",(function(){return gn})),e.d(i,"findIndex",(function(){return wn})),e.d(i,"findLastIndex",(function(){return xn})),e.d(i,"sortedIndex",(function(){return yn})),e.d(i,"indexOf",(function(){return kn})),e.d(i,"lastIndexOf",(function(){return Tn})),e.d(i,"find",(function(){return Sn})),e.d(i,"detect",(function(){return Sn})),e.d(i,"findWhere",(function(){return In})),e.d(i,"each",(function(){return $n})),e.d(i,"forEach",(function(){return $n})),e.d(i,"map",(function(){return Dn})),e.d(i,"collect",(function(){return Dn})),e.d(i,"reduce",(function(){return Cn})),e.d(i,"foldl",(function(){return Cn})),e.d(i,"inject",(function(){return Cn})),e.d(i,"reduceRight",(function(){return zn})),e.d(i,"foldr",(function(){return zn})),e.d(i,"filter",(function(){return On})),e.d(i,"select",(function(){return On})),e.d(i,"reject",(function(){return Pn})),e.d(i,"every",(function(){return Rn})),e.d(i,"all",(function(){return Rn})),e.d(i,"some",(function(){return An})),e.d(i,"any",(function(){return An})),e.d(i,"contains",(function(){return En})),e.d(i,"includes",(function(){return En})),e.d(i,"include",(function(){return En})),e.d(i,"invoke",(function(){return Mn})),e.d(i,"pluck",(function(){return Fn})),e.d(i,"where",(function(){return Vn})),e.d(i,"max",(function(){return Ln})),e.d(i,"min",(function(){return Nn})),e.d(i,"shuffle",(function(){return Bn})),e.d(i,"sample",(function(){return Kn})),e.d(i,"sortBy",(function(){return Un})),e.d(i,"groupBy",(function(){return Hn})),e.d(i,"indexBy",(function(){return Gn})),e.d(i,"countBy",(function(){return Yn})),e.d(i,"partition",(function(){return Zn})),e.d(i,"toArray",(function(){return Xn})),e.d(i,"size",(function(){return Jn})),e.d(i,"pick",(function(){return te})),e.d(i,"omit",(function(){return ne})),e.d(i,"first",(function(){return ie})),e.d(i,"head",(function(){return ie})),e.d(i,"take",(function(){return ie})),e.d(i,"initial",(function(){return ee})),e.d(i,"last",(function(){return ae})),e.d(i,"rest",(function(){return re})),e.d(i,"tail",(function(){return re})),e.d(i,"drop",(function(){return re})),e.d(i,"compact",(function(){return oe})),e.d(i,"flatten",(function(){return se})),e.d(i,"without",(function(){return de})),e.d(i,"uniq",(function(){return ce})),e.d(i,"unique",(function(){return ce})),e.d(i,"union",(function(){return fe})),e.d(i,"intersection",(function(){return pe})),e.d(i,"difference",(function(){return le})),e.d(i,"unzip",(function(){return ue})),e.d(i,"transpose",(function(){return ue})),e.d(i,"zip",(function(){return he})),e.d(i,"object",(function(){return me})),e.d(i,"range",(function(){return ve})),e.d(i,"chunk",(function(){return ge})),e.d(i,"mixin",(function(){return we})),e.d(i,"default",(function(){return xe}));var r=e(0);function a(t,n){return n=null==n?t.length-1:+n,function(){for(var e=Math.max(arguments.length-n,0),i=Array(e),r=0;r<e;r++)i[r]=arguments[r+n];switch(n){case 0:return t.call(this,i);case 1:return t.call(this,arguments[0],i);case 2:return t.call(this,arguments[0],arguments[1],i)}var a=Array(n+1);for(r=0;r<n;r++)a[r]=arguments[r];return a[n]=i,t.apply(this,a)}}function o(t){var n=typeof t;return"function"===n||"object"===n&&!!t}function s(t){return null===t}function l(t){return void 0===t}function d(t){return!0===t||!1===t||"[object Boolean]"===r.t.call(t)}function c(t){return!(!t||1!==t.nodeType)}function f(t){var n="[object "+t+"]";return function(t){return r.t.call(t)===n}}var p=f("String"),u=f("Number"),h=f("Date"),m=f("RegExp"),v=f("Error"),g=f("Symbol"),b=f("ArrayBuffer"),w=f("Function"),x=r.p.document&&r.p.document.childNodes;"object"!=typeof Int8Array&&"function"!=typeof x&&(w=function(t){return"function"==typeof t||!1});var y=w,_=f("Object"),k=r.s&&_(new DataView(new ArrayBuffer(8))),T="undefined"!=typeof Map&&_(new Map),S=f("DataView");var I=k?function(t){return null!=t&&y(t.getInt8)&&b(t.buffer)}:S,D=r.k||f("Array");function j(t,n){return null!=t&&r.i.call(t,n)}var C=f("Arguments");!function(){C(arguments)||(C=function(t){return j(t,"callee")})}();var z=C;function O(t){return!g(t)&&Object(r.f)(t)&&!isNaN(parseFloat(t))}function P(t){return u(t)&&Object(r.g)(t)}function R(t){return function(){return t}}function A(t){return function(n){var e=t(n);return"number"==typeof e&&e>=0&&e<=r.b}}function E(t){return function(n){return null==n?void 0:n[t]}}var M=E("byteLength"),F=A(M),V=/\[object ((I|Ui)nt(8|16|32)|Float(32|64)|Uint8Clamped|Big(I|Ui)nt64)Array\]/;var L=r.r?function(t){return r.l?Object(r.l)(t)&&!I(t):F(t)&&V.test(r.t.call(t))}:R(!1),N=E("length");function K(t,n){n=function(t){for(var n={},e=t.length,i=0;i<e;++i)n[t[i]]=!0;return{contains:function(t){return n[t]},push:function(e){return n[e]=!0,t.push(e)}}}(n);var e=r.n.length,i=t.constructor,a=y(i)&&i.prototype||r.c,o="constructor";for(j(t,o)&&!n.contains(o)&&n.push(o);e--;)(o=r.n[e])in t&&t[o]!==a[o]&&!n.contains(o)&&n.push(o)}function B(t){if(!o(t))return[];if(r.m)return Object(r.m)(t);var n=[];for(var e in t)j(t,e)&&n.push(e);return r.h&&K(t,n),n}function U(t){if(null==t)return!0;var n=N(t);return"number"==typeof n&&(D(t)||p(t)||z(t))?0===n:0===N(B(t))}function q(t,n){var e=B(n),i=e.length;if(null==t)return!i;for(var r=Object(t),a=0;a<i;a++){var o=e[a];if(n[o]!==r[o]||!(o in r))return!1}return!0}function H(t){return t instanceof H?t:this instanceof H?void(this._wrapped=t):new H(t)}function G(t){return new Uint8Array(t.buffer||t,t.byteOffset||0,M(t))}H.VERSION=r.e,H.prototype.value=function(){return this._wrapped},H.prototype.valueOf=H.prototype.toJSON=H.prototype.value,H.prototype.toString=function(){return String(this._wrapped)};function Y(t,n,e,i){if(t===n)return 0!==t||1/t==1/n;if(null==t||null==n)return!1;if(t!=t)return n!=n;var a=typeof t;return("function"===a||"object"===a||"object"==typeof n)&&function t(n,e,i,a){n instanceof H&&(n=n._wrapped);e instanceof H&&(e=e._wrapped);var o=r.t.call(n);if(o!==r.t.call(e))return!1;if(k&&"[object Object]"==o&&I(n)){if(!I(e))return!1;o="[object DataView]"}switch(o){case"[object RegExp]":case"[object String]":return""+n==""+e;case"[object Number]":return+n!=+n?+e!=+e:0==+n?1/+n==1/e:+n==+e;case"[object Date]":case"[object Boolean]":return+n==+e;case"[object Symbol]":return r.d.valueOf.call(n)===r.d.valueOf.call(e);case"[object ArrayBuffer]":case"[object DataView]":return t(G(n),G(e),i,a)}var s="[object Array]"===o;if(!s&&L(n)){if(M(n)!==M(e))return!1;if(n.buffer===e.buffer&&n.byteOffset===e.byteOffset)return!0;s=!0}if(!s){if("object"!=typeof n||"object"!=typeof e)return!1;var l=n.constructor,d=e.constructor;if(l!==d&&!(y(l)&&l instanceof l&&y(d)&&d instanceof d)&&"constructor"in n&&"constructor"in e)return!1}a=a||[];var c=(i=i||[]).length;for(;c--;)if(i[c]===n)return a[c]===e;if(i.push(n),a.push(e),s){if((c=n.length)!==e.length)return!1;for(;c--;)if(!Y(n[c],e[c],i,a))return!1}else{var f,p=B(n);if(c=p.length,B(e).length!==c)return!1;for(;c--;)if(f=p[c],!j(e,f)||!Y(n[f],e[f],i,a))return!1}return i.pop(),a.pop(),!0}(t,n,e,i)}function Z(t,n){return Y(t,n)}function W(t){if(!o(t))return[];var n=[];for(var e in t)n.push(e);return r.h&&K(t,n),n}function X(t){var n=N(t);return function(e){if(null==e)return!1;var i=W(e);if(N(i))return!1;for(var r=0;r<n;r++)if(!y(e[t[r]]))return!1;return t!==et||!y(e[J])}}var J="forEach",Q=["clear","delete"],tt=["get","has","set"],nt=Q.concat(J,tt),et=Q.concat(tt),it=["add"].concat(Q,J,"has"),rt=T?X(nt):f("Map"),at=T?X(et):f("WeakMap"),ot=T?X(it):f("Set"),st=f("WeakSet");function lt(t){for(var n=B(t),e=n.length,i=Array(e),r=0;r<e;r++)i[r]=t[n[r]];return i}function dt(t){for(var n=B(t),e=n.length,i=Array(e),r=0;r<e;r++)i[r]=[n[r],t[n[r]]];return i}function ct(t){for(var n={},e=B(t),i=0,r=e.length;i<r;i++)n[t[e[i]]]=e[i];return n}function ft(t){var n=[];for(var e in t)y(t[e])&&n.push(e);return n.sort()}function pt(t,n){return function(e){var i=arguments.length;if(n&&(e=Object(e)),i<2||null==e)return e;for(var r=1;r<i;r++)for(var a=arguments[r],o=t(a),s=o.length,l=0;l<s;l++){var d=o[l];n&&void 0!==e[d]||(e[d]=a[d])}return e}}var ut=pt(W),ht=pt(B),mt=pt(W,!0);function vt(t){if(!o(t))return{};if(r.j)return Object(r.j)(t);var n=function(){};n.prototype=t;var e=new n;return n.prototype=null,e}function gt(t,n){var e=vt(t);return n&&ht(e,n),e}function bt(t){return o(t)?D(t)?t.slice():ut({},t):t}function wt(t,n){return n(t),t}function xt(t){return D(t)?t:[t]}function yt(t){return H.toPath(t)}function _t(t,n){for(var e=n.length,i=0;i<e;i++){if(null==t)return;t=t[n[i]]}return e?t:void 0}function kt(t,n,e){var i=_t(t,yt(n));return l(i)?e:i}function Tt(t,n){for(var e=(n=yt(n)).length,i=0;i<e;i++){var r=n[i];if(!j(t,r))return!1;t=t[r]}return!!e}function St(t){return t}function It(t){return t=ht({},t),function(n){return q(n,t)}}function $t(t){return t=yt(t),function(n){return _t(n,t)}}function Dt(t,n,e){if(void 0===n)return t;switch(null==e?3:e){case 1:return function(e){return t.call(n,e)};case 3:return function(e,i,r){return t.call(n,e,i,r)};case 4:return function(e,i,r,a){return t.call(n,e,i,r,a)}}return function(){return t.apply(n,arguments)}}function jt(t,n,e){return null==t?St:y(t)?Dt(t,n,e):o(t)&&!D(t)?It(t):$t(t)}function Ct(t,n){return jt(t,n,1/0)}function zt(t,n,e){return H.iteratee!==Ct?H.iteratee(t,n):jt(t,n,e)}function Ot(t,n,e){n=zt(n,e);for(var i=B(t),r=i.length,a={},o=0;o<r;o++){var s=i[o];a[s]=n(t[s],s,t)}return a}function Pt(){}function Rt(t){return null==t?Pt:function(n){return kt(t,n)}}function At(t,n,e){var i=Array(Math.max(0,t));n=Dt(n,e,1);for(var r=0;r<t;r++)i[r]=n(r);return i}function Et(t,n){return null==n&&(n=t,t=0),t+Math.floor(Math.random()*(n-t+1))}H.toPath=xt,H.iteratee=Ct;var Mt=Date.now||function(){return(new Date).getTime()};function Ft(t){var n=function(n){return t[n]},e="(?:"+B(t).join("|")+")",i=RegExp(e),r=RegExp(e,"g");return function(t){return t=null==t?"":""+t,i.test(t)?t.replace(r,n):t}}var Vt={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#x27;","`":"&#x60;"},Lt=Ft(Vt),Nt=Ft(ct(Vt)),Kt=H.templateSettings={evaluate:/<%([\s\S]+?)%>/g,interpolate:/<%=([\s\S]+?)%>/g,escape:/<%-([\s\S]+?)%>/g},Bt=/(.)^/,Ut={"'":"'","\\":"\\","\r":"r","\n":"n","\u2028":"u2028","\u2029":"u2029"},qt=/\\|'|\r|\n|\u2028|\u2029/g;function Ht(t){return"\\"+Ut[t]}function Gt(t,n,e){!n&&e&&(n=e),n=mt({},n,H.templateSettings);var i,r=RegExp([(n.escape||Bt).source,(n.interpolate||Bt).source,(n.evaluate||Bt).source].join("|")+"|$","g"),a=0,o="__p+='";t.replace(r,(function(n,e,i,r,s){return o+=t.slice(a,s).replace(qt,Ht),a=s+n.length,e?o+="'+\n((__t=("+e+"))==null?'':_.escape(__t))+\n'":i?o+="'+\n((__t=("+i+"))==null?'':__t)+\n'":r&&(o+="';\n"+r+"\n__p+='"),n})),o+="';\n",n.variable||(o="with(obj||{}){\n"+o+"}\n"),o="var __t,__p='',__j=Array.prototype.join,print=function(){__p+=__j.call(arguments,'');};\n"+o+"return __p;\n";try{i=new Function(n.variable||"obj","_",o)}catch(t){throw t.source=o,t}var s=function(t){return i.call(this,t,H)},l=n.variable||"obj";return s.source="function("+l+"){\n"+o+"}",s}function Yt(t,n,e){var i=(n=yt(n)).length;if(!i)return y(e)?e.call(t):e;for(var r=0;r<i;r++){var a=null==t?void 0:t[n[r]];void 0===a&&(a=e,r=i),t=y(a)?a.call(t):a}return t}var Zt=0;function Wt(t){var n=++Zt+"";return t?t+n:n}function Xt(t){var n=H(t);return n._chain=!0,n}function Jt(t,n,e,i,r){if(!(i instanceof n))return t.apply(e,r);var a=vt(t.prototype),s=t.apply(a,r);return o(s)?s:a}var Qt=a((function(t,n){var e=Qt.placeholder,i=function(){for(var r=0,a=n.length,o=Array(a),s=0;s<a;s++)o[s]=n[s]===e?arguments[r++]:n[s];for(;r<arguments.length;)o.push(arguments[r++]);return Jt(t,i,this,this,o)};return i}));Qt.placeholder=H;var tn=Qt,nn=a((function(t,n,e){if(!y(t))throw new TypeError("Bind must be called on a function");var i=a((function(r){return Jt(t,i,n,this,e.concat(r))}));return i})),en=A(N);function rn(t,n,e,i){if(i=i||[],n||0===n){if(n<=0)return i.concat(t)}else n=1/0;for(var r=i.length,a=0,o=N(t);a<o;a++){var s=t[a];if(en(s)&&(D(s)||z(s)))if(n>1)rn(s,n-1,e,i),r=i.length;else for(var l=0,d=s.length;l<d;)i[r++]=s[l++];else e||(i[r++]=s)}return i}var an=a((function(t,n){var e=(n=rn(n,!1,!1)).length;if(e<1)throw new Error("bindAll must be passed function names");for(;e--;){var i=n[e];t[i]=nn(t[i],t)}return t}));function on(t,n){var e=function(i){var r=e.cache,a=""+(n?n.apply(this,arguments):i);return j(r,a)||(r[a]=t.apply(this,arguments)),r[a]};return e.cache={},e}var sn=a((function(t,n,e){return setTimeout((function(){return t.apply(null,e)}),n)})),ln=tn(sn,H,1);function dn(t,n,e){var i,r,a,o,s=0;e||(e={});var l=function(){s=!1===e.leading?0:Mt(),i=null,o=t.apply(r,a),i||(r=a=null)},d=function(){var d=Mt();s||!1!==e.leading||(s=d);var c=n-(d-s);return r=this,a=arguments,c<=0||c>n?(i&&(clearTimeout(i),i=null),s=d,o=t.apply(r,a),i||(r=a=null)):i||!1===e.trailing||(i=setTimeout(l,c)),o};return d.cancel=function(){clearTimeout(i),s=0,i=r=a=null},d}function cn(t,n,e){var i,r,o=function(n,e){i=null,e&&(r=t.apply(n,e))},s=a((function(a){if(i&&clearTimeout(i),e){var s=!i;i=setTimeout(o,n),s&&(r=t.apply(this,a))}else i=sn(o,n,this,a);return r}));return s.cancel=function(){clearTimeout(i),i=null},s}function fn(t,n){return tn(n,t)}function pn(t){return function(){return!t.apply(this,arguments)}}function un(){var t=arguments,n=t.length-1;return function(){for(var e=n,i=t[n].apply(this,arguments);e--;)i=t[e].call(this,i);return i}}function hn(t,n){return function(){if(--t<1)return n.apply(this,arguments)}}function mn(t,n){var e;return function(){return--t>0&&(e=n.apply(this,arguments)),t<=1&&(n=null),e}}var vn=tn(mn,2);function gn(t,n,e){n=zt(n,e);for(var i,r=B(t),a=0,o=r.length;a<o;a++)if(n(t[i=r[a]],i,t))return i}function bn(t){return function(n,e,i){e=zt(e,i);for(var r=N(n),a=t>0?0:r-1;a>=0&&a<r;a+=t)if(e(n[a],a,n))return a;return-1}}var wn=bn(1),xn=bn(-1);function yn(t,n,e,i){for(var r=(e=zt(e,i,1))(n),a=0,o=N(t);a<o;){var s=Math.floor((a+o)/2);e(t[s])<r?a=s+1:o=s}return a}function _n(t,n,e){return function(i,a,o){var s=0,l=N(i);if("number"==typeof o)t>0?s=o>=0?o:Math.max(o+l,s):l=o>=0?Math.min(o+1,l):o+l+1;else if(e&&o&&l)return i[o=e(i,a)]===a?o:-1;if(a!=a)return(o=n(r.q.call(i,s,l),P))>=0?o+s:-1;for(o=t>0?s:l-1;o>=0&&o<l;o+=t)if(i[o]===a)return o;return-1}}var kn=_n(1,wn,yn),Tn=_n(-1,xn);function Sn(t,n,e){var i=(en(t)?wn:gn)(t,n,e);if(void 0!==i&&-1!==i)return t[i]}function In(t,n){return Sn(t,It(n))}function $n(t,n,e){var i,r;if(n=Dt(n,e),en(t))for(i=0,r=t.length;i<r;i++)n(t[i],i,t);else{var a=B(t);for(i=0,r=a.length;i<r;i++)n(t[a[i]],a[i],t)}return t}function Dn(t,n,e){n=zt(n,e);for(var i=!en(t)&&B(t),r=(i||t).length,a=Array(r),o=0;o<r;o++){var s=i?i[o]:o;a[o]=n(t[s],s,t)}return a}function jn(t){var n=function(n,e,i,r){var a=!en(n)&&B(n),o=(a||n).length,s=t>0?0:o-1;for(r||(i=n[a?a[s]:s],s+=t);s>=0&&s<o;s+=t){var l=a?a[s]:s;i=e(i,n[l],l,n)}return i};return function(t,e,i,r){var a=arguments.length>=3;return n(t,Dt(e,r,4),i,a)}}var Cn=jn(1),zn=jn(-1);function On(t,n,e){var i=[];return n=zt(n,e),$n(t,(function(t,e,r){n(t,e,r)&&i.push(t)})),i}function Pn(t,n,e){return On(t,pn(zt(n)),e)}function Rn(t,n,e){n=zt(n,e);for(var i=!en(t)&&B(t),r=(i||t).length,a=0;a<r;a++){var o=i?i[a]:a;if(!n(t[o],o,t))return!1}return!0}function An(t,n,e){n=zt(n,e);for(var i=!en(t)&&B(t),r=(i||t).length,a=0;a<r;a++){var o=i?i[a]:a;if(n(t[o],o,t))return!0}return!1}function En(t,n,e,i){return en(t)||(t=lt(t)),("number"!=typeof e||i)&&(e=0),kn(t,n,e)>=0}var Mn=a((function(t,n,e){var i,r;return y(n)?r=n:(n=yt(n),i=n.slice(0,-1),n=n[n.length-1]),Dn(t,(function(t){var a=r;if(!a){if(i&&i.length&&(t=_t(t,i)),null==t)return;a=t[n]}return null==a?a:a.apply(t,e)}))}));function Fn(t,n){return Dn(t,$t(n))}function Vn(t,n){return On(t,It(n))}function Ln(t,n,e){var i,r,a=-1/0,o=-1/0;if(null==n||"number"==typeof n&&"object"!=typeof t[0]&&null!=t)for(var s=0,l=(t=en(t)?t:lt(t)).length;s<l;s++)null!=(i=t[s])&&i>a&&(a=i);else n=zt(n,e),$n(t,(function(t,e,i){((r=n(t,e,i))>o||r===-1/0&&a===-1/0)&&(a=t,o=r)}));return a}function Nn(t,n,e){var i,r,a=1/0,o=1/0;if(null==n||"number"==typeof n&&"object"!=typeof t[0]&&null!=t)for(var s=0,l=(t=en(t)?t:lt(t)).length;s<l;s++)null!=(i=t[s])&&i<a&&(a=i);else n=zt(n,e),$n(t,(function(t,e,i){((r=n(t,e,i))<o||r===1/0&&a===1/0)&&(a=t,o=r)}));return a}function Kn(t,n,e){if(null==n||e)return en(t)||(t=lt(t)),t[Et(t.length-1)];var i=en(t)?bt(t):lt(t),r=N(i);n=Math.max(Math.min(n,r),0);for(var a=r-1,o=0;o<n;o++){var s=Et(o,a),l=i[o];i[o]=i[s],i[s]=l}return i.slice(0,n)}function Bn(t){return Kn(t,1/0)}function Un(t,n,e){var i=0;return n=zt(n,e),Fn(Dn(t,(function(t,e,r){return{value:t,index:i++,criteria:n(t,e,r)}})).sort((function(t,n){var e=t.criteria,i=n.criteria;if(e!==i){if(e>i||void 0===e)return 1;if(e<i||void 0===i)return-1}return t.index-n.index})),"value")}function qn(t,n){return function(e,i,r){var a=n?[[],[]]:{};return i=zt(i,r),$n(e,(function(n,r){var o=i(n,r,e);t(a,n,o)})),a}}var Hn=qn((function(t,n,e){j(t,e)?t[e].push(n):t[e]=[n]})),Gn=qn((function(t,n,e){t[e]=n})),Yn=qn((function(t,n,e){j(t,e)?t[e]++:t[e]=1})),Zn=qn((function(t,n,e){t[e?0:1].push(n)}),!0),Wn=/[^\ud800-\udfff]|[\ud800-\udbff][\udc00-\udfff]|[\ud800-\udfff]/g;function Xn(t){return t?D(t)?r.q.call(t):p(t)?t.match(Wn):en(t)?Dn(t,St):lt(t):[]}function Jn(t){return null==t?0:en(t)?t.length:B(t).length}function Qn(t,n,e){return n in e}var te=a((function(t,n){var e={},i=n[0];if(null==t)return e;y(i)?(n.length>1&&(i=Dt(i,n[1])),n=W(t)):(i=Qn,n=rn(n,!1,!1),t=Object(t));for(var r=0,a=n.length;r<a;r++){var o=n[r],s=t[o];i(s,o,t)&&(e[o]=s)}return e})),ne=a((function(t,n){var e,i=n[0];return y(i)?(i=pn(i),n.length>1&&(e=n[1])):(n=Dn(rn(n,!1,!1),String),i=function(t,e){return!En(n,e)}),te(t,i,e)}));function ee(t,n,e){return r.q.call(t,0,Math.max(0,t.length-(null==n||e?1:n)))}function ie(t,n,e){return null==t||t.length<1?null==n||e?void 0:[]:null==n||e?t[0]:ee(t,t.length-n)}function re(t,n,e){return r.q.call(t,null==n||e?1:n)}function ae(t,n,e){return null==t||t.length<1?null==n||e?void 0:[]:null==n||e?t[t.length-1]:re(t,Math.max(0,t.length-n))}function oe(t){return On(t,Boolean)}function se(t,n){return rn(t,n,!1)}var le=a((function(t,n){return n=rn(n,!0,!0),On(t,(function(t){return!En(n,t)}))})),de=a((function(t,n){return le(t,n)}));function ce(t,n,e,i){d(n)||(i=e,e=n,n=!1),null!=e&&(e=zt(e,i));for(var r=[],a=[],o=0,s=N(t);o<s;o++){var l=t[o],c=e?e(l,o,t):l;n&&!e?(o&&a===c||r.push(l),a=c):e?En(a,c)||(a.push(c),r.push(l)):En(r,l)||r.push(l)}return r}var fe=a((function(t){return ce(rn(t,!0,!0))}));function pe(t){for(var n=[],e=arguments.length,i=0,r=N(t);i<r;i++){var a=t[i];if(!En(n,a)){var o;for(o=1;o<e&&En(arguments[o],a);o++);o===e&&n.push(a)}}return n}function ue(t){for(var n=t&&Ln(t,N).length||0,e=Array(n),i=0;i<n;i++)e[i]=Fn(t,i);return e}var he=a(ue);function me(t,n){for(var e={},i=0,r=N(t);i<r;i++)n?e[t[i]]=n[i]:e[t[i][0]]=t[i][1];return e}function ve(t,n,e){null==n&&(n=t||0,t=0),e||(e=n<t?-1:1);for(var i=Math.max(Math.ceil((n-t)/e),0),r=Array(i),a=0;a<i;a++,t+=e)r[a]=t;return r}function ge(t,n){if(null==n||n<1)return[];for(var e=[],i=0,a=t.length;i<a;)e.push(r.q.call(t,i,i+=n));return e}function be(t,n){return t._chain?H(n).chain():n}function we(t){return $n(ft(t),(function(n){var e=H[n]=t[n];H.prototype[n]=function(){var t=[this._wrapped];return r.o.apply(t,arguments),be(this,e.apply(H,t))}})),H}$n(["pop","push","reverse","shift","sort","splice","unshift"],(function(t){var n=r.a[t];H.prototype[t]=function(){var e=this._wrapped;return null!=e&&(n.apply(e,arguments),"shift"!==t&&"splice"!==t||0!==e.length||delete e[0]),be(this,e)}})),$n(["concat","join","slice"],(function(t){var n=r.a[t];H.prototype[t]=function(){var t=this._wrapped;return null!=t&&(t=n.apply(t,arguments)),be(this,t)}}));var xe=H,ye=we(i);ye._=ye;e(4),e(5),e(6),e(7),e(8),e(9),e(10),e(11),e(12),e(13),e(14),e(15),e(16),e(17),e(18),e(19),e(20),e(21),e(22),e(23),e(24),e(25),e(26),e(27),e(28),e(29),e(30),e(31),e(32),e(33),e(34),e(35),e(36),e(37),e(38);setNORAenv({url_pref:window.location.origin+"/static/plugins/visualizations/nora/static/dist/"}),console.log("starting NORA's viewer"),console.log(window.location.href),stateManager.setDefaultState();window.bundleEntries.chartUtilities.Datasets;ut(window.bundleEntries||{},{load:function(t){t.chart;var n=$(document.getElementById(t.targets[0])),e=new KView(n.parent());n.remove(),e.crosshairMode=!0,e.showInfoBar=!0,e.globalCoordinates=!0,e.startImageLoader=startImageLoader,addKeyboardShortcuts(),ViewerSettings.nVisibleCols=2,ViewerSettings.nVisibleRows=2,ViewerSettings.nVisibleBarports=0,e.ViewerSettings=ViewerSettings,e.defaultFOV_mm=220,e.$screenShot.hide(),e.$iron.hide(),e.applyState();var i=t.dataset.name,r=t.dataset.extension;console.log(t.dataset);var a=[{url:window.location.host+t.dataset.download_url,intendedName:i,filetype:r,intent:{}}];e.startImageLoader(a,(function(){}))}})}]);
//# sourceMappingURL=script.js.map